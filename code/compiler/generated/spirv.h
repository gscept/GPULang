#pragma once
//-------------------------------------------------
// *** Generated by type_gen.py. ***
//       DO NOT MODIFY!!!
//-------------------------------------------------
static auto CreateSampledImageSPIRV = [](const Compiler* c, SPIRVGenerator* g, SPIRVResult img, SPIRVResult samp) -> SPIRVResult
{
        assert(img.parentTypes.size() > 0);
        SPIRVResult image = LoadValueSPIRV(c, g, img, true);
        SPIRVResult sampler = LoadValueSPIRV(c, g, samp, true);
        uint32_t typeSymbol = AddType(g, TStr::Compact("sampledImage_", img.parentTypes[0]), OpTypeSampledImage, SPVArg{img.parentTypes[0]});
        uint32_t sampledImage = g->writer->MappedInstruction(OpSampledImage, SPVWriter::Section::LocalFunction, typeSymbol, image, sampler);
        return SPIRVResult(sampledImage, typeSymbol, true);
};

constexpr auto ConverterTable = StaticMap{ std::array{
    { TypeConversionTable::Float32ToUInt32, [](const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt32(value.literalValue.f32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = g->writer->MappedInstruction(OpConvertFToU, SPVWriter::Section::LocalFunction, type, value);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Float32ToInt32, [](const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(value.literalValue.f32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = g->writer->MappedInstruction(OpConvertFToS, SPVWriter::Section::LocalFunction, type, value);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Float32ToFloat16, [](const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float16(value.literalValue.f32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = g->writer->MappedInstruction(OpFConvert, SPVWriter::Section::LocalFunction, type, value);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Float32ToUInt16, [](const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt16(value.literalValue.f32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = g->writer->MappedInstruction(OpConvertFToU, SPVWriter::Section::LocalFunction, type, value);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Float32ToInt16, [](const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int16(value.literalValue.f32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = g->writer->MappedInstruction(OpConvertFToS, SPVWriter::Section::LocalFunction, type, value);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::UInt32ToFloat32, [](const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float32(value.literalValue.u32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = g->writer->MappedInstruction(OpConvertUToF, SPVWriter::Section::LocalFunction, type, value);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::UInt32ToInt32, [](const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(value.literalValue.u32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, type, value);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::UInt32ToBool8, [](const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Bool8(value.literalValue.u32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Bool8, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Bool8);
            SPIRVResult falseValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt32(0));
            uint32_t res = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, type, value, falseValue);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::UInt32ToFloat16, [](const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float16(value.literalValue.u32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = g->writer->MappedInstruction(OpConvertUToF, SPVWriter::Section::LocalFunction, type, value);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::UInt32ToUInt16, [](const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt16(value.literalValue.u32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = g->writer->MappedInstruction(OpUConvert, SPVWriter::Section::LocalFunction, type, value);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::UInt32ToInt16, [](const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int16(value.literalValue.u32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, type, value);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Int32ToFloat32, [](const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float32(value.literalValue.i32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = g->writer->MappedInstruction(OpConvertSToF, SPVWriter::Section::LocalFunction, type, value);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Int32ToUInt32, [](const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt32(value.literalValue.i32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, type, value);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Int32ToBool8, [](const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Bool8(value.literalValue.i32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Bool8, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Bool8);
            SPIRVResult falseValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0));
            uint32_t res = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, type, value, falseValue);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Int32ToFloat16, [](const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float16(value.literalValue.i32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = g->writer->MappedInstruction(OpConvertSToF, SPVWriter::Section::LocalFunction, type, value);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Int32ToUInt16, [](const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt16(value.literalValue.i32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, type, value);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Int32ToInt16, [](const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int16(value.literalValue.i32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = g->writer->MappedInstruction(OpSConvert, SPVWriter::Section::LocalFunction, type, value);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Bool8ToUInt32, [](const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt32(value.literalValue.b8));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32);
            SPIRVResult trueValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt32(1));
            SPIRVResult falseValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt32(0));
            uint32_t res = g->writer->MappedInstruction(OpSelect, SPVWriter::Section::LocalFunction, type, value, trueValue, falseValue);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Bool8ToInt32, [](const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(value.literalValue.b8));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32);
            SPIRVResult trueValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(1));
            SPIRVResult falseValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0));
            uint32_t res = g->writer->MappedInstruction(OpSelect, SPVWriter::Section::LocalFunction, type, value, trueValue, falseValue);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Bool8ToUInt16, [](const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt16(value.literalValue.b8));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16);
            SPIRVResult trueValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt16(1));
            SPIRVResult falseValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt16(0));
            uint32_t res = g->writer->MappedInstruction(OpSelect, SPVWriter::Section::LocalFunction, type, value, trueValue, falseValue);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Bool8ToInt16, [](const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int16(value.literalValue.b8));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16);
            SPIRVResult trueValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int16(1));
            SPIRVResult falseValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int16(0));
            uint32_t res = g->writer->MappedInstruction(OpSelect, SPVWriter::Section::LocalFunction, type, value, trueValue, falseValue);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Float16ToFloat32, [](const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float32(value.literalValue.f16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = g->writer->MappedInstruction(OpFConvert, SPVWriter::Section::LocalFunction, type, value);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Float16ToUInt32, [](const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt32(value.literalValue.f16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = g->writer->MappedInstruction(OpConvertFToU, SPVWriter::Section::LocalFunction, type, value);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Float16ToInt32, [](const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(value.literalValue.f16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = g->writer->MappedInstruction(OpConvertFToS, SPVWriter::Section::LocalFunction, type, value);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Float16ToUInt16, [](const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt16(value.literalValue.f16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = g->writer->MappedInstruction(OpConvertFToU, SPVWriter::Section::LocalFunction, type, value);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Float16ToInt16, [](const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int16(value.literalValue.f16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = g->writer->MappedInstruction(OpConvertFToS, SPVWriter::Section::LocalFunction, type, value);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::UInt16ToFloat32, [](const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float32(value.literalValue.u16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = g->writer->MappedInstruction(OpConvertUToF, SPVWriter::Section::LocalFunction, type, value);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::UInt16ToUInt32, [](const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt32(value.literalValue.u16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = g->writer->MappedInstruction(OpUConvert, SPVWriter::Section::LocalFunction, type, value);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::UInt16ToInt32, [](const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(value.literalValue.u16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, type, value);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::UInt16ToBool8, [](const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Bool8(value.literalValue.u16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Bool8, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Bool8);
            SPIRVResult falseValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt16(0));
            uint32_t res = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, type, value, falseValue);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::UInt16ToFloat16, [](const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float16(value.literalValue.u16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = g->writer->MappedInstruction(OpConvertUToF, SPVWriter::Section::LocalFunction, type, value);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::UInt16ToInt16, [](const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int16(value.literalValue.u16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, type, value);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Int16ToFloat32, [](const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float32(value.literalValue.i16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = g->writer->MappedInstruction(OpConvertSToF, SPVWriter::Section::LocalFunction, type, value);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Int16ToUInt32, [](const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt32(value.literalValue.i16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, type, value);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Int16ToInt32, [](const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(value.literalValue.i16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = g->writer->MappedInstruction(OpSConvert, SPVWriter::Section::LocalFunction, type, value);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Int16ToBool8, [](const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Bool8(value.literalValue.i16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Bool8, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Bool8);
            SPIRVResult falseValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int16(0));
            uint32_t res = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, type, value, falseValue);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Int16ToFloat16, [](const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float16(value.literalValue.i16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = g->writer->MappedInstruction(OpConvertSToF, SPVWriter::Section::LocalFunction, type, value);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Int16ToUInt16, [](const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt16(value.literalValue.i16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, type, value);
            return SPIRVResult(res, type, true);
        }
    } }
}};

static const uint32_t SemanticsTable[] =
{
    0x0,
    0x1,
    0x2,
    0x4,
    0x8,
    0x10,
    0x20,
    0x40,
    0x80,
    0x100
};

static auto ScopeToAtomicScope = [](SPIRVResult::Storage scope) -> uint32_t
{
    switch (scope)
    {
        case SPIRVResult::Storage::Function:
        case SPIRVResult::Storage::Input:
        case SPIRVResult::Storage::Output:
        case SPIRVResult::Storage::PushConstant:
        case SPIRVResult::Storage::Private:
            return 4;
        case SPIRVResult::Storage::WorkGroup:
            return 2;
        case SPIRVResult::Storage::Device:
        case SPIRVResult::Storage::Uniform:
        case SPIRVResult::Storage::UniformConstant:
        case SPIRVResult::Storage::StorageBuffer:
        case SPIRVResult::Storage::MutableImage:
            return 1;
        case SPIRVResult::Storage::Sampler:
        case SPIRVResult::Storage::Image:
            assert(false);
    }
    return 0;
};

static auto ScopeToMemorySemantics = [](SPIRVResult::Storage scope) -> uint32_t
{
    switch (scope)
    {
        case SPIRVResult::Storage::WorkGroup:
            return 0x100; // WorkgroupMemory
        case SPIRVResult::Storage::Uniform:
        case SPIRVResult::Storage::UniformConstant:
        case SPIRVResult::Storage::StorageBuffer:
        case SPIRVResult::Storage::Sampler:
            return 0x40; // UniformMemory
        case SPIRVResult::Storage::Image:
        case SPIRVResult::Storage::MutableImage:
            return 0x800; // ImageMemory
    }
    return 0x0;
};

StaticMap default_intrinsics = std::array{
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_ctor0_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_ctor0_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_ctor0_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_ctor0_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_ctor0_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_ctor0_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_ctor0_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_ctor0_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_ctor0_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_ctor0_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_ctor0_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_ctor0_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_ctor0_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_ctor0_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_ctor0_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_ctor0_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_ctor0_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_ctor0_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_ctor0_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_ctor0_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_ctor0_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_ctor0_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_ctor0_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_ctor0_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_ctor0_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_ctor0_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_ctor0_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_ctor0_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x3_ctor1_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_ctor2_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_ctor0_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_ctor0_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_ctor0_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_ctor0_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_ctor0_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_ctor0_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_ctor0_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x3_ctor1_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_ctor2_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_ctor0_UInt32_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x3_ctor1_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_ctor2_UInt32_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_ctor0_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_ctor0_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_ctor0_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_ctor0_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_ctor0_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_ctor0_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_ctor0_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x3_ctor1_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_ctor2_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_ctor0_UInt32_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x3_ctor1_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_ctor2_UInt32_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_ctor0_Int32_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x3_ctor1_Int32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_ctor2_Int32_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_ctor0_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_ctor0_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_ctor0_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_ctor0_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_ctor0_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_ctor0_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_ctor0_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x3_ctor1_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_ctor2_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_ctor0_UInt32_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x3_ctor1_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_ctor2_UInt32_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_ctor0_Int32_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x3_ctor1_Int32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_ctor2_Int32_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_ctor0_Bool8_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x3_ctor1_Bool8x2_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_ctor2_Bool8_Bool8x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_ctor0_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_ctor0_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_ctor0_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_ctor0_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_ctor0_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_ctor0_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_ctor0_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x3_ctor1_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_ctor2_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_ctor0_UInt32_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x3_ctor1_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_ctor2_UInt32_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_ctor0_Int32_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x3_ctor1_Int32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_ctor2_Int32_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_ctor0_Bool8_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x3_ctor1_Bool8x2_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_ctor2_Bool8_Bool8x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_ctor0_Float16_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float16x3_ctor1_Float16x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x3_ctor2_Float16_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_ctor0_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_ctor0_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_ctor0_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_ctor0_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_ctor0_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_ctor0_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_ctor0_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x3_ctor1_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_ctor2_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_ctor0_UInt32_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x3_ctor1_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_ctor2_UInt32_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_ctor0_Int32_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x3_ctor1_Int32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_ctor2_Int32_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_ctor0_Bool8_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x3_ctor1_Bool8x2_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_ctor2_Bool8_Bool8x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_ctor0_Float16_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float16x3_ctor1_Float16x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x3_ctor2_Float16_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_ctor0_UInt16_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt16x3_ctor1_UInt16x2_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x3_ctor2_UInt16_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_ctor0_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_ctor0_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_ctor0_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_ctor0_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_ctor0_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_ctor0_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_ctor0_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x3_ctor1_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_ctor2_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_ctor0_UInt32_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x3_ctor1_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_ctor2_UInt32_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_ctor0_Int32_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x3_ctor1_Int32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_ctor2_Int32_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_ctor0_Bool8_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x3_ctor1_Bool8x2_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_ctor2_Bool8_Bool8x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_ctor0_Float16_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float16x3_ctor1_Float16x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x3_ctor2_Float16_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_ctor0_UInt16_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt16x3_ctor1_UInt16x2_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x3_ctor2_UInt16_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Int16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Int16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_ctor0_Int16_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int16x3_ctor1_Int16x2_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x3_ctor2_Int16_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_ctor0_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_ctor0_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_ctor0_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_ctor0_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_ctor0_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_ctor0_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_ctor0_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x3_ctor1_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_ctor2_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_ctor0_UInt32_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x3_ctor1_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_ctor2_UInt32_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_ctor0_Int32_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x3_ctor1_Int32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_ctor2_Int32_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_ctor0_Bool8_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x3_ctor1_Bool8x2_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_ctor2_Bool8_Bool8x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_ctor0_Float16_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float16x3_ctor1_Float16x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x3_ctor2_Float16_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_ctor0_UInt16_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt16x3_ctor1_UInt16x2_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x3_ctor2_UInt16_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Int16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Int16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_ctor0_Int16_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int16x3_ctor1_Int16x2_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x3_ctor2_Int16_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 4, args[0]);
}},
std::pair{ &Float32x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 4, args[0]);
}},
std::pair{ &Float32x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_ctor0_Float32_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &Float32x4_ctor1_Float32x2_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor2_Float32_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor3_Float32_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor4_Float32x3_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x4_ctor5_Float32_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_ctor0_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_ctor0_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_ctor0_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_ctor0_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_ctor0_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_ctor0_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_ctor0_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x3_ctor1_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_ctor2_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_ctor0_UInt32_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x3_ctor1_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_ctor2_UInt32_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_ctor0_Int32_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x3_ctor1_Int32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_ctor2_Int32_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_ctor0_Bool8_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x3_ctor1_Bool8x2_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_ctor2_Bool8_Bool8x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_ctor0_Float16_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float16x3_ctor1_Float16x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x3_ctor2_Float16_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_ctor0_UInt16_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt16x3_ctor1_UInt16x2_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x3_ctor2_UInt16_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Int16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Int16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_ctor0_Int16_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int16x3_ctor1_Int16x2_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x3_ctor2_Int16_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 4, args[0]);
}},
std::pair{ &Float32x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 4, args[0]);
}},
std::pair{ &Float32x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_ctor0_Float32_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &Float32x4_ctor1_Float32x2_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor2_Float32_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor3_Float32_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor4_Float32x3_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x4_ctor5_Float32_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt32x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_ctor0_UInt32_UInt32_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &UInt32x4_ctor1_UInt32x2_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x4_ctor2_UInt32_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x4_ctor3_UInt32_UInt32_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x4_ctor4_UInt32x3_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x4_ctor5_UInt32_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_ctor0_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_ctor0_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_ctor0_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_ctor0_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_ctor0_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_ctor0_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_ctor0_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x3_ctor1_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_ctor2_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_ctor0_UInt32_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x3_ctor1_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_ctor2_UInt32_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_ctor0_Int32_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x3_ctor1_Int32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_ctor2_Int32_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_ctor0_Bool8_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x3_ctor1_Bool8x2_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_ctor2_Bool8_Bool8x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_ctor0_Float16_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float16x3_ctor1_Float16x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x3_ctor2_Float16_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_ctor0_UInt16_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt16x3_ctor1_UInt16x2_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x3_ctor2_UInt16_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Int16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Int16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_ctor0_Int16_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int16x3_ctor1_Int16x2_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x3_ctor2_Int16_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 4, args[0]);
}},
std::pair{ &Float32x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 4, args[0]);
}},
std::pair{ &Float32x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_ctor0_Float32_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &Float32x4_ctor1_Float32x2_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor2_Float32_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor3_Float32_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor4_Float32x3_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x4_ctor5_Float32_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt32x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_ctor0_UInt32_UInt32_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &UInt32x4_ctor1_UInt32x2_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x4_ctor2_UInt32_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x4_ctor3_UInt32_UInt32_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x4_ctor4_UInt32x3_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x4_ctor5_UInt32_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 4, args[0]);
}},
std::pair{ &Int32x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 4, args[0]);
}},
std::pair{ &Int32x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int32x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 4, args[0]);
}},
std::pair{ &Int32x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 4, args[0]);
}},
std::pair{ &Int32x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 4, args[0]);
}},
std::pair{ &Int32x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_ctor0_Int32_Int32_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &Int32x4_ctor1_Int32x2_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x4_ctor2_Int32_Int32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x4_ctor3_Int32_Int32_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x4_ctor4_Int32x3_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x4_ctor5_Int32_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_ctor0_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_ctor0_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_ctor0_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_ctor0_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_ctor0_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_ctor0_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_ctor0_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x3_ctor1_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_ctor2_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_ctor0_UInt32_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x3_ctor1_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_ctor2_UInt32_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_ctor0_Int32_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x3_ctor1_Int32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_ctor2_Int32_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_ctor0_Bool8_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x3_ctor1_Bool8x2_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_ctor2_Bool8_Bool8x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_ctor0_Float16_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float16x3_ctor1_Float16x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x3_ctor2_Float16_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_ctor0_UInt16_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt16x3_ctor1_UInt16x2_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x3_ctor2_UInt16_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Int16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Int16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_ctor0_Int16_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int16x3_ctor1_Int16x2_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x3_ctor2_Int16_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 4, args[0]);
}},
std::pair{ &Float32x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 4, args[0]);
}},
std::pair{ &Float32x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_ctor0_Float32_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &Float32x4_ctor1_Float32x2_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor2_Float32_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor3_Float32_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor4_Float32x3_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x4_ctor5_Float32_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt32x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_ctor0_UInt32_UInt32_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &UInt32x4_ctor1_UInt32x2_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x4_ctor2_UInt32_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x4_ctor3_UInt32_UInt32_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x4_ctor4_UInt32x3_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x4_ctor5_UInt32_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 4, args[0]);
}},
std::pair{ &Int32x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 4, args[0]);
}},
std::pair{ &Int32x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int32x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 4, args[0]);
}},
std::pair{ &Int32x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 4, args[0]);
}},
std::pair{ &Int32x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 4, args[0]);
}},
std::pair{ &Int32x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_ctor0_Int32_Int32_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &Int32x4_ctor1_Int32x2_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x4_ctor2_Int32_Int32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x4_ctor3_Int32_Int32_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x4_ctor4_Int32x3_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x4_ctor5_Int32_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 4, args[0]);
}},
std::pair{ &Bool8x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Bool8x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 4, args[0]);
}},
std::pair{ &Bool8x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Bool8x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 4, args[0]);
}},
std::pair{ &Bool8x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Bool8x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 4, args[0]);
}},
std::pair{ &Bool8x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Bool8x4_ctor0_Bool8_Bool8_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &Bool8x4_ctor1_Bool8x2_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x4_ctor2_Bool8_Bool8x2_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x4_ctor3_Bool8_Bool8_Bool8x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x4_ctor4_Bool8x3_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x4_ctor5_Bool8_Bool8x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_ctor0_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_ctor0_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_ctor0_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_ctor0_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_ctor0_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_ctor0_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_ctor0_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x3_ctor1_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_ctor2_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_ctor0_UInt32_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x3_ctor1_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_ctor2_UInt32_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_ctor0_Int32_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x3_ctor1_Int32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_ctor2_Int32_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_ctor0_Bool8_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x3_ctor1_Bool8x2_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_ctor2_Bool8_Bool8x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_ctor0_Float16_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float16x3_ctor1_Float16x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x3_ctor2_Float16_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_ctor0_UInt16_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt16x3_ctor1_UInt16x2_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x3_ctor2_UInt16_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Int16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Int16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_ctor0_Int16_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int16x3_ctor1_Int16x2_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x3_ctor2_Int16_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 4, args[0]);
}},
std::pair{ &Float32x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 4, args[0]);
}},
std::pair{ &Float32x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_ctor0_Float32_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &Float32x4_ctor1_Float32x2_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor2_Float32_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor3_Float32_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor4_Float32x3_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x4_ctor5_Float32_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt32x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_ctor0_UInt32_UInt32_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &UInt32x4_ctor1_UInt32x2_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x4_ctor2_UInt32_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x4_ctor3_UInt32_UInt32_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x4_ctor4_UInt32x3_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x4_ctor5_UInt32_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 4, args[0]);
}},
std::pair{ &Int32x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 4, args[0]);
}},
std::pair{ &Int32x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int32x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 4, args[0]);
}},
std::pair{ &Int32x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 4, args[0]);
}},
std::pair{ &Int32x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 4, args[0]);
}},
std::pair{ &Int32x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_ctor0_Int32_Int32_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &Int32x4_ctor1_Int32x2_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x4_ctor2_Int32_Int32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x4_ctor3_Int32_Int32_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x4_ctor4_Int32x3_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x4_ctor5_Int32_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 4, args[0]);
}},
std::pair{ &Bool8x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Bool8x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 4, args[0]);
}},
std::pair{ &Bool8x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Bool8x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 4, args[0]);
}},
std::pair{ &Bool8x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Bool8x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 4, args[0]);
}},
std::pair{ &Bool8x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Bool8x4_ctor0_Bool8_Bool8_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &Bool8x4_ctor1_Bool8x2_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x4_ctor2_Bool8_Bool8x2_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x4_ctor3_Bool8_Bool8_Bool8x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x4_ctor4_Bool8x3_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x4_ctor5_Bool8_Bool8x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 4, args[0]);
}},
std::pair{ &Float16x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float16x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 4, args[0]);
}},
std::pair{ &Float16x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float16x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 4, args[0]);
}},
std::pair{ &Float16x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float16x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float16x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float16x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 4, args[0]);
}},
std::pair{ &Float16x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float16x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 4, args[0]);
}},
std::pair{ &Float16x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float16x4_ctor0_Float16_Float16_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &Float16x4_ctor1_Float16x2_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float16x4_ctor2_Float16_Float16x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float16x4_ctor3_Float16_Float16_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float16x4_ctor4_Float16x3_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x4_ctor5_Float16_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_ctor0_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_ctor0_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_ctor0_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_ctor0_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_ctor0_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_ctor0_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_ctor0_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x3_ctor1_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_ctor2_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_ctor0_UInt32_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x3_ctor1_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_ctor2_UInt32_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_ctor0_Int32_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x3_ctor1_Int32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_ctor2_Int32_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_ctor0_Bool8_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x3_ctor1_Bool8x2_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_ctor2_Bool8_Bool8x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_ctor0_Float16_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float16x3_ctor1_Float16x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x3_ctor2_Float16_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_ctor0_UInt16_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt16x3_ctor1_UInt16x2_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x3_ctor2_UInt16_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Int16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Int16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_ctor0_Int16_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int16x3_ctor1_Int16x2_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x3_ctor2_Int16_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 4, args[0]);
}},
std::pair{ &Float32x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 4, args[0]);
}},
std::pair{ &Float32x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_ctor0_Float32_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &Float32x4_ctor1_Float32x2_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor2_Float32_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor3_Float32_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor4_Float32x3_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x4_ctor5_Float32_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt32x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_ctor0_UInt32_UInt32_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &UInt32x4_ctor1_UInt32x2_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x4_ctor2_UInt32_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x4_ctor3_UInt32_UInt32_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x4_ctor4_UInt32x3_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x4_ctor5_UInt32_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 4, args[0]);
}},
std::pair{ &Int32x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 4, args[0]);
}},
std::pair{ &Int32x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int32x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 4, args[0]);
}},
std::pair{ &Int32x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 4, args[0]);
}},
std::pair{ &Int32x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 4, args[0]);
}},
std::pair{ &Int32x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_ctor0_Int32_Int32_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &Int32x4_ctor1_Int32x2_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x4_ctor2_Int32_Int32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x4_ctor3_Int32_Int32_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x4_ctor4_Int32x3_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x4_ctor5_Int32_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 4, args[0]);
}},
std::pair{ &Bool8x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Bool8x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 4, args[0]);
}},
std::pair{ &Bool8x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Bool8x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 4, args[0]);
}},
std::pair{ &Bool8x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Bool8x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 4, args[0]);
}},
std::pair{ &Bool8x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Bool8x4_ctor0_Bool8_Bool8_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &Bool8x4_ctor1_Bool8x2_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x4_ctor2_Bool8_Bool8x2_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x4_ctor3_Bool8_Bool8_Bool8x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x4_ctor4_Bool8x3_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x4_ctor5_Bool8_Bool8x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 4, args[0]);
}},
std::pair{ &Float16x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float16x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 4, args[0]);
}},
std::pair{ &Float16x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float16x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 4, args[0]);
}},
std::pair{ &Float16x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float16x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float16x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float16x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 4, args[0]);
}},
std::pair{ &Float16x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float16x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 4, args[0]);
}},
std::pair{ &Float16x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float16x4_ctor0_Float16_Float16_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &Float16x4_ctor1_Float16x2_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float16x4_ctor2_Float16_Float16x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float16x4_ctor3_Float16_Float16_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float16x4_ctor4_Float16x3_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x4_ctor5_Float16_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 4, args[0]);
}},
std::pair{ &UInt16x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt16x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 4, args[0]);
}},
std::pair{ &UInt16x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt16x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 4, args[0]);
}},
std::pair{ &UInt16x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt16x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 4, args[0]);
}},
std::pair{ &UInt16x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt16x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt16x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt16x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 4, args[0]);
}},
std::pair{ &UInt16x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt16x4_ctor0_UInt16_UInt16_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &UInt16x4_ctor1_UInt16x2_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt16x4_ctor2_UInt16_UInt16x2_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt16x4_ctor3_UInt16_UInt16_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt16x4_ctor4_UInt16x3_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x4_ctor5_UInt16_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_ctor0_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_ctor0_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_ctor0_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_ctor0_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_ctor0_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_ctor0_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_ctor0_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x3_ctor1_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_ctor2_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_ctor0_UInt32_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x3_ctor1_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_ctor2_UInt32_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_ctor0_Int32_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x3_ctor1_Int32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_ctor2_Int32_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_ctor0_Bool8_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x3_ctor1_Bool8x2_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_ctor2_Bool8_Bool8x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_ctor0_Float16_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float16x3_ctor1_Float16x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x3_ctor2_Float16_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_ctor0_UInt16_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt16x3_ctor1_UInt16x2_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x3_ctor2_UInt16_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 3, args[0]);
}},
std::pair{ &Int16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 3, args[0]);
}},
std::pair{ &Int16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_ctor0_Int16_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int16x3_ctor1_Int16x2_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x3_ctor2_Int16_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float32x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 4, args[0]);
}},
std::pair{ &Float32x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 4, args[0]);
}},
std::pair{ &Float32x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_ctor0_Float32_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &Float32x4_ctor1_Float32x2_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor2_Float32_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor3_Float32_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor4_Float32x3_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x4_ctor5_Float32_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt32x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_ctor0_UInt32_UInt32_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &UInt32x4_ctor1_UInt32x2_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x4_ctor2_UInt32_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x4_ctor3_UInt32_UInt32_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x4_ctor4_UInt32x3_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x4_ctor5_UInt32_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 4, args[0]);
}},
std::pair{ &Int32x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 4, args[0]);
}},
std::pair{ &Int32x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int32x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 4, args[0]);
}},
std::pair{ &Int32x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 4, args[0]);
}},
std::pair{ &Int32x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 4, args[0]);
}},
std::pair{ &Int32x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_ctor0_Int32_Int32_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &Int32x4_ctor1_Int32x2_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x4_ctor2_Int32_Int32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x4_ctor3_Int32_Int32_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x4_ctor4_Int32x3_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x4_ctor5_Int32_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 4, args[0]);
}},
std::pair{ &Bool8x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Bool8x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 4, args[0]);
}},
std::pair{ &Bool8x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Bool8x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 4, args[0]);
}},
std::pair{ &Bool8x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Bool8x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 4, args[0]);
}},
std::pair{ &Bool8x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Bool8x4_ctor0_Bool8_Bool8_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &Bool8x4_ctor1_Bool8x2_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x4_ctor2_Bool8_Bool8x2_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x4_ctor3_Bool8_Bool8_Bool8x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x4_ctor4_Bool8x3_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x4_ctor5_Bool8_Bool8x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 4, args[0]);
}},
std::pair{ &Float16x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float16x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 4, args[0]);
}},
std::pair{ &Float16x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float16x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 4, args[0]);
}},
std::pair{ &Float16x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float16x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Float16x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float16x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 4, args[0]);
}},
std::pair{ &Float16x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float16x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 4, args[0]);
}},
std::pair{ &Float16x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float16x4_ctor0_Float16_Float16_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &Float16x4_ctor1_Float16x2_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float16x4_ctor2_Float16_Float16x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float16x4_ctor3_Float16_Float16_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float16x4_ctor4_Float16x3_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x4_ctor5_Float16_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 4, args[0]);
}},
std::pair{ &UInt16x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt16x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 4, args[0]);
}},
std::pair{ &UInt16x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt16x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 4, args[0]);
}},
std::pair{ &UInt16x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt16x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 4, args[0]);
}},
std::pair{ &UInt16x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt16x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &UInt16x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt16x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 4, args[0]);
}},
std::pair{ &UInt16x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt16x4_ctor0_UInt16_UInt16_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &UInt16x4_ctor1_UInt16x2_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt16x4_ctor2_UInt16_UInt16x2_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt16x4_ctor3_UInt16_UInt16_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt16x4_ctor4_UInt16x3_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x4_ctor5_UInt16_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 4, args[0]);
}},
std::pair{ &Int16x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int16x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 4, args[0]);
}},
std::pair{ &Int16x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int16x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 4, args[0]);
}},
std::pair{ &Int16x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int16x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 4, args[0]);
}},
std::pair{ &Int16x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int16x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 4, args[0]);
}},
std::pair{ &Int16x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int16x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return args[0];
}},
std::pair{ &Int16x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int16x4_ctor0_Int16_Int16_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &Int16x4_ctor1_Int16x2_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int16x4_ctor2_Int16_Int16x2_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int16x4_ctor3_Int16_Int16_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int16x4_ctor4_Int16x3_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x4_ctor5_Int16_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32_operator_index_Int32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32_operator_index_UInt32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32_operator_index_Int16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32_operator_index_UInt16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32_operator_add_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32_operator_sub_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32_operator_mul_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32_operator_div_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32_operator_mod_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32_operator_addasg_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32_operator_subasg_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32_operator_mulasg_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32_operator_divasg_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32_operator_lt_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32_operator_lte_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32_operator_gt_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32_operator_gte_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32_operator_eq_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32_operator_neq_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdNotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32_operator_index_Int32.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt32_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32_operator_index_UInt32.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt32_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32_operator_index_Int16.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt32_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32_operator_index_UInt16.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt32_operator_add_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_sub_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_mul_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_div_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_mod_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_addasg_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_subasg_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_mulasg_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_divasg_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_lt_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_lte_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_gt_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_gte_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_eq_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_neq_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_or_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_and_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_xor_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_lsh_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_rsh_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_orasg_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_andasg_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_xorasg_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_lshasg_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_rhsasg_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32_operator_index_Int32.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int32_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32_operator_index_UInt32.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int32_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32_operator_index_Int16.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int32_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32_operator_index_UInt16.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int32_operator_add_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_sub_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_mul_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_div_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_mod_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_addasg_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_subasg_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_mulasg_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_divasg_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_lt_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_lte_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_gt_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_gte_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_eq_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_neq_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_or_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_and_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_xor_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_lsh_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_rsh_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_orasg_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_andasg_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_xorasg_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_lshasg_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_rhsasg_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Bool8_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8_operator_index_Int32.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Bool8_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8_operator_index_UInt32.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Bool8_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8_operator_index_Int16.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Bool8_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8_operator_index_UInt16.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Bool8_operator_oror_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpLogicalOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Bool8_operator_andand_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpLogicalAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Bool8_operator_eq_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Bool8_operator_neq_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16_operator_index_Int32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16_operator_index_UInt32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16_operator_index_Int16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16_operator_index_UInt16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16_operator_add_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16_operator_sub_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16_operator_mul_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16_operator_div_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16_operator_mod_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16_operator_addasg_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16_operator_subasg_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16_operator_mulasg_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16_operator_divasg_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16_operator_lt_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16_operator_lte_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16_operator_gt_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16_operator_gte_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16_operator_eq_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16_operator_neq_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdNotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16_operator_index_Int32.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt16_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16_operator_index_UInt32.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt16_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16_operator_index_Int16.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt16_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16_operator_index_UInt16.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt16_operator_add_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_sub_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_mul_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_div_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_mod_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_addasg_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_subasg_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_mulasg_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_divasg_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_lt_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_lte_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_gt_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_gte_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_eq_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_neq_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_or_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_and_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_xor_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_lsh_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_rsh_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_orasg_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_andasg_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_xorasg_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_lshasg_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_rhsasg_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16_operator_index_Int32.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int16_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16_operator_index_UInt32.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int16_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16_operator_index_Int16.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int16_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16_operator_index_UInt16.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int16_operator_add_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_sub_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_mul_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_div_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_mod_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_addasg_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_subasg_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_mulasg_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_divasg_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_lt_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_lte_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_gt_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_gte_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_eq_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_neq_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_or_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_and_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_xor_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_lsh_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_rsh_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_orasg_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_andasg_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_xorasg_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_lshasg_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_rhsasg_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2_operator_index_Int32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x2_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2_operator_index_UInt32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x2_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2_operator_index_Int16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x2_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2_operator_index_UInt16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x2_operator_add_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_sub_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_mul_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_div_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_mod_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_addasg_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_subasg_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_mulasg_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_divasg_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_lt_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_lte_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_gt_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_gte_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_eq_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_neq_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdNotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_scale_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_scale_Float32x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_scale_Float32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_scale_Float32x2_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_scale_Float32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_scale_Float32x2_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_mul_Float32x2x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_mul_Float32x2x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_mul_Float32x2x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32x2_operator_index_Int32.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt32x2_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32x2_operator_index_UInt32.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt32x2_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32x2_operator_index_Int16.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt32x2_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32x2_operator_index_UInt16.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt32x2_operator_add_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_sub_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_mul_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_div_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_mod_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_addasg_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_subasg_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_mulasg_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_divasg_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_lt_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_lte_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_gt_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_gte_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_eq_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_neq_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_scale_UInt32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_scale_UInt32x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_scale_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_scale_UInt32x2_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_scale_UInt32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_scale_UInt32x2_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_or_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_and_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_xor_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_lsh_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_rsh_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_orasg_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_andasg_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_xorasg_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_lshasg_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_rhsasg_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32x2_operator_index_Int32.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int32x2_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32x2_operator_index_UInt32.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int32x2_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32x2_operator_index_Int16.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int32x2_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32x2_operator_index_UInt16.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int32x2_operator_add_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_sub_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_mul_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_div_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_mod_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_addasg_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_subasg_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_mulasg_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_divasg_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_lt_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_lte_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_gt_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_gte_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_eq_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_neq_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_scale_Int32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_scale_Int32x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_scale_Int32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_scale_Int32x2_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_scale_Int32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_scale_Int32x2_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_or_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_and_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_xor_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_lsh_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_rsh_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_orasg_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_andasg_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_xorasg_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_lshasg_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_rhsasg_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Bool8x2_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8x2_operator_index_Int32.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Bool8x2_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8x2_operator_index_UInt32.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Bool8x2_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8x2_operator_index_Int16.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Bool8x2_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8x2_operator_index_UInt16.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Bool8x2_operator_oror_Bool8x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpLogicalOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Bool8x2_operator_andand_Bool8x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpLogicalAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Bool8x2_operator_eq_Bool8x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Bool8x2_operator_neq_Bool8x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2_operator_index_Int32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x2_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2_operator_index_UInt32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x2_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2_operator_index_Int16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x2_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2_operator_index_UInt16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x2_operator_add_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_sub_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_mul_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_div_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_mod_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_addasg_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_subasg_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_mulasg_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_divasg_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_lt_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_lte_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_gt_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_gte_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_eq_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_neq_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdNotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_scale_Float16x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_scale_Float16x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_scale_Float16x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_scale_Float16x2_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_scale_Float16x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_scale_Float16x2_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_mul_Float32x2x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_mul_Float32x2x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_mul_Float32x2x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16x2_operator_index_Int32.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt16x2_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16x2_operator_index_UInt32.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt16x2_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16x2_operator_index_Int16.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt16x2_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16x2_operator_index_UInt16.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt16x2_operator_add_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_sub_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_mul_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_div_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_mod_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_addasg_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_subasg_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_mulasg_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_divasg_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_lt_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_lte_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_gt_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_gte_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_eq_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_neq_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_scale_UInt16x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_scale_UInt16x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_scale_UInt16x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_scale_UInt16x2_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_scale_UInt16x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_scale_UInt16x2_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_or_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_and_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_xor_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_lsh_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_rsh_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_orasg_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_andasg_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_xorasg_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_lshasg_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_rhsasg_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16x2_operator_index_Int32.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int16x2_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16x2_operator_index_UInt32.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int16x2_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16x2_operator_index_Int16.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int16x2_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16x2_operator_index_UInt16.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int16x2_operator_add_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_sub_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_mul_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_div_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_mod_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_addasg_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_subasg_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_mulasg_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_divasg_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_lt_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_lte_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_gt_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_gte_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_eq_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_neq_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_scale_Int16x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_scale_Int16x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_scale_Int16x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_scale_Int16x2_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_scale_Int16x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_scale_Int16x2_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_or_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_and_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_xor_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_lsh_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_rsh_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_orasg_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_andasg_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_xorasg_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_lshasg_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_rhsasg_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3_operator_index_Int32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x3_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3_operator_index_UInt32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x3_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3_operator_index_Int16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x3_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3_operator_index_UInt16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x3_operator_add_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_sub_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_mul_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_div_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_mod_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_addasg_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_subasg_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_mulasg_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_divasg_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_lt_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_lte_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_gt_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_gte_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_eq_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_neq_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdNotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_scale_Float32x3_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_scale_Float32x3_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_scale_Float32x3_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_scale_Float32x3_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_scale_Float32x3_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_scale_Float32x3_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_mul_Float32x3x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_mul_Float32x3x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_mul_Float32x3x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32x3_operator_index_Int32.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt32x3_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32x3_operator_index_UInt32.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt32x3_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32x3_operator_index_Int16.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt32x3_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32x3_operator_index_UInt16.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt32x3_operator_add_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_sub_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_mul_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_div_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_mod_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_addasg_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_subasg_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_mulasg_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_divasg_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_lt_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_lte_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_gt_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_gte_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_eq_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_neq_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_scale_UInt32x3_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_scale_UInt32x3_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_scale_UInt32x3_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_scale_UInt32x3_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_scale_UInt32x3_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_scale_UInt32x3_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_or_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_and_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_xor_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_lsh_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_rsh_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_orasg_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_andasg_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_xorasg_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_lshasg_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_rhsasg_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32x3_operator_index_Int32.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int32x3_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32x3_operator_index_UInt32.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int32x3_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32x3_operator_index_Int16.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int32x3_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32x3_operator_index_UInt16.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int32x3_operator_add_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_sub_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_mul_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_div_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_mod_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_addasg_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_subasg_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_mulasg_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_divasg_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_lt_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_lte_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_gt_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_gte_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_eq_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_neq_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_scale_Int32x3_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_scale_Int32x3_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_scale_Int32x3_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_scale_Int32x3_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_scale_Int32x3_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_scale_Int32x3_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_or_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_and_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_xor_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_lsh_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_rsh_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_orasg_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_andasg_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_xorasg_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_lshasg_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_rhsasg_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Bool8x3_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8x3_operator_index_Int32.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Bool8x3_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8x3_operator_index_UInt32.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Bool8x3_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8x3_operator_index_Int16.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Bool8x3_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8x3_operator_index_UInt16.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Bool8x3_operator_oror_Bool8x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpLogicalOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Bool8x3_operator_andand_Bool8x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpLogicalAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Bool8x3_operator_eq_Bool8x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Bool8x3_operator_neq_Bool8x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3_operator_index_Int32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x3_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3_operator_index_UInt32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x3_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3_operator_index_Int16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x3_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3_operator_index_UInt16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x3_operator_add_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_sub_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_mul_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_div_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_mod_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_addasg_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_subasg_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_mulasg_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_divasg_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_lt_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_lte_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_gt_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_gte_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_eq_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_neq_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdNotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_scale_Float16x3_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_scale_Float16x3_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_scale_Float16x3_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_scale_Float16x3_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_scale_Float16x3_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_scale_Float16x3_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_mul_Float32x3x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_mul_Float32x3x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_mul_Float32x3x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16x3_operator_index_Int32.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt16x3_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16x3_operator_index_UInt32.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt16x3_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16x3_operator_index_Int16.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt16x3_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16x3_operator_index_UInt16.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt16x3_operator_add_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_sub_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_mul_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_div_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_mod_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_addasg_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_subasg_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_mulasg_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_divasg_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_lt_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_lte_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_gt_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_gte_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_eq_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_neq_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_scale_UInt16x3_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_scale_UInt16x3_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_scale_UInt16x3_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_scale_UInt16x3_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_scale_UInt16x3_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_scale_UInt16x3_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_or_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_and_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_xor_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_lsh_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_rsh_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_orasg_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_andasg_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_xorasg_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_lshasg_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_rhsasg_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16x3_operator_index_Int32.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int16x3_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16x3_operator_index_UInt32.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int16x3_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16x3_operator_index_Int16.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int16x3_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16x3_operator_index_UInt16.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int16x3_operator_add_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_sub_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_mul_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_div_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_mod_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_addasg_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_subasg_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_mulasg_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_divasg_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_lt_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_lte_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_gt_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_gte_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_eq_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_neq_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_scale_Int16x3_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_scale_Int16x3_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_scale_Int16x3_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_scale_Int16x3_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_scale_Int16x3_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_scale_Int16x3_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_or_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_and_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_xor_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_lsh_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_rsh_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_orasg_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_andasg_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_xorasg_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_lshasg_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_rhsasg_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4_operator_index_Int32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x4_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4_operator_index_UInt32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x4_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4_operator_index_Int16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x4_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4_operator_index_UInt16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x4_operator_add_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_sub_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_mul_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_div_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_mod_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_addasg_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_subasg_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_mulasg_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_divasg_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_lt_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_lte_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_gt_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_gte_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_eq_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_neq_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdNotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_scale_Float32x4_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_scale_Float32x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_scale_Float32x4_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_scale_Float32x4_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_scale_Float32x4_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_scale_Float32x4_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_mul_Float32x4x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_mul_Float32x4x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_mul_Float32x4x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32x4_operator_index_Int32.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt32x4_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32x4_operator_index_UInt32.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt32x4_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32x4_operator_index_Int16.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt32x4_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32x4_operator_index_UInt16.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt32x4_operator_add_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_sub_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_mul_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_div_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_mod_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_addasg_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_subasg_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_mulasg_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_divasg_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_lt_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_lte_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_gt_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_gte_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_eq_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_neq_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_scale_UInt32x4_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_scale_UInt32x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_scale_UInt32x4_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_scale_UInt32x4_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_scale_UInt32x4_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_scale_UInt32x4_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_or_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_and_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_xor_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_lsh_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_rsh_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_orasg_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_andasg_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_xorasg_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_lshasg_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_rhsasg_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32x4_operator_index_Int32.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int32x4_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32x4_operator_index_UInt32.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int32x4_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32x4_operator_index_Int16.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int32x4_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32x4_operator_index_UInt16.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int32x4_operator_add_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_sub_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_mul_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_div_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_mod_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_addasg_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_subasg_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_mulasg_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_divasg_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_lt_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_lte_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_gt_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_gte_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_eq_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_neq_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_scale_Int32x4_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_scale_Int32x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_scale_Int32x4_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_scale_Int32x4_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_scale_Int32x4_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_scale_Int32x4_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_or_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_and_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_xor_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_lsh_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_rsh_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_orasg_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_andasg_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_xorasg_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_lshasg_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_rhsasg_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Bool8x4_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8x4_operator_index_Int32.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Bool8x4_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8x4_operator_index_UInt32.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Bool8x4_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8x4_operator_index_Int16.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Bool8x4_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8x4_operator_index_UInt16.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Bool8x4_operator_oror_Bool8x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpLogicalOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Bool8x4_operator_andand_Bool8x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpLogicalAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Bool8x4_operator_eq_Bool8x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Bool8x4_operator_neq_Bool8x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4_operator_index_Int32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x4_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4_operator_index_UInt32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x4_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4_operator_index_Int16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x4_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4_operator_index_UInt16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x4_operator_add_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_sub_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_mul_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_div_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_mod_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_addasg_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_subasg_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_mulasg_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_divasg_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_lt_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_lte_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_gt_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_gte_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_eq_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_neq_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdNotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_scale_Float16x4_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_scale_Float16x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_scale_Float16x4_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_scale_Float16x4_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_scale_Float16x4_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_scale_Float16x4_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_mul_Float32x4x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_mul_Float32x4x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_mul_Float32x4x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16x4_operator_index_Int32.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt16x4_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16x4_operator_index_UInt32.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt16x4_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16x4_operator_index_Int16.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt16x4_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16x4_operator_index_UInt16.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt16x4_operator_add_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_sub_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_mul_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_div_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_mod_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_addasg_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_subasg_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_mulasg_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_divasg_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_lt_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_lte_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_gt_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_gte_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_eq_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_neq_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_scale_UInt16x4_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_scale_UInt16x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_scale_UInt16x4_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_scale_UInt16x4_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_scale_UInt16x4_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_scale_UInt16x4_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_or_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_and_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_xor_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_lsh_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_rsh_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_orasg_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_andasg_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_xorasg_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_lshasg_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_rhsasg_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16x4_operator_index_Int32.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int16x4_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16x4_operator_index_UInt32.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int16x4_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16x4_operator_index_Int16.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int16x4_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16x4_operator_index_UInt16.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int16x4_operator_add_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_sub_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_mul_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_div_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_mod_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_addasg_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_subasg_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_mulasg_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_divasg_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_lt_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_lte_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_gt_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_gte_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_eq_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_neq_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_scale_Int16x4_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_scale_Int16x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_scale_Int16x4_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_scale_Int16x4_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_scale_Int16x4_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_scale_Int16x4_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_or_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_and_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_xor_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_lsh_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_rsh_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_orasg_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_andasg_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_xorasg_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_lshasg_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_rhsasg_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x2_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2x2_operator_index_Int32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x2x2_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2x2_operator_index_UInt32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x2x2_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2x2_operator_index_Int16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x2x2_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2x2_operator_index_UInt16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x2x2_operator_add_Float32x2x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x2_operator_sub_Float32x2x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x2_operator_mul_Float32x2x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x2_operator_addasg_Float32x2x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x2_operator_subasg_Float32x2x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x2_operator_mulasg_Float32x2x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x2_operator_scale_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x3_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2x3_operator_index_Int32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x2x3_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2x3_operator_index_UInt32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x2x3_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2x3_operator_index_Int16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x2x3_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2x3_operator_index_UInt16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x2x3_operator_add_Float32x2x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x3_operator_sub_Float32x2x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x3_operator_mul_Float32x2x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x3_operator_addasg_Float32x2x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x3_operator_subasg_Float32x2x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x3_operator_mulasg_Float32x2x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x3_operator_scale_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x4_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2x4_operator_index_Int32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x2x4_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2x4_operator_index_UInt32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x2x4_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2x4_operator_index_Int16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x2x4_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2x4_operator_index_UInt16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x2x4_operator_add_Float32x2x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x4_operator_sub_Float32x2x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x4_operator_mul_Float32x2x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x4_operator_addasg_Float32x2x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x4_operator_subasg_Float32x2x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x4_operator_mulasg_Float32x2x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x4_operator_scale_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x2_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3x2_operator_index_Int32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x3x2_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3x2_operator_index_UInt32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x3x2_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3x2_operator_index_Int16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x3x2_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3x2_operator_index_UInt16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x3x2_operator_add_Float32x3x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x2_operator_sub_Float32x3x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x2_operator_mul_Float32x3x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x2_operator_addasg_Float32x3x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x2_operator_subasg_Float32x3x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x2_operator_mulasg_Float32x3x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x2_operator_scale_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x3_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3x3_operator_index_Int32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x3x3_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3x3_operator_index_UInt32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x3x3_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3x3_operator_index_Int16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x3x3_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3x3_operator_index_UInt16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x3x3_operator_add_Float32x3x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x3_operator_sub_Float32x3x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x3_operator_mul_Float32x3x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x3_operator_addasg_Float32x3x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x3_operator_subasg_Float32x3x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x3_operator_mulasg_Float32x3x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x3_operator_scale_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x4_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3x4_operator_index_Int32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x3x4_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3x4_operator_index_UInt32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x3x4_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3x4_operator_index_Int16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x3x4_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3x4_operator_index_UInt16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x3x4_operator_add_Float32x3x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x4_operator_sub_Float32x3x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x4_operator_mul_Float32x3x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x4_operator_addasg_Float32x3x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x4_operator_subasg_Float32x3x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x4_operator_mulasg_Float32x3x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x4_operator_scale_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x2_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4x2_operator_index_Int32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x4x2_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4x2_operator_index_UInt32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x4x2_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4x2_operator_index_Int16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x4x2_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4x2_operator_index_UInt16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x4x2_operator_add_Float32x4x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x2_operator_sub_Float32x4x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x2_operator_mul_Float32x4x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x2_operator_addasg_Float32x4x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x2_operator_subasg_Float32x4x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x2_operator_mulasg_Float32x4x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x2_operator_scale_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x3_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4x3_operator_index_Int32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x4x3_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4x3_operator_index_UInt32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x4x3_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4x3_operator_index_Int16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x4x3_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4x3_operator_index_UInt16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x4x3_operator_add_Float32x4x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x3_operator_sub_Float32x4x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x3_operator_mul_Float32x4x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x3_operator_addasg_Float32x4x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x3_operator_subasg_Float32x4x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x3_operator_mulasg_Float32x4x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x3_operator_scale_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x4_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4x4_operator_index_Int32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x4x4_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4x4_operator_index_UInt32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x4x4_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4x4_operator_index_Int16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x4x4_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4x4_operator_index_UInt16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x4x4_operator_add_Float32x4x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x4_operator_sub_Float32x4x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x4_operator_mul_Float32x4x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x4_operator_addasg_Float32x4x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x4_operator_subasg_Float32x4x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x4_operator_mulasg_Float32x4x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x4_operator_scale_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x2_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2x2_operator_index_Int32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x2x2_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2x2_operator_index_UInt32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x2x2_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2x2_operator_index_Int16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x2x2_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2x2_operator_index_UInt16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x2x2_operator_add_Float16x2x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x2_operator_sub_Float16x2x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x2_operator_mul_Float16x2x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x2_operator_addasg_Float16x2x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x2_operator_subasg_Float16x2x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x2_operator_mulasg_Float16x2x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x2_operator_scale_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x3_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2x3_operator_index_Int32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x2x3_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2x3_operator_index_UInt32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x2x3_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2x3_operator_index_Int16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x2x3_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2x3_operator_index_UInt16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x2x3_operator_add_Float16x2x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x3_operator_sub_Float16x2x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x3_operator_mul_Float16x2x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x3_operator_addasg_Float16x2x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x3_operator_subasg_Float16x2x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x3_operator_mulasg_Float16x2x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x3_operator_scale_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x4_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2x4_operator_index_Int32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x2x4_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2x4_operator_index_UInt32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x2x4_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2x4_operator_index_Int16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x2x4_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2x4_operator_index_UInt16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x2x4_operator_add_Float16x2x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x4_operator_sub_Float16x2x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x4_operator_mul_Float16x2x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x4_operator_addasg_Float16x2x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x4_operator_subasg_Float16x2x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x4_operator_mulasg_Float16x2x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x4_operator_scale_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x2_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3x2_operator_index_Int32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x3x2_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3x2_operator_index_UInt32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x3x2_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3x2_operator_index_Int16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x3x2_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3x2_operator_index_UInt16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x3x2_operator_add_Float16x3x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x2_operator_sub_Float16x3x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x2_operator_mul_Float16x3x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x2_operator_addasg_Float16x3x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x2_operator_subasg_Float16x3x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x2_operator_mulasg_Float16x3x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x2_operator_scale_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x3_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3x3_operator_index_Int32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x3x3_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3x3_operator_index_UInt32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x3x3_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3x3_operator_index_Int16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x3x3_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3x3_operator_index_UInt16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x3x3_operator_add_Float16x3x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x3_operator_sub_Float16x3x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x3_operator_mul_Float16x3x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x3_operator_addasg_Float16x3x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x3_operator_subasg_Float16x3x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x3_operator_mulasg_Float16x3x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x3_operator_scale_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x4_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3x4_operator_index_Int32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x3x4_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3x4_operator_index_UInt32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x3x4_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3x4_operator_index_Int16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x3x4_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3x4_operator_index_UInt16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x3x4_operator_add_Float16x3x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x4_operator_sub_Float16x3x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x4_operator_mul_Float16x3x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x4_operator_addasg_Float16x3x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x4_operator_subasg_Float16x3x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x4_operator_mulasg_Float16x3x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x4_operator_scale_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x2_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4x2_operator_index_Int32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x4x2_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4x2_operator_index_UInt32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x4x2_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4x2_operator_index_Int16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x4x2_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4x2_operator_index_UInt16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x4x2_operator_add_Float16x4x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x2_operator_sub_Float16x4x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x2_operator_mul_Float16x4x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x2_operator_addasg_Float16x4x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x2_operator_subasg_Float16x4x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x2_operator_mulasg_Float16x4x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x2_operator_scale_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x3_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4x3_operator_index_Int32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x4x3_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4x3_operator_index_UInt32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x4x3_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4x3_operator_index_Int16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x4x3_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4x3_operator_index_UInt16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x4x3_operator_add_Float16x4x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x3_operator_sub_Float16x4x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x3_operator_mul_Float16x4x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x3_operator_addasg_Float16x4x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x3_operator_subasg_Float16x4x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x3_operator_mulasg_Float16x4x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x3_operator_scale_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4x4_operator_index_Int32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x4x4_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4x4_operator_index_UInt32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x4x4_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4x4_operator_index_Int16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x4x4_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4x4_operator_index_UInt16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x4x4_operator_add_Float16x4x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_sub_Float16x4x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_mul_Float16x4x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_addasg_Float16x4x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_subasg_Float16x4x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_mulasg_Float16x4x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &acos_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acos, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &acos_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acos, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &acos_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acos, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &acos_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acos, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &acos_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acos, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &acos_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acos, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &acos_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acos, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &acos_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acos, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &acosh_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acosh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &acosh_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acosh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &acosh_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acosh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &acosh_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acosh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &acosh_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acosh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &acosh_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acosh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &acosh_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acosh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &acosh_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acosh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &asin_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asin, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &asin_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asin, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &asin_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asin, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &asin_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asin, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &asin_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asin, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &asin_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asin, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &asin_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asin, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &asin_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asin, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &asinh_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asinh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &asinh_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asinh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &asinh_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asinh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &asinh_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asinh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &asinh_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asinh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &asinh_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asinh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &asinh_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asinh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &asinh_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asinh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &atan_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &atan_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &atan_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &atan_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &atan_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &atan_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &atan_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &atan_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &atanh_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atanh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &atanh_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atanh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &atanh_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atanh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &atanh_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atanh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &atanh_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atanh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &atanh_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atanh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &atanh_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atanh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &atanh_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atanh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &cos_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cos, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &cos_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cos, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &cos_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cos, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &cos_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cos, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &cos_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cos, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &cos_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cos, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &cos_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cos, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &cos_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cos, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &cosh_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cosh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &cosh_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cosh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &cosh_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cosh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &cosh_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cosh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &cosh_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cosh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &cosh_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cosh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &cosh_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cosh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &cosh_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cosh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &exp_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &exp_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &exp_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &exp_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &exp_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &exp_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &exp_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &exp_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &exp2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp2, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &exp2_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp2, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &exp2_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp2, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &exp2_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp2, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &exp2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp2, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &exp2_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp2, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &exp2_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp2, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &exp2_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp2, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &invSqrt_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), InverseSqrt, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &invSqrt_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), InverseSqrt, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &invSqrt_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), InverseSqrt, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &invSqrt_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), InverseSqrt, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &invSqrt_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), InverseSqrt, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &invSqrt_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), InverseSqrt, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &invSqrt_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), InverseSqrt, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &invSqrt_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), InverseSqrt, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &log_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &log_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &log_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &log_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &log_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &log_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &log_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &log_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &log2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log2, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &log2_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log2, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &log2_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log2, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &log2_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log2, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &log2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log2, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &log2_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log2, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &log2_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log2, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &log2_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log2, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &sin_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sin, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &sin_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sin, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &sin_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sin, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &sin_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sin, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &sin_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sin, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &sin_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sin, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &sin_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sin, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &sin_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sin, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &sinh_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sinh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &sinh_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sinh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &sinh_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sinh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &sinh_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sinh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &sinh_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sinh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &sinh_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sinh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &sinh_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sinh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &sinh_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sinh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &sqrt_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sqrt, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &sqrt_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sqrt, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &sqrt_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sqrt, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &sqrt_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sqrt, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &sqrt_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sqrt, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &sqrt_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sqrt, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &sqrt_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sqrt, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &sqrt_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sqrt, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &tan_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tan, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &tan_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tan, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &tan_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tan, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &tan_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tan, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &tan_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tan, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &tan_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tan, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &tan_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tan, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &tan_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tan, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &tanh_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tanh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &tanh_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tanh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &tanh_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tanh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &tanh_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tanh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &tanh_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tanh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &tanh_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tanh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &tanh_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tanh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &tanh_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tanh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &atan2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult y = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan2, y, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &atan2_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult y = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan2, y, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &atan2_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult y = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan2, y, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &atan2_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult y = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan2, y, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &atan2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult y = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan2, y, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &atan2_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult y = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan2, y, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &atan2_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult y = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan2, y, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &atan2_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult y = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan2, y, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &pow_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult exponent = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Pow, val, exponent);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &pow_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult exponent = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Pow, val, exponent);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &pow_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult exponent = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Pow, val, exponent);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &pow_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult exponent = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Pow, val, exponent);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &pow_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult exponent = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Pow, val, exponent);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &pow_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult exponent = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Pow, val, exponent);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &pow_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult exponent = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Pow, val, exponent);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &pow_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult exponent = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Pow, val, exponent);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &mad_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &mad_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &mad_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &mad_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &mad_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &mad_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &mad_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &mad_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &mad_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &mad_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &mad_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &mad_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &mad_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &mad_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &mad_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &mad_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &mad_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &mad_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &mad_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &mad_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &mad_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &mad_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &mad_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &mad_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &dot_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult x = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult y = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpDot, SPVWriter::Section::LocalFunction, returnType, x, y);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &dot_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult x = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult y = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpDot, SPVWriter::Section::LocalFunction, returnType, x, y);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &dot_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult x = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult y = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpDot, SPVWriter::Section::LocalFunction, returnType, x, y);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &dot_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult x = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult y = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpDot, SPVWriter::Section::LocalFunction, returnType, x, y);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &dot_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult x = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult y = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpDot, SPVWriter::Section::LocalFunction, returnType, x, y);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &dot_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult x = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult y = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpDot, SPVWriter::Section::LocalFunction, returnType, x, y);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &reflect_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult incident = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult normal = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Reflect, incident, normal);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &reflect_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult incident = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult normal = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Reflect, incident, normal);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &reflect_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult incident = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult normal = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Reflect, incident, normal);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &reflect_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult incident = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult normal = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Reflect, incident, normal);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &reflect_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult incident = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult normal = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Reflect, incident, normal);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &reflect_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult incident = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult normal = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Reflect, incident, normal);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &refract_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult incident = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult normal = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult ior = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Refract, incident, normal, ior);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &refract_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult incident = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult normal = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult ior = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Refract, incident, normal, ior);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &refract_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult incident = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult normal = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult ior = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Refract, incident, normal, ior);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &refract_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult incident = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult normal = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult ior = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Refract, incident, normal, ior);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &refract_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult incident = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult normal = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult ior = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Refract, incident, normal, ior);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &refract_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult incident = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult normal = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult ior = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Refract, incident, normal, ior);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &cross_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult x = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult y = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cross, x, y);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &cross_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult x = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult y = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cross, x, y);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &length_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult vec = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Length, vec);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &length_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult vec = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Length, vec);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &length_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult vec = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Length, vec);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &length_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult vec = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Length, vec);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &length_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult vec = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Length, vec);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &length_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult vec = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Length, vec);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &normalize_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult vec = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Normalize, vec);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &normalize_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult vec = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Normalize, vec);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &normalize_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult vec = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Normalize, vec);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &normalize_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult vec = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Normalize, vec);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &normalize_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult vec = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Normalize, vec);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &normalize_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult vec = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Normalize, vec);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &distance_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult v0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult v1 = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Distance, v0, v1);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &distance_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult v0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult v1 = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Distance, v0, v1);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &distance_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult v0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult v1 = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Distance, v0, v1);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &distance_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult v0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult v1 = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Distance, v0, v1);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &distance_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult v0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult v1 = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Distance, v0, v1);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &distance_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult v0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult v1 = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Distance, v0, v1);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &min_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &min_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &min_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &min_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &min_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &min_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &min_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &min_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &min_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &min_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &min_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &min_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &min_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &min_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &min_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &min_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &min_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &min_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &min_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &min_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &min_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &min_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &min_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &min_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &max_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &max_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &max_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &max_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &max_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &max_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &max_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &max_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &max_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &max_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &max_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &max_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &max_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &max_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &max_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &max_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &max_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &max_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &max_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &max_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &max_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &max_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &max_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &max_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &clamp_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &clamp_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &clamp_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &clamp_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &clamp_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &clamp_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &clamp_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &clamp_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &clamp_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &clamp_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &clamp_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &clamp_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &clamp_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &clamp_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &clamp_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &clamp_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &clamp_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &clamp_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &clamp_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &clamp_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &clamp_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &clamp_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &clamp_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &clamp_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &lerp_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult a = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult b = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult t = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMix, a, b, t);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &lerp_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult a = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult b = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult t = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMix, a, b, t);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &lerp_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult a = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult b = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult t = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMix, a, b, t);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &lerp_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult a = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult b = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult t = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMix, a, b, t);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &lerp_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult a = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult b = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult t = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMix, a, b, t);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &lerp_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult a = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult b = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult t = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMix, a, b, t);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &step_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult edge = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Step, edge, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &step_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult edge = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Step, edge, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &step_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult edge = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Step, edge, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &step_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult edge = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Step, edge, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &step_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult edge = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Step, edge, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &step_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult edge = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Step, edge, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &step_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult edge = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Step, edge, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &step_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult edge = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Step, edge, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &smoothstep_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult edge0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult edge1 = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SmoothStep, edge0, edge1, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &smoothstep_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult edge0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult edge1 = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SmoothStep, edge0, edge1, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &smoothstep_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult edge0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult edge1 = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SmoothStep, edge0, edge1, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &smoothstep_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult edge0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult edge1 = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SmoothStep, edge0, edge1, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &smoothstep_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult edge0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult edge1 = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SmoothStep, edge0, edge1, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &smoothstep_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult edge0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult edge1 = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SmoothStep, edge0, edge1, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &smoothstep_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult edge0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult edge1 = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SmoothStep, edge0, edge1, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &smoothstep_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult edge0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult edge1 = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SmoothStep, edge0, edge1, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &ceil_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Ceil, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &ceil_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Ceil, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &ceil_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Ceil, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &ceil_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Ceil, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &ceil_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Ceil, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &ceil_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Ceil, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &ceil_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Ceil, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &ceil_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Ceil, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &floor_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Floor, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &floor_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Floor, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &floor_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Floor, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &floor_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Floor, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &floor_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Floor, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &floor_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Floor, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &floor_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Floor, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &floor_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Floor, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &fract_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fract, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &fract_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fract, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &fract_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fract, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &fract_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fract, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &fract_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fract, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &fract_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fract, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &fract_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fract, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &fract_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fract, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &saturate_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float(0));
    SPIRVResult max = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float(1));
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &saturate_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float(0));
    SPIRVResult max = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float(1));
    min = GenerateSplatCompositeSPIRV(c, g, returnType, 2, min);
    max = GenerateSplatCompositeSPIRV(c, g, returnType, 2, max);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &saturate_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float(0));
    SPIRVResult max = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float(1));
    min = GenerateSplatCompositeSPIRV(c, g, returnType, 3, min);
    max = GenerateSplatCompositeSPIRV(c, g, returnType, 3, max);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &saturate_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float(0));
    SPIRVResult max = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float(1));
    min = GenerateSplatCompositeSPIRV(c, g, returnType, 4, min);
    max = GenerateSplatCompositeSPIRV(c, g, returnType, 4, max);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &saturate_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float(0));
    SPIRVResult max = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float(1));
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &saturate_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float(0));
    SPIRVResult max = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float(1));
    min = GenerateSplatCompositeSPIRV(c, g, returnType, 2, min);
    max = GenerateSplatCompositeSPIRV(c, g, returnType, 2, max);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &saturate_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float(0));
    SPIRVResult max = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float(1));
    min = GenerateSplatCompositeSPIRV(c, g, returnType, 3, min);
    max = GenerateSplatCompositeSPIRV(c, g, returnType, 3, max);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &saturate_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float(0));
    SPIRVResult max = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float(1));
    min = GenerateSplatCompositeSPIRV(c, g, returnType, 4, min);
    max = GenerateSplatCompositeSPIRV(c, g, returnType, 4, max);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &trunc_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Trunc, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &trunc_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Trunc, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &trunc_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Trunc, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &trunc_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Trunc, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &trunc_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Trunc, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &trunc_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Trunc, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &trunc_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Trunc, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &trunc_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Trunc, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &ddx_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpDPdx, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &ddx_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpDPdx, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &ddx_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpDPdx, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &ddx_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpDPdx, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &ddx_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpDPdx, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &ddx_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpDPdx, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &ddx_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpDPdx, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &ddx_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpDPdx, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &ddy_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpDPdy, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &ddy_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpDPdy, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &ddy_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpDPdy, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &ddy_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpDPdy, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &ddy_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpDPdy, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &ddy_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpDPdy, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &ddy_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpDPdy, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &ddy_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpDPdy, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &fwidth_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpFwidth, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &fwidth_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpFwidth, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &fwidth_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpFwidth, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &fwidth_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpFwidth, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &fwidth_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpFwidth, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &fwidth_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpFwidth, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &fwidth_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpFwidth, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &fwidth_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpFwidth, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &sign_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SSign, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &sign_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SSign, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &sign_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SSign, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &sign_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SSign, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &sign_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SSign, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &sign_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SSign, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &sign_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SSign, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &sign_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SSign, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &sign_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FSign, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &sign_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FSign, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &sign_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FSign, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &sign_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FSign, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &sign_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FSign, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &sign_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FSign, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &sign_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FSign, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &sign_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FSign, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &abs_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SAbs, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &abs_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SAbs, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &abs_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SAbs, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &abs_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SAbs, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &abs_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SAbs, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &abs_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SAbs, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &abs_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SAbs, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &abs_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SAbs, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &abs_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FAbs, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &abs_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FAbs, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &abs_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FAbs, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &abs_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FAbs, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &abs_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FAbs, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &abs_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FAbs, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &abs_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FAbs, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &abs_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FAbs, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &castToF16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &castToF16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &castToU16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &castToU16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &castToI16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &castToI16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &castToF32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &castToF32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &castToU32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &castToU32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &castToI32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &castToI32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &any_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpAny, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &any_Bool8x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpAny, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &any_Bool8x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpAny, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &any_Bool8x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpAny, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &all_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpAll, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &all_Bool8x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpAll, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &all_Bool8x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpAll, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &all_Bool8x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpAll, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &transpose_Float32x2x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpTranspose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &transpose_Float16x2x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpTranspose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &transpose_Float32x2x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpTranspose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &transpose_Float16x2x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpTranspose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &transpose_Float32x2x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpTranspose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &transpose_Float16x2x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpTranspose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &transpose_Float32x3x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpTranspose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &transpose_Float16x3x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpTranspose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &transpose_Float32x3x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpTranspose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &transpose_Float16x3x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpTranspose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &transpose_Float32x3x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpTranspose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &transpose_Float16x3x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpTranspose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &transpose_Float32x4x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpTranspose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &transpose_Float16x4x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpTranspose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &transpose_Float32x4x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpTranspose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &transpose_Float16x4x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpTranspose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &transpose_Float32x4x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpTranspose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &transpose_Float16x4x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpTranspose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &inverse_Float32x2x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), MatrixInverse, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &inverse_Float16x2x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), MatrixInverse, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &inverse_Float32x2x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), MatrixInverse, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &inverse_Float16x2x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), MatrixInverse, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &inverse_Float32x2x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), MatrixInverse, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &inverse_Float16x2x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), MatrixInverse, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &inverse_Float32x3x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), MatrixInverse, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &inverse_Float16x3x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), MatrixInverse, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &inverse_Float32x3x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), MatrixInverse, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &inverse_Float16x3x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), MatrixInverse, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &inverse_Float32x3x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), MatrixInverse, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &inverse_Float16x3x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), MatrixInverse, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &inverse_Float32x4x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), MatrixInverse, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &inverse_Float16x4x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), MatrixInverse, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &inverse_Float32x4x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), MatrixInverse, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &inverse_Float16x4x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), MatrixInverse, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &inverse_Float32x4x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), MatrixInverse, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &inverse_Float16x4x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), MatrixInverse, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &VertexGetOutputLayer , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::ShaderLayer);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplOutputLayer"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::Layer);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &VertexGetOutputViewport , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::ShaderViewportIndex);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplOutputViewport"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::ViewportIndex);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &VertexGetIndex , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplIndex"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::VertexId);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &VertexGetInstanceIndex , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplInstanceIndex"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::InstanceId);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &VertexGetBaseIndex , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplBaseIndex"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::BaseVertex);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &VertexGetBaseInstanceIndex , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplBaseInstanceIndex"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::BaseInstance);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &VertexGetDrawIndex , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplDrawIndex"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::DrawIndex);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &VertexSetOutputLayer_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::ShaderLayer);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplOutputLayer"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::Layer);
    g->interfaceVariables.Insert(ret);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, args[0]);
    return SPIRVResult::Invalid();
}},
std::pair{ &VertexSetOutputLayer_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::ShaderLayer);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplOutputLayer"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::Layer);
    g->interfaceVariables.Insert(ret);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, args[0]);
    return SPIRVResult::Invalid();
}},
std::pair{ &VertexSetOutputViewport_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::ShaderViewportIndex);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplOutputViewport"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::ViewportIndex);
    g->interfaceVariables.Insert(ret);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, args[0]);
    return SPIRVResult::Invalid();
}},
std::pair{ &VertexSetOutputViewport_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::ShaderViewportIndex);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplOutputViewport"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::ViewportIndex);
    g->interfaceVariables.Insert(ret);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, args[0]);
    return SPIRVResult::Invalid();
}},
std::pair{ &VertexExportCoordinates_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplOutputViewport"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::Position);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &VertexExportCoordinates_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplOutputViewport"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::Position);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &GeometryExportVertex , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Geometry);
    g->writer->Instruction(OpEmitVertex, SPVWriter::Section::LocalFunction);
    return SPIRVResult::Invalid();
}},
std::pair{ &GeometryExportPrimitive , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Geometry);
    g->writer->Instruction(OpEndPrimitive, SPVWriter::Section::LocalFunction);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelGetCoordinates_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelGetCoordinates_Float32x4"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::FragCoord);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &PixelGetCoordinates_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelGetCoordinates_Float16x4"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::FragCoord);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &PixelGetDepth , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelGetDepth"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::FragDepth);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &PixelSetDepth , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32_Input"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelSetDepth"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::FragDepth);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Float32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Float32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Float32_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Float32_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Float32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32x2_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Float32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32x2_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Float32x2_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32x2_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Float32x2_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32x2_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Float32x3_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32x3_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Float32x3_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32x3_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Float32x3_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32x3_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Float32x3_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32x3_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Float32x4_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32x4_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Float32x4_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32x4_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Float32x4_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32x4_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Float32x4_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32x4_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Float16_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Float16_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Float16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Float16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Float16x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16x2_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Float16x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16x2_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Float16x2_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16x2_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Float16x2_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16x2_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Float16x3_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16x3_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Float16x3_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16x3_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Float16x3_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16x3_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Float16x3_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16x3_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Float16x4_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16x4_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Float16x4_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16x4_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Float16x4_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16x4_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Float16x4_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16x4_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Int32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Int32_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Int32_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Int32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32x2_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Int32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32x2_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Int32x2_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32x2_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Int32x2_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32x2_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Int32x3_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32x3_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Int32x3_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32x3_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Int32x3_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32x3_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Int32x3_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32x3_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Int32x4_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32x4_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Int32x4_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32x4_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Int32x4_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32x4_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Int32x4_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32x4_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Int16_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Int16_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Int16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Int16x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16x2_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Int16x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16x2_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Int16x2_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16x2_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Int16x2_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16x2_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Int16x3_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16x3_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Int16x3_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16x3_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Int16x3_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16x3_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Int16x3_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16x3_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Int16x4_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16x4_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Int16x4_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16x4_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Int16x4_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16x4_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_Int16x4_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16x4_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_UInt32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_UInt32_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_UInt32_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_UInt32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32x2_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32x2_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_UInt32x2_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32x2_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_UInt32x2_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32x2_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_UInt32x3_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32x3_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_UInt32x3_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32x3_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_UInt32x3_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32x3_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_UInt32x3_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32x3_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_UInt32x4_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32x4_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_UInt32x4_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32x4_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_UInt32x4_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32x4_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_UInt32x4_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32x4_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_UInt16_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_UInt16_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_UInt16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_UInt16x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16x2_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_UInt16x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16x2_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_UInt16x2_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16x2_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_UInt16x2_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16x2_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_UInt16x3_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16x3_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_UInt16x3_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16x3_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_UInt16x3_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16x3_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_UInt16x3_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16x3_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_UInt16x4_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16x4_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_UInt16x4_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16x4_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_UInt16x4_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16x4_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &PixelExportColor_UInt16x4_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16x4_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &ComputeGetLocalThreadIndices , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x3_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplComputeGetLocalThreadIndices"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::LocalInvocationId);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &ComputeGetGlobalThreadIndices , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x3_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplComputeGetGlobalThreadIndices"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::GlobalInvocationId);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &ComputeGetWorkgroupIndices , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x3_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplComputeGetWorkgroupIndices"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::WorkgroupId);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &ComputeGetWorkGroupDimensions , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x3_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplComputeGetWorkGroupDimensions"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::WorkgroupSize);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &ComputeGetIndexInWorkgroup , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplComputeGetIndexInWorkgroup"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::LocalInvocationIndex);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &SubgroupGetId , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniform);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x3_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplSubgroupGetId"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::LocalInvocationIndex);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &SubgroupGetSize , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniform);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x3_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplSubgroupGetSize"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::LocalInvocationIndex);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &SubgroupGetNum , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniform);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x3_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplSubgroupGetNum"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::LocalInvocationIndex);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &SubgroupGetThreadMask , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniform);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplSubgroupGetThreadMask"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::SubgroupEqMask);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &SubgroupGetThreadAndLowerMask , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniform);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplSubgroupGetThreadAndLowerMask"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::SubgroupLeMask);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &SubgroupGetLowerMask , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniform);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplSubgroupGetLowerMask"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::SubgroupLtMask);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &SubgroupGetThreadAndGreaterMask , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniform);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplSubgroupGetThreadAndGreaterMask"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::SubgroupGeMask);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &SubgroupGetGreaterMask , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniform);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplSubgroupGetGreaterMask"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::SubgroupGtMask);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &SubgroupFirstActiveThread , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniform);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformElect, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupBroadcastFirstActiveThread , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBroadcastFirst, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupBallot , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(['GroupNonUniformBallot', 'GroupNonUniformInverseBallot'], SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupInverseBallot , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(['GroupNonUniformBallot', 'GroupNonUniformInverseBallot'], SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupBallotBitCount , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitCount, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, 0, loaded);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupBallotFirstOne , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotFindLSB, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupBallotLastOne , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotFindMSB, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupBallotBit , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult bit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, bit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicLoad_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[1].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicLoad, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicIncrement_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[1].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIIncrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicDecrement_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[1].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicLoad_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[1].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicLoad, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicIncrement_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[1].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIIncrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicDecrement_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[1].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicLoad_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[1].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicLoad, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicIncrement_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[1].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIIncrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicDecrement_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[1].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicLoad_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[1].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicLoad, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicIncrement_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[1].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIIncrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicDecrement_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[1].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicStore_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicExchange_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicAdd_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicSubtract_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicAnd_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicOr_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicXor_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicStore_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicExchange_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicAdd_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicSubtract_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicAnd_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicOr_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicXor_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicStore_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicExchange_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicAdd_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicSubtract_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicAnd_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicOr_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicXor_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicStore_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicExchange_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicAdd_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicSubtract_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicAnd_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicOr_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicXor_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicCompareExchange_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[3].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult value = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, semanticsId, value, compare);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicCompareExchange_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[3].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult value = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, semanticsId, value, compare);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicCompareExchange_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[3].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult value = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, semanticsId, value, compare);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &AtomicCompareExchange_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[3].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult value = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, semanticsId, value, compare);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitInsert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult value = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult offset = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult count = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpBitFieldInsert, SPVWriter::Section::LocalFunction, returnType, base, value, offset, count);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitInsert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult value = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult offset = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult count = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpBitFieldInsert, SPVWriter::Section::LocalFunction, returnType, base, value, offset, count);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitExtract_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult offset = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult count = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpBitFieldSExtract, SPVWriter::Section::LocalFunction, returnType, base, offset, count);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitExtract_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult offset = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult count = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpBitFieldSExtract, SPVWriter::Section::LocalFunction, returnType, base, offset, count);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitExtract_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult offset = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult count = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpBitFieldSExtract, SPVWriter::Section::LocalFunction, returnType, base, offset, count);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitExtract_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult offset = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult count = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpBitFieldSExtract, SPVWriter::Section::LocalFunction, returnType, base, offset, count);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitExtract_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult offset = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult count = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpBitFieldSExtract, SPVWriter::Section::LocalFunction, returnType, base, offset, count);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitExtract_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult offset = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult count = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpBitFieldSExtract, SPVWriter::Section::LocalFunction, returnType, base, offset, count);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitExtract_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult offset = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult count = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpBitFieldSExtract, SPVWriter::Section::LocalFunction, returnType, base, offset, count);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitExtract_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult offset = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult count = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpBitFieldSExtract, SPVWriter::Section::LocalFunction, returnType, base, offset, count);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitExtract_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult offset = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult count = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpBitFieldUExtract, SPVWriter::Section::LocalFunction, returnType, base, offset, count);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitExtract_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult offset = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult count = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpBitFieldUExtract, SPVWriter::Section::LocalFunction, returnType, base, offset, count);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitExtract_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult offset = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult count = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpBitFieldUExtract, SPVWriter::Section::LocalFunction, returnType, base, offset, count);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitExtract_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult offset = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult count = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpBitFieldUExtract, SPVWriter::Section::LocalFunction, returnType, base, offset, count);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitExtract_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult offset = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult count = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpBitFieldUExtract, SPVWriter::Section::LocalFunction, returnType, base, offset, count);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitExtract_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult offset = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult count = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpBitFieldUExtract, SPVWriter::Section::LocalFunction, returnType, base, offset, count);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitExtract_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult offset = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult count = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpBitFieldUExtract, SPVWriter::Section::LocalFunction, returnType, base, offset, count);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitExtract_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult offset = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult count = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpBitFieldUExtract, SPVWriter::Section::LocalFunction, returnType, base, offset, count);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitReverse_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitReverse, SPVWriter::Section::LocalFunction, returnType, base);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitReverse_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitReverse, SPVWriter::Section::LocalFunction, returnType, base);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitReverse_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitReverse, SPVWriter::Section::LocalFunction, returnType, base);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitReverse_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitReverse, SPVWriter::Section::LocalFunction, returnType, base);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitReverse_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitReverse, SPVWriter::Section::LocalFunction, returnType, base);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitReverse_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitReverse, SPVWriter::Section::LocalFunction, returnType, base);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitReverse_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitReverse, SPVWriter::Section::LocalFunction, returnType, base);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitReverse_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitReverse, SPVWriter::Section::LocalFunction, returnType, base);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitReverse_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitReverse, SPVWriter::Section::LocalFunction, returnType, base);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitReverse_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitReverse, SPVWriter::Section::LocalFunction, returnType, base);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitReverse_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitReverse, SPVWriter::Section::LocalFunction, returnType, base);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitReverse_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitReverse, SPVWriter::Section::LocalFunction, returnType, base);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitReverse_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitReverse, SPVWriter::Section::LocalFunction, returnType, base);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitReverse_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitReverse, SPVWriter::Section::LocalFunction, returnType, base);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitReverse_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitReverse, SPVWriter::Section::LocalFunction, returnType, base);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitReverse_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitReverse, SPVWriter::Section::LocalFunction, returnType, base);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitCount_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitReverse, SPVWriter::Section::LocalFunction, returnType, base);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitCount_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitReverse, SPVWriter::Section::LocalFunction, returnType, base);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitCount_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitReverse, SPVWriter::Section::LocalFunction, returnType, base);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitCount_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitReverse, SPVWriter::Section::LocalFunction, returnType, base);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitCount_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitReverse, SPVWriter::Section::LocalFunction, returnType, base);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitCount_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitReverse, SPVWriter::Section::LocalFunction, returnType, base);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitCount_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitReverse, SPVWriter::Section::LocalFunction, returnType, base);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitCount_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitReverse, SPVWriter::Section::LocalFunction, returnType, base);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitCount_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitReverse, SPVWriter::Section::LocalFunction, returnType, base);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitCount_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitReverse, SPVWriter::Section::LocalFunction, returnType, base);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitCount_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitReverse, SPVWriter::Section::LocalFunction, returnType, base);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitCount_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitReverse, SPVWriter::Section::LocalFunction, returnType, base);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitCount_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitReverse, SPVWriter::Section::LocalFunction, returnType, base);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitCount_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitReverse, SPVWriter::Section::LocalFunction, returnType, base);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitCount_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitReverse, SPVWriter::Section::LocalFunction, returnType, base);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &BitCount_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitReverse, SPVWriter::Section::LocalFunction, returnType, base);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &ExecutionBarrier , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(2));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(0x2 | 0x40 | 0x80 | 0x100 | 0x200 | 0x400 | 0x800));
    uint32_t ret = g->writer->MappedInstruction(OpControlBarrier, SPVWriter::Section::LocalFunction, scopeId, scopeId, semanticsId);
    return SPIRVResult(0xFFFFFFFF, returnType);
}},
std::pair{ &ExecutionBarrierSubgroup , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(3));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(0x2 | 0x80));
    uint32_t ret = g->writer->MappedInstruction(OpControlBarrier, SPVWriter::Section::LocalFunction, scopeId, scopeId, semanticsId);
    return SPIRVResult(0xFFFFFFFF, returnType);
}},
std::pair{ &ExecutionBarrierWorkgroup , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(2));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(0x2 | 0x100));
    uint32_t ret = g->writer->MappedInstruction(OpControlBarrier, SPVWriter::Section::LocalFunction, scopeId, scopeId, semanticsId);
    return SPIRVResult(0xFFFFFFFF, returnType);
}},
std::pair{ &MemoryBarrier , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(2));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(0x2 | 0x40 | 0x80 | 0x100 | 0x200 | 0x400 | 0x800));
    uint32_t ret = g->writer->MappedInstruction(OpMemoryBarrier, SPVWriter::Section::LocalFunction, scopeId, scopeId, semanticsId);
    return SPIRVResult(0xFFFFFFFF, returnType);
}},
std::pair{ &MemoryBarrierBuffer , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(2));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(0x2 | 0x40));
    uint32_t ret = g->writer->MappedInstruction(OpMemoryBarrier, SPVWriter::Section::LocalFunction, scopeId, scopeId, semanticsId);
    return SPIRVResult(0xFFFFFFFF, returnType);
}},
std::pair{ &MemoryBarrierTexture , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(2));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(0x2 | 0x800));
    uint32_t ret = g->writer->MappedInstruction(OpMemoryBarrier, SPVWriter::Section::LocalFunction, scopeId, scopeId, semanticsId);
    return SPIRVResult(0xFFFFFFFF, returnType);
}},
std::pair{ &MemoryBarrierAtomic , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(2));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(0x2 | 0x400));
    uint32_t ret = g->writer->MappedInstruction(OpMemoryBarrier, SPVWriter::Section::LocalFunction, scopeId, scopeId, semanticsId);
    return SPIRVResult(0xFFFFFFFF, returnType);
}},
std::pair{ &MemoryBarrierSubgroup , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(3));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(0x2 | 0x80));
    uint32_t ret = g->writer->MappedInstruction(OpMemoryBarrier, SPVWriter::Section::LocalFunction, scopeId, scopeId, semanticsId);
    return SPIRVResult(0xFFFFFFFF, returnType);
}},
std::pair{ &MemoryBarrierWorkgroup , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(2));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(0x2 | 0x100));
    uint32_t ret = g->writer->MappedInstruction(OpMemoryBarrier, SPVWriter::Section::LocalFunction, scopeId, scopeId, semanticsId);
    return SPIRVResult(0xFFFFFFFF, returnType);
}},
std::pair{ &TextureGetSize_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySize, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGetSize_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySize, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGetSize_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySize, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGetSize_TextureCube , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySize, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGetSize_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySize, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGetSize_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySize, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGetSize_TextureCubeArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySize, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGetSizeMip_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySizeLod, SPVWriter::Section::LocalFunction, returnType, texture, mip);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGetSizeMip_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySizeLod, SPVWriter::Section::LocalFunction, returnType, texture, mip);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGetSizeMip_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySizeLod, SPVWriter::Section::LocalFunction, returnType, texture, mip);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGetSizeMip_TextureCube , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySizeLod, SPVWriter::Section::LocalFunction, returnType, texture, mip);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGetSizeMip_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySizeLod, SPVWriter::Section::LocalFunction, returnType, texture, mip);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGetSizeMip_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySizeLod, SPVWriter::Section::LocalFunction, returnType, texture, mip);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGetSizeMip_TextureCubeArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySizeLod, SPVWriter::Section::LocalFunction, returnType, texture, mip);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGetMips_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLevels, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGetMips_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLevels, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGetMips_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLevels, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGetMips_TextureCube , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLevels, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGetMips_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLevels, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGetMips_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLevels, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGetMips_TextureCubeArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLevels, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGetSamples_Texture2DMS , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGetSamples_Texture2DMSArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGetSampledMip_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureGetSampledMip_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGetSampledMip_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureGetSampledMip_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGetSampledMip_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureGetSampledMip_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGetSampledMip_TextureCube , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureGetSampledMip_TextureCube , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGetSampledMip_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureGetSampledMip_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGetSampledMip_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureGetSampledMip_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGetSampledMip_TextureCubeArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureGetSampledMip_TextureCubeArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureLoad_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageRead, SPVWriter::Section::LocalFunction, returnType, texture, coord);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureLoadMip_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageRead, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureStore_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult value = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageWrite, SPVWriter::Section::LocalFunction, returnType, texture, coord, value);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureStoreMip_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult value = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageWrite, SPVWriter::Section::LocalFunction, returnType, texture, coord, value, ImageOperands::Lod, mip);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureLoad_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageRead, SPVWriter::Section::LocalFunction, returnType, texture, coord);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureLoadMip_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageRead, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureStore_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult value = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageWrite, SPVWriter::Section::LocalFunction, returnType, texture, coord, value);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureStoreMip_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult value = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageWrite, SPVWriter::Section::LocalFunction, returnType, texture, coord, value, ImageOperands::Lod, mip);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureLoad_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageRead, SPVWriter::Section::LocalFunction, returnType, texture, coord);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureLoadMip_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageRead, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureStore_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult value = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageWrite, SPVWriter::Section::LocalFunction, returnType, texture, coord, value);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureStoreMip_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult value = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageWrite, SPVWriter::Section::LocalFunction, returnType, texture, coord, value, ImageOperands::Lod, mip);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureLoad_TextureCube , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageRead, SPVWriter::Section::LocalFunction, returnType, texture, coord);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureLoadMip_TextureCube , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageRead, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureStore_TextureCube , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult value = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageWrite, SPVWriter::Section::LocalFunction, returnType, texture, coord, value);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureStoreMip_TextureCube , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult value = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageWrite, SPVWriter::Section::LocalFunction, returnType, texture, coord, value, ImageOperands::Lod, mip);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureLoad_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageRead, SPVWriter::Section::LocalFunction, returnType, texture, coord);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureLoadMip_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageRead, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureStore_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult value = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageWrite, SPVWriter::Section::LocalFunction, returnType, texture, coord, value);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureStoreMip_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult value = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageWrite, SPVWriter::Section::LocalFunction, returnType, texture, coord, value, ImageOperands::Lod, mip);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureLoad_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageRead, SPVWriter::Section::LocalFunction, returnType, texture, coord);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureLoadMip_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageRead, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureStore_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult value = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageWrite, SPVWriter::Section::LocalFunction, returnType, texture, coord, value);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureStoreMip_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult value = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageWrite, SPVWriter::Section::LocalFunction, returnType, texture, coord, value, ImageOperands::Lod, mip);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureLoad_TextureCubeArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageRead, SPVWriter::Section::LocalFunction, returnType, texture, coord);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureLoadMip_TextureCubeArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageRead, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureStore_TextureCubeArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult value = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageWrite, SPVWriter::Section::LocalFunction, returnType, texture, coord, value);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureStoreMip_TextureCubeArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult value = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageWrite, SPVWriter::Section::LocalFunction, returnType, texture, coord, value, ImageOperands::Lod, mip);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureLoad_Texture2DMS , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageRead, SPVWriter::Section::LocalFunction, returnType, texture, coord);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureLoadMip_Texture2DMS , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageRead, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureStore_Texture2DMS , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult value = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageWrite, SPVWriter::Section::LocalFunction, returnType, texture, coord, value);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureStoreMip_Texture2DMS , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult value = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageWrite, SPVWriter::Section::LocalFunction, returnType, texture, coord, value, ImageOperands::Lod, mip);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureLoad_Texture2DMSArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageRead, SPVWriter::Section::LocalFunction, returnType, texture, coord);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureLoadMip_Texture2DMSArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageRead, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureStore_Texture2DMSArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult value = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageWrite, SPVWriter::Section::LocalFunction, returnType, texture, coord, value);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureStoreMip_Texture2DMSArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult value = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageWrite, SPVWriter::Section::LocalFunction, returnType, texture, coord, value, ImageOperands::Lod, mip);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureFetch_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureFetchSample_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult sample = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip, ImageOperands::Sample, sample);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureFetch_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureFetchSample_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult sample = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip, ImageOperands::Sample, sample);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureFetch_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureFetchSample_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult sample = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip, ImageOperands::Sample, sample);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureFetch_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureFetchSample_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult sample = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip, ImageOperands::Sample, sample);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureFetch_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureFetchSample_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult sample = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip, ImageOperands::Sample, sample);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureFetch_Texture2DMS , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureFetchSample_Texture2DMS , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult sample = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip, ImageOperands::Sample, sample);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureFetch_Texture2DMSArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureFetchSample_Texture2DMSArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult sample = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip, ImageOperands::Sample, sample);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGather_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult component = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, component);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureGather_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult component = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, component);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGatherOffset_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult component = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult offset = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, component, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureGatherOffset_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult component = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult offset = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, component, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGather_TextureCube , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult component = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, component);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureGather_TextureCube , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult component = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, component);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGatherOffset_TextureCube , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult component = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult offset = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, component, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureGatherOffset_TextureCube , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult component = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult offset = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, component, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGather_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult component = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, component);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureGather_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult component = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, component);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGatherOffset_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult component = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult offset = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, component, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureGatherOffset_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult component = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult offset = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, component, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGather_TextureCubeArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult component = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, component);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureGather_TextureCubeArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult component = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, component);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGatherOffset_TextureCubeArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult component = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult offset = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, component, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureGatherOffset_TextureCubeArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult component = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult offset = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, component, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSample_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, );
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSample_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, );
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSample_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, );
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSample_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, );
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSample_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, );
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSample_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, );
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSample_TextureCube , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, );
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSample_TextureCube , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, );
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSample_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, );
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSample_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, );
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSample_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, );
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSample_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, );
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSample_TextureCubeArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, );
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSample_TextureCubeArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, );
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleOffset_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleOffset_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleOffset_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleOffset_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleOffset_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleOffset_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleOffset_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleOffset_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleOffset_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleOffset_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleProj_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, );
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleProj_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, );
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleProj_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, );
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleProj_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, );
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleProj_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, );
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleProj_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, );
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleProjOffset_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleProjOffset_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleProjOffset_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleProjOffset_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleProjOffset_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleProjOffset_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleCompare_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleCompare_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleCompare_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleCompare_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleCompare_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleCompare_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleCompare_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleCompare_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleCompare_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleCompare_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleCompareOffset_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleCompareOffset_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleCompareOffset_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleCompareOffset_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleCompareOffset_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleCompareOffset_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleCompareOffset_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleCompareOffset_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleCompareOffset_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleCompareOffset_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleProjCompare_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleProjCompare_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleProjCompare_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleProjCompare_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleProjCompare_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleProjCompare_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleProjCompareOffset_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleProjCompareOffset_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleProjCompareOffset_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleProjCompareOffset_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleProjCompareOffset_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleProjCompareOffset_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleLod_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleLod_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleLod_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleLod_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleLod_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleLod_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleLod_TextureCube , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleLod_TextureCube , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleLod_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleLod_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleLod_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleLod_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleLod_TextureCubeArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleLod_TextureCubeArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleLodOffset_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleLodOffset_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleLodOffset_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleLodOffset_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleLodOffset_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleLodOffset_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleLodOffset_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleLodOffset_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleLodOffset_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleLodOffset_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleLodProj_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleLodProj_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleLodProj_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleLodProj_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleLodProj_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleLodProj_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleLodProjOffset_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleLodProjOffset_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleLodProjOffset_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleLodProjOffset_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleLodProjOffset_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleLodProjOffset_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleLodCompare_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleLodCompare_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleLodCompare_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleLodCompare_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleLodCompare_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleLodCompare_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleLodCompare_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleLodCompare_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleLodCompare_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleLodCompare_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleLodCompareOffset_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleLodCompareOffset_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleLodCompareOffset_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleLodCompareOffset_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleLodCompareOffset_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleLodCompareOffset_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleLodCompareOffset_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleLodCompareOffset_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleLodCompareOffset_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleLodCompareOffset_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleLodProjCompare_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[5]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleLodProjCompare_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleLodProjCompare_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[5]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleLodProjCompare_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleLodProjCompare_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[5]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleLodProjCompare_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleLodProjCompareOffset_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[5]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleLodProjCompareOffset_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleLodProjCompareOffset_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[5]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleLodProjCompareOffset_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleLodProjCompareOffset_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[5]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleLodProjCompareOffset_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleGrad_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::GradY, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleGrad_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::GradY, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleGrad_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::GradY, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleGrad_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::GradY, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleGrad_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::GradY, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleGrad_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::GradY, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleGrad_TextureCube , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::GradY, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleGrad_TextureCube , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::GradY, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleGrad_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::GradY, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleGrad_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::GradY, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleGrad_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::GradY, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleGrad_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::GradY, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleGrad_TextureCubeArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::GradY, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleGrad_TextureCubeArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::GradY, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleGradOffset_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::GradY, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleGradOffset_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::GradY, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleGradOffset_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::GradY, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleGradOffset_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::GradY, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleGradOffset_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::GradY, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleGradOffset_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::GradY, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleGradOffset_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::GradY, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleGradOffset_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::GradY, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleGradOffset_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::GradY, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleGradOffset_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::GradY, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleGradProj_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::GradY, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleGradProj_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::GradY, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleGradProj_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::GradY, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleGradProj_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::GradY, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleGradProj_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::GradY, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleGradProj_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::GradY, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleGradProjOffset_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::GradY, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleGradProjOffset_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::GradY, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleGradProjOffset_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::GradY, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleGradProjOffset_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::GradY, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleGradProjOffset_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::GradY, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleGradProjOffset_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::GradY, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleGradCompare_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::GradY, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleGradCompare_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::GradY, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleGradCompare_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::GradY, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleGradCompare_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::GradY, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleGradCompare_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::GradY, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleGradCompare_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::GradY, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleGradCompare_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::GradY, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleGradCompare_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::GradY, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleGradCompare_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::GradY, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleGradCompare_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::GradY, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleGradCompareOffset_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::GradY, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleGradCompareOffset_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::GradY, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleGradCompareOffset_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::GradY, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleGradCompareOffset_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::GradY, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleGradCompareOffset_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::GradY, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleGradCompareOffset_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::GradY, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleGradCompareOffset_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::GradY, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleGradCompareOffset_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::GradY, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleGradCompareOffset_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::GradY, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleGradCompareOffset_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::GradY, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleGradProjCompare_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[5]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[6]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::GradY, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleGradProjCompare_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::GradY, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleGradProjCompare_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[5]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[6]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::GradY, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleGradProjCompare_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::GradY, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleGradProjCompare_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[5]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[6]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::GradY, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleGradProjCompare_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::GradY, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleGradProjCompareOffset_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[5]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[6]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::GradY, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleGradProjCompareOffset_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::GradY, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleGradProjCompareOffset_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[5]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[6]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::GradY, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleGradProjCompareOffset_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::GradY, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleGradProjCompareOffset_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[5]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[6]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::GradY, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleGradProjCompareOffset_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::GradY, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleBias_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleBias_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleBias_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleBias_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleBias_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleBias_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleBias_TextureCube , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleBias_TextureCube , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleBias_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleBias_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleBias_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleBias_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleBias_TextureCubeArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleBias_TextureCubeArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleBiasOffset_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleBiasOffset_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleBiasOffset_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleBiasOffset_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleBiasOffset_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleBiasOffset_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleBiasOffset_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleBiasOffset_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleBiasOffset_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleBiasOffset_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleBiasProj_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleBiasProj_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleBiasProj_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleBiasProj_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleBiasProj_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleBiasProj_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleBiasProjOffset_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleBiasProjOffset_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleBiasProjOffset_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleBiasProjOffset_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleBiasProjOffset_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleBiasProjOffset_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleBiasCompare_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleBiasCompare_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleBiasCompare_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleBiasCompare_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleBiasCompare_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleBiasCompare_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleBiasCompare_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleBiasCompare_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleBiasCompare_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleBiasCompare_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleBiasCompareOffset_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleBiasCompareOffset_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleBiasCompareOffset_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleBiasCompareOffset_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleBiasCompareOffset_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleBiasCompareOffset_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleBiasCompareOffset_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleBiasCompareOffset_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleBiasCompareOffset_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleBiasCompareOffset_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleBiasProjCompare_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[5]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleBiasProjCompare_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleBiasProjCompare_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[5]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleBiasProjCompare_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleBiasProjCompare_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[5]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleBiasProjCompare_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleBiasProjCompareOffset_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[5]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleBiasProjCompareOffset_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleBiasProjCompareOffset_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[5]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleBiasProjCompareOffset_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureSampleBiasProjCompareOffset_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[5]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureSampleBiasProjCompareOffset_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}},
};
