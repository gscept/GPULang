#pragma once
//-------------------------------------------------
// *** Generated by type_gen.py. ***
//       DO NOT MODIFY!!!
//-------------------------------------------------
static auto CreateSampledImageSPIRV = [](const Compiler* c, SPIRVGenerator* g, SPIRVResult img, SPIRVResult samp) -> SPIRVResult
{
        assert(img.parentTypes.size() > 0);
        SPIRVResult image = LoadValueSPIRV(c, g, img, true);
        SPIRVResult sampler = LoadValueSPIRV(c, g, samp, true);
        uint32_t typeSymbol = AddType(g, TStr::Compact("sampledImage_", img.parentTypes[0]), OpTypeSampledImage, SPVArg{img.parentTypes[0]});
        uint32_t sampledImage = g->writer->MappedInstruction(OpSampledImage, SPVWriter::Section::LocalFunction, typeSymbol, image, sampler);
        return SPIRVResult(sampledImage, typeSymbol, true);
};

SPIRVResult SPIRV_Float32ToUInt32(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) 
{
    if (value.isLiteral)
    {
        assert(vectorSize == 1);
        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt32(value.literalValue.f32));
    }
    else
    {
        uint32_t type;
        if (vectorSize > 1)
            type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, vectorSize);
        else
            type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32);
        value = LoadValueSPIRV(c, g, value);
        uint32_t res = g->writer->MappedInstruction(OpConvertFToU, SPVWriter::Section::LocalFunction, type, value);
        return SPIRVResult(res, type, true);
    }
}

SPIRVResult SPIRV_Float32ToInt32(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) 
{
    if (value.isLiteral)
    {
        assert(vectorSize == 1);
        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(value.literalValue.f32));
    }
    else
    {
        uint32_t type;
        if (vectorSize > 1)
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32, vectorSize);
        else
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32);
        value = LoadValueSPIRV(c, g, value);
        uint32_t res = g->writer->MappedInstruction(OpConvertFToS, SPVWriter::Section::LocalFunction, type, value);
        return SPIRVResult(res, type, true);
    }
}

SPIRVResult SPIRV_Float32ToFloat16(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) 
{
    if (value.isLiteral)
    {
        assert(vectorSize == 1);
        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float16(value.literalValue.f32));
    }
    else
    {
        uint32_t type;
        if (vectorSize > 1)
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16, vectorSize);
        else
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16);
        value = LoadValueSPIRV(c, g, value);
        uint32_t res = g->writer->MappedInstruction(OpFConvert, SPVWriter::Section::LocalFunction, type, value);
        return SPIRVResult(res, type, true);
    }
}

SPIRVResult SPIRV_Float32ToUInt16(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) 
{
    if (value.isLiteral)
    {
        assert(vectorSize == 1);
        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt16(value.literalValue.f32));
    }
    else
    {
        uint32_t type;
        if (vectorSize > 1)
            type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16, vectorSize);
        else
            type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16);
        value = LoadValueSPIRV(c, g, value);
        uint32_t res = g->writer->MappedInstruction(OpConvertFToU, SPVWriter::Section::LocalFunction, type, value);
        return SPIRVResult(res, type, true);
    }
}

SPIRVResult SPIRV_Float32ToInt16(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) 
{
    if (value.isLiteral)
    {
        assert(vectorSize == 1);
        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int16(value.literalValue.f32));
    }
    else
    {
        uint32_t type;
        if (vectorSize > 1)
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16, vectorSize);
        else
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16);
        value = LoadValueSPIRV(c, g, value);
        uint32_t res = g->writer->MappedInstruction(OpConvertFToS, SPVWriter::Section::LocalFunction, type, value);
        return SPIRVResult(res, type, true);
    }
}

SPIRVResult SPIRV_UInt32ToFloat32(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) 
{
    if (value.isLiteral)
    {
        assert(vectorSize == 1);
        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float32(value.literalValue.u32));
    }
    else
    {
        uint32_t type;
        if (vectorSize > 1)
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, vectorSize);
        else
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32);
        value = LoadValueSPIRV(c, g, value);
        uint32_t res = g->writer->MappedInstruction(OpConvertUToF, SPVWriter::Section::LocalFunction, type, value);
        return SPIRVResult(res, type, true);
    }
}

SPIRVResult SPIRV_UInt32ToInt32(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) 
{
    if (value.isLiteral)
    {
        assert(vectorSize == 1);
        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(value.literalValue.u32));
    }
    else
    {
        uint32_t type;
        if (vectorSize > 1)
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32, vectorSize);
        else
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32);
        value = LoadValueSPIRV(c, g, value);
        uint32_t res = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, type, value);
        return SPIRVResult(res, type, true);
    }
}

SPIRVResult SPIRV_UInt32ToBool8(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) 
{
    if (value.isLiteral)
    {
        assert(vectorSize == 1);
        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Bool8(value.literalValue.u32));
    }
    else
    {
        uint32_t type;
        if (vectorSize > 1)
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Bool8, vectorSize);
        else
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Bool8);
            SPIRVResult falseValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt32(0));
        uint32_t res = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, type, value, falseValue);
        return SPIRVResult(res, type, true);
    }
}

SPIRVResult SPIRV_UInt32ToFloat16(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) 
{
    if (value.isLiteral)
    {
        assert(vectorSize == 1);
        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float16(value.literalValue.u32));
    }
    else
    {
        uint32_t type;
        if (vectorSize > 1)
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16, vectorSize);
        else
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16);
        value = LoadValueSPIRV(c, g, value);
        uint32_t res = g->writer->MappedInstruction(OpConvertUToF, SPVWriter::Section::LocalFunction, type, value);
        return SPIRVResult(res, type, true);
    }
}

SPIRVResult SPIRV_UInt32ToUInt16(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) 
{
    if (value.isLiteral)
    {
        assert(vectorSize == 1);
        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt16(value.literalValue.u32));
    }
    else
    {
        uint32_t type;
        if (vectorSize > 1)
            type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16, vectorSize);
        else
            type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16);
        value = LoadValueSPIRV(c, g, value);
        uint32_t res = g->writer->MappedInstruction(OpUConvert, SPVWriter::Section::LocalFunction, type, value);
        return SPIRVResult(res, type, true);
    }
}

SPIRVResult SPIRV_UInt32ToInt16(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) 
{
    if (value.isLiteral)
    {
        assert(vectorSize == 1);
        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int16(value.literalValue.u32));
    }
    else
    {
        uint32_t type;
        if (vectorSize > 1)
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16, vectorSize);
        else
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16);
        value = LoadValueSPIRV(c, g, value);
        uint32_t res = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, type, value);
        return SPIRVResult(res, type, true);
    }
}

SPIRVResult SPIRV_Int32ToFloat32(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) 
{
    if (value.isLiteral)
    {
        assert(vectorSize == 1);
        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float32(value.literalValue.i32));
    }
    else
    {
        uint32_t type;
        if (vectorSize > 1)
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, vectorSize);
        else
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32);
        value = LoadValueSPIRV(c, g, value);
        uint32_t res = g->writer->MappedInstruction(OpConvertSToF, SPVWriter::Section::LocalFunction, type, value);
        return SPIRVResult(res, type, true);
    }
}

SPIRVResult SPIRV_Int32ToUInt32(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) 
{
    if (value.isLiteral)
    {
        assert(vectorSize == 1);
        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt32(value.literalValue.i32));
    }
    else
    {
        uint32_t type;
        if (vectorSize > 1)
            type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, vectorSize);
        else
            type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32);
        value = LoadValueSPIRV(c, g, value);
        uint32_t res = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, type, value);
        return SPIRVResult(res, type, true);
    }
}

SPIRVResult SPIRV_Int32ToBool8(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) 
{
    if (value.isLiteral)
    {
        assert(vectorSize == 1);
        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Bool8(value.literalValue.i32));
    }
    else
    {
        uint32_t type;
        if (vectorSize > 1)
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Bool8, vectorSize);
        else
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Bool8);
            SPIRVResult falseValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0));
        uint32_t res = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, type, value, falseValue);
        return SPIRVResult(res, type, true);
    }
}

SPIRVResult SPIRV_Int32ToFloat16(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) 
{
    if (value.isLiteral)
    {
        assert(vectorSize == 1);
        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float16(value.literalValue.i32));
    }
    else
    {
        uint32_t type;
        if (vectorSize > 1)
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16, vectorSize);
        else
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16);
        value = LoadValueSPIRV(c, g, value);
        uint32_t res = g->writer->MappedInstruction(OpConvertSToF, SPVWriter::Section::LocalFunction, type, value);
        return SPIRVResult(res, type, true);
    }
}

SPIRVResult SPIRV_Int32ToUInt16(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) 
{
    if (value.isLiteral)
    {
        assert(vectorSize == 1);
        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt16(value.literalValue.i32));
    }
    else
    {
        uint32_t type;
        if (vectorSize > 1)
            type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16, vectorSize);
        else
            type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16);
        value = LoadValueSPIRV(c, g, value);
        uint32_t res = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, type, value);
        return SPIRVResult(res, type, true);
    }
}

SPIRVResult SPIRV_Int32ToInt16(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) 
{
    if (value.isLiteral)
    {
        assert(vectorSize == 1);
        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int16(value.literalValue.i32));
    }
    else
    {
        uint32_t type;
        if (vectorSize > 1)
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16, vectorSize);
        else
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16);
        value = LoadValueSPIRV(c, g, value);
        uint32_t res = g->writer->MappedInstruction(OpSConvert, SPVWriter::Section::LocalFunction, type, value);
        return SPIRVResult(res, type, true);
    }
}

SPIRVResult SPIRV_Bool8ToFloat32(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) 
{
    if (value.isLiteral)
    {
        assert(vectorSize == 1);
        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float32(value.literalValue.b8));
    }
    else
    {
        uint32_t type;
        if (vectorSize > 1)
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, vectorSize);
        else
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32);
            SPIRVResult trueValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float32(1));
            SPIRVResult falseValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float32(0));
        uint32_t res = g->writer->MappedInstruction(OpSelect, SPVWriter::Section::LocalFunction, type, value, trueValue, falseValue);
        return SPIRVResult(res, type, true);
    }
}

SPIRVResult SPIRV_Bool8ToUInt32(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) 
{
    if (value.isLiteral)
    {
        assert(vectorSize == 1);
        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt32(value.literalValue.b8));
    }
    else
    {
        uint32_t type;
        if (vectorSize > 1)
            type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, vectorSize);
        else
            type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32);
            SPIRVResult trueValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt32(1));
            SPIRVResult falseValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt32(0));
        uint32_t res = g->writer->MappedInstruction(OpSelect, SPVWriter::Section::LocalFunction, type, value, trueValue, falseValue);
        return SPIRVResult(res, type, true);
    }
}

SPIRVResult SPIRV_Bool8ToInt32(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) 
{
    if (value.isLiteral)
    {
        assert(vectorSize == 1);
        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(value.literalValue.b8));
    }
    else
    {
        uint32_t type;
        if (vectorSize > 1)
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32, vectorSize);
        else
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32);
            SPIRVResult trueValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(1));
            SPIRVResult falseValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0));
        uint32_t res = g->writer->MappedInstruction(OpSelect, SPVWriter::Section::LocalFunction, type, value, trueValue, falseValue);
        return SPIRVResult(res, type, true);
    }
}

SPIRVResult SPIRV_Bool8ToFloat16(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) 
{
    if (value.isLiteral)
    {
        assert(vectorSize == 1);
        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float16(value.literalValue.b8));
    }
    else
    {
        uint32_t type;
        if (vectorSize > 1)
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16, vectorSize);
        else
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16);
            SPIRVResult trueValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float16(1));
            SPIRVResult falseValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float16(0));
        uint32_t res = g->writer->MappedInstruction(OpSelect, SPVWriter::Section::LocalFunction, type, value, trueValue, falseValue);
        return SPIRVResult(res, type, true);
    }
}

SPIRVResult SPIRV_Bool8ToUInt16(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) 
{
    if (value.isLiteral)
    {
        assert(vectorSize == 1);
        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt16(value.literalValue.b8));
    }
    else
    {
        uint32_t type;
        if (vectorSize > 1)
            type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16, vectorSize);
        else
            type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16);
            SPIRVResult trueValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt16(1));
            SPIRVResult falseValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt16(0));
        uint32_t res = g->writer->MappedInstruction(OpSelect, SPVWriter::Section::LocalFunction, type, value, trueValue, falseValue);
        return SPIRVResult(res, type, true);
    }
}

SPIRVResult SPIRV_Bool8ToInt16(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) 
{
    if (value.isLiteral)
    {
        assert(vectorSize == 1);
        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int16(value.literalValue.b8));
    }
    else
    {
        uint32_t type;
        if (vectorSize > 1)
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16, vectorSize);
        else
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16);
            SPIRVResult trueValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int16(1));
            SPIRVResult falseValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int16(0));
        uint32_t res = g->writer->MappedInstruction(OpSelect, SPVWriter::Section::LocalFunction, type, value, trueValue, falseValue);
        return SPIRVResult(res, type, true);
    }
}

SPIRVResult SPIRV_Float16ToFloat32(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) 
{
    if (value.isLiteral)
    {
        assert(vectorSize == 1);
        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float32(value.literalValue.f16));
    }
    else
    {
        uint32_t type;
        if (vectorSize > 1)
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, vectorSize);
        else
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32);
        value = LoadValueSPIRV(c, g, value);
        uint32_t res = g->writer->MappedInstruction(OpFConvert, SPVWriter::Section::LocalFunction, type, value);
        return SPIRVResult(res, type, true);
    }
}

SPIRVResult SPIRV_Float16ToUInt32(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) 
{
    if (value.isLiteral)
    {
        assert(vectorSize == 1);
        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt32(value.literalValue.f16));
    }
    else
    {
        uint32_t type;
        if (vectorSize > 1)
            type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, vectorSize);
        else
            type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32);
        value = LoadValueSPIRV(c, g, value);
        uint32_t res = g->writer->MappedInstruction(OpConvertFToU, SPVWriter::Section::LocalFunction, type, value);
        return SPIRVResult(res, type, true);
    }
}

SPIRVResult SPIRV_Float16ToInt32(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) 
{
    if (value.isLiteral)
    {
        assert(vectorSize == 1);
        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(value.literalValue.f16));
    }
    else
    {
        uint32_t type;
        if (vectorSize > 1)
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32, vectorSize);
        else
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32);
        value = LoadValueSPIRV(c, g, value);
        uint32_t res = g->writer->MappedInstruction(OpConvertFToS, SPVWriter::Section::LocalFunction, type, value);
        return SPIRVResult(res, type, true);
    }
}

SPIRVResult SPIRV_Float16ToUInt16(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) 
{
    if (value.isLiteral)
    {
        assert(vectorSize == 1);
        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt16(value.literalValue.f16));
    }
    else
    {
        uint32_t type;
        if (vectorSize > 1)
            type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16, vectorSize);
        else
            type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16);
        value = LoadValueSPIRV(c, g, value);
        uint32_t res = g->writer->MappedInstruction(OpConvertFToU, SPVWriter::Section::LocalFunction, type, value);
        return SPIRVResult(res, type, true);
    }
}

SPIRVResult SPIRV_Float16ToInt16(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) 
{
    if (value.isLiteral)
    {
        assert(vectorSize == 1);
        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int16(value.literalValue.f16));
    }
    else
    {
        uint32_t type;
        if (vectorSize > 1)
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16, vectorSize);
        else
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16);
        value = LoadValueSPIRV(c, g, value);
        uint32_t res = g->writer->MappedInstruction(OpConvertFToS, SPVWriter::Section::LocalFunction, type, value);
        return SPIRVResult(res, type, true);
    }
}

SPIRVResult SPIRV_UInt16ToFloat32(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) 
{
    if (value.isLiteral)
    {
        assert(vectorSize == 1);
        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float32(value.literalValue.u16));
    }
    else
    {
        uint32_t type;
        if (vectorSize > 1)
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, vectorSize);
        else
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32);
        value = LoadValueSPIRV(c, g, value);
        uint32_t res = g->writer->MappedInstruction(OpConvertUToF, SPVWriter::Section::LocalFunction, type, value);
        return SPIRVResult(res, type, true);
    }
}

SPIRVResult SPIRV_UInt16ToUInt32(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) 
{
    if (value.isLiteral)
    {
        assert(vectorSize == 1);
        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt32(value.literalValue.u16));
    }
    else
    {
        uint32_t type;
        if (vectorSize > 1)
            type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, vectorSize);
        else
            type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32);
        value = LoadValueSPIRV(c, g, value);
        uint32_t res = g->writer->MappedInstruction(OpUConvert, SPVWriter::Section::LocalFunction, type, value);
        return SPIRVResult(res, type, true);
    }
}

SPIRVResult SPIRV_UInt16ToInt32(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) 
{
    if (value.isLiteral)
    {
        assert(vectorSize == 1);
        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(value.literalValue.u16));
    }
    else
    {
        uint32_t type;
        if (vectorSize > 1)
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32, vectorSize);
        else
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32);
        value = LoadValueSPIRV(c, g, value);
        uint32_t res = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, type, value);
        return SPIRVResult(res, type, true);
    }
}

SPIRVResult SPIRV_UInt16ToBool8(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) 
{
    if (value.isLiteral)
    {
        assert(vectorSize == 1);
        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Bool8(value.literalValue.u16));
    }
    else
    {
        uint32_t type;
        if (vectorSize > 1)
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Bool8, vectorSize);
        else
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Bool8);
            SPIRVResult falseValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt16(0));
        uint32_t res = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, type, value, falseValue);
        return SPIRVResult(res, type, true);
    }
}

SPIRVResult SPIRV_UInt16ToFloat16(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) 
{
    if (value.isLiteral)
    {
        assert(vectorSize == 1);
        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float16(value.literalValue.u16));
    }
    else
    {
        uint32_t type;
        if (vectorSize > 1)
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16, vectorSize);
        else
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16);
        value = LoadValueSPIRV(c, g, value);
        uint32_t res = g->writer->MappedInstruction(OpConvertUToF, SPVWriter::Section::LocalFunction, type, value);
        return SPIRVResult(res, type, true);
    }
}

SPIRVResult SPIRV_UInt16ToInt16(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) 
{
    if (value.isLiteral)
    {
        assert(vectorSize == 1);
        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int16(value.literalValue.u16));
    }
    else
    {
        uint32_t type;
        if (vectorSize > 1)
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16, vectorSize);
        else
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16);
        value = LoadValueSPIRV(c, g, value);
        uint32_t res = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, type, value);
        return SPIRVResult(res, type, true);
    }
}

SPIRVResult SPIRV_Int16ToFloat32(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) 
{
    if (value.isLiteral)
    {
        assert(vectorSize == 1);
        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float32(value.literalValue.i16));
    }
    else
    {
        uint32_t type;
        if (vectorSize > 1)
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, vectorSize);
        else
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32);
        value = LoadValueSPIRV(c, g, value);
        uint32_t res = g->writer->MappedInstruction(OpConvertSToF, SPVWriter::Section::LocalFunction, type, value);
        return SPIRVResult(res, type, true);
    }
}

SPIRVResult SPIRV_Int16ToUInt32(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) 
{
    if (value.isLiteral)
    {
        assert(vectorSize == 1);
        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt32(value.literalValue.i16));
    }
    else
    {
        uint32_t type;
        if (vectorSize > 1)
            type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, vectorSize);
        else
            type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32);
        value = LoadValueSPIRV(c, g, value);
        uint32_t res = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, type, value);
        return SPIRVResult(res, type, true);
    }
}

SPIRVResult SPIRV_Int16ToInt32(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) 
{
    if (value.isLiteral)
    {
        assert(vectorSize == 1);
        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(value.literalValue.i16));
    }
    else
    {
        uint32_t type;
        if (vectorSize > 1)
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32, vectorSize);
        else
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32);
        value = LoadValueSPIRV(c, g, value);
        uint32_t res = g->writer->MappedInstruction(OpSConvert, SPVWriter::Section::LocalFunction, type, value);
        return SPIRVResult(res, type, true);
    }
}

SPIRVResult SPIRV_Int16ToBool8(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) 
{
    if (value.isLiteral)
    {
        assert(vectorSize == 1);
        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Bool8(value.literalValue.i16));
    }
    else
    {
        uint32_t type;
        if (vectorSize > 1)
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Bool8, vectorSize);
        else
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Bool8);
            SPIRVResult falseValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int16(0));
        uint32_t res = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, type, value, falseValue);
        return SPIRVResult(res, type, true);
    }
}

SPIRVResult SPIRV_Int16ToFloat16(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) 
{
    if (value.isLiteral)
    {
        assert(vectorSize == 1);
        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float16(value.literalValue.i16));
    }
    else
    {
        uint32_t type;
        if (vectorSize > 1)
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16, vectorSize);
        else
            type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16);
        value = LoadValueSPIRV(c, g, value);
        uint32_t res = g->writer->MappedInstruction(OpConvertSToF, SPVWriter::Section::LocalFunction, type, value);
        return SPIRVResult(res, type, true);
    }
}

SPIRVResult SPIRV_Int16ToUInt16(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) 
{
    if (value.isLiteral)
    {
        assert(vectorSize == 1);
        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt16(value.literalValue.i16));
    }
    else
    {
        uint32_t type;
        if (vectorSize > 1)
            type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16, vectorSize);
        else
            type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16);
        value = LoadValueSPIRV(c, g, value);
        uint32_t res = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, type, value);
        return SPIRVResult(res, type, true);
    }
}

using SPIRVConversionFunction = SPIRVResult (*)(const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult);
constexpr StaticMap<TypeConversionTable, SPIRVConversionFunction, 40> ConverterTable = {
    std::pair{ TypeConversionTable::Float32ToUInt32, &SPIRV_Float32ToUInt32 },
    std::pair{ TypeConversionTable::Float32ToInt32, &SPIRV_Float32ToInt32 },
    std::pair{ TypeConversionTable::Float32ToFloat16, &SPIRV_Float32ToFloat16 },
    std::pair{ TypeConversionTable::Float32ToUInt16, &SPIRV_Float32ToUInt16 },
    std::pair{ TypeConversionTable::Float32ToInt16, &SPIRV_Float32ToInt16 },
    std::pair{ TypeConversionTable::UInt32ToFloat32, &SPIRV_UInt32ToFloat32 },
    std::pair{ TypeConversionTable::UInt32ToInt32, &SPIRV_UInt32ToInt32 },
    std::pair{ TypeConversionTable::UInt32ToBool8, &SPIRV_UInt32ToBool8 },
    std::pair{ TypeConversionTable::UInt32ToFloat16, &SPIRV_UInt32ToFloat16 },
    std::pair{ TypeConversionTable::UInt32ToUInt16, &SPIRV_UInt32ToUInt16 },
    std::pair{ TypeConversionTable::UInt32ToInt16, &SPIRV_UInt32ToInt16 },
    std::pair{ TypeConversionTable::Int32ToFloat32, &SPIRV_Int32ToFloat32 },
    std::pair{ TypeConversionTable::Int32ToUInt32, &SPIRV_Int32ToUInt32 },
    std::pair{ TypeConversionTable::Int32ToBool8, &SPIRV_Int32ToBool8 },
    std::pair{ TypeConversionTable::Int32ToFloat16, &SPIRV_Int32ToFloat16 },
    std::pair{ TypeConversionTable::Int32ToUInt16, &SPIRV_Int32ToUInt16 },
    std::pair{ TypeConversionTable::Int32ToInt16, &SPIRV_Int32ToInt16 },
    std::pair{ TypeConversionTable::Bool8ToFloat32, &SPIRV_Bool8ToFloat32 },
    std::pair{ TypeConversionTable::Bool8ToUInt32, &SPIRV_Bool8ToUInt32 },
    std::pair{ TypeConversionTable::Bool8ToInt32, &SPIRV_Bool8ToInt32 },
    std::pair{ TypeConversionTable::Bool8ToFloat16, &SPIRV_Bool8ToFloat16 },
    std::pair{ TypeConversionTable::Bool8ToUInt16, &SPIRV_Bool8ToUInt16 },
    std::pair{ TypeConversionTable::Bool8ToInt16, &SPIRV_Bool8ToInt16 },
    std::pair{ TypeConversionTable::Float16ToFloat32, &SPIRV_Float16ToFloat32 },
    std::pair{ TypeConversionTable::Float16ToUInt32, &SPIRV_Float16ToUInt32 },
    std::pair{ TypeConversionTable::Float16ToInt32, &SPIRV_Float16ToInt32 },
    std::pair{ TypeConversionTable::Float16ToUInt16, &SPIRV_Float16ToUInt16 },
    std::pair{ TypeConversionTable::Float16ToInt16, &SPIRV_Float16ToInt16 },
    std::pair{ TypeConversionTable::UInt16ToFloat32, &SPIRV_UInt16ToFloat32 },
    std::pair{ TypeConversionTable::UInt16ToUInt32, &SPIRV_UInt16ToUInt32 },
    std::pair{ TypeConversionTable::UInt16ToInt32, &SPIRV_UInt16ToInt32 },
    std::pair{ TypeConversionTable::UInt16ToBool8, &SPIRV_UInt16ToBool8 },
    std::pair{ TypeConversionTable::UInt16ToFloat16, &SPIRV_UInt16ToFloat16 },
    std::pair{ TypeConversionTable::UInt16ToInt16, &SPIRV_UInt16ToInt16 },
    std::pair{ TypeConversionTable::Int16ToFloat32, &SPIRV_Int16ToFloat32 },
    std::pair{ TypeConversionTable::Int16ToUInt32, &SPIRV_Int16ToUInt32 },
    std::pair{ TypeConversionTable::Int16ToInt32, &SPIRV_Int16ToInt32 },
    std::pair{ TypeConversionTable::Int16ToBool8, &SPIRV_Int16ToBool8 },
    std::pair{ TypeConversionTable::Int16ToFloat16, &SPIRV_Int16ToFloat16 },
    std::pair{ TypeConversionTable::Int16ToUInt16, &SPIRV_Int16ToUInt16 }
};

static const uint32_t SemanticsTable[] =
{
    0x0,
    0x1,
    0x2,
    0x4,
    0x8,
    0x10,
    0x20,
    0x40,
    0x80,
    0x100
};

static auto ScopeToAtomicScope = [](SPIRVResult::Storage scope) -> uint32_t
{
    switch (scope)
    {
        case SPIRVResult::Storage::Function:
        case SPIRVResult::Storage::Input:
        case SPIRVResult::Storage::Output:
        case SPIRVResult::Storage::PushConstant:
        case SPIRVResult::Storage::Private:
            return 4;
        case SPIRVResult::Storage::WorkGroup:
            return 2;
        case SPIRVResult::Storage::Device:
        case SPIRVResult::Storage::Uniform:
        case SPIRVResult::Storage::UniformConstant:
        case SPIRVResult::Storage::StorageBuffer:
        case SPIRVResult::Storage::MutableImage:
            return 1;
        case SPIRVResult::Storage::Sampler:
        case SPIRVResult::Storage::Image:
            assert(false);
    }
    return 0;
};

static auto ScopeToMemorySemantics = [](SPIRVResult::Storage scope) -> uint32_t
{
    switch (scope)
    {
        case SPIRVResult::Storage::WorkGroup:
            return 0x100; // WorkgroupMemory
        case SPIRVResult::Storage::Uniform:
        case SPIRVResult::Storage::UniformConstant:
        case SPIRVResult::Storage::StorageBuffer:
        case SPIRVResult::Storage::Sampler:
            return 0x40; // UniformMemory
        case SPIRVResult::Storage::Image:
        case SPIRVResult::Storage::MutableImage:
            return 0x800; // ImageMemory
    }
    return 0x0;
};

SPIRVResult SPIRV_Float32_from_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, args[0]);
}

SPIRVResult SPIRV_Float32_from_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, args[0]);
}

SPIRVResult SPIRV_Float32_from_Bool8(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Bool8ToFloat32](c, g, 1, args[0]);
}

SPIRVResult SPIRV_Float32_from_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, args[0]);
}

SPIRVResult SPIRV_Float32_from_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, args[0]);
}

SPIRVResult SPIRV_Float32_from_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, args[0]);
}

SPIRVResult SPIRV_Float32_ctor0(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}

SPIRVResult SPIRV_UInt32_from_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, args[0]);
}

SPIRVResult SPIRV_UInt32_from_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, args[0]);
}

SPIRVResult SPIRV_UInt32_from_Bool8(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 1, args[0]);
}

SPIRVResult SPIRV_UInt32_from_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, args[0]);
}

SPIRVResult SPIRV_UInt32_from_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, args[0]);
}

SPIRVResult SPIRV_UInt32_from_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, args[0]);
}

SPIRVResult SPIRV_UInt32_ctor0(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}

SPIRVResult SPIRV_Int32_from_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, args[0]);
}

SPIRVResult SPIRV_Int32_from_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, args[0]);
}

SPIRVResult SPIRV_Int32_from_Bool8(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 1, args[0]);
}

SPIRVResult SPIRV_Int32_from_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, args[0]);
}

SPIRVResult SPIRV_Int32_from_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, args[0]);
}

SPIRVResult SPIRV_Int32_from_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, args[0]);
}

SPIRVResult SPIRV_Int32_ctor0(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}

SPIRVResult SPIRV_Bool8_from_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt32ToBool8](c, g, 1, args[0]);
}

SPIRVResult SPIRV_Bool8_from_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int32ToBool8](c, g, 1, args[0]);
}

SPIRVResult SPIRV_Bool8_from_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt16ToBool8](c, g, 1, args[0]);
}

SPIRVResult SPIRV_Bool8_from_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int16ToBool8](c, g, 1, args[0]);
}

SPIRVResult SPIRV_Bool8_ctor0(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}

SPIRVResult SPIRV_Float16_from_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, args[0]);
}

SPIRVResult SPIRV_Float16_from_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, args[0]);
}

SPIRVResult SPIRV_Float16_from_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, args[0]);
}

SPIRVResult SPIRV_Float16_from_Bool8(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Bool8ToFloat16](c, g, 1, args[0]);
}

SPIRVResult SPIRV_Float16_from_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, args[0]);
}

SPIRVResult SPIRV_Float16_from_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, args[0]);
}

SPIRVResult SPIRV_Float16_ctor0(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}

SPIRVResult SPIRV_UInt16_from_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, args[0]);
}

SPIRVResult SPIRV_UInt16_from_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, args[0]);
}

SPIRVResult SPIRV_UInt16_from_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, args[0]);
}

SPIRVResult SPIRV_UInt16_from_Bool8(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 1, args[0]);
}

SPIRVResult SPIRV_UInt16_from_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, args[0]);
}

SPIRVResult SPIRV_UInt16_from_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, args[0]);
}

SPIRVResult SPIRV_UInt16_ctor0(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}

SPIRVResult SPIRV_Int16_from_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, args[0]);
}

SPIRVResult SPIRV_Int16_from_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, args[0]);
}

SPIRVResult SPIRV_Int16_from_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, args[0]);
}

SPIRVResult SPIRV_Int16_from_Bool8(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 1, args[0]);
}

SPIRVResult SPIRV_Int16_from_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, args[0]);
}

SPIRVResult SPIRV_Int16_from_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, args[0]);
}

SPIRVResult SPIRV_Int16_ctor0(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}

SPIRVResult SPIRV_Float32x2_from_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return args[0];
}

SPIRVResult SPIRV_Float32x2_splat_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_Float32x2_from_UInt32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 2, args[0]);
}

SPIRVResult SPIRV_Float32x2_splat_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_Float32x2_from_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 2, args[0]);
}

SPIRVResult SPIRV_Float32x2_splat_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_Float32x2_from_Bool8x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Bool8ToFloat32](c, g, 2, args[0]);
}

SPIRVResult SPIRV_Float32x2_splat_Bool8(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Bool8ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_Float32x2_from_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 2, args[0]);
}

SPIRVResult SPIRV_Float32x2_splat_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_Float32x2_from_UInt16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 2, args[0]);
}

SPIRVResult SPIRV_Float32x2_splat_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_Float32x2_from_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 2, args[0]);
}

SPIRVResult SPIRV_Float32x2_splat_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_Float32x2_ctor0(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_UInt32x2_from_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 2, args[0]);
}

SPIRVResult SPIRV_UInt32x2_splat_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_UInt32x2_from_UInt32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return args[0];
}

SPIRVResult SPIRV_UInt32x2_splat_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_UInt32x2_from_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 2, args[0]);
}

SPIRVResult SPIRV_UInt32x2_splat_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_UInt32x2_from_Bool8x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 2, args[0]);
}

SPIRVResult SPIRV_UInt32x2_splat_Bool8(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_UInt32x2_from_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 2, args[0]);
}

SPIRVResult SPIRV_UInt32x2_splat_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_UInt32x2_from_UInt16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 2, args[0]);
}

SPIRVResult SPIRV_UInt32x2_splat_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_UInt32x2_from_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 2, args[0]);
}

SPIRVResult SPIRV_UInt32x2_splat_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_UInt32x2_ctor0(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_Int32x2_from_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 2, args[0]);
}

SPIRVResult SPIRV_Int32x2_splat_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_Int32x2_from_UInt32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 2, args[0]);
}

SPIRVResult SPIRV_Int32x2_splat_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_Int32x2_from_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return args[0];
}

SPIRVResult SPIRV_Int32x2_splat_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_Int32x2_from_Bool8x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 2, args[0]);
}

SPIRVResult SPIRV_Int32x2_splat_Bool8(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_Int32x2_from_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 2, args[0]);
}

SPIRVResult SPIRV_Int32x2_splat_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_Int32x2_from_UInt16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 2, args[0]);
}

SPIRVResult SPIRV_Int32x2_splat_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_Int32x2_from_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 2, args[0]);
}

SPIRVResult SPIRV_Int32x2_splat_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_Int32x2_ctor0(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_Bool8x2_from_UInt32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt32ToBool8](c, g, 2, args[0]);
}

SPIRVResult SPIRV_Bool8x2_splat_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_Bool8x2_from_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int32ToBool8](c, g, 2, args[0]);
}

SPIRVResult SPIRV_Bool8x2_splat_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_Bool8x2_from_Bool8x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return args[0];
}

SPIRVResult SPIRV_Bool8x2_splat_Bool8(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_Bool8x2_from_UInt16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt16ToBool8](c, g, 2, args[0]);
}

SPIRVResult SPIRV_Bool8x2_splat_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_Bool8x2_from_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int16ToBool8](c, g, 2, args[0]);
}

SPIRVResult SPIRV_Bool8x2_splat_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_Bool8x2_ctor0(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_Float16x2_from_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 2, args[0]);
}

SPIRVResult SPIRV_Float16x2_splat_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_Float16x2_from_UInt32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 2, args[0]);
}

SPIRVResult SPIRV_Float16x2_splat_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_Float16x2_from_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 2, args[0]);
}

SPIRVResult SPIRV_Float16x2_splat_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_Float16x2_from_Bool8x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Bool8ToFloat16](c, g, 2, args[0]);
}

SPIRVResult SPIRV_Float16x2_splat_Bool8(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Bool8ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_Float16x2_from_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return args[0];
}

SPIRVResult SPIRV_Float16x2_splat_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_Float16x2_from_UInt16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 2, args[0]);
}

SPIRVResult SPIRV_Float16x2_splat_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_Float16x2_from_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 2, args[0]);
}

SPIRVResult SPIRV_Float16x2_splat_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_Float16x2_ctor0(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_UInt16x2_from_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 2, args[0]);
}

SPIRVResult SPIRV_UInt16x2_splat_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_UInt16x2_from_UInt32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 2, args[0]);
}

SPIRVResult SPIRV_UInt16x2_splat_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_UInt16x2_from_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 2, args[0]);
}

SPIRVResult SPIRV_UInt16x2_splat_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_UInt16x2_from_Bool8x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 2, args[0]);
}

SPIRVResult SPIRV_UInt16x2_splat_Bool8(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_UInt16x2_from_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 2, args[0]);
}

SPIRVResult SPIRV_UInt16x2_splat_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_UInt16x2_from_UInt16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return args[0];
}

SPIRVResult SPIRV_UInt16x2_splat_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_UInt16x2_from_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 2, args[0]);
}

SPIRVResult SPIRV_UInt16x2_splat_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_UInt16x2_ctor0(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_Int16x2_from_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 2, args[0]);
}

SPIRVResult SPIRV_Int16x2_splat_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_Int16x2_from_UInt32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 2, args[0]);
}

SPIRVResult SPIRV_Int16x2_splat_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_Int16x2_from_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 2, args[0]);
}

SPIRVResult SPIRV_Int16x2_splat_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_Int16x2_from_Bool8x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 2, args[0]);
}

SPIRVResult SPIRV_Int16x2_splat_Bool8(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_Int16x2_from_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 2, args[0]);
}

SPIRVResult SPIRV_Int16x2_splat_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_Int16x2_from_UInt16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 2, args[0]);
}

SPIRVResult SPIRV_Int16x2_splat_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_Int16x2_from_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return args[0];
}

SPIRVResult SPIRV_Int16x2_splat_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}

SPIRVResult SPIRV_Int16x2_ctor0(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_Float32x3_from_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return args[0];
}

SPIRVResult SPIRV_Float32x3_splat_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_Float32x3_from_UInt32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 3, args[0]);
}

SPIRVResult SPIRV_Float32x3_splat_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_Float32x3_from_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 3, args[0]);
}

SPIRVResult SPIRV_Float32x3_splat_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_Float32x3_from_Bool8x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Bool8ToFloat32](c, g, 3, args[0]);
}

SPIRVResult SPIRV_Float32x3_splat_Bool8(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Bool8ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_Float32x3_from_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 3, args[0]);
}

SPIRVResult SPIRV_Float32x3_splat_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_Float32x3_from_UInt16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 3, args[0]);
}

SPIRVResult SPIRV_Float32x3_splat_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_Float32x3_from_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 3, args[0]);
}

SPIRVResult SPIRV_Float32x3_splat_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_Float32x3_ctor0(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}

SPIRVResult SPIRV_Float32x3_ctor1(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_Float32x3_ctor2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_UInt32x3_from_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 3, args[0]);
}

SPIRVResult SPIRV_UInt32x3_splat_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_UInt32x3_from_UInt32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return args[0];
}

SPIRVResult SPIRV_UInt32x3_splat_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_UInt32x3_from_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 3, args[0]);
}

SPIRVResult SPIRV_UInt32x3_splat_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_UInt32x3_from_Bool8x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 3, args[0]);
}

SPIRVResult SPIRV_UInt32x3_splat_Bool8(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_UInt32x3_from_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 3, args[0]);
}

SPIRVResult SPIRV_UInt32x3_splat_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_UInt32x3_from_UInt16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 3, args[0]);
}

SPIRVResult SPIRV_UInt32x3_splat_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_UInt32x3_from_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 3, args[0]);
}

SPIRVResult SPIRV_UInt32x3_splat_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_UInt32x3_ctor0(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}

SPIRVResult SPIRV_UInt32x3_ctor1(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_UInt32x3_ctor2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_Int32x3_from_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 3, args[0]);
}

SPIRVResult SPIRV_Int32x3_splat_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_Int32x3_from_UInt32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 3, args[0]);
}

SPIRVResult SPIRV_Int32x3_splat_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_Int32x3_from_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return args[0];
}

SPIRVResult SPIRV_Int32x3_splat_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_Int32x3_from_Bool8x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 3, args[0]);
}

SPIRVResult SPIRV_Int32x3_splat_Bool8(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_Int32x3_from_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 3, args[0]);
}

SPIRVResult SPIRV_Int32x3_splat_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_Int32x3_from_UInt16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 3, args[0]);
}

SPIRVResult SPIRV_Int32x3_splat_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_Int32x3_from_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 3, args[0]);
}

SPIRVResult SPIRV_Int32x3_splat_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_Int32x3_ctor0(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}

SPIRVResult SPIRV_Int32x3_ctor1(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_Int32x3_ctor2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_Bool8x3_from_UInt32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt32ToBool8](c, g, 3, args[0]);
}

SPIRVResult SPIRV_Bool8x3_splat_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_Bool8x3_from_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int32ToBool8](c, g, 3, args[0]);
}

SPIRVResult SPIRV_Bool8x3_splat_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_Bool8x3_from_Bool8x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return args[0];
}

SPIRVResult SPIRV_Bool8x3_splat_Bool8(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_Bool8x3_from_UInt16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt16ToBool8](c, g, 3, args[0]);
}

SPIRVResult SPIRV_Bool8x3_splat_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_Bool8x3_from_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int16ToBool8](c, g, 3, args[0]);
}

SPIRVResult SPIRV_Bool8x3_splat_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_Bool8x3_ctor0(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}

SPIRVResult SPIRV_Bool8x3_ctor1(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_Bool8x3_ctor2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_Float16x3_from_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 3, args[0]);
}

SPIRVResult SPIRV_Float16x3_splat_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_Float16x3_from_UInt32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 3, args[0]);
}

SPIRVResult SPIRV_Float16x3_splat_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_Float16x3_from_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 3, args[0]);
}

SPIRVResult SPIRV_Float16x3_splat_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_Float16x3_from_Bool8x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Bool8ToFloat16](c, g, 3, args[0]);
}

SPIRVResult SPIRV_Float16x3_splat_Bool8(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Bool8ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_Float16x3_from_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return args[0];
}

SPIRVResult SPIRV_Float16x3_splat_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_Float16x3_from_UInt16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 3, args[0]);
}

SPIRVResult SPIRV_Float16x3_splat_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_Float16x3_from_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 3, args[0]);
}

SPIRVResult SPIRV_Float16x3_splat_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_Float16x3_ctor0(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}

SPIRVResult SPIRV_Float16x3_ctor1(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_Float16x3_ctor2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_UInt16x3_from_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 3, args[0]);
}

SPIRVResult SPIRV_UInt16x3_splat_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_UInt16x3_from_UInt32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 3, args[0]);
}

SPIRVResult SPIRV_UInt16x3_splat_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_UInt16x3_from_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 3, args[0]);
}

SPIRVResult SPIRV_UInt16x3_splat_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_UInt16x3_from_Bool8x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 3, args[0]);
}

SPIRVResult SPIRV_UInt16x3_splat_Bool8(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_UInt16x3_from_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 3, args[0]);
}

SPIRVResult SPIRV_UInt16x3_splat_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_UInt16x3_from_UInt16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return args[0];
}

SPIRVResult SPIRV_UInt16x3_splat_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_UInt16x3_from_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 3, args[0]);
}

SPIRVResult SPIRV_UInt16x3_splat_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_UInt16x3_ctor0(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}

SPIRVResult SPIRV_UInt16x3_ctor1(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_UInt16x3_ctor2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_Int16x3_from_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 3, args[0]);
}

SPIRVResult SPIRV_Int16x3_splat_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_Int16x3_from_UInt32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 3, args[0]);
}

SPIRVResult SPIRV_Int16x3_splat_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_Int16x3_from_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 3, args[0]);
}

SPIRVResult SPIRV_Int16x3_splat_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_Int16x3_from_Bool8x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 3, args[0]);
}

SPIRVResult SPIRV_Int16x3_splat_Bool8(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_Int16x3_from_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 3, args[0]);
}

SPIRVResult SPIRV_Int16x3_splat_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_Int16x3_from_UInt16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 3, args[0]);
}

SPIRVResult SPIRV_Int16x3_splat_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_Int16x3_from_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return args[0];
}

SPIRVResult SPIRV_Int16x3_splat_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}

SPIRVResult SPIRV_Int16x3_ctor0(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}

SPIRVResult SPIRV_Int16x3_ctor1(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_Int16x3_ctor2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_Float32x4_from_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return args[0];
}

SPIRVResult SPIRV_Float32x4_splat_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_Float32x4_from_UInt32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 4, args[0]);
}

SPIRVResult SPIRV_Float32x4_splat_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_Float32x4_from_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 4, args[0]);
}

SPIRVResult SPIRV_Float32x4_splat_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_Float32x4_from_Bool8x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Bool8ToFloat32](c, g, 4, args[0]);
}

SPIRVResult SPIRV_Float32x4_splat_Bool8(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Bool8ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_Float32x4_from_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 4, args[0]);
}

SPIRVResult SPIRV_Float32x4_splat_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_Float32x4_from_UInt16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 4, args[0]);
}

SPIRVResult SPIRV_Float32x4_splat_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_Float32x4_from_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 4, args[0]);
}

SPIRVResult SPIRV_Float32x4_splat_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_Float32x4_ctor0(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}

SPIRVResult SPIRV_Float32x4_ctor1(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}

SPIRVResult SPIRV_Float32x4_ctor2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}

SPIRVResult SPIRV_Float32x4_ctor3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}

SPIRVResult SPIRV_Float32x4_ctor4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_Float32x4_ctor5(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_Float32x4_ctor6(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_UInt32x4_from_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 4, args[0]);
}

SPIRVResult SPIRV_UInt32x4_splat_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_UInt32x4_from_UInt32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return args[0];
}

SPIRVResult SPIRV_UInt32x4_splat_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_UInt32x4_from_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 4, args[0]);
}

SPIRVResult SPIRV_UInt32x4_splat_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_UInt32x4_from_Bool8x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 4, args[0]);
}

SPIRVResult SPIRV_UInt32x4_splat_Bool8(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Bool8ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_UInt32x4_from_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 4, args[0]);
}

SPIRVResult SPIRV_UInt32x4_splat_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_UInt32x4_from_UInt16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 4, args[0]);
}

SPIRVResult SPIRV_UInt32x4_splat_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_UInt32x4_from_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 4, args[0]);
}

SPIRVResult SPIRV_UInt32x4_splat_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_UInt32x4_ctor0(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}

SPIRVResult SPIRV_UInt32x4_ctor1(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}

SPIRVResult SPIRV_UInt32x4_ctor2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}

SPIRVResult SPIRV_UInt32x4_ctor3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}

SPIRVResult SPIRV_UInt32x4_ctor4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_UInt32x4_ctor5(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_UInt32x4_ctor6(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_Int32x4_from_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 4, args[0]);
}

SPIRVResult SPIRV_Int32x4_splat_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_Int32x4_from_UInt32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 4, args[0]);
}

SPIRVResult SPIRV_Int32x4_splat_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_Int32x4_from_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return args[0];
}

SPIRVResult SPIRV_Int32x4_splat_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_Int32x4_from_Bool8x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 4, args[0]);
}

SPIRVResult SPIRV_Int32x4_splat_Bool8(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Bool8ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_Int32x4_from_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 4, args[0]);
}

SPIRVResult SPIRV_Int32x4_splat_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_Int32x4_from_UInt16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 4, args[0]);
}

SPIRVResult SPIRV_Int32x4_splat_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_Int32x4_from_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 4, args[0]);
}

SPIRVResult SPIRV_Int32x4_splat_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToInt32](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_Int32x4_ctor0(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}

SPIRVResult SPIRV_Int32x4_ctor1(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}

SPIRVResult SPIRV_Int32x4_ctor2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}

SPIRVResult SPIRV_Int32x4_ctor3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}

SPIRVResult SPIRV_Int32x4_ctor4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_Int32x4_ctor5(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_Int32x4_ctor6(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_Bool8x4_from_UInt32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt32ToBool8](c, g, 4, args[0]);
}

SPIRVResult SPIRV_Bool8x4_splat_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_Bool8x4_from_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int32ToBool8](c, g, 4, args[0]);
}

SPIRVResult SPIRV_Bool8x4_splat_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_Bool8x4_from_Bool8x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return args[0];
}

SPIRVResult SPIRV_Bool8x4_splat_Bool8(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_Bool8x4_from_UInt16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt16ToBool8](c, g, 4, args[0]);
}

SPIRVResult SPIRV_Bool8x4_splat_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_Bool8x4_from_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int16ToBool8](c, g, 4, args[0]);
}

SPIRVResult SPIRV_Bool8x4_splat_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToBool8](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_Bool8x4_ctor0(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}

SPIRVResult SPIRV_Bool8x4_ctor1(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}

SPIRVResult SPIRV_Bool8x4_ctor2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}

SPIRVResult SPIRV_Bool8x4_ctor3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}

SPIRVResult SPIRV_Bool8x4_ctor4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_Bool8x4_ctor5(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_Bool8x4_ctor6(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_Float16x4_from_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 4, args[0]);
}

SPIRVResult SPIRV_Float16x4_splat_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_Float16x4_from_UInt32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 4, args[0]);
}

SPIRVResult SPIRV_Float16x4_splat_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_Float16x4_from_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 4, args[0]);
}

SPIRVResult SPIRV_Float16x4_splat_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_Float16x4_from_Bool8x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Bool8ToFloat16](c, g, 4, args[0]);
}

SPIRVResult SPIRV_Float16x4_splat_Bool8(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Bool8ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_Float16x4_from_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return args[0];
}

SPIRVResult SPIRV_Float16x4_splat_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_Float16x4_from_UInt16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 4, args[0]);
}

SPIRVResult SPIRV_Float16x4_splat_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_Float16x4_from_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 4, args[0]);
}

SPIRVResult SPIRV_Float16x4_splat_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToFloat16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_Float16x4_ctor0(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}

SPIRVResult SPIRV_Float16x4_ctor1(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}

SPIRVResult SPIRV_Float16x4_ctor2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}

SPIRVResult SPIRV_Float16x4_ctor3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}

SPIRVResult SPIRV_Float16x4_ctor4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_Float16x4_ctor5(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_Float16x4_ctor6(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_UInt16x4_from_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 4, args[0]);
}

SPIRVResult SPIRV_UInt16x4_splat_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_UInt16x4_from_UInt32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 4, args[0]);
}

SPIRVResult SPIRV_UInt16x4_splat_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_UInt16x4_from_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 4, args[0]);
}

SPIRVResult SPIRV_UInt16x4_splat_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_UInt16x4_from_Bool8x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 4, args[0]);
}

SPIRVResult SPIRV_UInt16x4_splat_Bool8(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Bool8ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_UInt16x4_from_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 4, args[0]);
}

SPIRVResult SPIRV_UInt16x4_splat_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_UInt16x4_from_UInt16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return args[0];
}

SPIRVResult SPIRV_UInt16x4_splat_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_UInt16x4_from_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 4, args[0]);
}

SPIRVResult SPIRV_UInt16x4_splat_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int16ToUInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_UInt16x4_ctor0(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}

SPIRVResult SPIRV_UInt16x4_ctor1(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}

SPIRVResult SPIRV_UInt16x4_ctor2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}

SPIRVResult SPIRV_UInt16x4_ctor3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}

SPIRVResult SPIRV_UInt16x4_ctor4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_UInt16x4_ctor5(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_UInt16x4_ctor6(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_Int16x4_from_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 4, args[0]);
}

SPIRVResult SPIRV_Int16x4_splat_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_Int16x4_from_UInt32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 4, args[0]);
}

SPIRVResult SPIRV_Int16x4_splat_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_Int16x4_from_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 4, args[0]);
}

SPIRVResult SPIRV_Int16x4_splat_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Int32ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_Int16x4_from_Bool8x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 4, args[0]);
}

SPIRVResult SPIRV_Int16x4_splat_Bool8(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Bool8ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_Int16x4_from_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 4, args[0]);
}

SPIRVResult SPIRV_Int16x4_splat_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::Float16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_Int16x4_from_UInt16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 4, args[0]);
}

SPIRVResult SPIRV_Int16x4_splat_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    val = ConverterTable[TypeConversionTable::UInt16ToInt16](c, g, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_Int16x4_from_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return args[0];
}

SPIRVResult SPIRV_Int16x4_splat_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}

SPIRVResult SPIRV_Int16x4_ctor0(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}

SPIRVResult SPIRV_Int16x4_ctor1(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}

SPIRVResult SPIRV_Int16x4_ctor2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}

SPIRVResult SPIRV_Int16x4_ctor3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}

SPIRVResult SPIRV_Int16x4_ctor4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_Int16x4_ctor5(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_Int16x4_ctor6(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}

SPIRVResult SPIRV_Float32_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32_operator_index_Int32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32_operator_index_UInt32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32_operator_index_Int16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32_operator_index_UInt16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32_operator_add_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32_operator_sub_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32_operator_mul_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32_operator_div_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32_operator_mod_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32_operator_addasg_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32_operator_subasg_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32_operator_mulasg_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32_operator_divasg_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32_operator_lt_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32_operator_lte_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32_operator_gt_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32_operator_gte_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32_operator_eq_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32_operator_neq_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdNotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32_operator_index_Int32.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_UInt32_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32_operator_index_UInt32.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_UInt32_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32_operator_index_Int16.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_UInt32_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32_operator_index_UInt16.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_UInt32_operator_add_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32_operator_sub_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32_operator_mul_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32_operator_div_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32_operator_mod_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32_operator_addasg_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32_operator_subasg_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32_operator_mulasg_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32_operator_divasg_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32_operator_lt_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32_operator_lte_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32_operator_gt_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32_operator_gte_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32_operator_eq_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32_operator_neq_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32_operator_or_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32_operator_and_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32_operator_xor_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32_operator_lsh_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32_operator_rsh_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32_operator_orasg_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32_operator_andasg_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32_operator_xorasg_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32_operator_lshasg_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32_operator_rhsasg_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32_operator_index_Int32.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Int32_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32_operator_index_UInt32.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Int32_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32_operator_index_Int16.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Int32_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32_operator_index_UInt16.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Int32_operator_add_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32_operator_sub_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32_operator_mul_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32_operator_div_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32_operator_mod_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32_operator_addasg_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32_operator_subasg_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32_operator_mulasg_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32_operator_divasg_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32_operator_lt_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32_operator_lte_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32_operator_gt_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32_operator_gte_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32_operator_eq_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32_operator_neq_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32_operator_or_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32_operator_and_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32_operator_xor_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32_operator_lsh_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32_operator_rsh_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32_operator_orasg_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32_operator_andasg_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32_operator_xorasg_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32_operator_lshasg_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32_operator_rhsasg_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Bool8_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8_operator_index_Int32.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Bool8_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8_operator_index_UInt32.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Bool8_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8_operator_index_Int16.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Bool8_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8_operator_index_UInt16.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Bool8_operator_oror_Bool8(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpLogicalOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Bool8_operator_andand_Bool8(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpLogicalAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Bool8_operator_eq_Bool8(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Bool8_operator_neq_Bool8(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16_operator_index_Int32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16_operator_index_UInt32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16_operator_index_Int16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16_operator_index_UInt16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16_operator_add_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16_operator_sub_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16_operator_mul_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16_operator_div_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16_operator_mod_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16_operator_addasg_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16_operator_subasg_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16_operator_mulasg_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16_operator_divasg_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16_operator_lt_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16_operator_lte_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16_operator_gt_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16_operator_gte_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16_operator_eq_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16_operator_neq_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdNotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16_operator_index_Int32.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_UInt16_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16_operator_index_UInt32.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_UInt16_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16_operator_index_Int16.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_UInt16_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16_operator_index_UInt16.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_UInt16_operator_add_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16_operator_sub_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16_operator_mul_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16_operator_div_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16_operator_mod_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16_operator_addasg_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16_operator_subasg_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16_operator_mulasg_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16_operator_divasg_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16_operator_lt_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16_operator_lte_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16_operator_gt_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16_operator_gte_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16_operator_eq_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16_operator_neq_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16_operator_or_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16_operator_and_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16_operator_xor_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16_operator_lsh_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16_operator_rsh_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16_operator_orasg_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16_operator_andasg_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16_operator_xorasg_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16_operator_lshasg_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16_operator_rhsasg_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16_operator_index_Int32.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Int16_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16_operator_index_UInt32.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Int16_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16_operator_index_Int16.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Int16_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16_operator_index_UInt16.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Int16_operator_add_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16_operator_sub_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16_operator_mul_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16_operator_div_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16_operator_mod_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16_operator_addasg_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16_operator_subasg_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16_operator_mulasg_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16_operator_divasg_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16_operator_lt_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16_operator_lte_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16_operator_gt_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16_operator_gte_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16_operator_eq_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16_operator_neq_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16_operator_or_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16_operator_and_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16_operator_xor_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16_operator_lsh_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16_operator_rsh_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16_operator_orasg_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16_operator_andasg_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16_operator_xorasg_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16_operator_lshasg_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16_operator_rhsasg_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2_operator_index_Int32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x2_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2_operator_index_UInt32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x2_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2_operator_index_Int16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x2_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2_operator_index_UInt16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x2_operator_add_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2_operator_sub_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2_operator_mul_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2_operator_div_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2_operator_mod_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2_operator_addasg_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2_operator_subasg_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2_operator_mulasg_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2_operator_divasg_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2_operator_lt_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2_operator_lte_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2_operator_gt_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2_operator_gte_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2_operator_eq_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2_operator_neq_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdNotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2_operator_scale_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2_operator_scale_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2_operator_scale_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2_operator_transform_Float32x2x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2_operator_transform_Float32x2x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2_operator_transform_Float32x2x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x2_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32x2_operator_index_Int32.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_UInt32x2_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32x2_operator_index_UInt32.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_UInt32x2_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32x2_operator_index_Int16.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_UInt32x2_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32x2_operator_index_UInt16.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_UInt32x2_operator_add_UInt32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x2_operator_sub_UInt32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x2_operator_mul_UInt32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x2_operator_div_UInt32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x2_operator_mod_UInt32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x2_operator_addasg_UInt32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x2_operator_subasg_UInt32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x2_operator_mulasg_UInt32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x2_operator_divasg_UInt32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x2_operator_lt_UInt32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x2_operator_lte_UInt32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x2_operator_gt_UInt32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x2_operator_gte_UInt32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x2_operator_eq_UInt32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x2_operator_neq_UInt32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x2_operator_scale_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x2_operator_scale_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x2_operator_scale_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x2_operator_or_UInt32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x2_operator_and_UInt32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x2_operator_xor_UInt32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x2_operator_lsh_UInt32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x2_operator_rsh_UInt32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x2_operator_orasg_UInt32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x2_operator_andasg_UInt32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x2_operator_xorasg_UInt32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x2_operator_lshasg_UInt32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x2_operator_rhsasg_UInt32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x2_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32x2_operator_index_Int32.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Int32x2_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32x2_operator_index_UInt32.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Int32x2_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32x2_operator_index_Int16.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Int32x2_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32x2_operator_index_UInt16.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Int32x2_operator_add_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x2_operator_sub_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x2_operator_mul_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x2_operator_div_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x2_operator_mod_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x2_operator_addasg_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x2_operator_subasg_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x2_operator_mulasg_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x2_operator_divasg_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x2_operator_lt_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x2_operator_lte_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x2_operator_gt_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x2_operator_gte_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x2_operator_eq_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x2_operator_neq_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x2_operator_scale_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x2_operator_scale_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x2_operator_scale_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x2_operator_or_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x2_operator_and_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x2_operator_xor_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x2_operator_lsh_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x2_operator_rsh_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x2_operator_orasg_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x2_operator_andasg_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x2_operator_xorasg_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x2_operator_lshasg_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x2_operator_rhsasg_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Bool8x2_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8x2_operator_index_Int32.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Bool8x2_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8x2_operator_index_UInt32.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Bool8x2_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8x2_operator_index_Int16.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Bool8x2_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8x2_operator_index_UInt16.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Bool8x2_operator_oror_Bool8x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpLogicalOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Bool8x2_operator_andand_Bool8x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpLogicalAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Bool8x2_operator_eq_Bool8x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Bool8x2_operator_neq_Bool8x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2_operator_index_Int32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x2_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2_operator_index_UInt32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x2_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2_operator_index_Int16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x2_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2_operator_index_UInt16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x2_operator_add_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2_operator_sub_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2_operator_mul_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2_operator_div_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2_operator_mod_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2_operator_addasg_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2_operator_subasg_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2_operator_mulasg_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2_operator_divasg_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2_operator_lt_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2_operator_lte_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2_operator_gt_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2_operator_gte_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2_operator_eq_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2_operator_neq_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdNotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2_operator_scale_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2_operator_scale_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2_operator_scale_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2_operator_transform_Float32x2x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2_operator_transform_Float32x2x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2_operator_transform_Float32x2x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x2_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16x2_operator_index_Int32.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_UInt16x2_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16x2_operator_index_UInt32.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_UInt16x2_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16x2_operator_index_Int16.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_UInt16x2_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16x2_operator_index_UInt16.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_UInt16x2_operator_add_UInt16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x2_operator_sub_UInt16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x2_operator_mul_UInt16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x2_operator_div_UInt16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x2_operator_mod_UInt16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x2_operator_addasg_UInt16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x2_operator_subasg_UInt16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x2_operator_mulasg_UInt16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x2_operator_divasg_UInt16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x2_operator_lt_UInt16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x2_operator_lte_UInt16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x2_operator_gt_UInt16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x2_operator_gte_UInt16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x2_operator_eq_UInt16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x2_operator_neq_UInt16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x2_operator_scale_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x2_operator_scale_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x2_operator_scale_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x2_operator_or_UInt16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x2_operator_and_UInt16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x2_operator_xor_UInt16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x2_operator_lsh_UInt16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x2_operator_rsh_UInt16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x2_operator_orasg_UInt16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x2_operator_andasg_UInt16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x2_operator_xorasg_UInt16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x2_operator_lshasg_UInt16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x2_operator_rhsasg_UInt16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x2_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16x2_operator_index_Int32.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Int16x2_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16x2_operator_index_UInt32.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Int16x2_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16x2_operator_index_Int16.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Int16x2_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16x2_operator_index_UInt16.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Int16x2_operator_add_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x2_operator_sub_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x2_operator_mul_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x2_operator_div_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x2_operator_mod_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x2_operator_addasg_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x2_operator_subasg_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x2_operator_mulasg_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x2_operator_divasg_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x2_operator_lt_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x2_operator_lte_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x2_operator_gt_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x2_operator_gte_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x2_operator_eq_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x2_operator_neq_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x2_operator_scale_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x2_operator_scale_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x2_operator_scale_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x2_operator_or_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x2_operator_and_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x2_operator_xor_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x2_operator_lsh_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x2_operator_rsh_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x2_operator_orasg_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x2_operator_andasg_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x2_operator_xorasg_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x2_operator_lshasg_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x2_operator_rhsasg_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3_operator_index_Int32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x3_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3_operator_index_UInt32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x3_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3_operator_index_Int16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x3_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3_operator_index_UInt16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x3_operator_add_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3_operator_sub_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3_operator_mul_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3_operator_div_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3_operator_mod_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3_operator_addasg_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3_operator_subasg_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3_operator_mulasg_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3_operator_divasg_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3_operator_lt_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3_operator_lte_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3_operator_gt_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3_operator_gte_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3_operator_eq_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3_operator_neq_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdNotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3_operator_scale_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3_operator_scale_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3_operator_scale_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3_operator_transform_Float32x3x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3_operator_transform_Float32x3x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3_operator_transform_Float32x3x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x3_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32x3_operator_index_Int32.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_UInt32x3_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32x3_operator_index_UInt32.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_UInt32x3_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32x3_operator_index_Int16.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_UInt32x3_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32x3_operator_index_UInt16.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_UInt32x3_operator_add_UInt32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x3_operator_sub_UInt32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x3_operator_mul_UInt32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x3_operator_div_UInt32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x3_operator_mod_UInt32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x3_operator_addasg_UInt32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x3_operator_subasg_UInt32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x3_operator_mulasg_UInt32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x3_operator_divasg_UInt32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x3_operator_lt_UInt32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x3_operator_lte_UInt32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x3_operator_gt_UInt32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x3_operator_gte_UInt32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x3_operator_eq_UInt32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x3_operator_neq_UInt32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x3_operator_scale_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x3_operator_scale_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x3_operator_scale_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x3_operator_or_UInt32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x3_operator_and_UInt32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x3_operator_xor_UInt32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x3_operator_lsh_UInt32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x3_operator_rsh_UInt32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x3_operator_orasg_UInt32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x3_operator_andasg_UInt32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x3_operator_xorasg_UInt32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x3_operator_lshasg_UInt32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x3_operator_rhsasg_UInt32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x3_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32x3_operator_index_Int32.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Int32x3_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32x3_operator_index_UInt32.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Int32x3_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32x3_operator_index_Int16.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Int32x3_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32x3_operator_index_UInt16.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Int32x3_operator_add_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x3_operator_sub_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x3_operator_mul_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x3_operator_div_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x3_operator_mod_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x3_operator_addasg_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x3_operator_subasg_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x3_operator_mulasg_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x3_operator_divasg_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x3_operator_lt_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x3_operator_lte_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x3_operator_gt_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x3_operator_gte_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x3_operator_eq_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x3_operator_neq_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x3_operator_scale_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x3_operator_scale_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x3_operator_scale_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x3_operator_or_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x3_operator_and_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x3_operator_xor_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x3_operator_lsh_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x3_operator_rsh_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x3_operator_orasg_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x3_operator_andasg_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x3_operator_xorasg_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x3_operator_lshasg_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x3_operator_rhsasg_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Bool8x3_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8x3_operator_index_Int32.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Bool8x3_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8x3_operator_index_UInt32.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Bool8x3_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8x3_operator_index_Int16.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Bool8x3_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8x3_operator_index_UInt16.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Bool8x3_operator_oror_Bool8x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpLogicalOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Bool8x3_operator_andand_Bool8x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpLogicalAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Bool8x3_operator_eq_Bool8x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Bool8x3_operator_neq_Bool8x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3_operator_index_Int32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x3_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3_operator_index_UInt32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x3_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3_operator_index_Int16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x3_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3_operator_index_UInt16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x3_operator_add_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3_operator_sub_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3_operator_mul_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3_operator_div_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3_operator_mod_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3_operator_addasg_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3_operator_subasg_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3_operator_mulasg_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3_operator_divasg_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3_operator_lt_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3_operator_lte_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3_operator_gt_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3_operator_gte_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3_operator_eq_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3_operator_neq_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdNotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3_operator_scale_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3_operator_scale_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3_operator_scale_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3_operator_transform_Float32x3x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3_operator_transform_Float32x3x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3_operator_transform_Float32x3x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x3_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16x3_operator_index_Int32.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_UInt16x3_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16x3_operator_index_UInt32.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_UInt16x3_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16x3_operator_index_Int16.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_UInt16x3_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16x3_operator_index_UInt16.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_UInt16x3_operator_add_UInt16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x3_operator_sub_UInt16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x3_operator_mul_UInt16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x3_operator_div_UInt16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x3_operator_mod_UInt16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x3_operator_addasg_UInt16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x3_operator_subasg_UInt16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x3_operator_mulasg_UInt16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x3_operator_divasg_UInt16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x3_operator_lt_UInt16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x3_operator_lte_UInt16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x3_operator_gt_UInt16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x3_operator_gte_UInt16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x3_operator_eq_UInt16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x3_operator_neq_UInt16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x3_operator_scale_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x3_operator_scale_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x3_operator_scale_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x3_operator_or_UInt16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x3_operator_and_UInt16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x3_operator_xor_UInt16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x3_operator_lsh_UInt16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x3_operator_rsh_UInt16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x3_operator_orasg_UInt16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x3_operator_andasg_UInt16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x3_operator_xorasg_UInt16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x3_operator_lshasg_UInt16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x3_operator_rhsasg_UInt16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x3_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16x3_operator_index_Int32.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Int16x3_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16x3_operator_index_UInt32.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Int16x3_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16x3_operator_index_Int16.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Int16x3_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16x3_operator_index_UInt16.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Int16x3_operator_add_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x3_operator_sub_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x3_operator_mul_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x3_operator_div_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x3_operator_mod_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x3_operator_addasg_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x3_operator_subasg_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x3_operator_mulasg_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x3_operator_divasg_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x3_operator_lt_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x3_operator_lte_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x3_operator_gt_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x3_operator_gte_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x3_operator_eq_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x3_operator_neq_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x3_operator_scale_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x3_operator_scale_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x3_operator_scale_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x3_operator_or_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x3_operator_and_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x3_operator_xor_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x3_operator_lsh_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x3_operator_rsh_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x3_operator_orasg_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x3_operator_andasg_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x3_operator_xorasg_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x3_operator_lshasg_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x3_operator_rhsasg_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4_operator_index_Int32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x4_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4_operator_index_UInt32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x4_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4_operator_index_Int16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x4_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4_operator_index_UInt16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x4_operator_add_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4_operator_sub_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4_operator_mul_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4_operator_div_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4_operator_mod_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4_operator_addasg_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4_operator_subasg_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4_operator_mulasg_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4_operator_divasg_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4_operator_lt_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4_operator_lte_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4_operator_gt_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4_operator_gte_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4_operator_eq_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4_operator_neq_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdNotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4_operator_scale_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4_operator_scale_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4_operator_scale_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4_operator_transform_Float32x4x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4_operator_transform_Float32x4x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4_operator_transform_Float32x4x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x4_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32x4_operator_index_Int32.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_UInt32x4_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32x4_operator_index_UInt32.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_UInt32x4_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32x4_operator_index_Int16.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_UInt32x4_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32x4_operator_index_UInt16.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_UInt32x4_operator_add_UInt32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x4_operator_sub_UInt32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x4_operator_mul_UInt32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x4_operator_div_UInt32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x4_operator_mod_UInt32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x4_operator_addasg_UInt32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x4_operator_subasg_UInt32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x4_operator_mulasg_UInt32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x4_operator_divasg_UInt32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x4_operator_lt_UInt32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x4_operator_lte_UInt32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x4_operator_gt_UInt32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x4_operator_gte_UInt32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x4_operator_eq_UInt32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x4_operator_neq_UInt32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x4_operator_scale_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x4_operator_scale_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x4_operator_scale_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x4_operator_or_UInt32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x4_operator_and_UInt32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x4_operator_xor_UInt32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x4_operator_lsh_UInt32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x4_operator_rsh_UInt32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x4_operator_orasg_UInt32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x4_operator_andasg_UInt32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x4_operator_xorasg_UInt32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x4_operator_lshasg_UInt32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt32x4_operator_rhsasg_UInt32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x4_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32x4_operator_index_Int32.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Int32x4_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32x4_operator_index_UInt32.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Int32x4_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32x4_operator_index_Int16.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Int32x4_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32x4_operator_index_UInt16.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Int32x4_operator_add_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x4_operator_sub_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x4_operator_mul_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x4_operator_div_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x4_operator_mod_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x4_operator_addasg_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x4_operator_subasg_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x4_operator_mulasg_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x4_operator_divasg_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x4_operator_lt_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x4_operator_lte_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x4_operator_gt_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x4_operator_gte_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x4_operator_eq_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x4_operator_neq_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x4_operator_scale_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x4_operator_scale_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x4_operator_scale_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x4_operator_or_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x4_operator_and_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x4_operator_xor_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x4_operator_lsh_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x4_operator_rsh_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x4_operator_orasg_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x4_operator_andasg_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x4_operator_xorasg_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x4_operator_lshasg_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int32x4_operator_rhsasg_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Bool8x4_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8x4_operator_index_Int32.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Bool8x4_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8x4_operator_index_UInt32.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Bool8x4_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8x4_operator_index_Int16.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Bool8x4_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8x4_operator_index_UInt16.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Bool8x4_operator_oror_Bool8x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpLogicalOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Bool8x4_operator_andand_Bool8x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpLogicalAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Bool8x4_operator_eq_Bool8x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Bool8x4_operator_neq_Bool8x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4_operator_index_Int32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x4_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4_operator_index_UInt32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x4_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4_operator_index_Int16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x4_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4_operator_index_UInt16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x4_operator_add_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4_operator_sub_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4_operator_mul_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4_operator_div_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4_operator_mod_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4_operator_addasg_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4_operator_subasg_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4_operator_mulasg_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4_operator_divasg_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4_operator_lt_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4_operator_lte_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4_operator_gt_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4_operator_gte_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4_operator_eq_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4_operator_neq_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFOrdNotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4_operator_scale_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4_operator_scale_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4_operator_scale_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4_operator_transform_Float32x4x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4_operator_transform_Float32x4x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4_operator_transform_Float32x4x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x4_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16x4_operator_index_Int32.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_UInt16x4_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16x4_operator_index_UInt32.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_UInt16x4_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16x4_operator_index_Int16.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_UInt16x4_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16x4_operator_index_UInt16.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_UInt16x4_operator_add_UInt16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x4_operator_sub_UInt16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x4_operator_mul_UInt16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x4_operator_div_UInt16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x4_operator_mod_UInt16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x4_operator_addasg_UInt16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x4_operator_subasg_UInt16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x4_operator_mulasg_UInt16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x4_operator_divasg_UInt16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x4_operator_lt_UInt16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x4_operator_lte_UInt16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x4_operator_gt_UInt16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x4_operator_gte_UInt16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x4_operator_eq_UInt16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x4_operator_neq_UInt16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x4_operator_scale_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x4_operator_scale_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x4_operator_scale_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x4_operator_or_UInt16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x4_operator_and_UInt16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x4_operator_xor_UInt16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x4_operator_lsh_UInt16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x4_operator_rsh_UInt16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x4_operator_orasg_UInt16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x4_operator_andasg_UInt16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x4_operator_xorasg_UInt16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x4_operator_lshasg_UInt16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_UInt16x4_operator_rhsasg_UInt16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x4_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16x4_operator_index_Int32.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Int16x4_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16x4_operator_index_UInt32.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Int16x4_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16x4_operator_index_Int16.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Int16x4_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16x4_operator_index_UInt16.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Int16x4_operator_add_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x4_operator_sub_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x4_operator_mul_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x4_operator_div_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x4_operator_mod_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x4_operator_addasg_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x4_operator_subasg_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x4_operator_mulasg_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x4_operator_divasg_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x4_operator_lt_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x4_operator_lte_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x4_operator_gt_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x4_operator_gte_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x4_operator_eq_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x4_operator_neq_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x4_operator_scale_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x4_operator_scale_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x4_operator_scale_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x4_operator_or_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x4_operator_and_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x4_operator_xor_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x4_operator_lsh_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x4_operator_rsh_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x4_operator_orasg_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x4_operator_andasg_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x4_operator_xorasg_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x4_operator_lshasg_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Int16x4_operator_rhsasg_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2x2_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2x2_operator_index_Int32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x2x2_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2x2_operator_index_UInt32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x2x2_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2x2_operator_index_Int16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x2x2_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2x2_operator_index_UInt16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x2x2_transform_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesVector, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2x2_operator_add_Float32x2x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2x2_operator_sub_Float32x2x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2x2_operator_mul_Float32x2x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2x2_operator_addasg_Float32x2x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2x2_operator_subasg_Float32x2x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2x2_operator_mulasg_Float32x2x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2x2_operator_scale_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2x3_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2x3_operator_index_Int32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x2x3_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2x3_operator_index_UInt32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x2x3_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2x3_operator_index_Int16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x2x3_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2x3_operator_index_UInt16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x2x3_transform_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesVector, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2x3_operator_add_Float32x2x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2x3_operator_sub_Float32x2x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2x3_operator_mul_Float32x2x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2x3_operator_addasg_Float32x2x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2x3_operator_subasg_Float32x2x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2x3_operator_mulasg_Float32x2x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2x3_operator_scale_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2x4_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2x4_operator_index_Int32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x2x4_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2x4_operator_index_UInt32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x2x4_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2x4_operator_index_Int16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x2x4_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2x4_operator_index_UInt16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x2x4_transform_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesVector, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2x4_operator_add_Float32x2x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2x4_operator_sub_Float32x2x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2x4_operator_mul_Float32x2x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2x4_operator_addasg_Float32x2x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2x4_operator_subasg_Float32x2x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2x4_operator_mulasg_Float32x2x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x2x4_operator_scale_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3x2_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3x2_operator_index_Int32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x3x2_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3x2_operator_index_UInt32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x3x2_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3x2_operator_index_Int16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x3x2_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3x2_operator_index_UInt16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x3x2_transform_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesVector, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3x2_operator_add_Float32x3x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3x2_operator_sub_Float32x3x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3x2_operator_mul_Float32x3x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3x2_operator_addasg_Float32x3x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3x2_operator_subasg_Float32x3x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3x2_operator_mulasg_Float32x3x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3x2_operator_scale_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3x3_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3x3_operator_index_Int32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x3x3_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3x3_operator_index_UInt32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x3x3_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3x3_operator_index_Int16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x3x3_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3x3_operator_index_UInt16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x3x3_transform_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesVector, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3x3_operator_add_Float32x3x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3x3_operator_sub_Float32x3x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3x3_operator_mul_Float32x3x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3x3_operator_addasg_Float32x3x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3x3_operator_subasg_Float32x3x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3x3_operator_mulasg_Float32x3x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3x3_operator_scale_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3x4_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3x4_operator_index_Int32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x3x4_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3x4_operator_index_UInt32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x3x4_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3x4_operator_index_Int16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x3x4_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3x4_operator_index_UInt16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x3x4_transform_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesVector, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3x4_operator_add_Float32x3x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3x4_operator_sub_Float32x3x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3x4_operator_mul_Float32x3x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3x4_operator_addasg_Float32x3x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3x4_operator_subasg_Float32x3x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3x4_operator_mulasg_Float32x3x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x3x4_operator_scale_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4x2_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4x2_operator_index_Int32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x4x2_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4x2_operator_index_UInt32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x4x2_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4x2_operator_index_Int16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x4x2_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4x2_operator_index_UInt16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x4x2_transform_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesVector, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4x2_operator_add_Float32x4x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4x2_operator_sub_Float32x4x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4x2_operator_mul_Float32x4x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4x2_operator_addasg_Float32x4x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4x2_operator_subasg_Float32x4x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4x2_operator_mulasg_Float32x4x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4x2_operator_scale_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4x3_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4x3_operator_index_Int32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x4x3_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4x3_operator_index_UInt32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x4x3_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4x3_operator_index_Int16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x4x3_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4x3_operator_index_UInt16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x4x3_transform_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesVector, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4x3_operator_add_Float32x4x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4x3_operator_sub_Float32x4x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4x3_operator_mul_Float32x4x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4x3_operator_addasg_Float32x4x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4x3_operator_subasg_Float32x4x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4x3_operator_mulasg_Float32x4x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4x3_operator_scale_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4x4_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4x4_operator_index_Int32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x4x4_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4x4_operator_index_UInt32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x4x4_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4x4_operator_index_Int16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x4x4_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4x4_operator_index_UInt16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float32x4x4_transform_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesVector, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4x4_operator_add_Float32x4x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4x4_operator_sub_Float32x4x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4x4_operator_mul_Float32x4x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4x4_operator_addasg_Float32x4x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4x4_operator_subasg_Float32x4x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4x4_operator_mulasg_Float32x4x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float32x4x4_operator_scale_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2x2_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2x2_operator_index_Int32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x2x2_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2x2_operator_index_UInt32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x2x2_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2x2_operator_index_Int16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x2x2_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2x2_operator_index_UInt16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x2x2_transform_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesVector, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2x2_operator_add_Float16x2x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2x2_operator_sub_Float16x2x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2x2_operator_mul_Float16x2x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2x2_operator_addasg_Float16x2x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2x2_operator_subasg_Float16x2x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2x2_operator_mulasg_Float16x2x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2x2_operator_scale_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2x3_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2x3_operator_index_Int32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x2x3_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2x3_operator_index_UInt32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x2x3_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2x3_operator_index_Int16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x2x3_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2x3_operator_index_UInt16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x2x3_transform_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesVector, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2x3_operator_add_Float16x2x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2x3_operator_sub_Float16x2x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2x3_operator_mul_Float16x2x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2x3_operator_addasg_Float16x2x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2x3_operator_subasg_Float16x2x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2x3_operator_mulasg_Float16x2x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2x3_operator_scale_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2x4_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2x4_operator_index_Int32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x2x4_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2x4_operator_index_UInt32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x2x4_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2x4_operator_index_Int16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x2x4_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2x4_operator_index_UInt16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x2x4_transform_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesVector, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2x4_operator_add_Float16x2x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2x4_operator_sub_Float16x2x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2x4_operator_mul_Float16x2x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2x4_operator_addasg_Float16x2x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2x4_operator_subasg_Float16x2x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2x4_operator_mulasg_Float16x2x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x2x4_operator_scale_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3x2_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3x2_operator_index_Int32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x3x2_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3x2_operator_index_UInt32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x3x2_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3x2_operator_index_Int16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x3x2_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3x2_operator_index_UInt16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x3x2_transform_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesVector, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3x2_operator_add_Float16x3x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3x2_operator_sub_Float16x3x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3x2_operator_mul_Float16x3x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3x2_operator_addasg_Float16x3x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3x2_operator_subasg_Float16x3x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3x2_operator_mulasg_Float16x3x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3x2_operator_scale_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3x3_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3x3_operator_index_Int32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x3x3_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3x3_operator_index_UInt32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x3x3_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3x3_operator_index_Int16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x3x3_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3x3_operator_index_UInt16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x3x3_transform_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesVector, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3x3_operator_add_Float16x3x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3x3_operator_sub_Float16x3x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3x3_operator_mul_Float16x3x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3x3_operator_addasg_Float16x3x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3x3_operator_subasg_Float16x3x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3x3_operator_mulasg_Float16x3x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3x3_operator_scale_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3x4_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3x4_operator_index_Int32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x3x4_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3x4_operator_index_UInt32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x3x4_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3x4_operator_index_Int16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x3x4_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3x4_operator_index_UInt16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x3x4_transform_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesVector, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3x4_operator_add_Float16x3x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3x4_operator_sub_Float16x3x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3x4_operator_mul_Float16x3x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3x4_operator_addasg_Float16x3x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3x4_operator_subasg_Float16x3x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3x4_operator_mulasg_Float16x3x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x3x4_operator_scale_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4x2_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4x2_operator_index_Int32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x4x2_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4x2_operator_index_UInt32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x4x2_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4x2_operator_index_Int16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x4x2_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4x2_operator_index_UInt16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x4x2_transform_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesVector, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4x2_operator_add_Float16x4x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4x2_operator_sub_Float16x4x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4x2_operator_mul_Float16x4x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4x2_operator_addasg_Float16x4x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4x2_operator_subasg_Float16x4x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4x2_operator_mulasg_Float16x4x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4x2_operator_scale_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4x3_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4x3_operator_index_Int32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x4x3_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4x3_operator_index_UInt32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x4x3_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4x3_operator_index_Int16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x4x3_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4x3_operator_index_UInt16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x4x3_transform_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesVector, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4x3_operator_add_Float16x4x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4x3_operator_sub_Float16x4x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4x3_operator_mul_Float16x4x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4x3_operator_addasg_Float16x4x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4x3_operator_subasg_Float16x4x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4x3_operator_mulasg_Float16x4x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4x3_operator_scale_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4x4_operator_index_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4x4_operator_index_Int32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x4x4_operator_index_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4x4_operator_index_UInt32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x4x4_operator_index_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4x4_operator_index_Int16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x4x4_operator_index_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4x4_operator_index_UInt16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({index});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}

SPIRVResult SPIRV_Float16x4x4_transform_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesVector, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4x4_operator_add_Float16x4x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4x4_operator_sub_Float16x4x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4x4_operator_mul_Float16x4x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4x4_operator_addasg_Float16x4x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4x4_operator_subasg_Float16x4x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++)
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4x4_operator_mulasg_Float16x4x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_Float16x4x4_operator_scale_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_acos_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acos, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_acos_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acos, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_acos_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acos, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_acos_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acos, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_acos_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acos, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_acos_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acos, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_acos_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acos, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_acos_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acos, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_acosh_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acosh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_acosh_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acosh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_acosh_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acosh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_acosh_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acosh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_acosh_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acosh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_acosh_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acosh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_acosh_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acosh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_acosh_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acosh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_asin_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asin, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_asin_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asin, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_asin_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asin, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_asin_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asin, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_asin_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asin, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_asin_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asin, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_asin_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asin, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_asin_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asin, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_asinh_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asinh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_asinh_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asinh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_asinh_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asinh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_asinh_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asinh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_asinh_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asinh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_asinh_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asinh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_asinh_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asinh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_asinh_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asinh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_atan_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_atan_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_atan_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_atan_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_atan_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_atan_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_atan_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_atan_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_atanh_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atanh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_atanh_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atanh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_atanh_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atanh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_atanh_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atanh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_atanh_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atanh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_atanh_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atanh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_atanh_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atanh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_atanh_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atanh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_cos_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cos, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_cos_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cos, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_cos_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cos, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_cos_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cos, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_cos_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cos, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_cos_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cos, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_cos_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cos, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_cos_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cos, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_cosh_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cosh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_cosh_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cosh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_cosh_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cosh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_cosh_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cosh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_cosh_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cosh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_cosh_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cosh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_cosh_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cosh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_cosh_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cosh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_exp_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_exp_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_exp_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_exp_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_exp_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_exp_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_exp_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_exp_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_exp2_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp2, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_exp2_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp2, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_exp2_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp2, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_exp2_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp2, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_exp2_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp2, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_exp2_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp2, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_exp2_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp2, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_exp2_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp2, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_invSqrt_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), InverseSqrt, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_invSqrt_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), InverseSqrt, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_invSqrt_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), InverseSqrt, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_invSqrt_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), InverseSqrt, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_invSqrt_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), InverseSqrt, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_invSqrt_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), InverseSqrt, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_invSqrt_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), InverseSqrt, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_invSqrt_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), InverseSqrt, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_log_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_log_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_log_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_log_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_log_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_log_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_log_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_log_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_log2_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log2, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_log2_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log2, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_log2_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log2, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_log2_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log2, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_log2_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log2, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_log2_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log2, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_log2_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log2, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_log2_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log2, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_sin_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sin, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_sin_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sin, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_sin_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sin, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_sin_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sin, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_sin_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sin, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_sin_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sin, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_sin_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sin, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_sin_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sin, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_sinh_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sinh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_sinh_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sinh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_sinh_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sinh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_sinh_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sinh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_sinh_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sinh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_sinh_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sinh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_sinh_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sinh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_sinh_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sinh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_sqrt_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sqrt, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_sqrt_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sqrt, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_sqrt_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sqrt, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_sqrt_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sqrt, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_sqrt_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sqrt, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_sqrt_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sqrt, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_sqrt_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sqrt, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_sqrt_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sqrt, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_tan_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tan, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_tan_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tan, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_tan_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tan, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_tan_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tan, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_tan_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tan, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_tan_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tan, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_tan_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tan, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_tan_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tan, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_tanh_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tanh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_tanh_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tanh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_tanh_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tanh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_tanh_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tanh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_tanh_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tanh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_tanh_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tanh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_tanh_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tanh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_tanh_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tanh, arg);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_atan2_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult y = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan2, y, x);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_atan2_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult y = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan2, y, x);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_atan2_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult y = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan2, y, x);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_atan2_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult y = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan2, y, x);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_atan2_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult y = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan2, y, x);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_atan2_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult y = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan2, y, x);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_atan2_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult y = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan2, y, x);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_atan2_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult y = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan2, y, x);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_pow_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult exponent = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Pow, val, exponent);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_pow_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult exponent = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Pow, val, exponent);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_pow_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult exponent = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Pow, val, exponent);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_pow_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult exponent = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Pow, val, exponent);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_pow_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult exponent = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Pow, val, exponent);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_pow_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult exponent = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Pow, val, exponent);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_pow_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult exponent = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Pow, val, exponent);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_pow_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult exponent = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Pow, val, exponent);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_mad_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_mad_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_mad_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_mad_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_mad_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_mad_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_mad_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_mad_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_mad_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_mad_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_mad_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_mad_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_mad_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_mad_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_mad_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_mad_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_mad_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_mad_UInt32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_mad_UInt32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_mad_UInt32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_mad_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_mad_UInt16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_mad_UInt16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_mad_UInt16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_dot_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult x = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult y = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpDot, SPVWriter::Section::LocalFunction, returnType, x, y);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_dot_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult x = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult y = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpDot, SPVWriter::Section::LocalFunction, returnType, x, y);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_dot_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult x = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult y = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpDot, SPVWriter::Section::LocalFunction, returnType, x, y);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_dot_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult x = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult y = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpDot, SPVWriter::Section::LocalFunction, returnType, x, y);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_dot_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult x = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult y = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpDot, SPVWriter::Section::LocalFunction, returnType, x, y);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_dot_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult x = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult y = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpDot, SPVWriter::Section::LocalFunction, returnType, x, y);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_reflect_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult incident = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult normal = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Reflect, incident, normal);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_reflect_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult incident = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult normal = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Reflect, incident, normal);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_reflect_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult incident = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult normal = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Reflect, incident, normal);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_reflect_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult incident = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult normal = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Reflect, incident, normal);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_reflect_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult incident = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult normal = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Reflect, incident, normal);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_reflect_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult incident = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult normal = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Reflect, incident, normal);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_refract_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult incident = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult normal = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult ior = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Refract, incident, normal, ior);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_refract_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult incident = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult normal = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult ior = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Refract, incident, normal, ior);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_refract_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult incident = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult normal = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult ior = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Refract, incident, normal, ior);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_refract_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult incident = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult normal = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult ior = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Refract, incident, normal, ior);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_refract_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult incident = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult normal = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult ior = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Refract, incident, normal, ior);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_refract_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult incident = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult normal = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult ior = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Refract, incident, normal, ior);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_cross_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult x = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult y = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cross, x, y);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_cross_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult x = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult y = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cross, x, y);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_length_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult vec = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Length, vec);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_length_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult vec = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Length, vec);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_length_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult vec = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Length, vec);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_length_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult vec = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Length, vec);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_length_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult vec = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Length, vec);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_length_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult vec = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Length, vec);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_normalize_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult vec = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Normalize, vec);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_normalize_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult vec = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Normalize, vec);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_normalize_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult vec = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Normalize, vec);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_normalize_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult vec = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Normalize, vec);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_normalize_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult vec = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Normalize, vec);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_normalize_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult vec = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Normalize, vec);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_distance_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult v0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult v1 = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Distance, v0, v1);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_distance_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult v0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult v1 = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Distance, v0, v1);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_distance_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult v0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult v1 = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Distance, v0, v1);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_distance_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult v0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult v1 = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Distance, v0, v1);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_distance_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult v0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult v1 = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Distance, v0, v1);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_distance_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult v0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult v1 = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Distance, v0, v1);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_min_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_min_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_min_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_min_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_min_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_min_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_min_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_min_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_min_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_min_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_min_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_min_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_min_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_min_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_min_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_min_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_min_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_min_UInt32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_min_UInt32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_min_UInt32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_min_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_min_UInt16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_min_UInt16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_min_UInt16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_max_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_max_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_max_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_max_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_max_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_max_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_max_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_max_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_max_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_max_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_max_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_max_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_max_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_max_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_max_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_max_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_max_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_max_UInt32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_max_UInt32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_max_UInt32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_max_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_max_UInt16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_max_UInt16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_max_UInt16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_clamp_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_clamp_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_clamp_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_clamp_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_clamp_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_clamp_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_clamp_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_clamp_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_clamp_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_clamp_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_clamp_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_clamp_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_clamp_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_clamp_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_clamp_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_clamp_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_clamp_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_clamp_UInt32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_clamp_UInt32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_clamp_UInt32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_clamp_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_clamp_UInt16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_clamp_UInt16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_clamp_UInt16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_lerp_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult a = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult b = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult t = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMix, a, b, t);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_lerp_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult a = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult b = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult t = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMix, a, b, t);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_lerp_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult a = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult b = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult t = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMix, a, b, t);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_lerp_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult a = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult b = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult t = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMix, a, b, t);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_lerp_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult a = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult b = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult t = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMix, a, b, t);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_lerp_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult a = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult b = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult t = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMix, a, b, t);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_step_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult edge = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Step, edge, x);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_step_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult edge = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Step, edge, x);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_step_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult edge = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Step, edge, x);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_step_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult edge = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Step, edge, x);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_step_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult edge = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Step, edge, x);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_step_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult edge = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Step, edge, x);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_step_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult edge = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Step, edge, x);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_step_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult edge = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Step, edge, x);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_smoothstep_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult edge0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult edge1 = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SmoothStep, edge0, edge1, x);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_smoothstep_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult edge0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult edge1 = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SmoothStep, edge0, edge1, x);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_smoothstep_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult edge0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult edge1 = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SmoothStep, edge0, edge1, x);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_smoothstep_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult edge0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult edge1 = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SmoothStep, edge0, edge1, x);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_smoothstep_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult edge0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult edge1 = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SmoothStep, edge0, edge1, x);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_smoothstep_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult edge0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult edge1 = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SmoothStep, edge0, edge1, x);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_smoothstep_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult edge0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult edge1 = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SmoothStep, edge0, edge1, x);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_smoothstep_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult edge0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult edge1 = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SmoothStep, edge0, edge1, x);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_ceil_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Ceil, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_ceil_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Ceil, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_ceil_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Ceil, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_ceil_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Ceil, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_ceil_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Ceil, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_ceil_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Ceil, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_ceil_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Ceil, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_ceil_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Ceil, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_floor_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Floor, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_floor_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Floor, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_floor_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Floor, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_floor_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Floor, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_floor_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Floor, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_floor_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Floor, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_floor_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Floor, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_floor_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Floor, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_fract_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fract, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_fract_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fract, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_fract_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fract, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_fract_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fract, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_fract_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fract, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_fract_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fract, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_fract_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fract, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_fract_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fract, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_saturate_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float(0));
    SPIRVResult max = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float(1));
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_saturate_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float(0));
    SPIRVResult max = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float(1));
    min = GenerateSplatCompositeSPIRV(c, g, returnType, 2, min);
    max = GenerateSplatCompositeSPIRV(c, g, returnType, 2, max);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_saturate_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float(0));
    SPIRVResult max = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float(1));
    min = GenerateSplatCompositeSPIRV(c, g, returnType, 3, min);
    max = GenerateSplatCompositeSPIRV(c, g, returnType, 3, max);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_saturate_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float(0));
    SPIRVResult max = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float(1));
    min = GenerateSplatCompositeSPIRV(c, g, returnType, 4, min);
    max = GenerateSplatCompositeSPIRV(c, g, returnType, 4, max);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_saturate_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float(0));
    SPIRVResult max = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float(1));
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_saturate_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float(0));
    SPIRVResult max = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float(1));
    min = GenerateSplatCompositeSPIRV(c, g, returnType, 2, min);
    max = GenerateSplatCompositeSPIRV(c, g, returnType, 2, max);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_saturate_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float(0));
    SPIRVResult max = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float(1));
    min = GenerateSplatCompositeSPIRV(c, g, returnType, 3, min);
    max = GenerateSplatCompositeSPIRV(c, g, returnType, 3, max);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_saturate_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float(0));
    SPIRVResult max = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float(1));
    min = GenerateSplatCompositeSPIRV(c, g, returnType, 4, min);
    max = GenerateSplatCompositeSPIRV(c, g, returnType, 4, max);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_trunc_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Trunc, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_trunc_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Trunc, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_trunc_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Trunc, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_trunc_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Trunc, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_trunc_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Trunc, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_trunc_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Trunc, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_trunc_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Trunc, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_trunc_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Trunc, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_ddx_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpDPdx, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_ddx_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpDPdx, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_ddx_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpDPdx, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_ddx_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpDPdx, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_ddx_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpDPdx, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_ddx_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpDPdx, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_ddx_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpDPdx, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_ddx_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpDPdx, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_ddy_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpDPdy, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_ddy_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpDPdy, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_ddy_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpDPdy, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_ddy_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpDPdy, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_ddy_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpDPdy, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_ddy_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpDPdy, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_ddy_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpDPdy, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_ddy_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpDPdy, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_fwidth_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpFwidth, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_fwidth_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpFwidth, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_fwidth_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpFwidth, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_fwidth_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpFwidth, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_fwidth_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpFwidth, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_fwidth_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpFwidth, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_fwidth_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpFwidth, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_fwidth_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpFwidth, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_sign_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SSign, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_sign_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SSign, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_sign_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SSign, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_sign_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SSign, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_sign_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SSign, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_sign_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SSign, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_sign_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SSign, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_sign_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SSign, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_sign_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FSign, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_sign_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FSign, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_sign_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FSign, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_sign_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FSign, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_sign_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FSign, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_sign_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FSign, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_sign_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FSign, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_sign_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FSign, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_abs_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SAbs, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_abs_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SAbs, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_abs_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SAbs, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_abs_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SAbs, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_abs_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SAbs, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_abs_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SAbs, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_abs_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SAbs, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_abs_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SAbs, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_abs_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FAbs, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_abs_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FAbs, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_abs_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FAbs, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_abs_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FAbs, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_abs_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FAbs, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_abs_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FAbs, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_abs_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FAbs, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_abs_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FAbs, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_castToF16_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_castToF16_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_castToU16_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_castToU16_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_castToI16_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_castToI16_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_castToF32_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_castToF32_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_castToU32_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_castToU32_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_castToI32_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_castToI32_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_any_Bool8(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpAny, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_any_Bool8x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpAny, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_any_Bool8x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpAny, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_any_Bool8x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpAny, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_all_Bool8(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpAll, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_all_Bool8x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpAll, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_all_Bool8x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpAll, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_all_Bool8x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpAll, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_transpose_Float32x2x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpTranspose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_transpose_Float16x2x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpTranspose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_transpose_Float32x2x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpTranspose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_transpose_Float16x2x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpTranspose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_transpose_Float32x2x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpTranspose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_transpose_Float16x2x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpTranspose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_transpose_Float32x3x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpTranspose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_transpose_Float16x3x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpTranspose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_transpose_Float32x3x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpTranspose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_transpose_Float16x3x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpTranspose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_transpose_Float32x3x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpTranspose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_transpose_Float16x3x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpTranspose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_transpose_Float32x4x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpTranspose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_transpose_Float16x4x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpTranspose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_transpose_Float32x4x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpTranspose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_transpose_Float16x4x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpTranspose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_transpose_Float32x4x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpTranspose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_transpose_Float16x4x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpTranspose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_inverse_Float32x2x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), MatrixInverse, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_inverse_Float16x2x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), MatrixInverse, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_inverse_Float32x2x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), MatrixInverse, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_inverse_Float16x2x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), MatrixInverse, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_inverse_Float32x2x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), MatrixInverse, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_inverse_Float16x2x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), MatrixInverse, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_inverse_Float32x3x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), MatrixInverse, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_inverse_Float16x3x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), MatrixInverse, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_inverse_Float32x3x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), MatrixInverse, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_inverse_Float16x3x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), MatrixInverse, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_inverse_Float32x3x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), MatrixInverse, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_inverse_Float16x3x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), MatrixInverse, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_inverse_Float32x4x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), MatrixInverse, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_inverse_Float16x4x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), MatrixInverse, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_inverse_Float32x4x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), MatrixInverse, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_inverse_Float16x4x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), MatrixInverse, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_inverse_Float32x4x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), MatrixInverse, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_inverse_Float16x4x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), MatrixInverse, val);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_VertexGetOutputLayer(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplGetOutputLayer"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::Layer);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}

SPIRVResult SPIRV_VertexGetOutputViewport(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplGetOutputViewport"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::ViewportIndex);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}

SPIRVResult SPIRV_VertexGetIndex(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplGetIndex"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::VertexId);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}

SPIRVResult SPIRV_VertexGetInstanceIndex(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplGetInstanceIndex"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::InstanceId);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}

SPIRVResult SPIRV_VertexGetBaseIndex(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplGetBaseIndex"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::BaseVertex);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}

SPIRVResult SPIRV_VertexGetBaseInstanceIndex(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplGetBaseInstanceIndex"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::BaseInstance);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}

SPIRVResult SPIRV_VertexGetDrawIndex(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplGetDrawIndex"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::DrawIndex);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}

SPIRVResult SPIRV_VertexSetOutputLayer_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplSetOutputLayer"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::Layer);
    g->interfaceVariables.Insert(ret);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, args[0]);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_VertexSetOutputLayer_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplSetOutputLayer"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::Layer);
    g->interfaceVariables.Insert(ret);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, args[0]);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_VertexSetOutputViewport_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplSetOutputViewport"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::ViewportIndex);
    g->interfaceVariables.Insert(ret);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, args[0]);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_VertexSetOutputViewport_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplSetOutputViewport"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::ViewportIndex);
    g->interfaceVariables.Insert(ret);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, args[0]);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_VertexExportCoordinates_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplSetOutputViewport"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::Position);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_VertexExportCoordinates_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplSetOutputViewport"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::Position);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_GeometryExportVertex(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Geometry);
    g->writer->Instruction(OpEmitVertex, SPVWriter::Section::LocalFunction);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_GeometryExportPrimitive(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Geometry);
    g->writer->Instruction(OpEndPrimitive, SPVWriter::Section::LocalFunction);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelGetCoordinates_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelGetCoordinates_Float32x4"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::FragCoord);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}

SPIRVResult SPIRV_PixelGetCoordinates_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelGetCoordinates_Float16x4"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::FragCoord);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}

SPIRVResult SPIRV_PixelGetDepth(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelGetDepth"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::FragDepth);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}

SPIRVResult SPIRV_PixelSetDepth(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelSetDepth"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::FragDepth);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Float32_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Float32_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Float32_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Float32_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Float32x2_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x2_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32x2_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Float32x2_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x2_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32x2_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Float32x2_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x2_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32x2_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Float32x2_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x2_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32x2_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Float32x3_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x3_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32x3_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Float32x3_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x3_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32x3_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Float32x3_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x3_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32x3_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Float32x3_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x3_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32x3_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Float32x4_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32x4_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Float32x4_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32x4_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Float32x4_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32x4_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Float32x4_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32x4_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Float16_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float16, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f16_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Float16_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float16, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f16_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Float16_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float16, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f16_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Float16_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float16, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f16_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Float16x2_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float16, 2);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f16x2_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16x2_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Float16x2_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float16, 2);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f16x2_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16x2_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Float16x2_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float16, 2);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f16x2_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16x2_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Float16x2_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float16, 2);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f16x2_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16x2_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Float16x3_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float16, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f16x3_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16x3_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Float16x3_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float16, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f16x3_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16x3_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Float16x3_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float16, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f16x3_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16x3_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Float16x3_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float16, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f16x3_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16x3_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Float16x4_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float16, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f16x4_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16x4_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Float16x4_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float16, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f16x4_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16x4_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Float16x4_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float16, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f16x4_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16x4_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Float16x4_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float16, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f16x4_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16x4_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Int32_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Int32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_i32_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Int32_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Int32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_i32_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Int32_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Int32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_i32_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Int32_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Int32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_i32_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Int32x2_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Int32, 2);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_i32x2_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32x2_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Int32x2_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Int32, 2);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_i32x2_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32x2_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Int32x2_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Int32, 2);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_i32x2_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32x2_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Int32x2_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Int32, 2);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_i32x2_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32x2_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Int32x3_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Int32, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_i32x3_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32x3_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Int32x3_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Int32, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_i32x3_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32x3_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Int32x3_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Int32, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_i32x3_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32x3_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Int32x3_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Int32, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_i32x3_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32x3_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Int32x4_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Int32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_i32x4_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32x4_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Int32x4_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Int32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_i32x4_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32x4_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Int32x4_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Int32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_i32x4_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32x4_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Int32x4_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Int32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_i32x4_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32x4_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Int16_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Int16, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_i16_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Int16_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Int16, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_i16_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Int16_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Int16, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_i16_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Int16_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Int16, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_i16_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Int16x2_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Int16, 2);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_i16x2_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16x2_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Int16x2_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Int16, 2);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_i16x2_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16x2_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Int16x2_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Int16, 2);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_i16x2_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16x2_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Int16x2_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Int16, 2);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_i16x2_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16x2_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Int16x3_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Int16, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_i16x3_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16x3_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Int16x3_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Int16, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_i16x3_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16x3_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Int16x3_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Int16, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_i16x3_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16x3_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Int16x3_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Int16, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_i16x3_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16x3_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Int16x4_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Int16, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_i16x4_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16x4_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Int16x4_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Int16, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_i16x4_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16x4_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Int16x4_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Int16, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_i16x4_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16x4_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_Int16x4_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Int16, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_i16x4_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16x4_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_UInt32_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_UInt32_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_UInt32_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_UInt32_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_UInt32x2_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 2);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x2_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32x2_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_UInt32x2_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 2);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x2_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32x2_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_UInt32x2_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 2);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x2_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32x2_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_UInt32x2_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 2);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x2_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32x2_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_UInt32x3_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x3_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32x3_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_UInt32x3_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x3_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32x3_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_UInt32x3_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x3_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32x3_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_UInt32x3_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x3_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32x3_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_UInt32x4_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x4_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32x4_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_UInt32x4_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x4_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32x4_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_UInt32x4_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x4_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32x4_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_UInt32x4_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x4_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32x4_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_UInt16_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u16_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_UInt16_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u16_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_UInt16_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u16_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_UInt16_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u16_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_UInt16x2_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16, 2);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u16x2_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16x2_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_UInt16x2_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16, 2);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u16x2_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16x2_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_UInt16x2_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16, 2);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u16x2_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16x2_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_UInt16x2_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16, 2);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u16x2_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16x2_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_UInt16x3_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u16x3_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16x3_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_UInt16x3_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u16x3_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16x3_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_UInt16x3_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u16x3_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16x3_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_UInt16x3_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u16x3_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16x3_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_UInt16x4_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u16x4_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16x4_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_UInt16x4_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u16x4_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16x4_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_UInt16x4_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u16x4_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16x4_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_PixelExportColor_UInt16x4_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u16x4_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16x4_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}

SPIRVResult SPIRV_ComputeGetLocalThreadIndices(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x3_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplComputeGetLocalThreadIndices"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::LocalInvocationId);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}

SPIRVResult SPIRV_ComputeGetGlobalThreadIndices(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x3_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplComputeGetGlobalThreadIndices"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::GlobalInvocationId);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}

SPIRVResult SPIRV_ComputeGetWorkgroupIndices(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x3_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplComputeGetWorkgroupIndices"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::WorkgroupId);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}

SPIRVResult SPIRV_ComputeGetWorkGroupDimensions(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x3_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplComputeGetWorkGroupDimensions"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::WorkgroupSize);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}

SPIRVResult SPIRV_ComputeGetIndexInWorkgroup(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplComputeGetIndexInWorkgroup"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::LocalInvocationIndex);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}

SPIRVResult SPIRV_SubgroupGetId(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniform);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x3_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplSubgroupGetId"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::SubgroupId);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}

SPIRVResult SPIRV_SubgroupGetSize(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniform);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x3_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplSubgroupGetSize"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::SubgroupSize);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}

SPIRVResult SPIRV_SubgroupGetNum(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniform);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x3_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplSubgroupGetNum"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::NumSubgroups);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}

SPIRVResult SPIRV_SubgroupGetThreadMask(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniform);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplSubgroupGetThreadMask"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::SubgroupEqMask);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}

SPIRVResult SPIRV_SubgroupGetThreadAndLowerMask(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniform);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplSubgroupGetThreadAndLowerMask"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::SubgroupLeMask);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}

SPIRVResult SPIRV_SubgroupGetLowerMask(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniform);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplSubgroupGetLowerMask"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::SubgroupLtMask);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}

SPIRVResult SPIRV_SubgroupGetThreadAndGreaterMask(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniform);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplSubgroupGetThreadAndGreaterMask"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::SubgroupGeMask);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}

SPIRVResult SPIRV_SubgroupGetGreaterMask(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniform);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplSubgroupGetGreaterMask"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::SubgroupGtMask);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}

SPIRVResult SPIRV_SubgroupGetFirstActiveThread(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniform);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformElect, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupBroadcastFirstActiveThread_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBroadcastFirst, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupBroadcastFirstActiveThread_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBroadcastFirst, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupBroadcastFirstActiveThread_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBroadcastFirst, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupBroadcastFirstActiveThread_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBroadcastFirst, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupBroadcastFirstActiveThread_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBroadcastFirst, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupBroadcastFirstActiveThread_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBroadcastFirst, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupBroadcastFirstActiveThread_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBroadcastFirst, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupBroadcastFirstActiveThread_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBroadcastFirst, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupBroadcastFirstActiveThread_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBroadcastFirst, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupBroadcastFirstActiveThread_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBroadcastFirst, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupBroadcastFirstActiveThread_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBroadcastFirst, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupBroadcastFirstActiveThread_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBroadcastFirst, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupBroadcastFirstActiveThread_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBroadcastFirst, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupBroadcastFirstActiveThread_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBroadcastFirst, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupBroadcastFirstActiveThread_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBroadcastFirst, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupBroadcastFirstActiveThread_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBroadcastFirst, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupBroadcastFirstActiveThread_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBroadcastFirst, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupBroadcastFirstActiveThread_UInt32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBroadcastFirst, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupBroadcastFirstActiveThread_UInt32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBroadcastFirst, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupBroadcastFirstActiveThread_UInt32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBroadcastFirst, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupBroadcastFirstActiveThread_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBroadcastFirst, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupBroadcastFirstActiveThread_UInt16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBroadcastFirst, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupBroadcastFirstActiveThread_UInt16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBroadcastFirst, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupBroadcastFirstActiveThread_UInt16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBroadcastFirst, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupBallot(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallot, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupInverseBallot(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformInverseBallot, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupBallotBitCount(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitCount, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, 0, loaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupBallotFirstOne(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotFindLSB, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupBallotLastOne(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotFindMSB, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupBallotBit(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult bit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, bit);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapDiagonal_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapDiagonal_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapDiagonal_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapDiagonal_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapDiagonal_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapDiagonal_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapDiagonal_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapDiagonal_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapDiagonal_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapDiagonal_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapDiagonal_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapDiagonal_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapDiagonal_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapDiagonal_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapDiagonal_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapDiagonal_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapDiagonal_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapDiagonal_UInt32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapDiagonal_UInt32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapDiagonal_UInt32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapDiagonal_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapDiagonal_UInt16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapDiagonal_UInt16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapDiagonal_UInt16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapVertical_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapVertical_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapVertical_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapVertical_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapVertical_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapVertical_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapVertical_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapVertical_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapVertical_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapVertical_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapVertical_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapVertical_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapVertical_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapVertical_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapVertical_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapVertical_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapVertical_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapVertical_UInt32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapVertical_UInt32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapVertical_UInt32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapVertical_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapVertical_UInt16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapVertical_UInt16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapVertical_UInt16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapHorizontal_Float32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapHorizontal_Float32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapHorizontal_Float32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapHorizontal_Float32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapHorizontal_Float16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapHorizontal_Float16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapHorizontal_Float16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapHorizontal_Float16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapHorizontal_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapHorizontal_Int32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapHorizontal_Int32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapHorizontal_Int32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapHorizontal_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapHorizontal_Int16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapHorizontal_Int16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapHorizontal_Int16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapHorizontal_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapHorizontal_UInt32x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapHorizontal_UInt32x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapHorizontal_UInt32x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapHorizontal_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapHorizontal_UInt16x2(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapHorizontal_UInt16x3(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SubgroupSwapHorizontal_UInt16x4(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformQuadSwap, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicLoad_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[1].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicLoad, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicIncrement_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[1].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIIncrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicDecrement_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[1].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicLoad_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[1].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicLoad, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicIncrement_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[1].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIIncrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicDecrement_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[1].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicLoad_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[1].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicLoad, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicIncrement_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[1].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIIncrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicDecrement_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[1].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicLoad_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[1].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicLoad, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicIncrement_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[1].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIIncrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicDecrement_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[1].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicStore_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicExchange_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicAdd_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicSubtract_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicAnd_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicOr_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicXor_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicStore_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicExchange_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicAdd_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicSubtract_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicAnd_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicOr_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicXor_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicStore_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicExchange_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicAdd_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicSubtract_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicAnd_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicOr_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicXor_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicStore_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicExchange_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicAdd_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicSubtract_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicAnd_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicOr_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicXor_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicCompareExchange_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[3].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult value = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, semanticsId, value, compare);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicCompareExchange_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[3].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult value = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, semanticsId, value, compare);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicCompareExchange_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[3].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult value = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, semanticsId, value, compare);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_AtomicCompareExchange_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    uint32_t scope = ScopeToAtomicScope(args[0].scope);
    uint32_t semantics = SemanticsTable[args[3].literalValue.ui];
    semantics |= ScopeToMemorySemantics(args[0].scope);
    SPIRVResult value = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));
    uint32_t ret = g->writer->MappedInstruction(OpAtomicIDecrement, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, semanticsId, value, compare);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_BitInsert_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult value = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult offset = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult count = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpBitFieldInsert, SPVWriter::Section::LocalFunction, returnType, base, value, offset, count);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_BitInsert_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult value = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult offset = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult count = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpBitFieldInsert, SPVWriter::Section::LocalFunction, returnType, base, value, offset, count);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_BitExtract_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult offset = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult count = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpBitFieldUExtract, SPVWriter::Section::LocalFunction, returnType, base, offset, count);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_BitExtract_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult offset = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult count = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpBitFieldSExtract, SPVWriter::Section::LocalFunction, returnType, base, offset, count);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_BitExtract_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult offset = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult count = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpBitFieldUExtract, SPVWriter::Section::LocalFunction, returnType, base, offset, count);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_BitExtract_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult offset = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult count = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpBitFieldSExtract, SPVWriter::Section::LocalFunction, returnType, base, offset, count);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_BitReverse_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    g->writer->Capability(Capabilities::BitInstructions);
    uint32_t ret = g->writer->MappedInstruction(OpBitReverse, SPVWriter::Section::LocalFunction, returnType, base);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_BitReverse_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    g->writer->Capability(Capabilities::BitInstructions);
    uint32_t ret = g->writer->MappedInstruction(OpBitReverse, SPVWriter::Section::LocalFunction, returnType, base);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_BitReverse_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    g->writer->Capability(Capabilities::BitInstructions);
    uint32_t ret = g->writer->MappedInstruction(OpBitReverse, SPVWriter::Section::LocalFunction, returnType, base);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_BitReverse_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    g->writer->Capability(Capabilities::BitInstructions);
    uint32_t ret = g->writer->MappedInstruction(OpBitReverse, SPVWriter::Section::LocalFunction, returnType, base);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_BitCount_UInt32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitCount, SPVWriter::Section::LocalFunction, returnType, base);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_BitCount_Int32(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitCount, SPVWriter::Section::LocalFunction, returnType, base);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_BitCount_UInt16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitCount, SPVWriter::Section::LocalFunction, returnType, base);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_BitCount_Int16(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitCount, SPVWriter::Section::LocalFunction, returnType, base);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_ExecutionBarrier(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(2));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(0x2 | 0x40 | 0x80 | 0x100 | 0x200 | 0x400 | 0x800));
    g->writer->Instruction(OpControlBarrier, SPVWriter::Section::LocalFunction, scopeId, scopeId, semanticsId);
    return SPIRVResult(0xFFFFFFFF, returnType);
}

SPIRVResult SPIRV_ExecutionBarrierSubgroup(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(3));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(0x2 | 0x80));
    g->writer->Instruction(OpControlBarrier, SPVWriter::Section::LocalFunction, scopeId, scopeId, semanticsId);
    return SPIRVResult(0xFFFFFFFF, returnType);
}

SPIRVResult SPIRV_ExecutionBarrierWorkgroup(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(2));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(0x2 | 0x100));
    g->writer->Instruction(OpControlBarrier, SPVWriter::Section::LocalFunction, scopeId, scopeId, semanticsId);
    return SPIRVResult(0xFFFFFFFF, returnType);
}

SPIRVResult SPIRV_MemoryBarrier(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(2));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(0x2 | 0x40 | 0x80 | 0x100 | 0x200 | 0x400 | 0x800));
    g->writer->Instruction(OpMemoryBarrier, SPVWriter::Section::LocalFunction, scopeId, scopeId, semanticsId);
    return SPIRVResult(0xFFFFFFFF, returnType);
}

SPIRVResult SPIRV_MemoryBarrierBuffer(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(2));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(0x2 | 0x40));
    g->writer->Instruction(OpMemoryBarrier, SPVWriter::Section::LocalFunction, scopeId, scopeId, semanticsId);
    return SPIRVResult(0xFFFFFFFF, returnType);
}

SPIRVResult SPIRV_MemoryBarrierTexture(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(2));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(0x2 | 0x800));
    g->writer->Instruction(OpMemoryBarrier, SPVWriter::Section::LocalFunction, scopeId, scopeId, semanticsId);
    return SPIRVResult(0xFFFFFFFF, returnType);
}

SPIRVResult SPIRV_MemoryBarrierAtomic(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(2));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(0x2 | 0x400));
    g->writer->Instruction(OpMemoryBarrier, SPVWriter::Section::LocalFunction, scopeId, scopeId, semanticsId);
    return SPIRVResult(0xFFFFFFFF, returnType);
}

SPIRVResult SPIRV_MemoryBarrierSubgroup(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(3));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(0x2 | 0x80));
    g->writer->Instruction(OpMemoryBarrier, SPVWriter::Section::LocalFunction, scopeId, scopeId, semanticsId);
    return SPIRVResult(0xFFFFFFFF, returnType);
}

SPIRVResult SPIRV_MemoryBarrierWorkgroup(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(2));
    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(0x2 | 0x100));
    g->writer->Instruction(OpMemoryBarrier, SPVWriter::Section::LocalFunction, scopeId, scopeId, semanticsId);
    return SPIRVResult(0xFFFFFFFF, returnType);
}

SPIRVResult SPIRV_TextureGetSize_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySize, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureGetSize_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySize, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureGetSize_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySize, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureGetSize_TextureCube(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySize, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureGetSize_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySize, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureGetSize_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySize, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureGetSize_TextureCubeArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySize, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureGetSizeMip_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySizeLod, SPVWriter::Section::LocalFunction, returnType, texture, mip);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureGetSizeMip_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySizeLod, SPVWriter::Section::LocalFunction, returnType, texture, mip);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureGetSizeMip_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySizeLod, SPVWriter::Section::LocalFunction, returnType, texture, mip);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureGetSizeMip_TextureCube(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySizeLod, SPVWriter::Section::LocalFunction, returnType, texture, mip);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureGetSizeMip_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySizeLod, SPVWriter::Section::LocalFunction, returnType, texture, mip);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureGetSizeMip_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySizeLod, SPVWriter::Section::LocalFunction, returnType, texture, mip);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureGetSizeMip_TextureCubeArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySizeLod, SPVWriter::Section::LocalFunction, returnType, texture, mip);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureGetMips_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLevels, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureGetMips_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLevels, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureGetMips_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLevels, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureGetMips_TextureCube(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLevels, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureGetMips_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLevels, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureGetMips_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLevels, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureGetMips_TextureCubeArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLevels, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureGetSamples_Texture2DMS(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureGetSamples_Texture2DMSArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureGetSampledMip_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureGetSampledMip_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureGetSampledMip_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureGetSampledMip_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureGetSampledMip_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureGetSampledMip_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureGetSampledMip_TextureCube(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureGetSampledMip_TextureCube(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureGetSampledMip_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureGetSampledMip_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureGetSampledMip_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureGetSampledMip_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureGetSampledMip_TextureCubeArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureGetSampledMip_TextureCubeArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureLoad_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageRead, SPVWriter::Section::LocalFunction, returnType, texture, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureLoadMip_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageRead, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureStore_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult value = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = 0xFFFFFFFF;
    g->writer->Instruction(OpImageWrite, SPVWriter::Section::LocalFunction, texture, coord, value);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureStoreMip_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult value = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = 0xFFFFFFFF;
    g->writer->Instruction(OpImageWrite, SPVWriter::Section::LocalFunction, texture, coord, value, ImageOperands::Lod, mip);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureLoad_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageRead, SPVWriter::Section::LocalFunction, returnType, texture, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureLoadMip_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageRead, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureStore_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult value = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = 0xFFFFFFFF;
    g->writer->Instruction(OpImageWrite, SPVWriter::Section::LocalFunction, texture, coord, value);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureStoreMip_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult value = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = 0xFFFFFFFF;
    g->writer->Instruction(OpImageWrite, SPVWriter::Section::LocalFunction, texture, coord, value, ImageOperands::Lod, mip);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureLoad_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageRead, SPVWriter::Section::LocalFunction, returnType, texture, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureLoadMip_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageRead, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureStore_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult value = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = 0xFFFFFFFF;
    g->writer->Instruction(OpImageWrite, SPVWriter::Section::LocalFunction, texture, coord, value);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureStoreMip_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult value = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = 0xFFFFFFFF;
    g->writer->Instruction(OpImageWrite, SPVWriter::Section::LocalFunction, texture, coord, value, ImageOperands::Lod, mip);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureLoad_TextureCube(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageRead, SPVWriter::Section::LocalFunction, returnType, texture, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureLoadMip_TextureCube(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageRead, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureStore_TextureCube(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult value = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = 0xFFFFFFFF;
    g->writer->Instruction(OpImageWrite, SPVWriter::Section::LocalFunction, texture, coord, value);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureStoreMip_TextureCube(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult value = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = 0xFFFFFFFF;
    g->writer->Instruction(OpImageWrite, SPVWriter::Section::LocalFunction, texture, coord, value, ImageOperands::Lod, mip);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureLoad_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageRead, SPVWriter::Section::LocalFunction, returnType, texture, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureLoadMip_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageRead, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureStore_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult value = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = 0xFFFFFFFF;
    g->writer->Instruction(OpImageWrite, SPVWriter::Section::LocalFunction, texture, coord, value);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureStoreMip_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult value = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = 0xFFFFFFFF;
    g->writer->Instruction(OpImageWrite, SPVWriter::Section::LocalFunction, texture, coord, value, ImageOperands::Lod, mip);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureLoad_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageRead, SPVWriter::Section::LocalFunction, returnType, texture, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureLoadMip_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageRead, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureStore_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult value = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = 0xFFFFFFFF;
    g->writer->Instruction(OpImageWrite, SPVWriter::Section::LocalFunction, texture, coord, value);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureStoreMip_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult value = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = 0xFFFFFFFF;
    g->writer->Instruction(OpImageWrite, SPVWriter::Section::LocalFunction, texture, coord, value, ImageOperands::Lod, mip);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureLoad_TextureCubeArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageRead, SPVWriter::Section::LocalFunction, returnType, texture, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureLoadMip_TextureCubeArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageRead, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureStore_TextureCubeArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult value = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = 0xFFFFFFFF;
    g->writer->Instruction(OpImageWrite, SPVWriter::Section::LocalFunction, texture, coord, value);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureStoreMip_TextureCubeArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult value = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = 0xFFFFFFFF;
    g->writer->Instruction(OpImageWrite, SPVWriter::Section::LocalFunction, texture, coord, value, ImageOperands::Lod, mip);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureLoad_Texture2DMS(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageRead, SPVWriter::Section::LocalFunction, returnType, texture, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureLoadMip_Texture2DMS(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageRead, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureStore_Texture2DMS(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult value = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = 0xFFFFFFFF;
    g->writer->Instruction(OpImageWrite, SPVWriter::Section::LocalFunction, texture, coord, value);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureStoreMip_Texture2DMS(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult value = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = 0xFFFFFFFF;
    g->writer->Instruction(OpImageWrite, SPVWriter::Section::LocalFunction, texture, coord, value, ImageOperands::Lod, mip);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureLoad_Texture2DMSArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageRead, SPVWriter::Section::LocalFunction, returnType, texture, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureLoadMip_Texture2DMSArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageRead, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureStore_Texture2DMSArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult value = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = 0xFFFFFFFF;
    g->writer->Instruction(OpImageWrite, SPVWriter::Section::LocalFunction, texture, coord, value);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureStoreMip_Texture2DMSArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult value = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = 0xFFFFFFFF;
    g->writer->Instruction(OpImageWrite, SPVWriter::Section::LocalFunction, texture, coord, value, ImageOperands::Lod, mip);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureFetch_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureFetchSample_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult sample = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip, ImageOperands::Sample, sample);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureFetch_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureFetchSample_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult sample = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip, ImageOperands::Sample, sample);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureFetch_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureFetchSample_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult sample = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip, ImageOperands::Sample, sample);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureFetch_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureFetchSample_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult sample = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip, ImageOperands::Sample, sample);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureFetch_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureFetchSample_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult sample = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip, ImageOperands::Sample, sample);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureFetch_Texture2DMS(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureFetchSample_Texture2DMS(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult sample = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip, ImageOperands::Sample, sample);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureFetch_Texture2DMSArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureFetchSample_Texture2DMSArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult sample = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip, ImageOperands::Sample, sample);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureGather_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult component = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, component);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureGather_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult component = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, component);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureGatherOffset_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult component = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult offset = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, component, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureGatherOffset_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult component = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult offset = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, component, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureGather_TextureCube(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult component = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, component);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureGather_TextureCube(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult component = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, component);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureGatherOffset_TextureCube(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult component = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult offset = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, component, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureGatherOffset_TextureCube(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult component = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult offset = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, component, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureGather_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult component = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, component);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureGather_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult component = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, component);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureGatherOffset_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult component = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult offset = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, component, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureGatherOffset_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult component = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult offset = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, component, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureGather_TextureCubeArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult component = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, component);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureGather_TextureCubeArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult component = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, component);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureGatherOffset_TextureCubeArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult component = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult offset = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, component, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureGatherOffset_TextureCubeArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult component = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult offset = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, component, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSample_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSample_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSample_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSample_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSample_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSample_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSample_TextureCube(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSample_TextureCube(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSample_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSample_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSample_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSample_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSample_TextureCubeArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSample_TextureCubeArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleOffset_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleOffset_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleOffset_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleOffset_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleOffset_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleOffset_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleOffset_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleOffset_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleOffset_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleOffset_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleProj_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleProj_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleProj_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleProj_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleProj_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleProj_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleProjOffset_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleProjOffset_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleProjOffset_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleProjOffset_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleProjOffset_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleProjOffset_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleCompare_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleCompare_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleCompare_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleCompare_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleCompare_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleCompare_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleCompare_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleCompare_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleCompare_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleCompare_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleCompareOffset_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleCompareOffset_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleCompareOffset_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleCompareOffset_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleCompareOffset_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleCompareOffset_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleCompareOffset_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleCompareOffset_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleCompareOffset_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleCompareOffset_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleProjCompare_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleProjCompare_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleProjCompare_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleProjCompare_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleProjCompare_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleProjCompare_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleProjCompareOffset_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleProjCompareOffset_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleProjCompareOffset_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleProjCompareOffset_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleProjCompareOffset_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleProjCompareOffset_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleLod_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleLod_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleLod_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleLod_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleLod_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleLod_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleLod_TextureCube(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleLod_TextureCube(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleLod_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleLod_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleLod_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleLod_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleLod_TextureCubeArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleLod_TextureCubeArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleLodOffset_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleLodOffset_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleLodOffset_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleLodOffset_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleLodOffset_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleLodOffset_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleLodOffset_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleLodOffset_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleLodOffset_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleLodOffset_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleLodProj_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleLodProj_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleLodProj_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleLodProj_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleLodProj_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleLodProj_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleLodProjOffset_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleLodProjOffset_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleLodProjOffset_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleLodProjOffset_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleLodProjOffset_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleLodProjOffset_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleLodCompare_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleLodCompare_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleLodCompare_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleLodCompare_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleLodCompare_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleLodCompare_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleLodCompare_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleLodCompare_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleLodCompare_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleLodCompare_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleLodCompareOffset_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleLodCompareOffset_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleLodCompareOffset_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleLodCompareOffset_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleLodCompareOffset_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleLodCompareOffset_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleLodCompareOffset_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleLodCompareOffset_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleLodCompareOffset_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleLodCompareOffset_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleLodProjCompare_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[5]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleLodProjCompare_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleLodProjCompare_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[5]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleLodProjCompare_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleLodProjCompare_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[5]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleLodProjCompare_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleLodProjCompareOffset_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[5]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleLodProjCompareOffset_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleLodProjCompareOffset_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[5]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleLodProjCompareOffset_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleLodProjCompareOffset_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[5]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleLodProjCompareOffset_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult lod = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Lod, lod, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleGrad_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Grad, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleGrad_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Grad, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleGrad_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Grad, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleGrad_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Grad, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleGrad_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Grad, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleGrad_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Grad, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleGrad_TextureCube(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Grad, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleGrad_TextureCube(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Grad, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleGrad_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Grad, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleGrad_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Grad, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleGrad_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Grad, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleGrad_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Grad, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleGrad_TextureCubeArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Grad, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleGrad_TextureCubeArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Grad, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleGradOffset_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Grad, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleGradOffset_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Grad, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleGradOffset_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Grad, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleGradOffset_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Grad, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleGradOffset_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Grad, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleGradOffset_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Grad, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleGradOffset_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Grad, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleGradOffset_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Grad, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleGradOffset_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Grad, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleGradOffset_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Grad, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleGradProj_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Grad, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleGradProj_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Grad, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleGradProj_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Grad, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleGradProj_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Grad, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleGradProj_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Grad, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleGradProj_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Grad, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleGradProjOffset_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Grad, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleGradProjOffset_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Grad, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleGradProjOffset_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Grad, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleGradProjOffset_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Grad, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleGradProjOffset_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Grad, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleGradProjOffset_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Grad, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleGradCompare_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Grad, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleGradCompare_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Grad, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleGradCompare_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Grad, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleGradCompare_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Grad, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleGradCompare_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Grad, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleGradCompare_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Grad, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleGradCompare_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Grad, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleGradCompare_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Grad, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleGradCompare_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Grad, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleGradCompare_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Grad, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleGradCompareOffset_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Grad, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleGradCompareOffset_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Grad, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleGradCompareOffset_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Grad, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleGradCompareOffset_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Grad, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleGradCompareOffset_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Grad, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleGradCompareOffset_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Grad, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleGradCompareOffset_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Grad, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleGradCompareOffset_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Grad, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleGradCompareOffset_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Grad, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleGradCompareOffset_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Grad, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleGradProjCompare_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[5]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[6]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Grad, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleGradProjCompare_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Grad, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleGradProjCompare_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[5]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[6]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Grad, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleGradProjCompare_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Grad, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleGradProjCompare_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[5]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[6]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Grad, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleGradProjCompare_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Grad, gradX, gradY);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleGradProjCompareOffset_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[5]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[6]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Grad, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleGradProjCompareOffset_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Grad, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleGradProjCompareOffset_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[5]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[6]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Grad, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleGradProjCompareOffset_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Grad, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleGradProjCompareOffset_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[5]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[6]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Grad, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleGradProjCompareOffset_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult gradX = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult gradY = LoadValueSPIRV(c, g, args[5]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefExplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Grad, gradX, gradY, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleBias_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleBias_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleBias_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleBias_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleBias_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleBias_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleBias_TextureCube(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleBias_TextureCube(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleBias_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleBias_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleBias_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleBias_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleBias_TextureCubeArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleBias_TextureCubeArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleBiasOffset_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleBiasOffset_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleBiasOffset_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleBiasOffset_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleBiasOffset_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleBiasOffset_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleBiasOffset_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleBiasOffset_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleBiasOffset_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleBiasOffset_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[2]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleBiasProj_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleBiasProj_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleBiasProj_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleBiasProj_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleBiasProj_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleBiasProj_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleBiasProjOffset_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleBiasProjOffset_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleBiasProjOffset_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleBiasProjOffset_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleBiasProjOffset_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleBiasProjOffset_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleBiasCompare_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleBiasCompare_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleBiasCompare_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleBiasCompare_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleBiasCompare_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleBiasCompare_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleBiasCompare_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleBiasCompare_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleBiasCompare_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleBiasCompare_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleBiasCompareOffset_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleBiasCompareOffset_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleBiasCompareOffset_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleBiasCompareOffset_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleBiasCompareOffset_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleBiasCompareOffset_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleBiasCompareOffset_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleBiasCompareOffset_Texture1DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleBiasCompareOffset_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleBiasCompareOffset_Texture2DArray(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[3]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleBiasProjCompare_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[5]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleBiasProjCompare_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleBiasProjCompare_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[5]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleBiasProjCompare_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleBiasProjCompare_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[5]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleBiasProjCompare_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleBiasProjCompareOffset_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[5]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleBiasProjCompareOffset_Texture1D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 2);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleBiasProjCompareOffset_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[5]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleBiasProjCompareOffset_Texture2D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 3);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_TextureSampleBiasProjCompareOffset_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[3]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[4]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[5]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

SPIRVResult SPIRV_SampledTextureSampleBiasProjCompareOffset_Texture3D(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)
{
    g->writer->Capability(Capabilities::Shader);
    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult proj = LoadValueSPIRV(c, g, args[2]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    coord = GenerateCompositeSPIRV(c, g, vectorType, { coord, proj });
    SPIRVResult compare = LoadValueSPIRV(c, g, args[3]);
    SPIRVResult bias = LoadValueSPIRV(c, g, args[4]);
    g->writer->Capability(Capabilities::ImageQuery);
    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);
    uint32_t ret = g->writer->MappedInstruction(OpImageSampleProjDrefImplicitLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, compare, ImageOperands::Bias, bias, ImageOperands::Offset, offset);
    return SPIRVResult(ret, returnType, true);
}

const StaticMap SPIRVDefaultIntrinsics = std::array{
    std::pair{ &Float32_from_UInt32, &SPIRV_Float32_from_UInt32 },
    std::pair{ &Float32_from_Int32, &SPIRV_Float32_from_Int32 },
    std::pair{ &Float32_from_Bool8, &SPIRV_Float32_from_Bool8 },
    std::pair{ &Float32_from_Float16, &SPIRV_Float32_from_Float16 },
    std::pair{ &Float32_from_UInt16, &SPIRV_Float32_from_UInt16 },
    std::pair{ &Float32_from_Int16, &SPIRV_Float32_from_Int16 },
    std::pair{ &Float32_ctor0, &SPIRV_Float32_ctor0 },
    std::pair{ &Float32_operator_index_Int32, &SPIRV_Float32_operator_index_Int32 },
    std::pair{ &Float32_operator_index_UInt32, &SPIRV_Float32_operator_index_UInt32 },
    std::pair{ &Float32_operator_index_Int16, &SPIRV_Float32_operator_index_Int16 },
    std::pair{ &Float32_operator_index_UInt16, &SPIRV_Float32_operator_index_UInt16 },
    std::pair{ &Float32_operator_add_Float32, &SPIRV_Float32_operator_add_Float32 },
    std::pair{ &Float32_operator_sub_Float32, &SPIRV_Float32_operator_sub_Float32 },
    std::pair{ &Float32_operator_mul_Float32, &SPIRV_Float32_operator_mul_Float32 },
    std::pair{ &Float32_operator_div_Float32, &SPIRV_Float32_operator_div_Float32 },
    std::pair{ &Float32_operator_mod_Float32, &SPIRV_Float32_operator_mod_Float32 },
    std::pair{ &Float32_operator_addasg_Float32, &SPIRV_Float32_operator_addasg_Float32 },
    std::pair{ &Float32_operator_subasg_Float32, &SPIRV_Float32_operator_subasg_Float32 },
    std::pair{ &Float32_operator_mulasg_Float32, &SPIRV_Float32_operator_mulasg_Float32 },
    std::pair{ &Float32_operator_divasg_Float32, &SPIRV_Float32_operator_divasg_Float32 },
    std::pair{ &Float32_operator_lt_Float32, &SPIRV_Float32_operator_lt_Float32 },
    std::pair{ &Float32_operator_lte_Float32, &SPIRV_Float32_operator_lte_Float32 },
    std::pair{ &Float32_operator_gt_Float32, &SPIRV_Float32_operator_gt_Float32 },
    std::pair{ &Float32_operator_gte_Float32, &SPIRV_Float32_operator_gte_Float32 },
    std::pair{ &Float32_operator_eq_Float32, &SPIRV_Float32_operator_eq_Float32 },
    std::pair{ &Float32_operator_neq_Float32, &SPIRV_Float32_operator_neq_Float32 },
    std::pair{ &UInt32_from_Float32, &SPIRV_UInt32_from_Float32 },
    std::pair{ &UInt32_from_Int32, &SPIRV_UInt32_from_Int32 },
    std::pair{ &UInt32_from_Bool8, &SPIRV_UInt32_from_Bool8 },
    std::pair{ &UInt32_from_Float16, &SPIRV_UInt32_from_Float16 },
    std::pair{ &UInt32_from_UInt16, &SPIRV_UInt32_from_UInt16 },
    std::pair{ &UInt32_from_Int16, &SPIRV_UInt32_from_Int16 },
    std::pair{ &UInt32_ctor0, &SPIRV_UInt32_ctor0 },
    std::pair{ &UInt32_operator_index_Int32, &SPIRV_UInt32_operator_index_Int32 },
    std::pair{ &UInt32_operator_index_UInt32, &SPIRV_UInt32_operator_index_UInt32 },
    std::pair{ &UInt32_operator_index_Int16, &SPIRV_UInt32_operator_index_Int16 },
    std::pair{ &UInt32_operator_index_UInt16, &SPIRV_UInt32_operator_index_UInt16 },
    std::pair{ &UInt32_operator_add_UInt32, &SPIRV_UInt32_operator_add_UInt32 },
    std::pair{ &UInt32_operator_sub_UInt32, &SPIRV_UInt32_operator_sub_UInt32 },
    std::pair{ &UInt32_operator_mul_UInt32, &SPIRV_UInt32_operator_mul_UInt32 },
    std::pair{ &UInt32_operator_div_UInt32, &SPIRV_UInt32_operator_div_UInt32 },
    std::pair{ &UInt32_operator_mod_UInt32, &SPIRV_UInt32_operator_mod_UInt32 },
    std::pair{ &UInt32_operator_addasg_UInt32, &SPIRV_UInt32_operator_addasg_UInt32 },
    std::pair{ &UInt32_operator_subasg_UInt32, &SPIRV_UInt32_operator_subasg_UInt32 },
    std::pair{ &UInt32_operator_mulasg_UInt32, &SPIRV_UInt32_operator_mulasg_UInt32 },
    std::pair{ &UInt32_operator_divasg_UInt32, &SPIRV_UInt32_operator_divasg_UInt32 },
    std::pair{ &UInt32_operator_lt_UInt32, &SPIRV_UInt32_operator_lt_UInt32 },
    std::pair{ &UInt32_operator_lte_UInt32, &SPIRV_UInt32_operator_lte_UInt32 },
    std::pair{ &UInt32_operator_gt_UInt32, &SPIRV_UInt32_operator_gt_UInt32 },
    std::pair{ &UInt32_operator_gte_UInt32, &SPIRV_UInt32_operator_gte_UInt32 },
    std::pair{ &UInt32_operator_eq_UInt32, &SPIRV_UInt32_operator_eq_UInt32 },
    std::pair{ &UInt32_operator_neq_UInt32, &SPIRV_UInt32_operator_neq_UInt32 },
    std::pair{ &UInt32_operator_or_UInt32, &SPIRV_UInt32_operator_or_UInt32 },
    std::pair{ &UInt32_operator_and_UInt32, &SPIRV_UInt32_operator_and_UInt32 },
    std::pair{ &UInt32_operator_xor_UInt32, &SPIRV_UInt32_operator_xor_UInt32 },
    std::pair{ &UInt32_operator_lsh_UInt32, &SPIRV_UInt32_operator_lsh_UInt32 },
    std::pair{ &UInt32_operator_rsh_UInt32, &SPIRV_UInt32_operator_rsh_UInt32 },
    std::pair{ &UInt32_operator_orasg_UInt32, &SPIRV_UInt32_operator_orasg_UInt32 },
    std::pair{ &UInt32_operator_andasg_UInt32, &SPIRV_UInt32_operator_andasg_UInt32 },
    std::pair{ &UInt32_operator_xorasg_UInt32, &SPIRV_UInt32_operator_xorasg_UInt32 },
    std::pair{ &UInt32_operator_lshasg_UInt32, &SPIRV_UInt32_operator_lshasg_UInt32 },
    std::pair{ &UInt32_operator_rhsasg_UInt32, &SPIRV_UInt32_operator_rhsasg_UInt32 },
    std::pair{ &Int32_from_Float32, &SPIRV_Int32_from_Float32 },
    std::pair{ &Int32_from_UInt32, &SPIRV_Int32_from_UInt32 },
    std::pair{ &Int32_from_Bool8, &SPIRV_Int32_from_Bool8 },
    std::pair{ &Int32_from_Float16, &SPIRV_Int32_from_Float16 },
    std::pair{ &Int32_from_UInt16, &SPIRV_Int32_from_UInt16 },
    std::pair{ &Int32_from_Int16, &SPIRV_Int32_from_Int16 },
    std::pair{ &Int32_ctor0, &SPIRV_Int32_ctor0 },
    std::pair{ &Int32_operator_index_Int32, &SPIRV_Int32_operator_index_Int32 },
    std::pair{ &Int32_operator_index_UInt32, &SPIRV_Int32_operator_index_UInt32 },
    std::pair{ &Int32_operator_index_Int16, &SPIRV_Int32_operator_index_Int16 },
    std::pair{ &Int32_operator_index_UInt16, &SPIRV_Int32_operator_index_UInt16 },
    std::pair{ &Int32_operator_add_Int32, &SPIRV_Int32_operator_add_Int32 },
    std::pair{ &Int32_operator_sub_Int32, &SPIRV_Int32_operator_sub_Int32 },
    std::pair{ &Int32_operator_mul_Int32, &SPIRV_Int32_operator_mul_Int32 },
    std::pair{ &Int32_operator_div_Int32, &SPIRV_Int32_operator_div_Int32 },
    std::pair{ &Int32_operator_mod_Int32, &SPIRV_Int32_operator_mod_Int32 },
    std::pair{ &Int32_operator_addasg_Int32, &SPIRV_Int32_operator_addasg_Int32 },
    std::pair{ &Int32_operator_subasg_Int32, &SPIRV_Int32_operator_subasg_Int32 },
    std::pair{ &Int32_operator_mulasg_Int32, &SPIRV_Int32_operator_mulasg_Int32 },
    std::pair{ &Int32_operator_divasg_Int32, &SPIRV_Int32_operator_divasg_Int32 },
    std::pair{ &Int32_operator_lt_Int32, &SPIRV_Int32_operator_lt_Int32 },
    std::pair{ &Int32_operator_lte_Int32, &SPIRV_Int32_operator_lte_Int32 },
    std::pair{ &Int32_operator_gt_Int32, &SPIRV_Int32_operator_gt_Int32 },
    std::pair{ &Int32_operator_gte_Int32, &SPIRV_Int32_operator_gte_Int32 },
    std::pair{ &Int32_operator_eq_Int32, &SPIRV_Int32_operator_eq_Int32 },
    std::pair{ &Int32_operator_neq_Int32, &SPIRV_Int32_operator_neq_Int32 },
    std::pair{ &Int32_operator_or_Int32, &SPIRV_Int32_operator_or_Int32 },
    std::pair{ &Int32_operator_and_Int32, &SPIRV_Int32_operator_and_Int32 },
    std::pair{ &Int32_operator_xor_Int32, &SPIRV_Int32_operator_xor_Int32 },
    std::pair{ &Int32_operator_lsh_Int32, &SPIRV_Int32_operator_lsh_Int32 },
    std::pair{ &Int32_operator_rsh_Int32, &SPIRV_Int32_operator_rsh_Int32 },
    std::pair{ &Int32_operator_orasg_Int32, &SPIRV_Int32_operator_orasg_Int32 },
    std::pair{ &Int32_operator_andasg_Int32, &SPIRV_Int32_operator_andasg_Int32 },
    std::pair{ &Int32_operator_xorasg_Int32, &SPIRV_Int32_operator_xorasg_Int32 },
    std::pair{ &Int32_operator_lshasg_Int32, &SPIRV_Int32_operator_lshasg_Int32 },
    std::pair{ &Int32_operator_rhsasg_Int32, &SPIRV_Int32_operator_rhsasg_Int32 },
    std::pair{ &Bool8_from_UInt32, &SPIRV_Bool8_from_UInt32 },
    std::pair{ &Bool8_from_Int32, &SPIRV_Bool8_from_Int32 },
    std::pair{ &Bool8_from_UInt16, &SPIRV_Bool8_from_UInt16 },
    std::pair{ &Bool8_from_Int16, &SPIRV_Bool8_from_Int16 },
    std::pair{ &Bool8_ctor0, &SPIRV_Bool8_ctor0 },
    std::pair{ &Bool8_operator_index_Int32, &SPIRV_Bool8_operator_index_Int32 },
    std::pair{ &Bool8_operator_index_UInt32, &SPIRV_Bool8_operator_index_UInt32 },
    std::pair{ &Bool8_operator_index_Int16, &SPIRV_Bool8_operator_index_Int16 },
    std::pair{ &Bool8_operator_index_UInt16, &SPIRV_Bool8_operator_index_UInt16 },
    std::pair{ &Bool8_operator_oror_Bool8, &SPIRV_Bool8_operator_oror_Bool8 },
    std::pair{ &Bool8_operator_andand_Bool8, &SPIRV_Bool8_operator_andand_Bool8 },
    std::pair{ &Bool8_operator_eq_Bool8, &SPIRV_Bool8_operator_eq_Bool8 },
    std::pair{ &Bool8_operator_neq_Bool8, &SPIRV_Bool8_operator_neq_Bool8 },
    std::pair{ &Float16_from_Float32, &SPIRV_Float16_from_Float32 },
    std::pair{ &Float16_from_UInt32, &SPIRV_Float16_from_UInt32 },
    std::pair{ &Float16_from_Int32, &SPIRV_Float16_from_Int32 },
    std::pair{ &Float16_from_Bool8, &SPIRV_Float16_from_Bool8 },
    std::pair{ &Float16_from_UInt16, &SPIRV_Float16_from_UInt16 },
    std::pair{ &Float16_from_Int16, &SPIRV_Float16_from_Int16 },
    std::pair{ &Float16_ctor0, &SPIRV_Float16_ctor0 },
    std::pair{ &Float16_operator_index_Int32, &SPIRV_Float16_operator_index_Int32 },
    std::pair{ &Float16_operator_index_UInt32, &SPIRV_Float16_operator_index_UInt32 },
    std::pair{ &Float16_operator_index_Int16, &SPIRV_Float16_operator_index_Int16 },
    std::pair{ &Float16_operator_index_UInt16, &SPIRV_Float16_operator_index_UInt16 },
    std::pair{ &Float16_operator_add_Float16, &SPIRV_Float16_operator_add_Float16 },
    std::pair{ &Float16_operator_sub_Float16, &SPIRV_Float16_operator_sub_Float16 },
    std::pair{ &Float16_operator_mul_Float16, &SPIRV_Float16_operator_mul_Float16 },
    std::pair{ &Float16_operator_div_Float16, &SPIRV_Float16_operator_div_Float16 },
    std::pair{ &Float16_operator_mod_Float16, &SPIRV_Float16_operator_mod_Float16 },
    std::pair{ &Float16_operator_addasg_Float16, &SPIRV_Float16_operator_addasg_Float16 },
    std::pair{ &Float16_operator_subasg_Float16, &SPIRV_Float16_operator_subasg_Float16 },
    std::pair{ &Float16_operator_mulasg_Float16, &SPIRV_Float16_operator_mulasg_Float16 },
    std::pair{ &Float16_operator_divasg_Float16, &SPIRV_Float16_operator_divasg_Float16 },
    std::pair{ &Float16_operator_lt_Float16, &SPIRV_Float16_operator_lt_Float16 },
    std::pair{ &Float16_operator_lte_Float16, &SPIRV_Float16_operator_lte_Float16 },
    std::pair{ &Float16_operator_gt_Float16, &SPIRV_Float16_operator_gt_Float16 },
    std::pair{ &Float16_operator_gte_Float16, &SPIRV_Float16_operator_gte_Float16 },
    std::pair{ &Float16_operator_eq_Float16, &SPIRV_Float16_operator_eq_Float16 },
    std::pair{ &Float16_operator_neq_Float16, &SPIRV_Float16_operator_neq_Float16 },
    std::pair{ &UInt16_from_Float32, &SPIRV_UInt16_from_Float32 },
    std::pair{ &UInt16_from_UInt32, &SPIRV_UInt16_from_UInt32 },
    std::pair{ &UInt16_from_Int32, &SPIRV_UInt16_from_Int32 },
    std::pair{ &UInt16_from_Bool8, &SPIRV_UInt16_from_Bool8 },
    std::pair{ &UInt16_from_Float16, &SPIRV_UInt16_from_Float16 },
    std::pair{ &UInt16_from_Int16, &SPIRV_UInt16_from_Int16 },
    std::pair{ &UInt16_ctor0, &SPIRV_UInt16_ctor0 },
    std::pair{ &UInt16_operator_index_Int32, &SPIRV_UInt16_operator_index_Int32 },
    std::pair{ &UInt16_operator_index_UInt32, &SPIRV_UInt16_operator_index_UInt32 },
    std::pair{ &UInt16_operator_index_Int16, &SPIRV_UInt16_operator_index_Int16 },
    std::pair{ &UInt16_operator_index_UInt16, &SPIRV_UInt16_operator_index_UInt16 },
    std::pair{ &UInt16_operator_add_UInt16, &SPIRV_UInt16_operator_add_UInt16 },
    std::pair{ &UInt16_operator_sub_UInt16, &SPIRV_UInt16_operator_sub_UInt16 },
    std::pair{ &UInt16_operator_mul_UInt16, &SPIRV_UInt16_operator_mul_UInt16 },
    std::pair{ &UInt16_operator_div_UInt16, &SPIRV_UInt16_operator_div_UInt16 },
    std::pair{ &UInt16_operator_mod_UInt16, &SPIRV_UInt16_operator_mod_UInt16 },
    std::pair{ &UInt16_operator_addasg_UInt16, &SPIRV_UInt16_operator_addasg_UInt16 },
    std::pair{ &UInt16_operator_subasg_UInt16, &SPIRV_UInt16_operator_subasg_UInt16 },
    std::pair{ &UInt16_operator_mulasg_UInt16, &SPIRV_UInt16_operator_mulasg_UInt16 },
    std::pair{ &UInt16_operator_divasg_UInt16, &SPIRV_UInt16_operator_divasg_UInt16 },
    std::pair{ &UInt16_operator_lt_UInt16, &SPIRV_UInt16_operator_lt_UInt16 },
    std::pair{ &UInt16_operator_lte_UInt16, &SPIRV_UInt16_operator_lte_UInt16 },
    std::pair{ &UInt16_operator_gt_UInt16, &SPIRV_UInt16_operator_gt_UInt16 },
    std::pair{ &UInt16_operator_gte_UInt16, &SPIRV_UInt16_operator_gte_UInt16 },
    std::pair{ &UInt16_operator_eq_UInt16, &SPIRV_UInt16_operator_eq_UInt16 },
    std::pair{ &UInt16_operator_neq_UInt16, &SPIRV_UInt16_operator_neq_UInt16 },
    std::pair{ &UInt16_operator_or_UInt16, &SPIRV_UInt16_operator_or_UInt16 },
    std::pair{ &UInt16_operator_and_UInt16, &SPIRV_UInt16_operator_and_UInt16 },
    std::pair{ &UInt16_operator_xor_UInt16, &SPIRV_UInt16_operator_xor_UInt16 },
    std::pair{ &UInt16_operator_lsh_UInt16, &SPIRV_UInt16_operator_lsh_UInt16 },
    std::pair{ &UInt16_operator_rsh_UInt16, &SPIRV_UInt16_operator_rsh_UInt16 },
    std::pair{ &UInt16_operator_orasg_UInt16, &SPIRV_UInt16_operator_orasg_UInt16 },
    std::pair{ &UInt16_operator_andasg_UInt16, &SPIRV_UInt16_operator_andasg_UInt16 },
    std::pair{ &UInt16_operator_xorasg_UInt16, &SPIRV_UInt16_operator_xorasg_UInt16 },
    std::pair{ &UInt16_operator_lshasg_UInt16, &SPIRV_UInt16_operator_lshasg_UInt16 },
    std::pair{ &UInt16_operator_rhsasg_UInt16, &SPIRV_UInt16_operator_rhsasg_UInt16 },
    std::pair{ &Int16_from_Float32, &SPIRV_Int16_from_Float32 },
    std::pair{ &Int16_from_UInt32, &SPIRV_Int16_from_UInt32 },
    std::pair{ &Int16_from_Int32, &SPIRV_Int16_from_Int32 },
    std::pair{ &Int16_from_Bool8, &SPIRV_Int16_from_Bool8 },
    std::pair{ &Int16_from_Float16, &SPIRV_Int16_from_Float16 },
    std::pair{ &Int16_from_UInt16, &SPIRV_Int16_from_UInt16 },
    std::pair{ &Int16_ctor0, &SPIRV_Int16_ctor0 },
    std::pair{ &Int16_operator_index_Int32, &SPIRV_Int16_operator_index_Int32 },
    std::pair{ &Int16_operator_index_UInt32, &SPIRV_Int16_operator_index_UInt32 },
    std::pair{ &Int16_operator_index_Int16, &SPIRV_Int16_operator_index_Int16 },
    std::pair{ &Int16_operator_index_UInt16, &SPIRV_Int16_operator_index_UInt16 },
    std::pair{ &Int16_operator_add_Int16, &SPIRV_Int16_operator_add_Int16 },
    std::pair{ &Int16_operator_sub_Int16, &SPIRV_Int16_operator_sub_Int16 },
    std::pair{ &Int16_operator_mul_Int16, &SPIRV_Int16_operator_mul_Int16 },
    std::pair{ &Int16_operator_div_Int16, &SPIRV_Int16_operator_div_Int16 },
    std::pair{ &Int16_operator_mod_Int16, &SPIRV_Int16_operator_mod_Int16 },
    std::pair{ &Int16_operator_addasg_Int16, &SPIRV_Int16_operator_addasg_Int16 },
    std::pair{ &Int16_operator_subasg_Int16, &SPIRV_Int16_operator_subasg_Int16 },
    std::pair{ &Int16_operator_mulasg_Int16, &SPIRV_Int16_operator_mulasg_Int16 },
    std::pair{ &Int16_operator_divasg_Int16, &SPIRV_Int16_operator_divasg_Int16 },
    std::pair{ &Int16_operator_lt_Int16, &SPIRV_Int16_operator_lt_Int16 },
    std::pair{ &Int16_operator_lte_Int16, &SPIRV_Int16_operator_lte_Int16 },
    std::pair{ &Int16_operator_gt_Int16, &SPIRV_Int16_operator_gt_Int16 },
    std::pair{ &Int16_operator_gte_Int16, &SPIRV_Int16_operator_gte_Int16 },
    std::pair{ &Int16_operator_eq_Int16, &SPIRV_Int16_operator_eq_Int16 },
    std::pair{ &Int16_operator_neq_Int16, &SPIRV_Int16_operator_neq_Int16 },
    std::pair{ &Int16_operator_or_Int16, &SPIRV_Int16_operator_or_Int16 },
    std::pair{ &Int16_operator_and_Int16, &SPIRV_Int16_operator_and_Int16 },
    std::pair{ &Int16_operator_xor_Int16, &SPIRV_Int16_operator_xor_Int16 },
    std::pair{ &Int16_operator_lsh_Int16, &SPIRV_Int16_operator_lsh_Int16 },
    std::pair{ &Int16_operator_rsh_Int16, &SPIRV_Int16_operator_rsh_Int16 },
    std::pair{ &Int16_operator_orasg_Int16, &SPIRV_Int16_operator_orasg_Int16 },
    std::pair{ &Int16_operator_andasg_Int16, &SPIRV_Int16_operator_andasg_Int16 },
    std::pair{ &Int16_operator_xorasg_Int16, &SPIRV_Int16_operator_xorasg_Int16 },
    std::pair{ &Int16_operator_lshasg_Int16, &SPIRV_Int16_operator_lshasg_Int16 },
    std::pair{ &Int16_operator_rhsasg_Int16, &SPIRV_Int16_operator_rhsasg_Int16 },
    std::pair{ &Float32x2_from_Float32x2, &SPIRV_Float32x2_from_Float32x2 },
    std::pair{ &Float32x2_splat_Float32, &SPIRV_Float32x2_splat_Float32 },
    std::pair{ &Float32x2_from_UInt32x2, &SPIRV_Float32x2_from_UInt32x2 },
    std::pair{ &Float32x2_splat_UInt32, &SPIRV_Float32x2_splat_UInt32 },
    std::pair{ &Float32x2_from_Int32x2, &SPIRV_Float32x2_from_Int32x2 },
    std::pair{ &Float32x2_splat_Int32, &SPIRV_Float32x2_splat_Int32 },
    std::pair{ &Float32x2_from_Bool8x2, &SPIRV_Float32x2_from_Bool8x2 },
    std::pair{ &Float32x2_splat_Bool8, &SPIRV_Float32x2_splat_Bool8 },
    std::pair{ &Float32x2_from_Float16x2, &SPIRV_Float32x2_from_Float16x2 },
    std::pair{ &Float32x2_splat_Float16, &SPIRV_Float32x2_splat_Float16 },
    std::pair{ &Float32x2_from_UInt16x2, &SPIRV_Float32x2_from_UInt16x2 },
    std::pair{ &Float32x2_splat_UInt16, &SPIRV_Float32x2_splat_UInt16 },
    std::pair{ &Float32x2_from_Int16x2, &SPIRV_Float32x2_from_Int16x2 },
    std::pair{ &Float32x2_splat_Int16, &SPIRV_Float32x2_splat_Int16 },
    std::pair{ &Float32x2_ctor0, &SPIRV_Float32x2_ctor0 },
    std::pair{ &Float32x2_operator_index_Int32, &SPIRV_Float32x2_operator_index_Int32 },
    std::pair{ &Float32x2_operator_index_UInt32, &SPIRV_Float32x2_operator_index_UInt32 },
    std::pair{ &Float32x2_operator_index_Int16, &SPIRV_Float32x2_operator_index_Int16 },
    std::pair{ &Float32x2_operator_index_UInt16, &SPIRV_Float32x2_operator_index_UInt16 },
    std::pair{ &Float32x2_operator_add_Float32x2, &SPIRV_Float32x2_operator_add_Float32x2 },
    std::pair{ &Float32x2_operator_sub_Float32x2, &SPIRV_Float32x2_operator_sub_Float32x2 },
    std::pair{ &Float32x2_operator_mul_Float32x2, &SPIRV_Float32x2_operator_mul_Float32x2 },
    std::pair{ &Float32x2_operator_div_Float32x2, &SPIRV_Float32x2_operator_div_Float32x2 },
    std::pair{ &Float32x2_operator_mod_Float32x2, &SPIRV_Float32x2_operator_mod_Float32x2 },
    std::pair{ &Float32x2_operator_addasg_Float32x2, &SPIRV_Float32x2_operator_addasg_Float32x2 },
    std::pair{ &Float32x2_operator_subasg_Float32x2, &SPIRV_Float32x2_operator_subasg_Float32x2 },
    std::pair{ &Float32x2_operator_mulasg_Float32x2, &SPIRV_Float32x2_operator_mulasg_Float32x2 },
    std::pair{ &Float32x2_operator_divasg_Float32x2, &SPIRV_Float32x2_operator_divasg_Float32x2 },
    std::pair{ &Float32x2_operator_lt_Float32x2, &SPIRV_Float32x2_operator_lt_Float32x2 },
    std::pair{ &Float32x2_operator_lte_Float32x2, &SPIRV_Float32x2_operator_lte_Float32x2 },
    std::pair{ &Float32x2_operator_gt_Float32x2, &SPIRV_Float32x2_operator_gt_Float32x2 },
    std::pair{ &Float32x2_operator_gte_Float32x2, &SPIRV_Float32x2_operator_gte_Float32x2 },
    std::pair{ &Float32x2_operator_eq_Float32x2, &SPIRV_Float32x2_operator_eq_Float32x2 },
    std::pair{ &Float32x2_operator_neq_Float32x2, &SPIRV_Float32x2_operator_neq_Float32x2 },
    std::pair{ &Float32x2_operator_scale_Float32, &SPIRV_Float32x2_operator_scale_Float32 },
    std::pair{ &Float32x2_operator_scale_UInt32, &SPIRV_Float32x2_operator_scale_UInt32 },
    std::pair{ &Float32x2_operator_scale_Int32, &SPIRV_Float32x2_operator_scale_Int32 },
    std::pair{ &Float32x2_operator_transform_Float32x2x2, &SPIRV_Float32x2_operator_transform_Float32x2x2 },
    std::pair{ &Float32x2_operator_transform_Float32x2x3, &SPIRV_Float32x2_operator_transform_Float32x2x3 },
    std::pair{ &Float32x2_operator_transform_Float32x2x4, &SPIRV_Float32x2_operator_transform_Float32x2x4 },
    std::pair{ &UInt32x2_from_Float32x2, &SPIRV_UInt32x2_from_Float32x2 },
    std::pair{ &UInt32x2_splat_Float32, &SPIRV_UInt32x2_splat_Float32 },
    std::pair{ &UInt32x2_from_UInt32x2, &SPIRV_UInt32x2_from_UInt32x2 },
    std::pair{ &UInt32x2_splat_UInt32, &SPIRV_UInt32x2_splat_UInt32 },
    std::pair{ &UInt32x2_from_Int32x2, &SPIRV_UInt32x2_from_Int32x2 },
    std::pair{ &UInt32x2_splat_Int32, &SPIRV_UInt32x2_splat_Int32 },
    std::pair{ &UInt32x2_from_Bool8x2, &SPIRV_UInt32x2_from_Bool8x2 },
    std::pair{ &UInt32x2_splat_Bool8, &SPIRV_UInt32x2_splat_Bool8 },
    std::pair{ &UInt32x2_from_Float16x2, &SPIRV_UInt32x2_from_Float16x2 },
    std::pair{ &UInt32x2_splat_Float16, &SPIRV_UInt32x2_splat_Float16 },
    std::pair{ &UInt32x2_from_UInt16x2, &SPIRV_UInt32x2_from_UInt16x2 },
    std::pair{ &UInt32x2_splat_UInt16, &SPIRV_UInt32x2_splat_UInt16 },
    std::pair{ &UInt32x2_from_Int16x2, &SPIRV_UInt32x2_from_Int16x2 },
    std::pair{ &UInt32x2_splat_Int16, &SPIRV_UInt32x2_splat_Int16 },
    std::pair{ &UInt32x2_ctor0, &SPIRV_UInt32x2_ctor0 },
    std::pair{ &UInt32x2_operator_index_Int32, &SPIRV_UInt32x2_operator_index_Int32 },
    std::pair{ &UInt32x2_operator_index_UInt32, &SPIRV_UInt32x2_operator_index_UInt32 },
    std::pair{ &UInt32x2_operator_index_Int16, &SPIRV_UInt32x2_operator_index_Int16 },
    std::pair{ &UInt32x2_operator_index_UInt16, &SPIRV_UInt32x2_operator_index_UInt16 },
    std::pair{ &UInt32x2_operator_add_UInt32x2, &SPIRV_UInt32x2_operator_add_UInt32x2 },
    std::pair{ &UInt32x2_operator_sub_UInt32x2, &SPIRV_UInt32x2_operator_sub_UInt32x2 },
    std::pair{ &UInt32x2_operator_mul_UInt32x2, &SPIRV_UInt32x2_operator_mul_UInt32x2 },
    std::pair{ &UInt32x2_operator_div_UInt32x2, &SPIRV_UInt32x2_operator_div_UInt32x2 },
    std::pair{ &UInt32x2_operator_mod_UInt32x2, &SPIRV_UInt32x2_operator_mod_UInt32x2 },
    std::pair{ &UInt32x2_operator_addasg_UInt32x2, &SPIRV_UInt32x2_operator_addasg_UInt32x2 },
    std::pair{ &UInt32x2_operator_subasg_UInt32x2, &SPIRV_UInt32x2_operator_subasg_UInt32x2 },
    std::pair{ &UInt32x2_operator_mulasg_UInt32x2, &SPIRV_UInt32x2_operator_mulasg_UInt32x2 },
    std::pair{ &UInt32x2_operator_divasg_UInt32x2, &SPIRV_UInt32x2_operator_divasg_UInt32x2 },
    std::pair{ &UInt32x2_operator_lt_UInt32x2, &SPIRV_UInt32x2_operator_lt_UInt32x2 },
    std::pair{ &UInt32x2_operator_lte_UInt32x2, &SPIRV_UInt32x2_operator_lte_UInt32x2 },
    std::pair{ &UInt32x2_operator_gt_UInt32x2, &SPIRV_UInt32x2_operator_gt_UInt32x2 },
    std::pair{ &UInt32x2_operator_gte_UInt32x2, &SPIRV_UInt32x2_operator_gte_UInt32x2 },
    std::pair{ &UInt32x2_operator_eq_UInt32x2, &SPIRV_UInt32x2_operator_eq_UInt32x2 },
    std::pair{ &UInt32x2_operator_neq_UInt32x2, &SPIRV_UInt32x2_operator_neq_UInt32x2 },
    std::pair{ &UInt32x2_operator_scale_Float32, &SPIRV_UInt32x2_operator_scale_Float32 },
    std::pair{ &UInt32x2_operator_scale_UInt32, &SPIRV_UInt32x2_operator_scale_UInt32 },
    std::pair{ &UInt32x2_operator_scale_Int32, &SPIRV_UInt32x2_operator_scale_Int32 },
    std::pair{ &UInt32x2_operator_or_UInt32x2, &SPIRV_UInt32x2_operator_or_UInt32x2 },
    std::pair{ &UInt32x2_operator_and_UInt32x2, &SPIRV_UInt32x2_operator_and_UInt32x2 },
    std::pair{ &UInt32x2_operator_xor_UInt32x2, &SPIRV_UInt32x2_operator_xor_UInt32x2 },
    std::pair{ &UInt32x2_operator_lsh_UInt32x2, &SPIRV_UInt32x2_operator_lsh_UInt32x2 },
    std::pair{ &UInt32x2_operator_rsh_UInt32x2, &SPIRV_UInt32x2_operator_rsh_UInt32x2 },
    std::pair{ &UInt32x2_operator_orasg_UInt32x2, &SPIRV_UInt32x2_operator_orasg_UInt32x2 },
    std::pair{ &UInt32x2_operator_andasg_UInt32x2, &SPIRV_UInt32x2_operator_andasg_UInt32x2 },
    std::pair{ &UInt32x2_operator_xorasg_UInt32x2, &SPIRV_UInt32x2_operator_xorasg_UInt32x2 },
    std::pair{ &UInt32x2_operator_lshasg_UInt32x2, &SPIRV_UInt32x2_operator_lshasg_UInt32x2 },
    std::pair{ &UInt32x2_operator_rhsasg_UInt32x2, &SPIRV_UInt32x2_operator_rhsasg_UInt32x2 },
    std::pair{ &Int32x2_from_Float32x2, &SPIRV_Int32x2_from_Float32x2 },
    std::pair{ &Int32x2_splat_Float32, &SPIRV_Int32x2_splat_Float32 },
    std::pair{ &Int32x2_from_UInt32x2, &SPIRV_Int32x2_from_UInt32x2 },
    std::pair{ &Int32x2_splat_UInt32, &SPIRV_Int32x2_splat_UInt32 },
    std::pair{ &Int32x2_from_Int32x2, &SPIRV_Int32x2_from_Int32x2 },
    std::pair{ &Int32x2_splat_Int32, &SPIRV_Int32x2_splat_Int32 },
    std::pair{ &Int32x2_from_Bool8x2, &SPIRV_Int32x2_from_Bool8x2 },
    std::pair{ &Int32x2_splat_Bool8, &SPIRV_Int32x2_splat_Bool8 },
    std::pair{ &Int32x2_from_Float16x2, &SPIRV_Int32x2_from_Float16x2 },
    std::pair{ &Int32x2_splat_Float16, &SPIRV_Int32x2_splat_Float16 },
    std::pair{ &Int32x2_from_UInt16x2, &SPIRV_Int32x2_from_UInt16x2 },
    std::pair{ &Int32x2_splat_UInt16, &SPIRV_Int32x2_splat_UInt16 },
    std::pair{ &Int32x2_from_Int16x2, &SPIRV_Int32x2_from_Int16x2 },
    std::pair{ &Int32x2_splat_Int16, &SPIRV_Int32x2_splat_Int16 },
    std::pair{ &Int32x2_ctor0, &SPIRV_Int32x2_ctor0 },
    std::pair{ &Int32x2_operator_index_Int32, &SPIRV_Int32x2_operator_index_Int32 },
    std::pair{ &Int32x2_operator_index_UInt32, &SPIRV_Int32x2_operator_index_UInt32 },
    std::pair{ &Int32x2_operator_index_Int16, &SPIRV_Int32x2_operator_index_Int16 },
    std::pair{ &Int32x2_operator_index_UInt16, &SPIRV_Int32x2_operator_index_UInt16 },
    std::pair{ &Int32x2_operator_add_Int32x2, &SPIRV_Int32x2_operator_add_Int32x2 },
    std::pair{ &Int32x2_operator_sub_Int32x2, &SPIRV_Int32x2_operator_sub_Int32x2 },
    std::pair{ &Int32x2_operator_mul_Int32x2, &SPIRV_Int32x2_operator_mul_Int32x2 },
    std::pair{ &Int32x2_operator_div_Int32x2, &SPIRV_Int32x2_operator_div_Int32x2 },
    std::pair{ &Int32x2_operator_mod_Int32x2, &SPIRV_Int32x2_operator_mod_Int32x2 },
    std::pair{ &Int32x2_operator_addasg_Int32x2, &SPIRV_Int32x2_operator_addasg_Int32x2 },
    std::pair{ &Int32x2_operator_subasg_Int32x2, &SPIRV_Int32x2_operator_subasg_Int32x2 },
    std::pair{ &Int32x2_operator_mulasg_Int32x2, &SPIRV_Int32x2_operator_mulasg_Int32x2 },
    std::pair{ &Int32x2_operator_divasg_Int32x2, &SPIRV_Int32x2_operator_divasg_Int32x2 },
    std::pair{ &Int32x2_operator_lt_Int32x2, &SPIRV_Int32x2_operator_lt_Int32x2 },
    std::pair{ &Int32x2_operator_lte_Int32x2, &SPIRV_Int32x2_operator_lte_Int32x2 },
    std::pair{ &Int32x2_operator_gt_Int32x2, &SPIRV_Int32x2_operator_gt_Int32x2 },
    std::pair{ &Int32x2_operator_gte_Int32x2, &SPIRV_Int32x2_operator_gte_Int32x2 },
    std::pair{ &Int32x2_operator_eq_Int32x2, &SPIRV_Int32x2_operator_eq_Int32x2 },
    std::pair{ &Int32x2_operator_neq_Int32x2, &SPIRV_Int32x2_operator_neq_Int32x2 },
    std::pair{ &Int32x2_operator_scale_Float32, &SPIRV_Int32x2_operator_scale_Float32 },
    std::pair{ &Int32x2_operator_scale_UInt32, &SPIRV_Int32x2_operator_scale_UInt32 },
    std::pair{ &Int32x2_operator_scale_Int32, &SPIRV_Int32x2_operator_scale_Int32 },
    std::pair{ &Int32x2_operator_or_Int32x2, &SPIRV_Int32x2_operator_or_Int32x2 },
    std::pair{ &Int32x2_operator_and_Int32x2, &SPIRV_Int32x2_operator_and_Int32x2 },
    std::pair{ &Int32x2_operator_xor_Int32x2, &SPIRV_Int32x2_operator_xor_Int32x2 },
    std::pair{ &Int32x2_operator_lsh_Int32x2, &SPIRV_Int32x2_operator_lsh_Int32x2 },
    std::pair{ &Int32x2_operator_rsh_Int32x2, &SPIRV_Int32x2_operator_rsh_Int32x2 },
    std::pair{ &Int32x2_operator_orasg_Int32x2, &SPIRV_Int32x2_operator_orasg_Int32x2 },
    std::pair{ &Int32x2_operator_andasg_Int32x2, &SPIRV_Int32x2_operator_andasg_Int32x2 },
    std::pair{ &Int32x2_operator_xorasg_Int32x2, &SPIRV_Int32x2_operator_xorasg_Int32x2 },
    std::pair{ &Int32x2_operator_lshasg_Int32x2, &SPIRV_Int32x2_operator_lshasg_Int32x2 },
    std::pair{ &Int32x2_operator_rhsasg_Int32x2, &SPIRV_Int32x2_operator_rhsasg_Int32x2 },
    std::pair{ &Bool8x2_from_UInt32x2, &SPIRV_Bool8x2_from_UInt32x2 },
    std::pair{ &Bool8x2_splat_UInt32, &SPIRV_Bool8x2_splat_UInt32 },
    std::pair{ &Bool8x2_from_Int32x2, &SPIRV_Bool8x2_from_Int32x2 },
    std::pair{ &Bool8x2_splat_Int32, &SPIRV_Bool8x2_splat_Int32 },
    std::pair{ &Bool8x2_from_Bool8x2, &SPIRV_Bool8x2_from_Bool8x2 },
    std::pair{ &Bool8x2_splat_Bool8, &SPIRV_Bool8x2_splat_Bool8 },
    std::pair{ &Bool8x2_from_UInt16x2, &SPIRV_Bool8x2_from_UInt16x2 },
    std::pair{ &Bool8x2_splat_UInt16, &SPIRV_Bool8x2_splat_UInt16 },
    std::pair{ &Bool8x2_from_Int16x2, &SPIRV_Bool8x2_from_Int16x2 },
    std::pair{ &Bool8x2_splat_Int16, &SPIRV_Bool8x2_splat_Int16 },
    std::pair{ &Bool8x2_ctor0, &SPIRV_Bool8x2_ctor0 },
    std::pair{ &Bool8x2_operator_index_Int32, &SPIRV_Bool8x2_operator_index_Int32 },
    std::pair{ &Bool8x2_operator_index_UInt32, &SPIRV_Bool8x2_operator_index_UInt32 },
    std::pair{ &Bool8x2_operator_index_Int16, &SPIRV_Bool8x2_operator_index_Int16 },
    std::pair{ &Bool8x2_operator_index_UInt16, &SPIRV_Bool8x2_operator_index_UInt16 },
    std::pair{ &Bool8x2_operator_oror_Bool8x2, &SPIRV_Bool8x2_operator_oror_Bool8x2 },
    std::pair{ &Bool8x2_operator_andand_Bool8x2, &SPIRV_Bool8x2_operator_andand_Bool8x2 },
    std::pair{ &Bool8x2_operator_eq_Bool8x2, &SPIRV_Bool8x2_operator_eq_Bool8x2 },
    std::pair{ &Bool8x2_operator_neq_Bool8x2, &SPIRV_Bool8x2_operator_neq_Bool8x2 },
    std::pair{ &Float16x2_from_Float32x2, &SPIRV_Float16x2_from_Float32x2 },
    std::pair{ &Float16x2_splat_Float32, &SPIRV_Float16x2_splat_Float32 },
    std::pair{ &Float16x2_from_UInt32x2, &SPIRV_Float16x2_from_UInt32x2 },
    std::pair{ &Float16x2_splat_UInt32, &SPIRV_Float16x2_splat_UInt32 },
    std::pair{ &Float16x2_from_Int32x2, &SPIRV_Float16x2_from_Int32x2 },
    std::pair{ &Float16x2_splat_Int32, &SPIRV_Float16x2_splat_Int32 },
    std::pair{ &Float16x2_from_Bool8x2, &SPIRV_Float16x2_from_Bool8x2 },
    std::pair{ &Float16x2_splat_Bool8, &SPIRV_Float16x2_splat_Bool8 },
    std::pair{ &Float16x2_from_Float16x2, &SPIRV_Float16x2_from_Float16x2 },
    std::pair{ &Float16x2_splat_Float16, &SPIRV_Float16x2_splat_Float16 },
    std::pair{ &Float16x2_from_UInt16x2, &SPIRV_Float16x2_from_UInt16x2 },
    std::pair{ &Float16x2_splat_UInt16, &SPIRV_Float16x2_splat_UInt16 },
    std::pair{ &Float16x2_from_Int16x2, &SPIRV_Float16x2_from_Int16x2 },
    std::pair{ &Float16x2_splat_Int16, &SPIRV_Float16x2_splat_Int16 },
    std::pair{ &Float16x2_ctor0, &SPIRV_Float16x2_ctor0 },
    std::pair{ &Float16x2_operator_index_Int32, &SPIRV_Float16x2_operator_index_Int32 },
    std::pair{ &Float16x2_operator_index_UInt32, &SPIRV_Float16x2_operator_index_UInt32 },
    std::pair{ &Float16x2_operator_index_Int16, &SPIRV_Float16x2_operator_index_Int16 },
    std::pair{ &Float16x2_operator_index_UInt16, &SPIRV_Float16x2_operator_index_UInt16 },
    std::pair{ &Float16x2_operator_add_Float16x2, &SPIRV_Float16x2_operator_add_Float16x2 },
    std::pair{ &Float16x2_operator_sub_Float16x2, &SPIRV_Float16x2_operator_sub_Float16x2 },
    std::pair{ &Float16x2_operator_mul_Float16x2, &SPIRV_Float16x2_operator_mul_Float16x2 },
    std::pair{ &Float16x2_operator_div_Float16x2, &SPIRV_Float16x2_operator_div_Float16x2 },
    std::pair{ &Float16x2_operator_mod_Float16x2, &SPIRV_Float16x2_operator_mod_Float16x2 },
    std::pair{ &Float16x2_operator_addasg_Float16x2, &SPIRV_Float16x2_operator_addasg_Float16x2 },
    std::pair{ &Float16x2_operator_subasg_Float16x2, &SPIRV_Float16x2_operator_subasg_Float16x2 },
    std::pair{ &Float16x2_operator_mulasg_Float16x2, &SPIRV_Float16x2_operator_mulasg_Float16x2 },
    std::pair{ &Float16x2_operator_divasg_Float16x2, &SPIRV_Float16x2_operator_divasg_Float16x2 },
    std::pair{ &Float16x2_operator_lt_Float16x2, &SPIRV_Float16x2_operator_lt_Float16x2 },
    std::pair{ &Float16x2_operator_lte_Float16x2, &SPIRV_Float16x2_operator_lte_Float16x2 },
    std::pair{ &Float16x2_operator_gt_Float16x2, &SPIRV_Float16x2_operator_gt_Float16x2 },
    std::pair{ &Float16x2_operator_gte_Float16x2, &SPIRV_Float16x2_operator_gte_Float16x2 },
    std::pair{ &Float16x2_operator_eq_Float16x2, &SPIRV_Float16x2_operator_eq_Float16x2 },
    std::pair{ &Float16x2_operator_neq_Float16x2, &SPIRV_Float16x2_operator_neq_Float16x2 },
    std::pair{ &Float16x2_operator_scale_Float16, &SPIRV_Float16x2_operator_scale_Float16 },
    std::pair{ &Float16x2_operator_scale_UInt16, &SPIRV_Float16x2_operator_scale_UInt16 },
    std::pair{ &Float16x2_operator_scale_Int16, &SPIRV_Float16x2_operator_scale_Int16 },
    std::pair{ &Float16x2_operator_transform_Float32x2x2, &SPIRV_Float16x2_operator_transform_Float32x2x2 },
    std::pair{ &Float16x2_operator_transform_Float32x2x3, &SPIRV_Float16x2_operator_transform_Float32x2x3 },
    std::pair{ &Float16x2_operator_transform_Float32x2x4, &SPIRV_Float16x2_operator_transform_Float32x2x4 },
    std::pair{ &UInt16x2_from_Float32x2, &SPIRV_UInt16x2_from_Float32x2 },
    std::pair{ &UInt16x2_splat_Float32, &SPIRV_UInt16x2_splat_Float32 },
    std::pair{ &UInt16x2_from_UInt32x2, &SPIRV_UInt16x2_from_UInt32x2 },
    std::pair{ &UInt16x2_splat_UInt32, &SPIRV_UInt16x2_splat_UInt32 },
    std::pair{ &UInt16x2_from_Int32x2, &SPIRV_UInt16x2_from_Int32x2 },
    std::pair{ &UInt16x2_splat_Int32, &SPIRV_UInt16x2_splat_Int32 },
    std::pair{ &UInt16x2_from_Bool8x2, &SPIRV_UInt16x2_from_Bool8x2 },
    std::pair{ &UInt16x2_splat_Bool8, &SPIRV_UInt16x2_splat_Bool8 },
    std::pair{ &UInt16x2_from_Float16x2, &SPIRV_UInt16x2_from_Float16x2 },
    std::pair{ &UInt16x2_splat_Float16, &SPIRV_UInt16x2_splat_Float16 },
    std::pair{ &UInt16x2_from_UInt16x2, &SPIRV_UInt16x2_from_UInt16x2 },
    std::pair{ &UInt16x2_splat_UInt16, &SPIRV_UInt16x2_splat_UInt16 },
    std::pair{ &UInt16x2_from_Int16x2, &SPIRV_UInt16x2_from_Int16x2 },
    std::pair{ &UInt16x2_splat_Int16, &SPIRV_UInt16x2_splat_Int16 },
    std::pair{ &UInt16x2_ctor0, &SPIRV_UInt16x2_ctor0 },
    std::pair{ &UInt16x2_operator_index_Int32, &SPIRV_UInt16x2_operator_index_Int32 },
    std::pair{ &UInt16x2_operator_index_UInt32, &SPIRV_UInt16x2_operator_index_UInt32 },
    std::pair{ &UInt16x2_operator_index_Int16, &SPIRV_UInt16x2_operator_index_Int16 },
    std::pair{ &UInt16x2_operator_index_UInt16, &SPIRV_UInt16x2_operator_index_UInt16 },
    std::pair{ &UInt16x2_operator_add_UInt16x2, &SPIRV_UInt16x2_operator_add_UInt16x2 },
    std::pair{ &UInt16x2_operator_sub_UInt16x2, &SPIRV_UInt16x2_operator_sub_UInt16x2 },
    std::pair{ &UInt16x2_operator_mul_UInt16x2, &SPIRV_UInt16x2_operator_mul_UInt16x2 },
    std::pair{ &UInt16x2_operator_div_UInt16x2, &SPIRV_UInt16x2_operator_div_UInt16x2 },
    std::pair{ &UInt16x2_operator_mod_UInt16x2, &SPIRV_UInt16x2_operator_mod_UInt16x2 },
    std::pair{ &UInt16x2_operator_addasg_UInt16x2, &SPIRV_UInt16x2_operator_addasg_UInt16x2 },
    std::pair{ &UInt16x2_operator_subasg_UInt16x2, &SPIRV_UInt16x2_operator_subasg_UInt16x2 },
    std::pair{ &UInt16x2_operator_mulasg_UInt16x2, &SPIRV_UInt16x2_operator_mulasg_UInt16x2 },
    std::pair{ &UInt16x2_operator_divasg_UInt16x2, &SPIRV_UInt16x2_operator_divasg_UInt16x2 },
    std::pair{ &UInt16x2_operator_lt_UInt16x2, &SPIRV_UInt16x2_operator_lt_UInt16x2 },
    std::pair{ &UInt16x2_operator_lte_UInt16x2, &SPIRV_UInt16x2_operator_lte_UInt16x2 },
    std::pair{ &UInt16x2_operator_gt_UInt16x2, &SPIRV_UInt16x2_operator_gt_UInt16x2 },
    std::pair{ &UInt16x2_operator_gte_UInt16x2, &SPIRV_UInt16x2_operator_gte_UInt16x2 },
    std::pair{ &UInt16x2_operator_eq_UInt16x2, &SPIRV_UInt16x2_operator_eq_UInt16x2 },
    std::pair{ &UInt16x2_operator_neq_UInt16x2, &SPIRV_UInt16x2_operator_neq_UInt16x2 },
    std::pair{ &UInt16x2_operator_scale_Float16, &SPIRV_UInt16x2_operator_scale_Float16 },
    std::pair{ &UInt16x2_operator_scale_UInt16, &SPIRV_UInt16x2_operator_scale_UInt16 },
    std::pair{ &UInt16x2_operator_scale_Int16, &SPIRV_UInt16x2_operator_scale_Int16 },
    std::pair{ &UInt16x2_operator_or_UInt16x2, &SPIRV_UInt16x2_operator_or_UInt16x2 },
    std::pair{ &UInt16x2_operator_and_UInt16x2, &SPIRV_UInt16x2_operator_and_UInt16x2 },
    std::pair{ &UInt16x2_operator_xor_UInt16x2, &SPIRV_UInt16x2_operator_xor_UInt16x2 },
    std::pair{ &UInt16x2_operator_lsh_UInt16x2, &SPIRV_UInt16x2_operator_lsh_UInt16x2 },
    std::pair{ &UInt16x2_operator_rsh_UInt16x2, &SPIRV_UInt16x2_operator_rsh_UInt16x2 },
    std::pair{ &UInt16x2_operator_orasg_UInt16x2, &SPIRV_UInt16x2_operator_orasg_UInt16x2 },
    std::pair{ &UInt16x2_operator_andasg_UInt16x2, &SPIRV_UInt16x2_operator_andasg_UInt16x2 },
    std::pair{ &UInt16x2_operator_xorasg_UInt16x2, &SPIRV_UInt16x2_operator_xorasg_UInt16x2 },
    std::pair{ &UInt16x2_operator_lshasg_UInt16x2, &SPIRV_UInt16x2_operator_lshasg_UInt16x2 },
    std::pair{ &UInt16x2_operator_rhsasg_UInt16x2, &SPIRV_UInt16x2_operator_rhsasg_UInt16x2 },
    std::pair{ &Int16x2_from_Float32x2, &SPIRV_Int16x2_from_Float32x2 },
    std::pair{ &Int16x2_splat_Float32, &SPIRV_Int16x2_splat_Float32 },
    std::pair{ &Int16x2_from_UInt32x2, &SPIRV_Int16x2_from_UInt32x2 },
    std::pair{ &Int16x2_splat_UInt32, &SPIRV_Int16x2_splat_UInt32 },
    std::pair{ &Int16x2_from_Int32x2, &SPIRV_Int16x2_from_Int32x2 },
    std::pair{ &Int16x2_splat_Int32, &SPIRV_Int16x2_splat_Int32 },
    std::pair{ &Int16x2_from_Bool8x2, &SPIRV_Int16x2_from_Bool8x2 },
    std::pair{ &Int16x2_splat_Bool8, &SPIRV_Int16x2_splat_Bool8 },
    std::pair{ &Int16x2_from_Float16x2, &SPIRV_Int16x2_from_Float16x2 },
    std::pair{ &Int16x2_splat_Float16, &SPIRV_Int16x2_splat_Float16 },
    std::pair{ &Int16x2_from_UInt16x2, &SPIRV_Int16x2_from_UInt16x2 },
    std::pair{ &Int16x2_splat_UInt16, &SPIRV_Int16x2_splat_UInt16 },
    std::pair{ &Int16x2_from_Int16x2, &SPIRV_Int16x2_from_Int16x2 },
    std::pair{ &Int16x2_splat_Int16, &SPIRV_Int16x2_splat_Int16 },
    std::pair{ &Int16x2_ctor0, &SPIRV_Int16x2_ctor0 },
    std::pair{ &Int16x2_operator_index_Int32, &SPIRV_Int16x2_operator_index_Int32 },
    std::pair{ &Int16x2_operator_index_UInt32, &SPIRV_Int16x2_operator_index_UInt32 },
    std::pair{ &Int16x2_operator_index_Int16, &SPIRV_Int16x2_operator_index_Int16 },
    std::pair{ &Int16x2_operator_index_UInt16, &SPIRV_Int16x2_operator_index_UInt16 },
    std::pair{ &Int16x2_operator_add_Int16x2, &SPIRV_Int16x2_operator_add_Int16x2 },
    std::pair{ &Int16x2_operator_sub_Int16x2, &SPIRV_Int16x2_operator_sub_Int16x2 },
    std::pair{ &Int16x2_operator_mul_Int16x2, &SPIRV_Int16x2_operator_mul_Int16x2 },
    std::pair{ &Int16x2_operator_div_Int16x2, &SPIRV_Int16x2_operator_div_Int16x2 },
    std::pair{ &Int16x2_operator_mod_Int16x2, &SPIRV_Int16x2_operator_mod_Int16x2 },
    std::pair{ &Int16x2_operator_addasg_Int16x2, &SPIRV_Int16x2_operator_addasg_Int16x2 },
    std::pair{ &Int16x2_operator_subasg_Int16x2, &SPIRV_Int16x2_operator_subasg_Int16x2 },
    std::pair{ &Int16x2_operator_mulasg_Int16x2, &SPIRV_Int16x2_operator_mulasg_Int16x2 },
    std::pair{ &Int16x2_operator_divasg_Int16x2, &SPIRV_Int16x2_operator_divasg_Int16x2 },
    std::pair{ &Int16x2_operator_lt_Int16x2, &SPIRV_Int16x2_operator_lt_Int16x2 },
    std::pair{ &Int16x2_operator_lte_Int16x2, &SPIRV_Int16x2_operator_lte_Int16x2 },
    std::pair{ &Int16x2_operator_gt_Int16x2, &SPIRV_Int16x2_operator_gt_Int16x2 },
    std::pair{ &Int16x2_operator_gte_Int16x2, &SPIRV_Int16x2_operator_gte_Int16x2 },
    std::pair{ &Int16x2_operator_eq_Int16x2, &SPIRV_Int16x2_operator_eq_Int16x2 },
    std::pair{ &Int16x2_operator_neq_Int16x2, &SPIRV_Int16x2_operator_neq_Int16x2 },
    std::pair{ &Int16x2_operator_scale_Float16, &SPIRV_Int16x2_operator_scale_Float16 },
    std::pair{ &Int16x2_operator_scale_UInt16, &SPIRV_Int16x2_operator_scale_UInt16 },
    std::pair{ &Int16x2_operator_scale_Int16, &SPIRV_Int16x2_operator_scale_Int16 },
    std::pair{ &Int16x2_operator_or_Int16x2, &SPIRV_Int16x2_operator_or_Int16x2 },
    std::pair{ &Int16x2_operator_and_Int16x2, &SPIRV_Int16x2_operator_and_Int16x2 },
    std::pair{ &Int16x2_operator_xor_Int16x2, &SPIRV_Int16x2_operator_xor_Int16x2 },
    std::pair{ &Int16x2_operator_lsh_Int16x2, &SPIRV_Int16x2_operator_lsh_Int16x2 },
    std::pair{ &Int16x2_operator_rsh_Int16x2, &SPIRV_Int16x2_operator_rsh_Int16x2 },
    std::pair{ &Int16x2_operator_orasg_Int16x2, &SPIRV_Int16x2_operator_orasg_Int16x2 },
    std::pair{ &Int16x2_operator_andasg_Int16x2, &SPIRV_Int16x2_operator_andasg_Int16x2 },
    std::pair{ &Int16x2_operator_xorasg_Int16x2, &SPIRV_Int16x2_operator_xorasg_Int16x2 },
    std::pair{ &Int16x2_operator_lshasg_Int16x2, &SPIRV_Int16x2_operator_lshasg_Int16x2 },
    std::pair{ &Int16x2_operator_rhsasg_Int16x2, &SPIRV_Int16x2_operator_rhsasg_Int16x2 },
    std::pair{ &Float32x3_from_Float32x3, &SPIRV_Float32x3_from_Float32x3 },
    std::pair{ &Float32x3_splat_Float32, &SPIRV_Float32x3_splat_Float32 },
    std::pair{ &Float32x3_from_UInt32x3, &SPIRV_Float32x3_from_UInt32x3 },
    std::pair{ &Float32x3_splat_UInt32, &SPIRV_Float32x3_splat_UInt32 },
    std::pair{ &Float32x3_from_Int32x3, &SPIRV_Float32x3_from_Int32x3 },
    std::pair{ &Float32x3_splat_Int32, &SPIRV_Float32x3_splat_Int32 },
    std::pair{ &Float32x3_from_Bool8x3, &SPIRV_Float32x3_from_Bool8x3 },
    std::pair{ &Float32x3_splat_Bool8, &SPIRV_Float32x3_splat_Bool8 },
    std::pair{ &Float32x3_from_Float16x3, &SPIRV_Float32x3_from_Float16x3 },
    std::pair{ &Float32x3_splat_Float16, &SPIRV_Float32x3_splat_Float16 },
    std::pair{ &Float32x3_from_UInt16x3, &SPIRV_Float32x3_from_UInt16x3 },
    std::pair{ &Float32x3_splat_UInt16, &SPIRV_Float32x3_splat_UInt16 },
    std::pair{ &Float32x3_from_Int16x3, &SPIRV_Float32x3_from_Int16x3 },
    std::pair{ &Float32x3_splat_Int16, &SPIRV_Float32x3_splat_Int16 },
    std::pair{ &Float32x3_ctor0, &SPIRV_Float32x3_ctor0 },
    std::pair{ &Float32x3_ctor1, &SPIRV_Float32x3_ctor1 },
    std::pair{ &Float32x3_ctor2, &SPIRV_Float32x3_ctor2 },
    std::pair{ &Float32x3_operator_index_Int32, &SPIRV_Float32x3_operator_index_Int32 },
    std::pair{ &Float32x3_operator_index_UInt32, &SPIRV_Float32x3_operator_index_UInt32 },
    std::pair{ &Float32x3_operator_index_Int16, &SPIRV_Float32x3_operator_index_Int16 },
    std::pair{ &Float32x3_operator_index_UInt16, &SPIRV_Float32x3_operator_index_UInt16 },
    std::pair{ &Float32x3_operator_add_Float32x3, &SPIRV_Float32x3_operator_add_Float32x3 },
    std::pair{ &Float32x3_operator_sub_Float32x3, &SPIRV_Float32x3_operator_sub_Float32x3 },
    std::pair{ &Float32x3_operator_mul_Float32x3, &SPIRV_Float32x3_operator_mul_Float32x3 },
    std::pair{ &Float32x3_operator_div_Float32x3, &SPIRV_Float32x3_operator_div_Float32x3 },
    std::pair{ &Float32x3_operator_mod_Float32x3, &SPIRV_Float32x3_operator_mod_Float32x3 },
    std::pair{ &Float32x3_operator_addasg_Float32x3, &SPIRV_Float32x3_operator_addasg_Float32x3 },
    std::pair{ &Float32x3_operator_subasg_Float32x3, &SPIRV_Float32x3_operator_subasg_Float32x3 },
    std::pair{ &Float32x3_operator_mulasg_Float32x3, &SPIRV_Float32x3_operator_mulasg_Float32x3 },
    std::pair{ &Float32x3_operator_divasg_Float32x3, &SPIRV_Float32x3_operator_divasg_Float32x3 },
    std::pair{ &Float32x3_operator_lt_Float32x3, &SPIRV_Float32x3_operator_lt_Float32x3 },
    std::pair{ &Float32x3_operator_lte_Float32x3, &SPIRV_Float32x3_operator_lte_Float32x3 },
    std::pair{ &Float32x3_operator_gt_Float32x3, &SPIRV_Float32x3_operator_gt_Float32x3 },
    std::pair{ &Float32x3_operator_gte_Float32x3, &SPIRV_Float32x3_operator_gte_Float32x3 },
    std::pair{ &Float32x3_operator_eq_Float32x3, &SPIRV_Float32x3_operator_eq_Float32x3 },
    std::pair{ &Float32x3_operator_neq_Float32x3, &SPIRV_Float32x3_operator_neq_Float32x3 },
    std::pair{ &Float32x3_operator_scale_Float32, &SPIRV_Float32x3_operator_scale_Float32 },
    std::pair{ &Float32x3_operator_scale_UInt32, &SPIRV_Float32x3_operator_scale_UInt32 },
    std::pair{ &Float32x3_operator_scale_Int32, &SPIRV_Float32x3_operator_scale_Int32 },
    std::pair{ &Float32x3_operator_transform_Float32x3x2, &SPIRV_Float32x3_operator_transform_Float32x3x2 },
    std::pair{ &Float32x3_operator_transform_Float32x3x3, &SPIRV_Float32x3_operator_transform_Float32x3x3 },
    std::pair{ &Float32x3_operator_transform_Float32x3x4, &SPIRV_Float32x3_operator_transform_Float32x3x4 },
    std::pair{ &UInt32x3_from_Float32x3, &SPIRV_UInt32x3_from_Float32x3 },
    std::pair{ &UInt32x3_splat_Float32, &SPIRV_UInt32x3_splat_Float32 },
    std::pair{ &UInt32x3_from_UInt32x3, &SPIRV_UInt32x3_from_UInt32x3 },
    std::pair{ &UInt32x3_splat_UInt32, &SPIRV_UInt32x3_splat_UInt32 },
    std::pair{ &UInt32x3_from_Int32x3, &SPIRV_UInt32x3_from_Int32x3 },
    std::pair{ &UInt32x3_splat_Int32, &SPIRV_UInt32x3_splat_Int32 },
    std::pair{ &UInt32x3_from_Bool8x3, &SPIRV_UInt32x3_from_Bool8x3 },
    std::pair{ &UInt32x3_splat_Bool8, &SPIRV_UInt32x3_splat_Bool8 },
    std::pair{ &UInt32x3_from_Float16x3, &SPIRV_UInt32x3_from_Float16x3 },
    std::pair{ &UInt32x3_splat_Float16, &SPIRV_UInt32x3_splat_Float16 },
    std::pair{ &UInt32x3_from_UInt16x3, &SPIRV_UInt32x3_from_UInt16x3 },
    std::pair{ &UInt32x3_splat_UInt16, &SPIRV_UInt32x3_splat_UInt16 },
    std::pair{ &UInt32x3_from_Int16x3, &SPIRV_UInt32x3_from_Int16x3 },
    std::pair{ &UInt32x3_splat_Int16, &SPIRV_UInt32x3_splat_Int16 },
    std::pair{ &UInt32x3_ctor0, &SPIRV_UInt32x3_ctor0 },
    std::pair{ &UInt32x3_ctor1, &SPIRV_UInt32x3_ctor1 },
    std::pair{ &UInt32x3_ctor2, &SPIRV_UInt32x3_ctor2 },
    std::pair{ &UInt32x3_operator_index_Int32, &SPIRV_UInt32x3_operator_index_Int32 },
    std::pair{ &UInt32x3_operator_index_UInt32, &SPIRV_UInt32x3_operator_index_UInt32 },
    std::pair{ &UInt32x3_operator_index_Int16, &SPIRV_UInt32x3_operator_index_Int16 },
    std::pair{ &UInt32x3_operator_index_UInt16, &SPIRV_UInt32x3_operator_index_UInt16 },
    std::pair{ &UInt32x3_operator_add_UInt32x3, &SPIRV_UInt32x3_operator_add_UInt32x3 },
    std::pair{ &UInt32x3_operator_sub_UInt32x3, &SPIRV_UInt32x3_operator_sub_UInt32x3 },
    std::pair{ &UInt32x3_operator_mul_UInt32x3, &SPIRV_UInt32x3_operator_mul_UInt32x3 },
    std::pair{ &UInt32x3_operator_div_UInt32x3, &SPIRV_UInt32x3_operator_div_UInt32x3 },
    std::pair{ &UInt32x3_operator_mod_UInt32x3, &SPIRV_UInt32x3_operator_mod_UInt32x3 },
    std::pair{ &UInt32x3_operator_addasg_UInt32x3, &SPIRV_UInt32x3_operator_addasg_UInt32x3 },
    std::pair{ &UInt32x3_operator_subasg_UInt32x3, &SPIRV_UInt32x3_operator_subasg_UInt32x3 },
    std::pair{ &UInt32x3_operator_mulasg_UInt32x3, &SPIRV_UInt32x3_operator_mulasg_UInt32x3 },
    std::pair{ &UInt32x3_operator_divasg_UInt32x3, &SPIRV_UInt32x3_operator_divasg_UInt32x3 },
    std::pair{ &UInt32x3_operator_lt_UInt32x3, &SPIRV_UInt32x3_operator_lt_UInt32x3 },
    std::pair{ &UInt32x3_operator_lte_UInt32x3, &SPIRV_UInt32x3_operator_lte_UInt32x3 },
    std::pair{ &UInt32x3_operator_gt_UInt32x3, &SPIRV_UInt32x3_operator_gt_UInt32x3 },
    std::pair{ &UInt32x3_operator_gte_UInt32x3, &SPIRV_UInt32x3_operator_gte_UInt32x3 },
    std::pair{ &UInt32x3_operator_eq_UInt32x3, &SPIRV_UInt32x3_operator_eq_UInt32x3 },
    std::pair{ &UInt32x3_operator_neq_UInt32x3, &SPIRV_UInt32x3_operator_neq_UInt32x3 },
    std::pair{ &UInt32x3_operator_scale_Float32, &SPIRV_UInt32x3_operator_scale_Float32 },
    std::pair{ &UInt32x3_operator_scale_UInt32, &SPIRV_UInt32x3_operator_scale_UInt32 },
    std::pair{ &UInt32x3_operator_scale_Int32, &SPIRV_UInt32x3_operator_scale_Int32 },
    std::pair{ &UInt32x3_operator_or_UInt32x3, &SPIRV_UInt32x3_operator_or_UInt32x3 },
    std::pair{ &UInt32x3_operator_and_UInt32x3, &SPIRV_UInt32x3_operator_and_UInt32x3 },
    std::pair{ &UInt32x3_operator_xor_UInt32x3, &SPIRV_UInt32x3_operator_xor_UInt32x3 },
    std::pair{ &UInt32x3_operator_lsh_UInt32x3, &SPIRV_UInt32x3_operator_lsh_UInt32x3 },
    std::pair{ &UInt32x3_operator_rsh_UInt32x3, &SPIRV_UInt32x3_operator_rsh_UInt32x3 },
    std::pair{ &UInt32x3_operator_orasg_UInt32x3, &SPIRV_UInt32x3_operator_orasg_UInt32x3 },
    std::pair{ &UInt32x3_operator_andasg_UInt32x3, &SPIRV_UInt32x3_operator_andasg_UInt32x3 },
    std::pair{ &UInt32x3_operator_xorasg_UInt32x3, &SPIRV_UInt32x3_operator_xorasg_UInt32x3 },
    std::pair{ &UInt32x3_operator_lshasg_UInt32x3, &SPIRV_UInt32x3_operator_lshasg_UInt32x3 },
    std::pair{ &UInt32x3_operator_rhsasg_UInt32x3, &SPIRV_UInt32x3_operator_rhsasg_UInt32x3 },
    std::pair{ &Int32x3_from_Float32x3, &SPIRV_Int32x3_from_Float32x3 },
    std::pair{ &Int32x3_splat_Float32, &SPIRV_Int32x3_splat_Float32 },
    std::pair{ &Int32x3_from_UInt32x3, &SPIRV_Int32x3_from_UInt32x3 },
    std::pair{ &Int32x3_splat_UInt32, &SPIRV_Int32x3_splat_UInt32 },
    std::pair{ &Int32x3_from_Int32x3, &SPIRV_Int32x3_from_Int32x3 },
    std::pair{ &Int32x3_splat_Int32, &SPIRV_Int32x3_splat_Int32 },
    std::pair{ &Int32x3_from_Bool8x3, &SPIRV_Int32x3_from_Bool8x3 },
    std::pair{ &Int32x3_splat_Bool8, &SPIRV_Int32x3_splat_Bool8 },
    std::pair{ &Int32x3_from_Float16x3, &SPIRV_Int32x3_from_Float16x3 },
    std::pair{ &Int32x3_splat_Float16, &SPIRV_Int32x3_splat_Float16 },
    std::pair{ &Int32x3_from_UInt16x3, &SPIRV_Int32x3_from_UInt16x3 },
    std::pair{ &Int32x3_splat_UInt16, &SPIRV_Int32x3_splat_UInt16 },
    std::pair{ &Int32x3_from_Int16x3, &SPIRV_Int32x3_from_Int16x3 },
    std::pair{ &Int32x3_splat_Int16, &SPIRV_Int32x3_splat_Int16 },
    std::pair{ &Int32x3_ctor0, &SPIRV_Int32x3_ctor0 },
    std::pair{ &Int32x3_ctor1, &SPIRV_Int32x3_ctor1 },
    std::pair{ &Int32x3_ctor2, &SPIRV_Int32x3_ctor2 },
    std::pair{ &Int32x3_operator_index_Int32, &SPIRV_Int32x3_operator_index_Int32 },
    std::pair{ &Int32x3_operator_index_UInt32, &SPIRV_Int32x3_operator_index_UInt32 },
    std::pair{ &Int32x3_operator_index_Int16, &SPIRV_Int32x3_operator_index_Int16 },
    std::pair{ &Int32x3_operator_index_UInt16, &SPIRV_Int32x3_operator_index_UInt16 },
    std::pair{ &Int32x3_operator_add_Int32x3, &SPIRV_Int32x3_operator_add_Int32x3 },
    std::pair{ &Int32x3_operator_sub_Int32x3, &SPIRV_Int32x3_operator_sub_Int32x3 },
    std::pair{ &Int32x3_operator_mul_Int32x3, &SPIRV_Int32x3_operator_mul_Int32x3 },
    std::pair{ &Int32x3_operator_div_Int32x3, &SPIRV_Int32x3_operator_div_Int32x3 },
    std::pair{ &Int32x3_operator_mod_Int32x3, &SPIRV_Int32x3_operator_mod_Int32x3 },
    std::pair{ &Int32x3_operator_addasg_Int32x3, &SPIRV_Int32x3_operator_addasg_Int32x3 },
    std::pair{ &Int32x3_operator_subasg_Int32x3, &SPIRV_Int32x3_operator_subasg_Int32x3 },
    std::pair{ &Int32x3_operator_mulasg_Int32x3, &SPIRV_Int32x3_operator_mulasg_Int32x3 },
    std::pair{ &Int32x3_operator_divasg_Int32x3, &SPIRV_Int32x3_operator_divasg_Int32x3 },
    std::pair{ &Int32x3_operator_lt_Int32x3, &SPIRV_Int32x3_operator_lt_Int32x3 },
    std::pair{ &Int32x3_operator_lte_Int32x3, &SPIRV_Int32x3_operator_lte_Int32x3 },
    std::pair{ &Int32x3_operator_gt_Int32x3, &SPIRV_Int32x3_operator_gt_Int32x3 },
    std::pair{ &Int32x3_operator_gte_Int32x3, &SPIRV_Int32x3_operator_gte_Int32x3 },
    std::pair{ &Int32x3_operator_eq_Int32x3, &SPIRV_Int32x3_operator_eq_Int32x3 },
    std::pair{ &Int32x3_operator_neq_Int32x3, &SPIRV_Int32x3_operator_neq_Int32x3 },
    std::pair{ &Int32x3_operator_scale_Float32, &SPIRV_Int32x3_operator_scale_Float32 },
    std::pair{ &Int32x3_operator_scale_UInt32, &SPIRV_Int32x3_operator_scale_UInt32 },
    std::pair{ &Int32x3_operator_scale_Int32, &SPIRV_Int32x3_operator_scale_Int32 },
    std::pair{ &Int32x3_operator_or_Int32x3, &SPIRV_Int32x3_operator_or_Int32x3 },
    std::pair{ &Int32x3_operator_and_Int32x3, &SPIRV_Int32x3_operator_and_Int32x3 },
    std::pair{ &Int32x3_operator_xor_Int32x3, &SPIRV_Int32x3_operator_xor_Int32x3 },
    std::pair{ &Int32x3_operator_lsh_Int32x3, &SPIRV_Int32x3_operator_lsh_Int32x3 },
    std::pair{ &Int32x3_operator_rsh_Int32x3, &SPIRV_Int32x3_operator_rsh_Int32x3 },
    std::pair{ &Int32x3_operator_orasg_Int32x3, &SPIRV_Int32x3_operator_orasg_Int32x3 },
    std::pair{ &Int32x3_operator_andasg_Int32x3, &SPIRV_Int32x3_operator_andasg_Int32x3 },
    std::pair{ &Int32x3_operator_xorasg_Int32x3, &SPIRV_Int32x3_operator_xorasg_Int32x3 },
    std::pair{ &Int32x3_operator_lshasg_Int32x3, &SPIRV_Int32x3_operator_lshasg_Int32x3 },
    std::pair{ &Int32x3_operator_rhsasg_Int32x3, &SPIRV_Int32x3_operator_rhsasg_Int32x3 },
    std::pair{ &Bool8x3_from_UInt32x3, &SPIRV_Bool8x3_from_UInt32x3 },
    std::pair{ &Bool8x3_splat_UInt32, &SPIRV_Bool8x3_splat_UInt32 },
    std::pair{ &Bool8x3_from_Int32x3, &SPIRV_Bool8x3_from_Int32x3 },
    std::pair{ &Bool8x3_splat_Int32, &SPIRV_Bool8x3_splat_Int32 },
    std::pair{ &Bool8x3_from_Bool8x3, &SPIRV_Bool8x3_from_Bool8x3 },
    std::pair{ &Bool8x3_splat_Bool8, &SPIRV_Bool8x3_splat_Bool8 },
    std::pair{ &Bool8x3_from_UInt16x3, &SPIRV_Bool8x3_from_UInt16x3 },
    std::pair{ &Bool8x3_splat_UInt16, &SPIRV_Bool8x3_splat_UInt16 },
    std::pair{ &Bool8x3_from_Int16x3, &SPIRV_Bool8x3_from_Int16x3 },
    std::pair{ &Bool8x3_splat_Int16, &SPIRV_Bool8x3_splat_Int16 },
    std::pair{ &Bool8x3_ctor0, &SPIRV_Bool8x3_ctor0 },
    std::pair{ &Bool8x3_ctor1, &SPIRV_Bool8x3_ctor1 },
    std::pair{ &Bool8x3_ctor2, &SPIRV_Bool8x3_ctor2 },
    std::pair{ &Bool8x3_operator_index_Int32, &SPIRV_Bool8x3_operator_index_Int32 },
    std::pair{ &Bool8x3_operator_index_UInt32, &SPIRV_Bool8x3_operator_index_UInt32 },
    std::pair{ &Bool8x3_operator_index_Int16, &SPIRV_Bool8x3_operator_index_Int16 },
    std::pair{ &Bool8x3_operator_index_UInt16, &SPIRV_Bool8x3_operator_index_UInt16 },
    std::pair{ &Bool8x3_operator_oror_Bool8x3, &SPIRV_Bool8x3_operator_oror_Bool8x3 },
    std::pair{ &Bool8x3_operator_andand_Bool8x3, &SPIRV_Bool8x3_operator_andand_Bool8x3 },
    std::pair{ &Bool8x3_operator_eq_Bool8x3, &SPIRV_Bool8x3_operator_eq_Bool8x3 },
    std::pair{ &Bool8x3_operator_neq_Bool8x3, &SPIRV_Bool8x3_operator_neq_Bool8x3 },
    std::pair{ &Float16x3_from_Float32x3, &SPIRV_Float16x3_from_Float32x3 },
    std::pair{ &Float16x3_splat_Float32, &SPIRV_Float16x3_splat_Float32 },
    std::pair{ &Float16x3_from_UInt32x3, &SPIRV_Float16x3_from_UInt32x3 },
    std::pair{ &Float16x3_splat_UInt32, &SPIRV_Float16x3_splat_UInt32 },
    std::pair{ &Float16x3_from_Int32x3, &SPIRV_Float16x3_from_Int32x3 },
    std::pair{ &Float16x3_splat_Int32, &SPIRV_Float16x3_splat_Int32 },
    std::pair{ &Float16x3_from_Bool8x3, &SPIRV_Float16x3_from_Bool8x3 },
    std::pair{ &Float16x3_splat_Bool8, &SPIRV_Float16x3_splat_Bool8 },
    std::pair{ &Float16x3_from_Float16x3, &SPIRV_Float16x3_from_Float16x3 },
    std::pair{ &Float16x3_splat_Float16, &SPIRV_Float16x3_splat_Float16 },
    std::pair{ &Float16x3_from_UInt16x3, &SPIRV_Float16x3_from_UInt16x3 },
    std::pair{ &Float16x3_splat_UInt16, &SPIRV_Float16x3_splat_UInt16 },
    std::pair{ &Float16x3_from_Int16x3, &SPIRV_Float16x3_from_Int16x3 },
    std::pair{ &Float16x3_splat_Int16, &SPIRV_Float16x3_splat_Int16 },
    std::pair{ &Float16x3_ctor0, &SPIRV_Float16x3_ctor0 },
    std::pair{ &Float16x3_ctor1, &SPIRV_Float16x3_ctor1 },
    std::pair{ &Float16x3_ctor2, &SPIRV_Float16x3_ctor2 },
    std::pair{ &Float16x3_operator_index_Int32, &SPIRV_Float16x3_operator_index_Int32 },
    std::pair{ &Float16x3_operator_index_UInt32, &SPIRV_Float16x3_operator_index_UInt32 },
    std::pair{ &Float16x3_operator_index_Int16, &SPIRV_Float16x3_operator_index_Int16 },
    std::pair{ &Float16x3_operator_index_UInt16, &SPIRV_Float16x3_operator_index_UInt16 },
    std::pair{ &Float16x3_operator_add_Float16x3, &SPIRV_Float16x3_operator_add_Float16x3 },
    std::pair{ &Float16x3_operator_sub_Float16x3, &SPIRV_Float16x3_operator_sub_Float16x3 },
    std::pair{ &Float16x3_operator_mul_Float16x3, &SPIRV_Float16x3_operator_mul_Float16x3 },
    std::pair{ &Float16x3_operator_div_Float16x3, &SPIRV_Float16x3_operator_div_Float16x3 },
    std::pair{ &Float16x3_operator_mod_Float16x3, &SPIRV_Float16x3_operator_mod_Float16x3 },
    std::pair{ &Float16x3_operator_addasg_Float16x3, &SPIRV_Float16x3_operator_addasg_Float16x3 },
    std::pair{ &Float16x3_operator_subasg_Float16x3, &SPIRV_Float16x3_operator_subasg_Float16x3 },
    std::pair{ &Float16x3_operator_mulasg_Float16x3, &SPIRV_Float16x3_operator_mulasg_Float16x3 },
    std::pair{ &Float16x3_operator_divasg_Float16x3, &SPIRV_Float16x3_operator_divasg_Float16x3 },
    std::pair{ &Float16x3_operator_lt_Float16x3, &SPIRV_Float16x3_operator_lt_Float16x3 },
    std::pair{ &Float16x3_operator_lte_Float16x3, &SPIRV_Float16x3_operator_lte_Float16x3 },
    std::pair{ &Float16x3_operator_gt_Float16x3, &SPIRV_Float16x3_operator_gt_Float16x3 },
    std::pair{ &Float16x3_operator_gte_Float16x3, &SPIRV_Float16x3_operator_gte_Float16x3 },
    std::pair{ &Float16x3_operator_eq_Float16x3, &SPIRV_Float16x3_operator_eq_Float16x3 },
    std::pair{ &Float16x3_operator_neq_Float16x3, &SPIRV_Float16x3_operator_neq_Float16x3 },
    std::pair{ &Float16x3_operator_scale_Float16, &SPIRV_Float16x3_operator_scale_Float16 },
    std::pair{ &Float16x3_operator_scale_UInt16, &SPIRV_Float16x3_operator_scale_UInt16 },
    std::pair{ &Float16x3_operator_scale_Int16, &SPIRV_Float16x3_operator_scale_Int16 },
    std::pair{ &Float16x3_operator_transform_Float32x3x2, &SPIRV_Float16x3_operator_transform_Float32x3x2 },
    std::pair{ &Float16x3_operator_transform_Float32x3x3, &SPIRV_Float16x3_operator_transform_Float32x3x3 },
    std::pair{ &Float16x3_operator_transform_Float32x3x4, &SPIRV_Float16x3_operator_transform_Float32x3x4 },
    std::pair{ &UInt16x3_from_Float32x3, &SPIRV_UInt16x3_from_Float32x3 },
    std::pair{ &UInt16x3_splat_Float32, &SPIRV_UInt16x3_splat_Float32 },
    std::pair{ &UInt16x3_from_UInt32x3, &SPIRV_UInt16x3_from_UInt32x3 },
    std::pair{ &UInt16x3_splat_UInt32, &SPIRV_UInt16x3_splat_UInt32 },
    std::pair{ &UInt16x3_from_Int32x3, &SPIRV_UInt16x3_from_Int32x3 },
    std::pair{ &UInt16x3_splat_Int32, &SPIRV_UInt16x3_splat_Int32 },
    std::pair{ &UInt16x3_from_Bool8x3, &SPIRV_UInt16x3_from_Bool8x3 },
    std::pair{ &UInt16x3_splat_Bool8, &SPIRV_UInt16x3_splat_Bool8 },
    std::pair{ &UInt16x3_from_Float16x3, &SPIRV_UInt16x3_from_Float16x3 },
    std::pair{ &UInt16x3_splat_Float16, &SPIRV_UInt16x3_splat_Float16 },
    std::pair{ &UInt16x3_from_UInt16x3, &SPIRV_UInt16x3_from_UInt16x3 },
    std::pair{ &UInt16x3_splat_UInt16, &SPIRV_UInt16x3_splat_UInt16 },
    std::pair{ &UInt16x3_from_Int16x3, &SPIRV_UInt16x3_from_Int16x3 },
    std::pair{ &UInt16x3_splat_Int16, &SPIRV_UInt16x3_splat_Int16 },
    std::pair{ &UInt16x3_ctor0, &SPIRV_UInt16x3_ctor0 },
    std::pair{ &UInt16x3_ctor1, &SPIRV_UInt16x3_ctor1 },
    std::pair{ &UInt16x3_ctor2, &SPIRV_UInt16x3_ctor2 },
    std::pair{ &UInt16x3_operator_index_Int32, &SPIRV_UInt16x3_operator_index_Int32 },
    std::pair{ &UInt16x3_operator_index_UInt32, &SPIRV_UInt16x3_operator_index_UInt32 },
    std::pair{ &UInt16x3_operator_index_Int16, &SPIRV_UInt16x3_operator_index_Int16 },
    std::pair{ &UInt16x3_operator_index_UInt16, &SPIRV_UInt16x3_operator_index_UInt16 },
    std::pair{ &UInt16x3_operator_add_UInt16x3, &SPIRV_UInt16x3_operator_add_UInt16x3 },
    std::pair{ &UInt16x3_operator_sub_UInt16x3, &SPIRV_UInt16x3_operator_sub_UInt16x3 },
    std::pair{ &UInt16x3_operator_mul_UInt16x3, &SPIRV_UInt16x3_operator_mul_UInt16x3 },
    std::pair{ &UInt16x3_operator_div_UInt16x3, &SPIRV_UInt16x3_operator_div_UInt16x3 },
    std::pair{ &UInt16x3_operator_mod_UInt16x3, &SPIRV_UInt16x3_operator_mod_UInt16x3 },
    std::pair{ &UInt16x3_operator_addasg_UInt16x3, &SPIRV_UInt16x3_operator_addasg_UInt16x3 },
    std::pair{ &UInt16x3_operator_subasg_UInt16x3, &SPIRV_UInt16x3_operator_subasg_UInt16x3 },
    std::pair{ &UInt16x3_operator_mulasg_UInt16x3, &SPIRV_UInt16x3_operator_mulasg_UInt16x3 },
    std::pair{ &UInt16x3_operator_divasg_UInt16x3, &SPIRV_UInt16x3_operator_divasg_UInt16x3 },
    std::pair{ &UInt16x3_operator_lt_UInt16x3, &SPIRV_UInt16x3_operator_lt_UInt16x3 },
    std::pair{ &UInt16x3_operator_lte_UInt16x3, &SPIRV_UInt16x3_operator_lte_UInt16x3 },
    std::pair{ &UInt16x3_operator_gt_UInt16x3, &SPIRV_UInt16x3_operator_gt_UInt16x3 },
    std::pair{ &UInt16x3_operator_gte_UInt16x3, &SPIRV_UInt16x3_operator_gte_UInt16x3 },
    std::pair{ &UInt16x3_operator_eq_UInt16x3, &SPIRV_UInt16x3_operator_eq_UInt16x3 },
    std::pair{ &UInt16x3_operator_neq_UInt16x3, &SPIRV_UInt16x3_operator_neq_UInt16x3 },
    std::pair{ &UInt16x3_operator_scale_Float16, &SPIRV_UInt16x3_operator_scale_Float16 },
    std::pair{ &UInt16x3_operator_scale_UInt16, &SPIRV_UInt16x3_operator_scale_UInt16 },
    std::pair{ &UInt16x3_operator_scale_Int16, &SPIRV_UInt16x3_operator_scale_Int16 },
    std::pair{ &UInt16x3_operator_or_UInt16x3, &SPIRV_UInt16x3_operator_or_UInt16x3 },
    std::pair{ &UInt16x3_operator_and_UInt16x3, &SPIRV_UInt16x3_operator_and_UInt16x3 },
    std::pair{ &UInt16x3_operator_xor_UInt16x3, &SPIRV_UInt16x3_operator_xor_UInt16x3 },
    std::pair{ &UInt16x3_operator_lsh_UInt16x3, &SPIRV_UInt16x3_operator_lsh_UInt16x3 },
    std::pair{ &UInt16x3_operator_rsh_UInt16x3, &SPIRV_UInt16x3_operator_rsh_UInt16x3 },
    std::pair{ &UInt16x3_operator_orasg_UInt16x3, &SPIRV_UInt16x3_operator_orasg_UInt16x3 },
    std::pair{ &UInt16x3_operator_andasg_UInt16x3, &SPIRV_UInt16x3_operator_andasg_UInt16x3 },
    std::pair{ &UInt16x3_operator_xorasg_UInt16x3, &SPIRV_UInt16x3_operator_xorasg_UInt16x3 },
    std::pair{ &UInt16x3_operator_lshasg_UInt16x3, &SPIRV_UInt16x3_operator_lshasg_UInt16x3 },
    std::pair{ &UInt16x3_operator_rhsasg_UInt16x3, &SPIRV_UInt16x3_operator_rhsasg_UInt16x3 },
    std::pair{ &Int16x3_from_Float32x3, &SPIRV_Int16x3_from_Float32x3 },
    std::pair{ &Int16x3_splat_Float32, &SPIRV_Int16x3_splat_Float32 },
    std::pair{ &Int16x3_from_UInt32x3, &SPIRV_Int16x3_from_UInt32x3 },
    std::pair{ &Int16x3_splat_UInt32, &SPIRV_Int16x3_splat_UInt32 },
    std::pair{ &Int16x3_from_Int32x3, &SPIRV_Int16x3_from_Int32x3 },
    std::pair{ &Int16x3_splat_Int32, &SPIRV_Int16x3_splat_Int32 },
    std::pair{ &Int16x3_from_Bool8x3, &SPIRV_Int16x3_from_Bool8x3 },
    std::pair{ &Int16x3_splat_Bool8, &SPIRV_Int16x3_splat_Bool8 },
    std::pair{ &Int16x3_from_Float16x3, &SPIRV_Int16x3_from_Float16x3 },
    std::pair{ &Int16x3_splat_Float16, &SPIRV_Int16x3_splat_Float16 },
    std::pair{ &Int16x3_from_UInt16x3, &SPIRV_Int16x3_from_UInt16x3 },
    std::pair{ &Int16x3_splat_UInt16, &SPIRV_Int16x3_splat_UInt16 },
    std::pair{ &Int16x3_from_Int16x3, &SPIRV_Int16x3_from_Int16x3 },
    std::pair{ &Int16x3_splat_Int16, &SPIRV_Int16x3_splat_Int16 },
    std::pair{ &Int16x3_ctor0, &SPIRV_Int16x3_ctor0 },
    std::pair{ &Int16x3_ctor1, &SPIRV_Int16x3_ctor1 },
    std::pair{ &Int16x3_ctor2, &SPIRV_Int16x3_ctor2 },
    std::pair{ &Int16x3_operator_index_Int32, &SPIRV_Int16x3_operator_index_Int32 },
    std::pair{ &Int16x3_operator_index_UInt32, &SPIRV_Int16x3_operator_index_UInt32 },
    std::pair{ &Int16x3_operator_index_Int16, &SPIRV_Int16x3_operator_index_Int16 },
    std::pair{ &Int16x3_operator_index_UInt16, &SPIRV_Int16x3_operator_index_UInt16 },
    std::pair{ &Int16x3_operator_add_Int16x3, &SPIRV_Int16x3_operator_add_Int16x3 },
    std::pair{ &Int16x3_operator_sub_Int16x3, &SPIRV_Int16x3_operator_sub_Int16x3 },
    std::pair{ &Int16x3_operator_mul_Int16x3, &SPIRV_Int16x3_operator_mul_Int16x3 },
    std::pair{ &Int16x3_operator_div_Int16x3, &SPIRV_Int16x3_operator_div_Int16x3 },
    std::pair{ &Int16x3_operator_mod_Int16x3, &SPIRV_Int16x3_operator_mod_Int16x3 },
    std::pair{ &Int16x3_operator_addasg_Int16x3, &SPIRV_Int16x3_operator_addasg_Int16x3 },
    std::pair{ &Int16x3_operator_subasg_Int16x3, &SPIRV_Int16x3_operator_subasg_Int16x3 },
    std::pair{ &Int16x3_operator_mulasg_Int16x3, &SPIRV_Int16x3_operator_mulasg_Int16x3 },
    std::pair{ &Int16x3_operator_divasg_Int16x3, &SPIRV_Int16x3_operator_divasg_Int16x3 },
    std::pair{ &Int16x3_operator_lt_Int16x3, &SPIRV_Int16x3_operator_lt_Int16x3 },
    std::pair{ &Int16x3_operator_lte_Int16x3, &SPIRV_Int16x3_operator_lte_Int16x3 },
    std::pair{ &Int16x3_operator_gt_Int16x3, &SPIRV_Int16x3_operator_gt_Int16x3 },
    std::pair{ &Int16x3_operator_gte_Int16x3, &SPIRV_Int16x3_operator_gte_Int16x3 },
    std::pair{ &Int16x3_operator_eq_Int16x3, &SPIRV_Int16x3_operator_eq_Int16x3 },
    std::pair{ &Int16x3_operator_neq_Int16x3, &SPIRV_Int16x3_operator_neq_Int16x3 },
    std::pair{ &Int16x3_operator_scale_Float16, &SPIRV_Int16x3_operator_scale_Float16 },
    std::pair{ &Int16x3_operator_scale_UInt16, &SPIRV_Int16x3_operator_scale_UInt16 },
    std::pair{ &Int16x3_operator_scale_Int16, &SPIRV_Int16x3_operator_scale_Int16 },
    std::pair{ &Int16x3_operator_or_Int16x3, &SPIRV_Int16x3_operator_or_Int16x3 },
    std::pair{ &Int16x3_operator_and_Int16x3, &SPIRV_Int16x3_operator_and_Int16x3 },
    std::pair{ &Int16x3_operator_xor_Int16x3, &SPIRV_Int16x3_operator_xor_Int16x3 },
    std::pair{ &Int16x3_operator_lsh_Int16x3, &SPIRV_Int16x3_operator_lsh_Int16x3 },
    std::pair{ &Int16x3_operator_rsh_Int16x3, &SPIRV_Int16x3_operator_rsh_Int16x3 },
    std::pair{ &Int16x3_operator_orasg_Int16x3, &SPIRV_Int16x3_operator_orasg_Int16x3 },
    std::pair{ &Int16x3_operator_andasg_Int16x3, &SPIRV_Int16x3_operator_andasg_Int16x3 },
    std::pair{ &Int16x3_operator_xorasg_Int16x3, &SPIRV_Int16x3_operator_xorasg_Int16x3 },
    std::pair{ &Int16x3_operator_lshasg_Int16x3, &SPIRV_Int16x3_operator_lshasg_Int16x3 },
    std::pair{ &Int16x3_operator_rhsasg_Int16x3, &SPIRV_Int16x3_operator_rhsasg_Int16x3 },
    std::pair{ &Float32x4_from_Float32x4, &SPIRV_Float32x4_from_Float32x4 },
    std::pair{ &Float32x4_splat_Float32, &SPIRV_Float32x4_splat_Float32 },
    std::pair{ &Float32x4_from_UInt32x4, &SPIRV_Float32x4_from_UInt32x4 },
    std::pair{ &Float32x4_splat_UInt32, &SPIRV_Float32x4_splat_UInt32 },
    std::pair{ &Float32x4_from_Int32x4, &SPIRV_Float32x4_from_Int32x4 },
    std::pair{ &Float32x4_splat_Int32, &SPIRV_Float32x4_splat_Int32 },
    std::pair{ &Float32x4_from_Bool8x4, &SPIRV_Float32x4_from_Bool8x4 },
    std::pair{ &Float32x4_splat_Bool8, &SPIRV_Float32x4_splat_Bool8 },
    std::pair{ &Float32x4_from_Float16x4, &SPIRV_Float32x4_from_Float16x4 },
    std::pair{ &Float32x4_splat_Float16, &SPIRV_Float32x4_splat_Float16 },
    std::pair{ &Float32x4_from_UInt16x4, &SPIRV_Float32x4_from_UInt16x4 },
    std::pair{ &Float32x4_splat_UInt16, &SPIRV_Float32x4_splat_UInt16 },
    std::pair{ &Float32x4_from_Int16x4, &SPIRV_Float32x4_from_Int16x4 },
    std::pair{ &Float32x4_splat_Int16, &SPIRV_Float32x4_splat_Int16 },
    std::pair{ &Float32x4_ctor0, &SPIRV_Float32x4_ctor0 },
    std::pair{ &Float32x4_ctor1, &SPIRV_Float32x4_ctor1 },
    std::pair{ &Float32x4_ctor2, &SPIRV_Float32x4_ctor2 },
    std::pair{ &Float32x4_ctor3, &SPIRV_Float32x4_ctor3 },
    std::pair{ &Float32x4_ctor4, &SPIRV_Float32x4_ctor4 },
    std::pair{ &Float32x4_ctor5, &SPIRV_Float32x4_ctor5 },
    std::pair{ &Float32x4_ctor6, &SPIRV_Float32x4_ctor6 },
    std::pair{ &Float32x4_operator_index_Int32, &SPIRV_Float32x4_operator_index_Int32 },
    std::pair{ &Float32x4_operator_index_UInt32, &SPIRV_Float32x4_operator_index_UInt32 },
    std::pair{ &Float32x4_operator_index_Int16, &SPIRV_Float32x4_operator_index_Int16 },
    std::pair{ &Float32x4_operator_index_UInt16, &SPIRV_Float32x4_operator_index_UInt16 },
    std::pair{ &Float32x4_operator_add_Float32x4, &SPIRV_Float32x4_operator_add_Float32x4 },
    std::pair{ &Float32x4_operator_sub_Float32x4, &SPIRV_Float32x4_operator_sub_Float32x4 },
    std::pair{ &Float32x4_operator_mul_Float32x4, &SPIRV_Float32x4_operator_mul_Float32x4 },
    std::pair{ &Float32x4_operator_div_Float32x4, &SPIRV_Float32x4_operator_div_Float32x4 },
    std::pair{ &Float32x4_operator_mod_Float32x4, &SPIRV_Float32x4_operator_mod_Float32x4 },
    std::pair{ &Float32x4_operator_addasg_Float32x4, &SPIRV_Float32x4_operator_addasg_Float32x4 },
    std::pair{ &Float32x4_operator_subasg_Float32x4, &SPIRV_Float32x4_operator_subasg_Float32x4 },
    std::pair{ &Float32x4_operator_mulasg_Float32x4, &SPIRV_Float32x4_operator_mulasg_Float32x4 },
    std::pair{ &Float32x4_operator_divasg_Float32x4, &SPIRV_Float32x4_operator_divasg_Float32x4 },
    std::pair{ &Float32x4_operator_lt_Float32x4, &SPIRV_Float32x4_operator_lt_Float32x4 },
    std::pair{ &Float32x4_operator_lte_Float32x4, &SPIRV_Float32x4_operator_lte_Float32x4 },
    std::pair{ &Float32x4_operator_gt_Float32x4, &SPIRV_Float32x4_operator_gt_Float32x4 },
    std::pair{ &Float32x4_operator_gte_Float32x4, &SPIRV_Float32x4_operator_gte_Float32x4 },
    std::pair{ &Float32x4_operator_eq_Float32x4, &SPIRV_Float32x4_operator_eq_Float32x4 },
    std::pair{ &Float32x4_operator_neq_Float32x4, &SPIRV_Float32x4_operator_neq_Float32x4 },
    std::pair{ &Float32x4_operator_scale_Float32, &SPIRV_Float32x4_operator_scale_Float32 },
    std::pair{ &Float32x4_operator_scale_UInt32, &SPIRV_Float32x4_operator_scale_UInt32 },
    std::pair{ &Float32x4_operator_scale_Int32, &SPIRV_Float32x4_operator_scale_Int32 },
    std::pair{ &Float32x4_operator_transform_Float32x4x2, &SPIRV_Float32x4_operator_transform_Float32x4x2 },
    std::pair{ &Float32x4_operator_transform_Float32x4x3, &SPIRV_Float32x4_operator_transform_Float32x4x3 },
    std::pair{ &Float32x4_operator_transform_Float32x4x4, &SPIRV_Float32x4_operator_transform_Float32x4x4 },
    std::pair{ &UInt32x4_from_Float32x4, &SPIRV_UInt32x4_from_Float32x4 },
    std::pair{ &UInt32x4_splat_Float32, &SPIRV_UInt32x4_splat_Float32 },
    std::pair{ &UInt32x4_from_UInt32x4, &SPIRV_UInt32x4_from_UInt32x4 },
    std::pair{ &UInt32x4_splat_UInt32, &SPIRV_UInt32x4_splat_UInt32 },
    std::pair{ &UInt32x4_from_Int32x4, &SPIRV_UInt32x4_from_Int32x4 },
    std::pair{ &UInt32x4_splat_Int32, &SPIRV_UInt32x4_splat_Int32 },
    std::pair{ &UInt32x4_from_Bool8x4, &SPIRV_UInt32x4_from_Bool8x4 },
    std::pair{ &UInt32x4_splat_Bool8, &SPIRV_UInt32x4_splat_Bool8 },
    std::pair{ &UInt32x4_from_Float16x4, &SPIRV_UInt32x4_from_Float16x4 },
    std::pair{ &UInt32x4_splat_Float16, &SPIRV_UInt32x4_splat_Float16 },
    std::pair{ &UInt32x4_from_UInt16x4, &SPIRV_UInt32x4_from_UInt16x4 },
    std::pair{ &UInt32x4_splat_UInt16, &SPIRV_UInt32x4_splat_UInt16 },
    std::pair{ &UInt32x4_from_Int16x4, &SPIRV_UInt32x4_from_Int16x4 },
    std::pair{ &UInt32x4_splat_Int16, &SPIRV_UInt32x4_splat_Int16 },
    std::pair{ &UInt32x4_ctor0, &SPIRV_UInt32x4_ctor0 },
    std::pair{ &UInt32x4_ctor1, &SPIRV_UInt32x4_ctor1 },
    std::pair{ &UInt32x4_ctor2, &SPIRV_UInt32x4_ctor2 },
    std::pair{ &UInt32x4_ctor3, &SPIRV_UInt32x4_ctor3 },
    std::pair{ &UInt32x4_ctor4, &SPIRV_UInt32x4_ctor4 },
    std::pair{ &UInt32x4_ctor5, &SPIRV_UInt32x4_ctor5 },
    std::pair{ &UInt32x4_ctor6, &SPIRV_UInt32x4_ctor6 },
    std::pair{ &UInt32x4_operator_index_Int32, &SPIRV_UInt32x4_operator_index_Int32 },
    std::pair{ &UInt32x4_operator_index_UInt32, &SPIRV_UInt32x4_operator_index_UInt32 },
    std::pair{ &UInt32x4_operator_index_Int16, &SPIRV_UInt32x4_operator_index_Int16 },
    std::pair{ &UInt32x4_operator_index_UInt16, &SPIRV_UInt32x4_operator_index_UInt16 },
    std::pair{ &UInt32x4_operator_add_UInt32x4, &SPIRV_UInt32x4_operator_add_UInt32x4 },
    std::pair{ &UInt32x4_operator_sub_UInt32x4, &SPIRV_UInt32x4_operator_sub_UInt32x4 },
    std::pair{ &UInt32x4_operator_mul_UInt32x4, &SPIRV_UInt32x4_operator_mul_UInt32x4 },
    std::pair{ &UInt32x4_operator_div_UInt32x4, &SPIRV_UInt32x4_operator_div_UInt32x4 },
    std::pair{ &UInt32x4_operator_mod_UInt32x4, &SPIRV_UInt32x4_operator_mod_UInt32x4 },
    std::pair{ &UInt32x4_operator_addasg_UInt32x4, &SPIRV_UInt32x4_operator_addasg_UInt32x4 },
    std::pair{ &UInt32x4_operator_subasg_UInt32x4, &SPIRV_UInt32x4_operator_subasg_UInt32x4 },
    std::pair{ &UInt32x4_operator_mulasg_UInt32x4, &SPIRV_UInt32x4_operator_mulasg_UInt32x4 },
    std::pair{ &UInt32x4_operator_divasg_UInt32x4, &SPIRV_UInt32x4_operator_divasg_UInt32x4 },
    std::pair{ &UInt32x4_operator_lt_UInt32x4, &SPIRV_UInt32x4_operator_lt_UInt32x4 },
    std::pair{ &UInt32x4_operator_lte_UInt32x4, &SPIRV_UInt32x4_operator_lte_UInt32x4 },
    std::pair{ &UInt32x4_operator_gt_UInt32x4, &SPIRV_UInt32x4_operator_gt_UInt32x4 },
    std::pair{ &UInt32x4_operator_gte_UInt32x4, &SPIRV_UInt32x4_operator_gte_UInt32x4 },
    std::pair{ &UInt32x4_operator_eq_UInt32x4, &SPIRV_UInt32x4_operator_eq_UInt32x4 },
    std::pair{ &UInt32x4_operator_neq_UInt32x4, &SPIRV_UInt32x4_operator_neq_UInt32x4 },
    std::pair{ &UInt32x4_operator_scale_Float32, &SPIRV_UInt32x4_operator_scale_Float32 },
    std::pair{ &UInt32x4_operator_scale_UInt32, &SPIRV_UInt32x4_operator_scale_UInt32 },
    std::pair{ &UInt32x4_operator_scale_Int32, &SPIRV_UInt32x4_operator_scale_Int32 },
    std::pair{ &UInt32x4_operator_or_UInt32x4, &SPIRV_UInt32x4_operator_or_UInt32x4 },
    std::pair{ &UInt32x4_operator_and_UInt32x4, &SPIRV_UInt32x4_operator_and_UInt32x4 },
    std::pair{ &UInt32x4_operator_xor_UInt32x4, &SPIRV_UInt32x4_operator_xor_UInt32x4 },
    std::pair{ &UInt32x4_operator_lsh_UInt32x4, &SPIRV_UInt32x4_operator_lsh_UInt32x4 },
    std::pair{ &UInt32x4_operator_rsh_UInt32x4, &SPIRV_UInt32x4_operator_rsh_UInt32x4 },
    std::pair{ &UInt32x4_operator_orasg_UInt32x4, &SPIRV_UInt32x4_operator_orasg_UInt32x4 },
    std::pair{ &UInt32x4_operator_andasg_UInt32x4, &SPIRV_UInt32x4_operator_andasg_UInt32x4 },
    std::pair{ &UInt32x4_operator_xorasg_UInt32x4, &SPIRV_UInt32x4_operator_xorasg_UInt32x4 },
    std::pair{ &UInt32x4_operator_lshasg_UInt32x4, &SPIRV_UInt32x4_operator_lshasg_UInt32x4 },
    std::pair{ &UInt32x4_operator_rhsasg_UInt32x4, &SPIRV_UInt32x4_operator_rhsasg_UInt32x4 },
    std::pair{ &Int32x4_from_Float32x4, &SPIRV_Int32x4_from_Float32x4 },
    std::pair{ &Int32x4_splat_Float32, &SPIRV_Int32x4_splat_Float32 },
    std::pair{ &Int32x4_from_UInt32x4, &SPIRV_Int32x4_from_UInt32x4 },
    std::pair{ &Int32x4_splat_UInt32, &SPIRV_Int32x4_splat_UInt32 },
    std::pair{ &Int32x4_from_Int32x4, &SPIRV_Int32x4_from_Int32x4 },
    std::pair{ &Int32x4_splat_Int32, &SPIRV_Int32x4_splat_Int32 },
    std::pair{ &Int32x4_from_Bool8x4, &SPIRV_Int32x4_from_Bool8x4 },
    std::pair{ &Int32x4_splat_Bool8, &SPIRV_Int32x4_splat_Bool8 },
    std::pair{ &Int32x4_from_Float16x4, &SPIRV_Int32x4_from_Float16x4 },
    std::pair{ &Int32x4_splat_Float16, &SPIRV_Int32x4_splat_Float16 },
    std::pair{ &Int32x4_from_UInt16x4, &SPIRV_Int32x4_from_UInt16x4 },
    std::pair{ &Int32x4_splat_UInt16, &SPIRV_Int32x4_splat_UInt16 },
    std::pair{ &Int32x4_from_Int16x4, &SPIRV_Int32x4_from_Int16x4 },
    std::pair{ &Int32x4_splat_Int16, &SPIRV_Int32x4_splat_Int16 },
    std::pair{ &Int32x4_ctor0, &SPIRV_Int32x4_ctor0 },
    std::pair{ &Int32x4_ctor1, &SPIRV_Int32x4_ctor1 },
    std::pair{ &Int32x4_ctor2, &SPIRV_Int32x4_ctor2 },
    std::pair{ &Int32x4_ctor3, &SPIRV_Int32x4_ctor3 },
    std::pair{ &Int32x4_ctor4, &SPIRV_Int32x4_ctor4 },
    std::pair{ &Int32x4_ctor5, &SPIRV_Int32x4_ctor5 },
    std::pair{ &Int32x4_ctor6, &SPIRV_Int32x4_ctor6 },
    std::pair{ &Int32x4_operator_index_Int32, &SPIRV_Int32x4_operator_index_Int32 },
    std::pair{ &Int32x4_operator_index_UInt32, &SPIRV_Int32x4_operator_index_UInt32 },
    std::pair{ &Int32x4_operator_index_Int16, &SPIRV_Int32x4_operator_index_Int16 },
    std::pair{ &Int32x4_operator_index_UInt16, &SPIRV_Int32x4_operator_index_UInt16 },
    std::pair{ &Int32x4_operator_add_Int32x4, &SPIRV_Int32x4_operator_add_Int32x4 },
    std::pair{ &Int32x4_operator_sub_Int32x4, &SPIRV_Int32x4_operator_sub_Int32x4 },
    std::pair{ &Int32x4_operator_mul_Int32x4, &SPIRV_Int32x4_operator_mul_Int32x4 },
    std::pair{ &Int32x4_operator_div_Int32x4, &SPIRV_Int32x4_operator_div_Int32x4 },
    std::pair{ &Int32x4_operator_mod_Int32x4, &SPIRV_Int32x4_operator_mod_Int32x4 },
    std::pair{ &Int32x4_operator_addasg_Int32x4, &SPIRV_Int32x4_operator_addasg_Int32x4 },
    std::pair{ &Int32x4_operator_subasg_Int32x4, &SPIRV_Int32x4_operator_subasg_Int32x4 },
    std::pair{ &Int32x4_operator_mulasg_Int32x4, &SPIRV_Int32x4_operator_mulasg_Int32x4 },
    std::pair{ &Int32x4_operator_divasg_Int32x4, &SPIRV_Int32x4_operator_divasg_Int32x4 },
    std::pair{ &Int32x4_operator_lt_Int32x4, &SPIRV_Int32x4_operator_lt_Int32x4 },
    std::pair{ &Int32x4_operator_lte_Int32x4, &SPIRV_Int32x4_operator_lte_Int32x4 },
    std::pair{ &Int32x4_operator_gt_Int32x4, &SPIRV_Int32x4_operator_gt_Int32x4 },
    std::pair{ &Int32x4_operator_gte_Int32x4, &SPIRV_Int32x4_operator_gte_Int32x4 },
    std::pair{ &Int32x4_operator_eq_Int32x4, &SPIRV_Int32x4_operator_eq_Int32x4 },
    std::pair{ &Int32x4_operator_neq_Int32x4, &SPIRV_Int32x4_operator_neq_Int32x4 },
    std::pair{ &Int32x4_operator_scale_Float32, &SPIRV_Int32x4_operator_scale_Float32 },
    std::pair{ &Int32x4_operator_scale_UInt32, &SPIRV_Int32x4_operator_scale_UInt32 },
    std::pair{ &Int32x4_operator_scale_Int32, &SPIRV_Int32x4_operator_scale_Int32 },
    std::pair{ &Int32x4_operator_or_Int32x4, &SPIRV_Int32x4_operator_or_Int32x4 },
    std::pair{ &Int32x4_operator_and_Int32x4, &SPIRV_Int32x4_operator_and_Int32x4 },
    std::pair{ &Int32x4_operator_xor_Int32x4, &SPIRV_Int32x4_operator_xor_Int32x4 },
    std::pair{ &Int32x4_operator_lsh_Int32x4, &SPIRV_Int32x4_operator_lsh_Int32x4 },
    std::pair{ &Int32x4_operator_rsh_Int32x4, &SPIRV_Int32x4_operator_rsh_Int32x4 },
    std::pair{ &Int32x4_operator_orasg_Int32x4, &SPIRV_Int32x4_operator_orasg_Int32x4 },
    std::pair{ &Int32x4_operator_andasg_Int32x4, &SPIRV_Int32x4_operator_andasg_Int32x4 },
    std::pair{ &Int32x4_operator_xorasg_Int32x4, &SPIRV_Int32x4_operator_xorasg_Int32x4 },
    std::pair{ &Int32x4_operator_lshasg_Int32x4, &SPIRV_Int32x4_operator_lshasg_Int32x4 },
    std::pair{ &Int32x4_operator_rhsasg_Int32x4, &SPIRV_Int32x4_operator_rhsasg_Int32x4 },
    std::pair{ &Bool8x4_from_UInt32x4, &SPIRV_Bool8x4_from_UInt32x4 },
    std::pair{ &Bool8x4_splat_UInt32, &SPIRV_Bool8x4_splat_UInt32 },
    std::pair{ &Bool8x4_from_Int32x4, &SPIRV_Bool8x4_from_Int32x4 },
    std::pair{ &Bool8x4_splat_Int32, &SPIRV_Bool8x4_splat_Int32 },
    std::pair{ &Bool8x4_from_Bool8x4, &SPIRV_Bool8x4_from_Bool8x4 },
    std::pair{ &Bool8x4_splat_Bool8, &SPIRV_Bool8x4_splat_Bool8 },
    std::pair{ &Bool8x4_from_UInt16x4, &SPIRV_Bool8x4_from_UInt16x4 },
    std::pair{ &Bool8x4_splat_UInt16, &SPIRV_Bool8x4_splat_UInt16 },
    std::pair{ &Bool8x4_from_Int16x4, &SPIRV_Bool8x4_from_Int16x4 },
    std::pair{ &Bool8x4_splat_Int16, &SPIRV_Bool8x4_splat_Int16 },
    std::pair{ &Bool8x4_ctor0, &SPIRV_Bool8x4_ctor0 },
    std::pair{ &Bool8x4_ctor1, &SPIRV_Bool8x4_ctor1 },
    std::pair{ &Bool8x4_ctor2, &SPIRV_Bool8x4_ctor2 },
    std::pair{ &Bool8x4_ctor3, &SPIRV_Bool8x4_ctor3 },
    std::pair{ &Bool8x4_ctor4, &SPIRV_Bool8x4_ctor4 },
    std::pair{ &Bool8x4_ctor5, &SPIRV_Bool8x4_ctor5 },
    std::pair{ &Bool8x4_ctor6, &SPIRV_Bool8x4_ctor6 },
    std::pair{ &Bool8x4_operator_index_Int32, &SPIRV_Bool8x4_operator_index_Int32 },
    std::pair{ &Bool8x4_operator_index_UInt32, &SPIRV_Bool8x4_operator_index_UInt32 },
    std::pair{ &Bool8x4_operator_index_Int16, &SPIRV_Bool8x4_operator_index_Int16 },
    std::pair{ &Bool8x4_operator_index_UInt16, &SPIRV_Bool8x4_operator_index_UInt16 },
    std::pair{ &Bool8x4_operator_oror_Bool8x4, &SPIRV_Bool8x4_operator_oror_Bool8x4 },
    std::pair{ &Bool8x4_operator_andand_Bool8x4, &SPIRV_Bool8x4_operator_andand_Bool8x4 },
    std::pair{ &Bool8x4_operator_eq_Bool8x4, &SPIRV_Bool8x4_operator_eq_Bool8x4 },
    std::pair{ &Bool8x4_operator_neq_Bool8x4, &SPIRV_Bool8x4_operator_neq_Bool8x4 },
    std::pair{ &Float16x4_from_Float32x4, &SPIRV_Float16x4_from_Float32x4 },
    std::pair{ &Float16x4_splat_Float32, &SPIRV_Float16x4_splat_Float32 },
    std::pair{ &Float16x4_from_UInt32x4, &SPIRV_Float16x4_from_UInt32x4 },
    std::pair{ &Float16x4_splat_UInt32, &SPIRV_Float16x4_splat_UInt32 },
    std::pair{ &Float16x4_from_Int32x4, &SPIRV_Float16x4_from_Int32x4 },
    std::pair{ &Float16x4_splat_Int32, &SPIRV_Float16x4_splat_Int32 },
    std::pair{ &Float16x4_from_Bool8x4, &SPIRV_Float16x4_from_Bool8x4 },
    std::pair{ &Float16x4_splat_Bool8, &SPIRV_Float16x4_splat_Bool8 },
    std::pair{ &Float16x4_from_Float16x4, &SPIRV_Float16x4_from_Float16x4 },
    std::pair{ &Float16x4_splat_Float16, &SPIRV_Float16x4_splat_Float16 },
    std::pair{ &Float16x4_from_UInt16x4, &SPIRV_Float16x4_from_UInt16x4 },
    std::pair{ &Float16x4_splat_UInt16, &SPIRV_Float16x4_splat_UInt16 },
    std::pair{ &Float16x4_from_Int16x4, &SPIRV_Float16x4_from_Int16x4 },
    std::pair{ &Float16x4_splat_Int16, &SPIRV_Float16x4_splat_Int16 },
    std::pair{ &Float16x4_ctor0, &SPIRV_Float16x4_ctor0 },
    std::pair{ &Float16x4_ctor1, &SPIRV_Float16x4_ctor1 },
    std::pair{ &Float16x4_ctor2, &SPIRV_Float16x4_ctor2 },
    std::pair{ &Float16x4_ctor3, &SPIRV_Float16x4_ctor3 },
    std::pair{ &Float16x4_ctor4, &SPIRV_Float16x4_ctor4 },
    std::pair{ &Float16x4_ctor5, &SPIRV_Float16x4_ctor5 },
    std::pair{ &Float16x4_ctor6, &SPIRV_Float16x4_ctor6 },
    std::pair{ &Float16x4_operator_index_Int32, &SPIRV_Float16x4_operator_index_Int32 },
    std::pair{ &Float16x4_operator_index_UInt32, &SPIRV_Float16x4_operator_index_UInt32 },
    std::pair{ &Float16x4_operator_index_Int16, &SPIRV_Float16x4_operator_index_Int16 },
    std::pair{ &Float16x4_operator_index_UInt16, &SPIRV_Float16x4_operator_index_UInt16 },
    std::pair{ &Float16x4_operator_add_Float16x4, &SPIRV_Float16x4_operator_add_Float16x4 },
    std::pair{ &Float16x4_operator_sub_Float16x4, &SPIRV_Float16x4_operator_sub_Float16x4 },
    std::pair{ &Float16x4_operator_mul_Float16x4, &SPIRV_Float16x4_operator_mul_Float16x4 },
    std::pair{ &Float16x4_operator_div_Float16x4, &SPIRV_Float16x4_operator_div_Float16x4 },
    std::pair{ &Float16x4_operator_mod_Float16x4, &SPIRV_Float16x4_operator_mod_Float16x4 },
    std::pair{ &Float16x4_operator_addasg_Float16x4, &SPIRV_Float16x4_operator_addasg_Float16x4 },
    std::pair{ &Float16x4_operator_subasg_Float16x4, &SPIRV_Float16x4_operator_subasg_Float16x4 },
    std::pair{ &Float16x4_operator_mulasg_Float16x4, &SPIRV_Float16x4_operator_mulasg_Float16x4 },
    std::pair{ &Float16x4_operator_divasg_Float16x4, &SPIRV_Float16x4_operator_divasg_Float16x4 },
    std::pair{ &Float16x4_operator_lt_Float16x4, &SPIRV_Float16x4_operator_lt_Float16x4 },
    std::pair{ &Float16x4_operator_lte_Float16x4, &SPIRV_Float16x4_operator_lte_Float16x4 },
    std::pair{ &Float16x4_operator_gt_Float16x4, &SPIRV_Float16x4_operator_gt_Float16x4 },
    std::pair{ &Float16x4_operator_gte_Float16x4, &SPIRV_Float16x4_operator_gte_Float16x4 },
    std::pair{ &Float16x4_operator_eq_Float16x4, &SPIRV_Float16x4_operator_eq_Float16x4 },
    std::pair{ &Float16x4_operator_neq_Float16x4, &SPIRV_Float16x4_operator_neq_Float16x4 },
    std::pair{ &Float16x4_operator_scale_Float16, &SPIRV_Float16x4_operator_scale_Float16 },
    std::pair{ &Float16x4_operator_scale_UInt16, &SPIRV_Float16x4_operator_scale_UInt16 },
    std::pair{ &Float16x4_operator_scale_Int16, &SPIRV_Float16x4_operator_scale_Int16 },
    std::pair{ &Float16x4_operator_transform_Float32x4x2, &SPIRV_Float16x4_operator_transform_Float32x4x2 },
    std::pair{ &Float16x4_operator_transform_Float32x4x3, &SPIRV_Float16x4_operator_transform_Float32x4x3 },
    std::pair{ &Float16x4_operator_transform_Float32x4x4, &SPIRV_Float16x4_operator_transform_Float32x4x4 },
    std::pair{ &UInt16x4_from_Float32x4, &SPIRV_UInt16x4_from_Float32x4 },
    std::pair{ &UInt16x4_splat_Float32, &SPIRV_UInt16x4_splat_Float32 },
    std::pair{ &UInt16x4_from_UInt32x4, &SPIRV_UInt16x4_from_UInt32x4 },
    std::pair{ &UInt16x4_splat_UInt32, &SPIRV_UInt16x4_splat_UInt32 },
    std::pair{ &UInt16x4_from_Int32x4, &SPIRV_UInt16x4_from_Int32x4 },
    std::pair{ &UInt16x4_splat_Int32, &SPIRV_UInt16x4_splat_Int32 },
    std::pair{ &UInt16x4_from_Bool8x4, &SPIRV_UInt16x4_from_Bool8x4 },
    std::pair{ &UInt16x4_splat_Bool8, &SPIRV_UInt16x4_splat_Bool8 },
    std::pair{ &UInt16x4_from_Float16x4, &SPIRV_UInt16x4_from_Float16x4 },
    std::pair{ &UInt16x4_splat_Float16, &SPIRV_UInt16x4_splat_Float16 },
    std::pair{ &UInt16x4_from_UInt16x4, &SPIRV_UInt16x4_from_UInt16x4 },
    std::pair{ &UInt16x4_splat_UInt16, &SPIRV_UInt16x4_splat_UInt16 },
    std::pair{ &UInt16x4_from_Int16x4, &SPIRV_UInt16x4_from_Int16x4 },
    std::pair{ &UInt16x4_splat_Int16, &SPIRV_UInt16x4_splat_Int16 },
    std::pair{ &UInt16x4_ctor0, &SPIRV_UInt16x4_ctor0 },
    std::pair{ &UInt16x4_ctor1, &SPIRV_UInt16x4_ctor1 },
    std::pair{ &UInt16x4_ctor2, &SPIRV_UInt16x4_ctor2 },
    std::pair{ &UInt16x4_ctor3, &SPIRV_UInt16x4_ctor3 },
    std::pair{ &UInt16x4_ctor4, &SPIRV_UInt16x4_ctor4 },
    std::pair{ &UInt16x4_ctor5, &SPIRV_UInt16x4_ctor5 },
    std::pair{ &UInt16x4_ctor6, &SPIRV_UInt16x4_ctor6 },
    std::pair{ &UInt16x4_operator_index_Int32, &SPIRV_UInt16x4_operator_index_Int32 },
    std::pair{ &UInt16x4_operator_index_UInt32, &SPIRV_UInt16x4_operator_index_UInt32 },
    std::pair{ &UInt16x4_operator_index_Int16, &SPIRV_UInt16x4_operator_index_Int16 },
    std::pair{ &UInt16x4_operator_index_UInt16, &SPIRV_UInt16x4_operator_index_UInt16 },
    std::pair{ &UInt16x4_operator_add_UInt16x4, &SPIRV_UInt16x4_operator_add_UInt16x4 },
    std::pair{ &UInt16x4_operator_sub_UInt16x4, &SPIRV_UInt16x4_operator_sub_UInt16x4 },
    std::pair{ &UInt16x4_operator_mul_UInt16x4, &SPIRV_UInt16x4_operator_mul_UInt16x4 },
    std::pair{ &UInt16x4_operator_div_UInt16x4, &SPIRV_UInt16x4_operator_div_UInt16x4 },
    std::pair{ &UInt16x4_operator_mod_UInt16x4, &SPIRV_UInt16x4_operator_mod_UInt16x4 },
    std::pair{ &UInt16x4_operator_addasg_UInt16x4, &SPIRV_UInt16x4_operator_addasg_UInt16x4 },
    std::pair{ &UInt16x4_operator_subasg_UInt16x4, &SPIRV_UInt16x4_operator_subasg_UInt16x4 },
    std::pair{ &UInt16x4_operator_mulasg_UInt16x4, &SPIRV_UInt16x4_operator_mulasg_UInt16x4 },
    std::pair{ &UInt16x4_operator_divasg_UInt16x4, &SPIRV_UInt16x4_operator_divasg_UInt16x4 },
    std::pair{ &UInt16x4_operator_lt_UInt16x4, &SPIRV_UInt16x4_operator_lt_UInt16x4 },
    std::pair{ &UInt16x4_operator_lte_UInt16x4, &SPIRV_UInt16x4_operator_lte_UInt16x4 },
    std::pair{ &UInt16x4_operator_gt_UInt16x4, &SPIRV_UInt16x4_operator_gt_UInt16x4 },
    std::pair{ &UInt16x4_operator_gte_UInt16x4, &SPIRV_UInt16x4_operator_gte_UInt16x4 },
    std::pair{ &UInt16x4_operator_eq_UInt16x4, &SPIRV_UInt16x4_operator_eq_UInt16x4 },
    std::pair{ &UInt16x4_operator_neq_UInt16x4, &SPIRV_UInt16x4_operator_neq_UInt16x4 },
    std::pair{ &UInt16x4_operator_scale_Float16, &SPIRV_UInt16x4_operator_scale_Float16 },
    std::pair{ &UInt16x4_operator_scale_UInt16, &SPIRV_UInt16x4_operator_scale_UInt16 },
    std::pair{ &UInt16x4_operator_scale_Int16, &SPIRV_UInt16x4_operator_scale_Int16 },
    std::pair{ &UInt16x4_operator_or_UInt16x4, &SPIRV_UInt16x4_operator_or_UInt16x4 },
    std::pair{ &UInt16x4_operator_and_UInt16x4, &SPIRV_UInt16x4_operator_and_UInt16x4 },
    std::pair{ &UInt16x4_operator_xor_UInt16x4, &SPIRV_UInt16x4_operator_xor_UInt16x4 },
    std::pair{ &UInt16x4_operator_lsh_UInt16x4, &SPIRV_UInt16x4_operator_lsh_UInt16x4 },
    std::pair{ &UInt16x4_operator_rsh_UInt16x4, &SPIRV_UInt16x4_operator_rsh_UInt16x4 },
    std::pair{ &UInt16x4_operator_orasg_UInt16x4, &SPIRV_UInt16x4_operator_orasg_UInt16x4 },
    std::pair{ &UInt16x4_operator_andasg_UInt16x4, &SPIRV_UInt16x4_operator_andasg_UInt16x4 },
    std::pair{ &UInt16x4_operator_xorasg_UInt16x4, &SPIRV_UInt16x4_operator_xorasg_UInt16x4 },
    std::pair{ &UInt16x4_operator_lshasg_UInt16x4, &SPIRV_UInt16x4_operator_lshasg_UInt16x4 },
    std::pair{ &UInt16x4_operator_rhsasg_UInt16x4, &SPIRV_UInt16x4_operator_rhsasg_UInt16x4 },
    std::pair{ &Int16x4_from_Float32x4, &SPIRV_Int16x4_from_Float32x4 },
    std::pair{ &Int16x4_splat_Float32, &SPIRV_Int16x4_splat_Float32 },
    std::pair{ &Int16x4_from_UInt32x4, &SPIRV_Int16x4_from_UInt32x4 },
    std::pair{ &Int16x4_splat_UInt32, &SPIRV_Int16x4_splat_UInt32 },
    std::pair{ &Int16x4_from_Int32x4, &SPIRV_Int16x4_from_Int32x4 },
    std::pair{ &Int16x4_splat_Int32, &SPIRV_Int16x4_splat_Int32 },
    std::pair{ &Int16x4_from_Bool8x4, &SPIRV_Int16x4_from_Bool8x4 },
    std::pair{ &Int16x4_splat_Bool8, &SPIRV_Int16x4_splat_Bool8 },
    std::pair{ &Int16x4_from_Float16x4, &SPIRV_Int16x4_from_Float16x4 },
    std::pair{ &Int16x4_splat_Float16, &SPIRV_Int16x4_splat_Float16 },
    std::pair{ &Int16x4_from_UInt16x4, &SPIRV_Int16x4_from_UInt16x4 },
    std::pair{ &Int16x4_splat_UInt16, &SPIRV_Int16x4_splat_UInt16 },
    std::pair{ &Int16x4_from_Int16x4, &SPIRV_Int16x4_from_Int16x4 },
    std::pair{ &Int16x4_splat_Int16, &SPIRV_Int16x4_splat_Int16 },
    std::pair{ &Int16x4_ctor0, &SPIRV_Int16x4_ctor0 },
    std::pair{ &Int16x4_ctor1, &SPIRV_Int16x4_ctor1 },
    std::pair{ &Int16x4_ctor2, &SPIRV_Int16x4_ctor2 },
    std::pair{ &Int16x4_ctor3, &SPIRV_Int16x4_ctor3 },
    std::pair{ &Int16x4_ctor4, &SPIRV_Int16x4_ctor4 },
    std::pair{ &Int16x4_ctor5, &SPIRV_Int16x4_ctor5 },
    std::pair{ &Int16x4_ctor6, &SPIRV_Int16x4_ctor6 },
    std::pair{ &Int16x4_operator_index_Int32, &SPIRV_Int16x4_operator_index_Int32 },
    std::pair{ &Int16x4_operator_index_UInt32, &SPIRV_Int16x4_operator_index_UInt32 },
    std::pair{ &Int16x4_operator_index_Int16, &SPIRV_Int16x4_operator_index_Int16 },
    std::pair{ &Int16x4_operator_index_UInt16, &SPIRV_Int16x4_operator_index_UInt16 },
    std::pair{ &Int16x4_operator_add_Int16x4, &SPIRV_Int16x4_operator_add_Int16x4 },
    std::pair{ &Int16x4_operator_sub_Int16x4, &SPIRV_Int16x4_operator_sub_Int16x4 },
    std::pair{ &Int16x4_operator_mul_Int16x4, &SPIRV_Int16x4_operator_mul_Int16x4 },
    std::pair{ &Int16x4_operator_div_Int16x4, &SPIRV_Int16x4_operator_div_Int16x4 },
    std::pair{ &Int16x4_operator_mod_Int16x4, &SPIRV_Int16x4_operator_mod_Int16x4 },
    std::pair{ &Int16x4_operator_addasg_Int16x4, &SPIRV_Int16x4_operator_addasg_Int16x4 },
    std::pair{ &Int16x4_operator_subasg_Int16x4, &SPIRV_Int16x4_operator_subasg_Int16x4 },
    std::pair{ &Int16x4_operator_mulasg_Int16x4, &SPIRV_Int16x4_operator_mulasg_Int16x4 },
    std::pair{ &Int16x4_operator_divasg_Int16x4, &SPIRV_Int16x4_operator_divasg_Int16x4 },
    std::pair{ &Int16x4_operator_lt_Int16x4, &SPIRV_Int16x4_operator_lt_Int16x4 },
    std::pair{ &Int16x4_operator_lte_Int16x4, &SPIRV_Int16x4_operator_lte_Int16x4 },
    std::pair{ &Int16x4_operator_gt_Int16x4, &SPIRV_Int16x4_operator_gt_Int16x4 },
    std::pair{ &Int16x4_operator_gte_Int16x4, &SPIRV_Int16x4_operator_gte_Int16x4 },
    std::pair{ &Int16x4_operator_eq_Int16x4, &SPIRV_Int16x4_operator_eq_Int16x4 },
    std::pair{ &Int16x4_operator_neq_Int16x4, &SPIRV_Int16x4_operator_neq_Int16x4 },
    std::pair{ &Int16x4_operator_scale_Float16, &SPIRV_Int16x4_operator_scale_Float16 },
    std::pair{ &Int16x4_operator_scale_UInt16, &SPIRV_Int16x4_operator_scale_UInt16 },
    std::pair{ &Int16x4_operator_scale_Int16, &SPIRV_Int16x4_operator_scale_Int16 },
    std::pair{ &Int16x4_operator_or_Int16x4, &SPIRV_Int16x4_operator_or_Int16x4 },
    std::pair{ &Int16x4_operator_and_Int16x4, &SPIRV_Int16x4_operator_and_Int16x4 },
    std::pair{ &Int16x4_operator_xor_Int16x4, &SPIRV_Int16x4_operator_xor_Int16x4 },
    std::pair{ &Int16x4_operator_lsh_Int16x4, &SPIRV_Int16x4_operator_lsh_Int16x4 },
    std::pair{ &Int16x4_operator_rsh_Int16x4, &SPIRV_Int16x4_operator_rsh_Int16x4 },
    std::pair{ &Int16x4_operator_orasg_Int16x4, &SPIRV_Int16x4_operator_orasg_Int16x4 },
    std::pair{ &Int16x4_operator_andasg_Int16x4, &SPIRV_Int16x4_operator_andasg_Int16x4 },
    std::pair{ &Int16x4_operator_xorasg_Int16x4, &SPIRV_Int16x4_operator_xorasg_Int16x4 },
    std::pair{ &Int16x4_operator_lshasg_Int16x4, &SPIRV_Int16x4_operator_lshasg_Int16x4 },
    std::pair{ &Int16x4_operator_rhsasg_Int16x4, &SPIRV_Int16x4_operator_rhsasg_Int16x4 },
    std::pair{ &Float32x2x2_operator_index_Int32, &SPIRV_Float32x2x2_operator_index_Int32 },
    std::pair{ &Float32x2x2_operator_index_UInt32, &SPIRV_Float32x2x2_operator_index_UInt32 },
    std::pair{ &Float32x2x2_operator_index_Int16, &SPIRV_Float32x2x2_operator_index_Int16 },
    std::pair{ &Float32x2x2_operator_index_UInt16, &SPIRV_Float32x2x2_operator_index_UInt16 },
    std::pair{ &Float32x2x2_transform_Float32x2, &SPIRV_Float32x2x2_transform_Float32x2 },
    std::pair{ &Float32x2x2_operator_add_Float32x2x2, &SPIRV_Float32x2x2_operator_add_Float32x2x2 },
    std::pair{ &Float32x2x2_operator_sub_Float32x2x2, &SPIRV_Float32x2x2_operator_sub_Float32x2x2 },
    std::pair{ &Float32x2x2_operator_mul_Float32x2x2, &SPIRV_Float32x2x2_operator_mul_Float32x2x2 },
    std::pair{ &Float32x2x2_operator_addasg_Float32x2x2, &SPIRV_Float32x2x2_operator_addasg_Float32x2x2 },
    std::pair{ &Float32x2x2_operator_subasg_Float32x2x2, &SPIRV_Float32x2x2_operator_subasg_Float32x2x2 },
    std::pair{ &Float32x2x2_operator_mulasg_Float32x2x2, &SPIRV_Float32x2x2_operator_mulasg_Float32x2x2 },
    std::pair{ &Float32x2x2_operator_scale_Float32, &SPIRV_Float32x2x2_operator_scale_Float32 },
    std::pair{ &Float32x2x3_operator_index_Int32, &SPIRV_Float32x2x3_operator_index_Int32 },
    std::pair{ &Float32x2x3_operator_index_UInt32, &SPIRV_Float32x2x3_operator_index_UInt32 },
    std::pair{ &Float32x2x3_operator_index_Int16, &SPIRV_Float32x2x3_operator_index_Int16 },
    std::pair{ &Float32x2x3_operator_index_UInt16, &SPIRV_Float32x2x3_operator_index_UInt16 },
    std::pair{ &Float32x2x3_transform_Float32x3, &SPIRV_Float32x2x3_transform_Float32x3 },
    std::pair{ &Float32x2x3_operator_add_Float32x2x3, &SPIRV_Float32x2x3_operator_add_Float32x2x3 },
    std::pair{ &Float32x2x3_operator_sub_Float32x2x3, &SPIRV_Float32x2x3_operator_sub_Float32x2x3 },
    std::pair{ &Float32x2x3_operator_mul_Float32x2x3, &SPIRV_Float32x2x3_operator_mul_Float32x2x3 },
    std::pair{ &Float32x2x3_operator_addasg_Float32x2x3, &SPIRV_Float32x2x3_operator_addasg_Float32x2x3 },
    std::pair{ &Float32x2x3_operator_subasg_Float32x2x3, &SPIRV_Float32x2x3_operator_subasg_Float32x2x3 },
    std::pair{ &Float32x2x3_operator_mulasg_Float32x2x3, &SPIRV_Float32x2x3_operator_mulasg_Float32x2x3 },
    std::pair{ &Float32x2x3_operator_scale_Float32, &SPIRV_Float32x2x3_operator_scale_Float32 },
    std::pair{ &Float32x2x4_operator_index_Int32, &SPIRV_Float32x2x4_operator_index_Int32 },
    std::pair{ &Float32x2x4_operator_index_UInt32, &SPIRV_Float32x2x4_operator_index_UInt32 },
    std::pair{ &Float32x2x4_operator_index_Int16, &SPIRV_Float32x2x4_operator_index_Int16 },
    std::pair{ &Float32x2x4_operator_index_UInt16, &SPIRV_Float32x2x4_operator_index_UInt16 },
    std::pair{ &Float32x2x4_transform_Float32x4, &SPIRV_Float32x2x4_transform_Float32x4 },
    std::pair{ &Float32x2x4_operator_add_Float32x2x4, &SPIRV_Float32x2x4_operator_add_Float32x2x4 },
    std::pair{ &Float32x2x4_operator_sub_Float32x2x4, &SPIRV_Float32x2x4_operator_sub_Float32x2x4 },
    std::pair{ &Float32x2x4_operator_mul_Float32x2x4, &SPIRV_Float32x2x4_operator_mul_Float32x2x4 },
    std::pair{ &Float32x2x4_operator_addasg_Float32x2x4, &SPIRV_Float32x2x4_operator_addasg_Float32x2x4 },
    std::pair{ &Float32x2x4_operator_subasg_Float32x2x4, &SPIRV_Float32x2x4_operator_subasg_Float32x2x4 },
    std::pair{ &Float32x2x4_operator_mulasg_Float32x2x4, &SPIRV_Float32x2x4_operator_mulasg_Float32x2x4 },
    std::pair{ &Float32x2x4_operator_scale_Float32, &SPIRV_Float32x2x4_operator_scale_Float32 },
    std::pair{ &Float32x3x2_operator_index_Int32, &SPIRV_Float32x3x2_operator_index_Int32 },
    std::pair{ &Float32x3x2_operator_index_UInt32, &SPIRV_Float32x3x2_operator_index_UInt32 },
    std::pair{ &Float32x3x2_operator_index_Int16, &SPIRV_Float32x3x2_operator_index_Int16 },
    std::pair{ &Float32x3x2_operator_index_UInt16, &SPIRV_Float32x3x2_operator_index_UInt16 },
    std::pair{ &Float32x3x2_transform_Float32x2, &SPIRV_Float32x3x2_transform_Float32x2 },
    std::pair{ &Float32x3x2_operator_add_Float32x3x2, &SPIRV_Float32x3x2_operator_add_Float32x3x2 },
    std::pair{ &Float32x3x2_operator_sub_Float32x3x2, &SPIRV_Float32x3x2_operator_sub_Float32x3x2 },
    std::pair{ &Float32x3x2_operator_mul_Float32x3x2, &SPIRV_Float32x3x2_operator_mul_Float32x3x2 },
    std::pair{ &Float32x3x2_operator_addasg_Float32x3x2, &SPIRV_Float32x3x2_operator_addasg_Float32x3x2 },
    std::pair{ &Float32x3x2_operator_subasg_Float32x3x2, &SPIRV_Float32x3x2_operator_subasg_Float32x3x2 },
    std::pair{ &Float32x3x2_operator_mulasg_Float32x3x2, &SPIRV_Float32x3x2_operator_mulasg_Float32x3x2 },
    std::pair{ &Float32x3x2_operator_scale_Float32, &SPIRV_Float32x3x2_operator_scale_Float32 },
    std::pair{ &Float32x3x3_operator_index_Int32, &SPIRV_Float32x3x3_operator_index_Int32 },
    std::pair{ &Float32x3x3_operator_index_UInt32, &SPIRV_Float32x3x3_operator_index_UInt32 },
    std::pair{ &Float32x3x3_operator_index_Int16, &SPIRV_Float32x3x3_operator_index_Int16 },
    std::pair{ &Float32x3x3_operator_index_UInt16, &SPIRV_Float32x3x3_operator_index_UInt16 },
    std::pair{ &Float32x3x3_transform_Float32x3, &SPIRV_Float32x3x3_transform_Float32x3 },
    std::pair{ &Float32x3x3_operator_add_Float32x3x3, &SPIRV_Float32x3x3_operator_add_Float32x3x3 },
    std::pair{ &Float32x3x3_operator_sub_Float32x3x3, &SPIRV_Float32x3x3_operator_sub_Float32x3x3 },
    std::pair{ &Float32x3x3_operator_mul_Float32x3x3, &SPIRV_Float32x3x3_operator_mul_Float32x3x3 },
    std::pair{ &Float32x3x3_operator_addasg_Float32x3x3, &SPIRV_Float32x3x3_operator_addasg_Float32x3x3 },
    std::pair{ &Float32x3x3_operator_subasg_Float32x3x3, &SPIRV_Float32x3x3_operator_subasg_Float32x3x3 },
    std::pair{ &Float32x3x3_operator_mulasg_Float32x3x3, &SPIRV_Float32x3x3_operator_mulasg_Float32x3x3 },
    std::pair{ &Float32x3x3_operator_scale_Float32, &SPIRV_Float32x3x3_operator_scale_Float32 },
    std::pair{ &Float32x3x4_operator_index_Int32, &SPIRV_Float32x3x4_operator_index_Int32 },
    std::pair{ &Float32x3x4_operator_index_UInt32, &SPIRV_Float32x3x4_operator_index_UInt32 },
    std::pair{ &Float32x3x4_operator_index_Int16, &SPIRV_Float32x3x4_operator_index_Int16 },
    std::pair{ &Float32x3x4_operator_index_UInt16, &SPIRV_Float32x3x4_operator_index_UInt16 },
    std::pair{ &Float32x3x4_transform_Float32x4, &SPIRV_Float32x3x4_transform_Float32x4 },
    std::pair{ &Float32x3x4_operator_add_Float32x3x4, &SPIRV_Float32x3x4_operator_add_Float32x3x4 },
    std::pair{ &Float32x3x4_operator_sub_Float32x3x4, &SPIRV_Float32x3x4_operator_sub_Float32x3x4 },
    std::pair{ &Float32x3x4_operator_mul_Float32x3x4, &SPIRV_Float32x3x4_operator_mul_Float32x3x4 },
    std::pair{ &Float32x3x4_operator_addasg_Float32x3x4, &SPIRV_Float32x3x4_operator_addasg_Float32x3x4 },
    std::pair{ &Float32x3x4_operator_subasg_Float32x3x4, &SPIRV_Float32x3x4_operator_subasg_Float32x3x4 },
    std::pair{ &Float32x3x4_operator_mulasg_Float32x3x4, &SPIRV_Float32x3x4_operator_mulasg_Float32x3x4 },
    std::pair{ &Float32x3x4_operator_scale_Float32, &SPIRV_Float32x3x4_operator_scale_Float32 },
    std::pair{ &Float32x4x2_operator_index_Int32, &SPIRV_Float32x4x2_operator_index_Int32 },
    std::pair{ &Float32x4x2_operator_index_UInt32, &SPIRV_Float32x4x2_operator_index_UInt32 },
    std::pair{ &Float32x4x2_operator_index_Int16, &SPIRV_Float32x4x2_operator_index_Int16 },
    std::pair{ &Float32x4x2_operator_index_UInt16, &SPIRV_Float32x4x2_operator_index_UInt16 },
    std::pair{ &Float32x4x2_transform_Float32x2, &SPIRV_Float32x4x2_transform_Float32x2 },
    std::pair{ &Float32x4x2_operator_add_Float32x4x2, &SPIRV_Float32x4x2_operator_add_Float32x4x2 },
    std::pair{ &Float32x4x2_operator_sub_Float32x4x2, &SPIRV_Float32x4x2_operator_sub_Float32x4x2 },
    std::pair{ &Float32x4x2_operator_mul_Float32x4x2, &SPIRV_Float32x4x2_operator_mul_Float32x4x2 },
    std::pair{ &Float32x4x2_operator_addasg_Float32x4x2, &SPIRV_Float32x4x2_operator_addasg_Float32x4x2 },
    std::pair{ &Float32x4x2_operator_subasg_Float32x4x2, &SPIRV_Float32x4x2_operator_subasg_Float32x4x2 },
    std::pair{ &Float32x4x2_operator_mulasg_Float32x4x2, &SPIRV_Float32x4x2_operator_mulasg_Float32x4x2 },
    std::pair{ &Float32x4x2_operator_scale_Float32, &SPIRV_Float32x4x2_operator_scale_Float32 },
    std::pair{ &Float32x4x3_operator_index_Int32, &SPIRV_Float32x4x3_operator_index_Int32 },
    std::pair{ &Float32x4x3_operator_index_UInt32, &SPIRV_Float32x4x3_operator_index_UInt32 },
    std::pair{ &Float32x4x3_operator_index_Int16, &SPIRV_Float32x4x3_operator_index_Int16 },
    std::pair{ &Float32x4x3_operator_index_UInt16, &SPIRV_Float32x4x3_operator_index_UInt16 },
    std::pair{ &Float32x4x3_transform_Float32x3, &SPIRV_Float32x4x3_transform_Float32x3 },
    std::pair{ &Float32x4x3_operator_add_Float32x4x3, &SPIRV_Float32x4x3_operator_add_Float32x4x3 },
    std::pair{ &Float32x4x3_operator_sub_Float32x4x3, &SPIRV_Float32x4x3_operator_sub_Float32x4x3 },
    std::pair{ &Float32x4x3_operator_mul_Float32x4x3, &SPIRV_Float32x4x3_operator_mul_Float32x4x3 },
    std::pair{ &Float32x4x3_operator_addasg_Float32x4x3, &SPIRV_Float32x4x3_operator_addasg_Float32x4x3 },
    std::pair{ &Float32x4x3_operator_subasg_Float32x4x3, &SPIRV_Float32x4x3_operator_subasg_Float32x4x3 },
    std::pair{ &Float32x4x3_operator_mulasg_Float32x4x3, &SPIRV_Float32x4x3_operator_mulasg_Float32x4x3 },
    std::pair{ &Float32x4x3_operator_scale_Float32, &SPIRV_Float32x4x3_operator_scale_Float32 },
    std::pair{ &Float32x4x4_operator_index_Int32, &SPIRV_Float32x4x4_operator_index_Int32 },
    std::pair{ &Float32x4x4_operator_index_UInt32, &SPIRV_Float32x4x4_operator_index_UInt32 },
    std::pair{ &Float32x4x4_operator_index_Int16, &SPIRV_Float32x4x4_operator_index_Int16 },
    std::pair{ &Float32x4x4_operator_index_UInt16, &SPIRV_Float32x4x4_operator_index_UInt16 },
    std::pair{ &Float32x4x4_transform_Float32x4, &SPIRV_Float32x4x4_transform_Float32x4 },
    std::pair{ &Float32x4x4_operator_add_Float32x4x4, &SPIRV_Float32x4x4_operator_add_Float32x4x4 },
    std::pair{ &Float32x4x4_operator_sub_Float32x4x4, &SPIRV_Float32x4x4_operator_sub_Float32x4x4 },
    std::pair{ &Float32x4x4_operator_mul_Float32x4x4, &SPIRV_Float32x4x4_operator_mul_Float32x4x4 },
    std::pair{ &Float32x4x4_operator_addasg_Float32x4x4, &SPIRV_Float32x4x4_operator_addasg_Float32x4x4 },
    std::pair{ &Float32x4x4_operator_subasg_Float32x4x4, &SPIRV_Float32x4x4_operator_subasg_Float32x4x4 },
    std::pair{ &Float32x4x4_operator_mulasg_Float32x4x4, &SPIRV_Float32x4x4_operator_mulasg_Float32x4x4 },
    std::pair{ &Float32x4x4_operator_scale_Float32, &SPIRV_Float32x4x4_operator_scale_Float32 },
    std::pair{ &Float16x2x2_operator_index_Int32, &SPIRV_Float16x2x2_operator_index_Int32 },
    std::pair{ &Float16x2x2_operator_index_UInt32, &SPIRV_Float16x2x2_operator_index_UInt32 },
    std::pair{ &Float16x2x2_operator_index_Int16, &SPIRV_Float16x2x2_operator_index_Int16 },
    std::pair{ &Float16x2x2_operator_index_UInt16, &SPIRV_Float16x2x2_operator_index_UInt16 },
    std::pair{ &Float16x2x2_transform_Float16x2, &SPIRV_Float16x2x2_transform_Float16x2 },
    std::pair{ &Float16x2x2_operator_add_Float16x2x2, &SPIRV_Float16x2x2_operator_add_Float16x2x2 },
    std::pair{ &Float16x2x2_operator_sub_Float16x2x2, &SPIRV_Float16x2x2_operator_sub_Float16x2x2 },
    std::pair{ &Float16x2x2_operator_mul_Float16x2x2, &SPIRV_Float16x2x2_operator_mul_Float16x2x2 },
    std::pair{ &Float16x2x2_operator_addasg_Float16x2x2, &SPIRV_Float16x2x2_operator_addasg_Float16x2x2 },
    std::pair{ &Float16x2x2_operator_subasg_Float16x2x2, &SPIRV_Float16x2x2_operator_subasg_Float16x2x2 },
    std::pair{ &Float16x2x2_operator_mulasg_Float16x2x2, &SPIRV_Float16x2x2_operator_mulasg_Float16x2x2 },
    std::pair{ &Float16x2x2_operator_scale_Float16, &SPIRV_Float16x2x2_operator_scale_Float16 },
    std::pair{ &Float16x2x3_operator_index_Int32, &SPIRV_Float16x2x3_operator_index_Int32 },
    std::pair{ &Float16x2x3_operator_index_UInt32, &SPIRV_Float16x2x3_operator_index_UInt32 },
    std::pair{ &Float16x2x3_operator_index_Int16, &SPIRV_Float16x2x3_operator_index_Int16 },
    std::pair{ &Float16x2x3_operator_index_UInt16, &SPIRV_Float16x2x3_operator_index_UInt16 },
    std::pair{ &Float16x2x3_transform_Float16x3, &SPIRV_Float16x2x3_transform_Float16x3 },
    std::pair{ &Float16x2x3_operator_add_Float16x2x3, &SPIRV_Float16x2x3_operator_add_Float16x2x3 },
    std::pair{ &Float16x2x3_operator_sub_Float16x2x3, &SPIRV_Float16x2x3_operator_sub_Float16x2x3 },
    std::pair{ &Float16x2x3_operator_mul_Float16x2x3, &SPIRV_Float16x2x3_operator_mul_Float16x2x3 },
    std::pair{ &Float16x2x3_operator_addasg_Float16x2x3, &SPIRV_Float16x2x3_operator_addasg_Float16x2x3 },
    std::pair{ &Float16x2x3_operator_subasg_Float16x2x3, &SPIRV_Float16x2x3_operator_subasg_Float16x2x3 },
    std::pair{ &Float16x2x3_operator_mulasg_Float16x2x3, &SPIRV_Float16x2x3_operator_mulasg_Float16x2x3 },
    std::pair{ &Float16x2x3_operator_scale_Float16, &SPIRV_Float16x2x3_operator_scale_Float16 },
    std::pair{ &Float16x2x4_operator_index_Int32, &SPIRV_Float16x2x4_operator_index_Int32 },
    std::pair{ &Float16x2x4_operator_index_UInt32, &SPIRV_Float16x2x4_operator_index_UInt32 },
    std::pair{ &Float16x2x4_operator_index_Int16, &SPIRV_Float16x2x4_operator_index_Int16 },
    std::pair{ &Float16x2x4_operator_index_UInt16, &SPIRV_Float16x2x4_operator_index_UInt16 },
    std::pair{ &Float16x2x4_transform_Float16x4, &SPIRV_Float16x2x4_transform_Float16x4 },
    std::pair{ &Float16x2x4_operator_add_Float16x2x4, &SPIRV_Float16x2x4_operator_add_Float16x2x4 },
    std::pair{ &Float16x2x4_operator_sub_Float16x2x4, &SPIRV_Float16x2x4_operator_sub_Float16x2x4 },
    std::pair{ &Float16x2x4_operator_mul_Float16x2x4, &SPIRV_Float16x2x4_operator_mul_Float16x2x4 },
    std::pair{ &Float16x2x4_operator_addasg_Float16x2x4, &SPIRV_Float16x2x4_operator_addasg_Float16x2x4 },
    std::pair{ &Float16x2x4_operator_subasg_Float16x2x4, &SPIRV_Float16x2x4_operator_subasg_Float16x2x4 },
    std::pair{ &Float16x2x4_operator_mulasg_Float16x2x4, &SPIRV_Float16x2x4_operator_mulasg_Float16x2x4 },
    std::pair{ &Float16x2x4_operator_scale_Float16, &SPIRV_Float16x2x4_operator_scale_Float16 },
    std::pair{ &Float16x3x2_operator_index_Int32, &SPIRV_Float16x3x2_operator_index_Int32 },
    std::pair{ &Float16x3x2_operator_index_UInt32, &SPIRV_Float16x3x2_operator_index_UInt32 },
    std::pair{ &Float16x3x2_operator_index_Int16, &SPIRV_Float16x3x2_operator_index_Int16 },
    std::pair{ &Float16x3x2_operator_index_UInt16, &SPIRV_Float16x3x2_operator_index_UInt16 },
    std::pair{ &Float16x3x2_transform_Float16x2, &SPIRV_Float16x3x2_transform_Float16x2 },
    std::pair{ &Float16x3x2_operator_add_Float16x3x2, &SPIRV_Float16x3x2_operator_add_Float16x3x2 },
    std::pair{ &Float16x3x2_operator_sub_Float16x3x2, &SPIRV_Float16x3x2_operator_sub_Float16x3x2 },
    std::pair{ &Float16x3x2_operator_mul_Float16x3x2, &SPIRV_Float16x3x2_operator_mul_Float16x3x2 },
    std::pair{ &Float16x3x2_operator_addasg_Float16x3x2, &SPIRV_Float16x3x2_operator_addasg_Float16x3x2 },
    std::pair{ &Float16x3x2_operator_subasg_Float16x3x2, &SPIRV_Float16x3x2_operator_subasg_Float16x3x2 },
    std::pair{ &Float16x3x2_operator_mulasg_Float16x3x2, &SPIRV_Float16x3x2_operator_mulasg_Float16x3x2 },
    std::pair{ &Float16x3x2_operator_scale_Float16, &SPIRV_Float16x3x2_operator_scale_Float16 },
    std::pair{ &Float16x3x3_operator_index_Int32, &SPIRV_Float16x3x3_operator_index_Int32 },
    std::pair{ &Float16x3x3_operator_index_UInt32, &SPIRV_Float16x3x3_operator_index_UInt32 },
    std::pair{ &Float16x3x3_operator_index_Int16, &SPIRV_Float16x3x3_operator_index_Int16 },
    std::pair{ &Float16x3x3_operator_index_UInt16, &SPIRV_Float16x3x3_operator_index_UInt16 },
    std::pair{ &Float16x3x3_transform_Float16x3, &SPIRV_Float16x3x3_transform_Float16x3 },
    std::pair{ &Float16x3x3_operator_add_Float16x3x3, &SPIRV_Float16x3x3_operator_add_Float16x3x3 },
    std::pair{ &Float16x3x3_operator_sub_Float16x3x3, &SPIRV_Float16x3x3_operator_sub_Float16x3x3 },
    std::pair{ &Float16x3x3_operator_mul_Float16x3x3, &SPIRV_Float16x3x3_operator_mul_Float16x3x3 },
    std::pair{ &Float16x3x3_operator_addasg_Float16x3x3, &SPIRV_Float16x3x3_operator_addasg_Float16x3x3 },
    std::pair{ &Float16x3x3_operator_subasg_Float16x3x3, &SPIRV_Float16x3x3_operator_subasg_Float16x3x3 },
    std::pair{ &Float16x3x3_operator_mulasg_Float16x3x3, &SPIRV_Float16x3x3_operator_mulasg_Float16x3x3 },
    std::pair{ &Float16x3x3_operator_scale_Float16, &SPIRV_Float16x3x3_operator_scale_Float16 },
    std::pair{ &Float16x3x4_operator_index_Int32, &SPIRV_Float16x3x4_operator_index_Int32 },
    std::pair{ &Float16x3x4_operator_index_UInt32, &SPIRV_Float16x3x4_operator_index_UInt32 },
    std::pair{ &Float16x3x4_operator_index_Int16, &SPIRV_Float16x3x4_operator_index_Int16 },
    std::pair{ &Float16x3x4_operator_index_UInt16, &SPIRV_Float16x3x4_operator_index_UInt16 },
    std::pair{ &Float16x3x4_transform_Float16x4, &SPIRV_Float16x3x4_transform_Float16x4 },
    std::pair{ &Float16x3x4_operator_add_Float16x3x4, &SPIRV_Float16x3x4_operator_add_Float16x3x4 },
    std::pair{ &Float16x3x4_operator_sub_Float16x3x4, &SPIRV_Float16x3x4_operator_sub_Float16x3x4 },
    std::pair{ &Float16x3x4_operator_mul_Float16x3x4, &SPIRV_Float16x3x4_operator_mul_Float16x3x4 },
    std::pair{ &Float16x3x4_operator_addasg_Float16x3x4, &SPIRV_Float16x3x4_operator_addasg_Float16x3x4 },
    std::pair{ &Float16x3x4_operator_subasg_Float16x3x4, &SPIRV_Float16x3x4_operator_subasg_Float16x3x4 },
    std::pair{ &Float16x3x4_operator_mulasg_Float16x3x4, &SPIRV_Float16x3x4_operator_mulasg_Float16x3x4 },
    std::pair{ &Float16x3x4_operator_scale_Float16, &SPIRV_Float16x3x4_operator_scale_Float16 },
    std::pair{ &Float16x4x2_operator_index_Int32, &SPIRV_Float16x4x2_operator_index_Int32 },
    std::pair{ &Float16x4x2_operator_index_UInt32, &SPIRV_Float16x4x2_operator_index_UInt32 },
    std::pair{ &Float16x4x2_operator_index_Int16, &SPIRV_Float16x4x2_operator_index_Int16 },
    std::pair{ &Float16x4x2_operator_index_UInt16, &SPIRV_Float16x4x2_operator_index_UInt16 },
    std::pair{ &Float16x4x2_transform_Float16x2, &SPIRV_Float16x4x2_transform_Float16x2 },
    std::pair{ &Float16x4x2_operator_add_Float16x4x2, &SPIRV_Float16x4x2_operator_add_Float16x4x2 },
    std::pair{ &Float16x4x2_operator_sub_Float16x4x2, &SPIRV_Float16x4x2_operator_sub_Float16x4x2 },
    std::pair{ &Float16x4x2_operator_mul_Float16x4x2, &SPIRV_Float16x4x2_operator_mul_Float16x4x2 },
    std::pair{ &Float16x4x2_operator_addasg_Float16x4x2, &SPIRV_Float16x4x2_operator_addasg_Float16x4x2 },
    std::pair{ &Float16x4x2_operator_subasg_Float16x4x2, &SPIRV_Float16x4x2_operator_subasg_Float16x4x2 },
    std::pair{ &Float16x4x2_operator_mulasg_Float16x4x2, &SPIRV_Float16x4x2_operator_mulasg_Float16x4x2 },
    std::pair{ &Float16x4x2_operator_scale_Float16, &SPIRV_Float16x4x2_operator_scale_Float16 },
    std::pair{ &Float16x4x3_operator_index_Int32, &SPIRV_Float16x4x3_operator_index_Int32 },
    std::pair{ &Float16x4x3_operator_index_UInt32, &SPIRV_Float16x4x3_operator_index_UInt32 },
    std::pair{ &Float16x4x3_operator_index_Int16, &SPIRV_Float16x4x3_operator_index_Int16 },
    std::pair{ &Float16x4x3_operator_index_UInt16, &SPIRV_Float16x4x3_operator_index_UInt16 },
    std::pair{ &Float16x4x3_transform_Float16x3, &SPIRV_Float16x4x3_transform_Float16x3 },
    std::pair{ &Float16x4x3_operator_add_Float16x4x3, &SPIRV_Float16x4x3_operator_add_Float16x4x3 },
    std::pair{ &Float16x4x3_operator_sub_Float16x4x3, &SPIRV_Float16x4x3_operator_sub_Float16x4x3 },
    std::pair{ &Float16x4x3_operator_mul_Float16x4x3, &SPIRV_Float16x4x3_operator_mul_Float16x4x3 },
    std::pair{ &Float16x4x3_operator_addasg_Float16x4x3, &SPIRV_Float16x4x3_operator_addasg_Float16x4x3 },
    std::pair{ &Float16x4x3_operator_subasg_Float16x4x3, &SPIRV_Float16x4x3_operator_subasg_Float16x4x3 },
    std::pair{ &Float16x4x3_operator_mulasg_Float16x4x3, &SPIRV_Float16x4x3_operator_mulasg_Float16x4x3 },
    std::pair{ &Float16x4x3_operator_scale_Float16, &SPIRV_Float16x4x3_operator_scale_Float16 },
    std::pair{ &Float16x4x4_operator_index_Int32, &SPIRV_Float16x4x4_operator_index_Int32 },
    std::pair{ &Float16x4x4_operator_index_UInt32, &SPIRV_Float16x4x4_operator_index_UInt32 },
    std::pair{ &Float16x4x4_operator_index_Int16, &SPIRV_Float16x4x4_operator_index_Int16 },
    std::pair{ &Float16x4x4_operator_index_UInt16, &SPIRV_Float16x4x4_operator_index_UInt16 },
    std::pair{ &Float16x4x4_transform_Float16x4, &SPIRV_Float16x4x4_transform_Float16x4 },
    std::pair{ &Float16x4x4_operator_add_Float16x4x4, &SPIRV_Float16x4x4_operator_add_Float16x4x4 },
    std::pair{ &Float16x4x4_operator_sub_Float16x4x4, &SPIRV_Float16x4x4_operator_sub_Float16x4x4 },
    std::pair{ &Float16x4x4_operator_mul_Float16x4x4, &SPIRV_Float16x4x4_operator_mul_Float16x4x4 },
    std::pair{ &Float16x4x4_operator_addasg_Float16x4x4, &SPIRV_Float16x4x4_operator_addasg_Float16x4x4 },
    std::pair{ &Float16x4x4_operator_subasg_Float16x4x4, &SPIRV_Float16x4x4_operator_subasg_Float16x4x4 },
    std::pair{ &Float16x4x4_operator_mulasg_Float16x4x4, &SPIRV_Float16x4x4_operator_mulasg_Float16x4x4 },
    std::pair{ &Float16x4x4_operator_scale_Float16, &SPIRV_Float16x4x4_operator_scale_Float16 },
    std::pair{ &acos_Float32, &SPIRV_acos_Float32 },
    std::pair{ &acos_Float32x2, &SPIRV_acos_Float32x2 },
    std::pair{ &acos_Float32x3, &SPIRV_acos_Float32x3 },
    std::pair{ &acos_Float32x4, &SPIRV_acos_Float32x4 },
    std::pair{ &acos_Float16, &SPIRV_acos_Float16 },
    std::pair{ &acos_Float16x2, &SPIRV_acos_Float16x2 },
    std::pair{ &acos_Float16x3, &SPIRV_acos_Float16x3 },
    std::pair{ &acos_Float16x4, &SPIRV_acos_Float16x4 },
    std::pair{ &acosh_Float32, &SPIRV_acosh_Float32 },
    std::pair{ &acosh_Float32x2, &SPIRV_acosh_Float32x2 },
    std::pair{ &acosh_Float32x3, &SPIRV_acosh_Float32x3 },
    std::pair{ &acosh_Float32x4, &SPIRV_acosh_Float32x4 },
    std::pair{ &acosh_Float16, &SPIRV_acosh_Float16 },
    std::pair{ &acosh_Float16x2, &SPIRV_acosh_Float16x2 },
    std::pair{ &acosh_Float16x3, &SPIRV_acosh_Float16x3 },
    std::pair{ &acosh_Float16x4, &SPIRV_acosh_Float16x4 },
    std::pair{ &asin_Float32, &SPIRV_asin_Float32 },
    std::pair{ &asin_Float32x2, &SPIRV_asin_Float32x2 },
    std::pair{ &asin_Float32x3, &SPIRV_asin_Float32x3 },
    std::pair{ &asin_Float32x4, &SPIRV_asin_Float32x4 },
    std::pair{ &asin_Float16, &SPIRV_asin_Float16 },
    std::pair{ &asin_Float16x2, &SPIRV_asin_Float16x2 },
    std::pair{ &asin_Float16x3, &SPIRV_asin_Float16x3 },
    std::pair{ &asin_Float16x4, &SPIRV_asin_Float16x4 },
    std::pair{ &asinh_Float32, &SPIRV_asinh_Float32 },
    std::pair{ &asinh_Float32x2, &SPIRV_asinh_Float32x2 },
    std::pair{ &asinh_Float32x3, &SPIRV_asinh_Float32x3 },
    std::pair{ &asinh_Float32x4, &SPIRV_asinh_Float32x4 },
    std::pair{ &asinh_Float16, &SPIRV_asinh_Float16 },
    std::pair{ &asinh_Float16x2, &SPIRV_asinh_Float16x2 },
    std::pair{ &asinh_Float16x3, &SPIRV_asinh_Float16x3 },
    std::pair{ &asinh_Float16x4, &SPIRV_asinh_Float16x4 },
    std::pair{ &atan_Float32, &SPIRV_atan_Float32 },
    std::pair{ &atan_Float32x2, &SPIRV_atan_Float32x2 },
    std::pair{ &atan_Float32x3, &SPIRV_atan_Float32x3 },
    std::pair{ &atan_Float32x4, &SPIRV_atan_Float32x4 },
    std::pair{ &atan_Float16, &SPIRV_atan_Float16 },
    std::pair{ &atan_Float16x2, &SPIRV_atan_Float16x2 },
    std::pair{ &atan_Float16x3, &SPIRV_atan_Float16x3 },
    std::pair{ &atan_Float16x4, &SPIRV_atan_Float16x4 },
    std::pair{ &atanh_Float32, &SPIRV_atanh_Float32 },
    std::pair{ &atanh_Float32x2, &SPIRV_atanh_Float32x2 },
    std::pair{ &atanh_Float32x3, &SPIRV_atanh_Float32x3 },
    std::pair{ &atanh_Float32x4, &SPIRV_atanh_Float32x4 },
    std::pair{ &atanh_Float16, &SPIRV_atanh_Float16 },
    std::pair{ &atanh_Float16x2, &SPIRV_atanh_Float16x2 },
    std::pair{ &atanh_Float16x3, &SPIRV_atanh_Float16x3 },
    std::pair{ &atanh_Float16x4, &SPIRV_atanh_Float16x4 },
    std::pair{ &cos_Float32, &SPIRV_cos_Float32 },
    std::pair{ &cos_Float32x2, &SPIRV_cos_Float32x2 },
    std::pair{ &cos_Float32x3, &SPIRV_cos_Float32x3 },
    std::pair{ &cos_Float32x4, &SPIRV_cos_Float32x4 },
    std::pair{ &cos_Float16, &SPIRV_cos_Float16 },
    std::pair{ &cos_Float16x2, &SPIRV_cos_Float16x2 },
    std::pair{ &cos_Float16x3, &SPIRV_cos_Float16x3 },
    std::pair{ &cos_Float16x4, &SPIRV_cos_Float16x4 },
    std::pair{ &cosh_Float32, &SPIRV_cosh_Float32 },
    std::pair{ &cosh_Float32x2, &SPIRV_cosh_Float32x2 },
    std::pair{ &cosh_Float32x3, &SPIRV_cosh_Float32x3 },
    std::pair{ &cosh_Float32x4, &SPIRV_cosh_Float32x4 },
    std::pair{ &cosh_Float16, &SPIRV_cosh_Float16 },
    std::pair{ &cosh_Float16x2, &SPIRV_cosh_Float16x2 },
    std::pair{ &cosh_Float16x3, &SPIRV_cosh_Float16x3 },
    std::pair{ &cosh_Float16x4, &SPIRV_cosh_Float16x4 },
    std::pair{ &exp_Float32, &SPIRV_exp_Float32 },
    std::pair{ &exp_Float32x2, &SPIRV_exp_Float32x2 },
    std::pair{ &exp_Float32x3, &SPIRV_exp_Float32x3 },
    std::pair{ &exp_Float32x4, &SPIRV_exp_Float32x4 },
    std::pair{ &exp_Float16, &SPIRV_exp_Float16 },
    std::pair{ &exp_Float16x2, &SPIRV_exp_Float16x2 },
    std::pair{ &exp_Float16x3, &SPIRV_exp_Float16x3 },
    std::pair{ &exp_Float16x4, &SPIRV_exp_Float16x4 },
    std::pair{ &exp2_Float32, &SPIRV_exp2_Float32 },
    std::pair{ &exp2_Float32x2, &SPIRV_exp2_Float32x2 },
    std::pair{ &exp2_Float32x3, &SPIRV_exp2_Float32x3 },
    std::pair{ &exp2_Float32x4, &SPIRV_exp2_Float32x4 },
    std::pair{ &exp2_Float16, &SPIRV_exp2_Float16 },
    std::pair{ &exp2_Float16x2, &SPIRV_exp2_Float16x2 },
    std::pair{ &exp2_Float16x3, &SPIRV_exp2_Float16x3 },
    std::pair{ &exp2_Float16x4, &SPIRV_exp2_Float16x4 },
    std::pair{ &invSqrt_Float32, &SPIRV_invSqrt_Float32 },
    std::pair{ &invSqrt_Float32x2, &SPIRV_invSqrt_Float32x2 },
    std::pair{ &invSqrt_Float32x3, &SPIRV_invSqrt_Float32x3 },
    std::pair{ &invSqrt_Float32x4, &SPIRV_invSqrt_Float32x4 },
    std::pair{ &invSqrt_Float16, &SPIRV_invSqrt_Float16 },
    std::pair{ &invSqrt_Float16x2, &SPIRV_invSqrt_Float16x2 },
    std::pair{ &invSqrt_Float16x3, &SPIRV_invSqrt_Float16x3 },
    std::pair{ &invSqrt_Float16x4, &SPIRV_invSqrt_Float16x4 },
    std::pair{ &log_Float32, &SPIRV_log_Float32 },
    std::pair{ &log_Float32x2, &SPIRV_log_Float32x2 },
    std::pair{ &log_Float32x3, &SPIRV_log_Float32x3 },
    std::pair{ &log_Float32x4, &SPIRV_log_Float32x4 },
    std::pair{ &log_Float16, &SPIRV_log_Float16 },
    std::pair{ &log_Float16x2, &SPIRV_log_Float16x2 },
    std::pair{ &log_Float16x3, &SPIRV_log_Float16x3 },
    std::pair{ &log_Float16x4, &SPIRV_log_Float16x4 },
    std::pair{ &log2_Float32, &SPIRV_log2_Float32 },
    std::pair{ &log2_Float32x2, &SPIRV_log2_Float32x2 },
    std::pair{ &log2_Float32x3, &SPIRV_log2_Float32x3 },
    std::pair{ &log2_Float32x4, &SPIRV_log2_Float32x4 },
    std::pair{ &log2_Float16, &SPIRV_log2_Float16 },
    std::pair{ &log2_Float16x2, &SPIRV_log2_Float16x2 },
    std::pair{ &log2_Float16x3, &SPIRV_log2_Float16x3 },
    std::pair{ &log2_Float16x4, &SPIRV_log2_Float16x4 },
    std::pair{ &sin_Float32, &SPIRV_sin_Float32 },
    std::pair{ &sin_Float32x2, &SPIRV_sin_Float32x2 },
    std::pair{ &sin_Float32x3, &SPIRV_sin_Float32x3 },
    std::pair{ &sin_Float32x4, &SPIRV_sin_Float32x4 },
    std::pair{ &sin_Float16, &SPIRV_sin_Float16 },
    std::pair{ &sin_Float16x2, &SPIRV_sin_Float16x2 },
    std::pair{ &sin_Float16x3, &SPIRV_sin_Float16x3 },
    std::pair{ &sin_Float16x4, &SPIRV_sin_Float16x4 },
    std::pair{ &sinh_Float32, &SPIRV_sinh_Float32 },
    std::pair{ &sinh_Float32x2, &SPIRV_sinh_Float32x2 },
    std::pair{ &sinh_Float32x3, &SPIRV_sinh_Float32x3 },
    std::pair{ &sinh_Float32x4, &SPIRV_sinh_Float32x4 },
    std::pair{ &sinh_Float16, &SPIRV_sinh_Float16 },
    std::pair{ &sinh_Float16x2, &SPIRV_sinh_Float16x2 },
    std::pair{ &sinh_Float16x3, &SPIRV_sinh_Float16x3 },
    std::pair{ &sinh_Float16x4, &SPIRV_sinh_Float16x4 },
    std::pair{ &sqrt_Float32, &SPIRV_sqrt_Float32 },
    std::pair{ &sqrt_Float32x2, &SPIRV_sqrt_Float32x2 },
    std::pair{ &sqrt_Float32x3, &SPIRV_sqrt_Float32x3 },
    std::pair{ &sqrt_Float32x4, &SPIRV_sqrt_Float32x4 },
    std::pair{ &sqrt_Float16, &SPIRV_sqrt_Float16 },
    std::pair{ &sqrt_Float16x2, &SPIRV_sqrt_Float16x2 },
    std::pair{ &sqrt_Float16x3, &SPIRV_sqrt_Float16x3 },
    std::pair{ &sqrt_Float16x4, &SPIRV_sqrt_Float16x4 },
    std::pair{ &tan_Float32, &SPIRV_tan_Float32 },
    std::pair{ &tan_Float32x2, &SPIRV_tan_Float32x2 },
    std::pair{ &tan_Float32x3, &SPIRV_tan_Float32x3 },
    std::pair{ &tan_Float32x4, &SPIRV_tan_Float32x4 },
    std::pair{ &tan_Float16, &SPIRV_tan_Float16 },
    std::pair{ &tan_Float16x2, &SPIRV_tan_Float16x2 },
    std::pair{ &tan_Float16x3, &SPIRV_tan_Float16x3 },
    std::pair{ &tan_Float16x4, &SPIRV_tan_Float16x4 },
    std::pair{ &tanh_Float32, &SPIRV_tanh_Float32 },
    std::pair{ &tanh_Float32x2, &SPIRV_tanh_Float32x2 },
    std::pair{ &tanh_Float32x3, &SPIRV_tanh_Float32x3 },
    std::pair{ &tanh_Float32x4, &SPIRV_tanh_Float32x4 },
    std::pair{ &tanh_Float16, &SPIRV_tanh_Float16 },
    std::pair{ &tanh_Float16x2, &SPIRV_tanh_Float16x2 },
    std::pair{ &tanh_Float16x3, &SPIRV_tanh_Float16x3 },
    std::pair{ &tanh_Float16x4, &SPIRV_tanh_Float16x4 },
    std::pair{ &atan2_Float32, &SPIRV_atan2_Float32 },
    std::pair{ &atan2_Float32x2, &SPIRV_atan2_Float32x2 },
    std::pair{ &atan2_Float32x3, &SPIRV_atan2_Float32x3 },
    std::pair{ &atan2_Float32x4, &SPIRV_atan2_Float32x4 },
    std::pair{ &atan2_Float16, &SPIRV_atan2_Float16 },
    std::pair{ &atan2_Float16x2, &SPIRV_atan2_Float16x2 },
    std::pair{ &atan2_Float16x3, &SPIRV_atan2_Float16x3 },
    std::pair{ &atan2_Float16x4, &SPIRV_atan2_Float16x4 },
    std::pair{ &pow_Float32, &SPIRV_pow_Float32 },
    std::pair{ &pow_Float32x2, &SPIRV_pow_Float32x2 },
    std::pair{ &pow_Float32x3, &SPIRV_pow_Float32x3 },
    std::pair{ &pow_Float32x4, &SPIRV_pow_Float32x4 },
    std::pair{ &pow_Float16, &SPIRV_pow_Float16 },
    std::pair{ &pow_Float16x2, &SPIRV_pow_Float16x2 },
    std::pair{ &pow_Float16x3, &SPIRV_pow_Float16x3 },
    std::pair{ &pow_Float16x4, &SPIRV_pow_Float16x4 },
    std::pair{ &mad_Float32, &SPIRV_mad_Float32 },
    std::pair{ &mad_Float32x2, &SPIRV_mad_Float32x2 },
    std::pair{ &mad_Float32x3, &SPIRV_mad_Float32x3 },
    std::pair{ &mad_Float32x4, &SPIRV_mad_Float32x4 },
    std::pair{ &mad_Float16, &SPIRV_mad_Float16 },
    std::pair{ &mad_Float16x2, &SPIRV_mad_Float16x2 },
    std::pair{ &mad_Float16x3, &SPIRV_mad_Float16x3 },
    std::pair{ &mad_Float16x4, &SPIRV_mad_Float16x4 },
    std::pair{ &mad_Int32, &SPIRV_mad_Int32 },
    std::pair{ &mad_Int32x2, &SPIRV_mad_Int32x2 },
    std::pair{ &mad_Int32x3, &SPIRV_mad_Int32x3 },
    std::pair{ &mad_Int32x4, &SPIRV_mad_Int32x4 },
    std::pair{ &mad_Int16, &SPIRV_mad_Int16 },
    std::pair{ &mad_Int16x2, &SPIRV_mad_Int16x2 },
    std::pair{ &mad_Int16x3, &SPIRV_mad_Int16x3 },
    std::pair{ &mad_Int16x4, &SPIRV_mad_Int16x4 },
    std::pair{ &mad_UInt32, &SPIRV_mad_UInt32 },
    std::pair{ &mad_UInt32x2, &SPIRV_mad_UInt32x2 },
    std::pair{ &mad_UInt32x3, &SPIRV_mad_UInt32x3 },
    std::pair{ &mad_UInt32x4, &SPIRV_mad_UInt32x4 },
    std::pair{ &mad_UInt16, &SPIRV_mad_UInt16 },
    std::pair{ &mad_UInt16x2, &SPIRV_mad_UInt16x2 },
    std::pair{ &mad_UInt16x3, &SPIRV_mad_UInt16x3 },
    std::pair{ &mad_UInt16x4, &SPIRV_mad_UInt16x4 },
    std::pair{ &dot_Float32x2, &SPIRV_dot_Float32x2 },
    std::pair{ &dot_Float32x3, &SPIRV_dot_Float32x3 },
    std::pair{ &dot_Float32x4, &SPIRV_dot_Float32x4 },
    std::pair{ &dot_Float16x2, &SPIRV_dot_Float16x2 },
    std::pair{ &dot_Float16x3, &SPIRV_dot_Float16x3 },
    std::pair{ &dot_Float16x4, &SPIRV_dot_Float16x4 },
    std::pair{ &reflect_Float32x2, &SPIRV_reflect_Float32x2 },
    std::pair{ &reflect_Float32x3, &SPIRV_reflect_Float32x3 },
    std::pair{ &reflect_Float32x4, &SPIRV_reflect_Float32x4 },
    std::pair{ &reflect_Float16x2, &SPIRV_reflect_Float16x2 },
    std::pair{ &reflect_Float16x3, &SPIRV_reflect_Float16x3 },
    std::pair{ &reflect_Float16x4, &SPIRV_reflect_Float16x4 },
    std::pair{ &refract_Float32x2, &SPIRV_refract_Float32x2 },
    std::pair{ &refract_Float32x3, &SPIRV_refract_Float32x3 },
    std::pair{ &refract_Float32x4, &SPIRV_refract_Float32x4 },
    std::pair{ &refract_Float16x2, &SPIRV_refract_Float16x2 },
    std::pair{ &refract_Float16x3, &SPIRV_refract_Float16x3 },
    std::pair{ &refract_Float16x4, &SPIRV_refract_Float16x4 },
    std::pair{ &cross_Float32x3, &SPIRV_cross_Float32x3 },
    std::pair{ &cross_Float16x3, &SPIRV_cross_Float16x3 },
    std::pair{ &length_Float32x2, &SPIRV_length_Float32x2 },
    std::pair{ &length_Float32x3, &SPIRV_length_Float32x3 },
    std::pair{ &length_Float32x4, &SPIRV_length_Float32x4 },
    std::pair{ &length_Float16x2, &SPIRV_length_Float16x2 },
    std::pair{ &length_Float16x3, &SPIRV_length_Float16x3 },
    std::pair{ &length_Float16x4, &SPIRV_length_Float16x4 },
    std::pair{ &normalize_Float32x2, &SPIRV_normalize_Float32x2 },
    std::pair{ &normalize_Float32x3, &SPIRV_normalize_Float32x3 },
    std::pair{ &normalize_Float32x4, &SPIRV_normalize_Float32x4 },
    std::pair{ &normalize_Float16x2, &SPIRV_normalize_Float16x2 },
    std::pair{ &normalize_Float16x3, &SPIRV_normalize_Float16x3 },
    std::pair{ &normalize_Float16x4, &SPIRV_normalize_Float16x4 },
    std::pair{ &distance_Float32x2, &SPIRV_distance_Float32x2 },
    std::pair{ &distance_Float32x3, &SPIRV_distance_Float32x3 },
    std::pair{ &distance_Float32x4, &SPIRV_distance_Float32x4 },
    std::pair{ &distance_Float16x2, &SPIRV_distance_Float16x2 },
    std::pair{ &distance_Float16x3, &SPIRV_distance_Float16x3 },
    std::pair{ &distance_Float16x4, &SPIRV_distance_Float16x4 },
    std::pair{ &min_Float32, &SPIRV_min_Float32 },
    std::pair{ &min_Float32x2, &SPIRV_min_Float32x2 },
    std::pair{ &min_Float32x3, &SPIRV_min_Float32x3 },
    std::pair{ &min_Float32x4, &SPIRV_min_Float32x4 },
    std::pair{ &min_Float16, &SPIRV_min_Float16 },
    std::pair{ &min_Float16x2, &SPIRV_min_Float16x2 },
    std::pair{ &min_Float16x3, &SPIRV_min_Float16x3 },
    std::pair{ &min_Float16x4, &SPIRV_min_Float16x4 },
    std::pair{ &min_Int32, &SPIRV_min_Int32 },
    std::pair{ &min_Int32x2, &SPIRV_min_Int32x2 },
    std::pair{ &min_Int32x3, &SPIRV_min_Int32x3 },
    std::pair{ &min_Int32x4, &SPIRV_min_Int32x4 },
    std::pair{ &min_Int16, &SPIRV_min_Int16 },
    std::pair{ &min_Int16x2, &SPIRV_min_Int16x2 },
    std::pair{ &min_Int16x3, &SPIRV_min_Int16x3 },
    std::pair{ &min_Int16x4, &SPIRV_min_Int16x4 },
    std::pair{ &min_UInt32, &SPIRV_min_UInt32 },
    std::pair{ &min_UInt32x2, &SPIRV_min_UInt32x2 },
    std::pair{ &min_UInt32x3, &SPIRV_min_UInt32x3 },
    std::pair{ &min_UInt32x4, &SPIRV_min_UInt32x4 },
    std::pair{ &min_UInt16, &SPIRV_min_UInt16 },
    std::pair{ &min_UInt16x2, &SPIRV_min_UInt16x2 },
    std::pair{ &min_UInt16x3, &SPIRV_min_UInt16x3 },
    std::pair{ &min_UInt16x4, &SPIRV_min_UInt16x4 },
    std::pair{ &max_Float32, &SPIRV_max_Float32 },
    std::pair{ &max_Float32x2, &SPIRV_max_Float32x2 },
    std::pair{ &max_Float32x3, &SPIRV_max_Float32x3 },
    std::pair{ &max_Float32x4, &SPIRV_max_Float32x4 },
    std::pair{ &max_Float16, &SPIRV_max_Float16 },
    std::pair{ &max_Float16x2, &SPIRV_max_Float16x2 },
    std::pair{ &max_Float16x3, &SPIRV_max_Float16x3 },
    std::pair{ &max_Float16x4, &SPIRV_max_Float16x4 },
    std::pair{ &max_Int32, &SPIRV_max_Int32 },
    std::pair{ &max_Int32x2, &SPIRV_max_Int32x2 },
    std::pair{ &max_Int32x3, &SPIRV_max_Int32x3 },
    std::pair{ &max_Int32x4, &SPIRV_max_Int32x4 },
    std::pair{ &max_Int16, &SPIRV_max_Int16 },
    std::pair{ &max_Int16x2, &SPIRV_max_Int16x2 },
    std::pair{ &max_Int16x3, &SPIRV_max_Int16x3 },
    std::pair{ &max_Int16x4, &SPIRV_max_Int16x4 },
    std::pair{ &max_UInt32, &SPIRV_max_UInt32 },
    std::pair{ &max_UInt32x2, &SPIRV_max_UInt32x2 },
    std::pair{ &max_UInt32x3, &SPIRV_max_UInt32x3 },
    std::pair{ &max_UInt32x4, &SPIRV_max_UInt32x4 },
    std::pair{ &max_UInt16, &SPIRV_max_UInt16 },
    std::pair{ &max_UInt16x2, &SPIRV_max_UInt16x2 },
    std::pair{ &max_UInt16x3, &SPIRV_max_UInt16x3 },
    std::pair{ &max_UInt16x4, &SPIRV_max_UInt16x4 },
    std::pair{ &clamp_Float32, &SPIRV_clamp_Float32 },
    std::pair{ &clamp_Float32x2, &SPIRV_clamp_Float32x2 },
    std::pair{ &clamp_Float32x3, &SPIRV_clamp_Float32x3 },
    std::pair{ &clamp_Float32x4, &SPIRV_clamp_Float32x4 },
    std::pair{ &clamp_Float16, &SPIRV_clamp_Float16 },
    std::pair{ &clamp_Float16x2, &SPIRV_clamp_Float16x2 },
    std::pair{ &clamp_Float16x3, &SPIRV_clamp_Float16x3 },
    std::pair{ &clamp_Float16x4, &SPIRV_clamp_Float16x4 },
    std::pair{ &clamp_Int32, &SPIRV_clamp_Int32 },
    std::pair{ &clamp_Int32x2, &SPIRV_clamp_Int32x2 },
    std::pair{ &clamp_Int32x3, &SPIRV_clamp_Int32x3 },
    std::pair{ &clamp_Int32x4, &SPIRV_clamp_Int32x4 },
    std::pair{ &clamp_Int16, &SPIRV_clamp_Int16 },
    std::pair{ &clamp_Int16x2, &SPIRV_clamp_Int16x2 },
    std::pair{ &clamp_Int16x3, &SPIRV_clamp_Int16x3 },
    std::pair{ &clamp_Int16x4, &SPIRV_clamp_Int16x4 },
    std::pair{ &clamp_UInt32, &SPIRV_clamp_UInt32 },
    std::pair{ &clamp_UInt32x2, &SPIRV_clamp_UInt32x2 },
    std::pair{ &clamp_UInt32x3, &SPIRV_clamp_UInt32x3 },
    std::pair{ &clamp_UInt32x4, &SPIRV_clamp_UInt32x4 },
    std::pair{ &clamp_UInt16, &SPIRV_clamp_UInt16 },
    std::pair{ &clamp_UInt16x2, &SPIRV_clamp_UInt16x2 },
    std::pair{ &clamp_UInt16x3, &SPIRV_clamp_UInt16x3 },
    std::pair{ &clamp_UInt16x4, &SPIRV_clamp_UInt16x4 },
    std::pair{ &lerp_Float32x2, &SPIRV_lerp_Float32x2 },
    std::pair{ &lerp_Float32x3, &SPIRV_lerp_Float32x3 },
    std::pair{ &lerp_Float32x4, &SPIRV_lerp_Float32x4 },
    std::pair{ &lerp_Float16x2, &SPIRV_lerp_Float16x2 },
    std::pair{ &lerp_Float16x3, &SPIRV_lerp_Float16x3 },
    std::pair{ &lerp_Float16x4, &SPIRV_lerp_Float16x4 },
    std::pair{ &step_Float32, &SPIRV_step_Float32 },
    std::pair{ &step_Float32x2, &SPIRV_step_Float32x2 },
    std::pair{ &step_Float32x3, &SPIRV_step_Float32x3 },
    std::pair{ &step_Float32x4, &SPIRV_step_Float32x4 },
    std::pair{ &step_Float16, &SPIRV_step_Float16 },
    std::pair{ &step_Float16x2, &SPIRV_step_Float16x2 },
    std::pair{ &step_Float16x3, &SPIRV_step_Float16x3 },
    std::pair{ &step_Float16x4, &SPIRV_step_Float16x4 },
    std::pair{ &smoothstep_Float32, &SPIRV_smoothstep_Float32 },
    std::pair{ &smoothstep_Float32x2, &SPIRV_smoothstep_Float32x2 },
    std::pair{ &smoothstep_Float32x3, &SPIRV_smoothstep_Float32x3 },
    std::pair{ &smoothstep_Float32x4, &SPIRV_smoothstep_Float32x4 },
    std::pair{ &smoothstep_Float16, &SPIRV_smoothstep_Float16 },
    std::pair{ &smoothstep_Float16x2, &SPIRV_smoothstep_Float16x2 },
    std::pair{ &smoothstep_Float16x3, &SPIRV_smoothstep_Float16x3 },
    std::pair{ &smoothstep_Float16x4, &SPIRV_smoothstep_Float16x4 },
    std::pair{ &ceil_Float32, &SPIRV_ceil_Float32 },
    std::pair{ &ceil_Float32x2, &SPIRV_ceil_Float32x2 },
    std::pair{ &ceil_Float32x3, &SPIRV_ceil_Float32x3 },
    std::pair{ &ceil_Float32x4, &SPIRV_ceil_Float32x4 },
    std::pair{ &ceil_Float16, &SPIRV_ceil_Float16 },
    std::pair{ &ceil_Float16x2, &SPIRV_ceil_Float16x2 },
    std::pair{ &ceil_Float16x3, &SPIRV_ceil_Float16x3 },
    std::pair{ &ceil_Float16x4, &SPIRV_ceil_Float16x4 },
    std::pair{ &floor_Float32, &SPIRV_floor_Float32 },
    std::pair{ &floor_Float32x2, &SPIRV_floor_Float32x2 },
    std::pair{ &floor_Float32x3, &SPIRV_floor_Float32x3 },
    std::pair{ &floor_Float32x4, &SPIRV_floor_Float32x4 },
    std::pair{ &floor_Float16, &SPIRV_floor_Float16 },
    std::pair{ &floor_Float16x2, &SPIRV_floor_Float16x2 },
    std::pair{ &floor_Float16x3, &SPIRV_floor_Float16x3 },
    std::pair{ &floor_Float16x4, &SPIRV_floor_Float16x4 },
    std::pair{ &fract_Float32, &SPIRV_fract_Float32 },
    std::pair{ &fract_Float32x2, &SPIRV_fract_Float32x2 },
    std::pair{ &fract_Float32x3, &SPIRV_fract_Float32x3 },
    std::pair{ &fract_Float32x4, &SPIRV_fract_Float32x4 },
    std::pair{ &fract_Float16, &SPIRV_fract_Float16 },
    std::pair{ &fract_Float16x2, &SPIRV_fract_Float16x2 },
    std::pair{ &fract_Float16x3, &SPIRV_fract_Float16x3 },
    std::pair{ &fract_Float16x4, &SPIRV_fract_Float16x4 },
    std::pair{ &saturate_Float32, &SPIRV_saturate_Float32 },
    std::pair{ &saturate_Float32x2, &SPIRV_saturate_Float32x2 },
    std::pair{ &saturate_Float32x3, &SPIRV_saturate_Float32x3 },
    std::pair{ &saturate_Float32x4, &SPIRV_saturate_Float32x4 },
    std::pair{ &saturate_Float16, &SPIRV_saturate_Float16 },
    std::pair{ &saturate_Float16x2, &SPIRV_saturate_Float16x2 },
    std::pair{ &saturate_Float16x3, &SPIRV_saturate_Float16x3 },
    std::pair{ &saturate_Float16x4, &SPIRV_saturate_Float16x4 },
    std::pair{ &trunc_Float32, &SPIRV_trunc_Float32 },
    std::pair{ &trunc_Float32x2, &SPIRV_trunc_Float32x2 },
    std::pair{ &trunc_Float32x3, &SPIRV_trunc_Float32x3 },
    std::pair{ &trunc_Float32x4, &SPIRV_trunc_Float32x4 },
    std::pair{ &trunc_Float16, &SPIRV_trunc_Float16 },
    std::pair{ &trunc_Float16x2, &SPIRV_trunc_Float16x2 },
    std::pair{ &trunc_Float16x3, &SPIRV_trunc_Float16x3 },
    std::pair{ &trunc_Float16x4, &SPIRV_trunc_Float16x4 },
    std::pair{ &ddx_Float32, &SPIRV_ddx_Float32 },
    std::pair{ &ddx_Float32x2, &SPIRV_ddx_Float32x2 },
    std::pair{ &ddx_Float32x3, &SPIRV_ddx_Float32x3 },
    std::pair{ &ddx_Float32x4, &SPIRV_ddx_Float32x4 },
    std::pair{ &ddx_Float16, &SPIRV_ddx_Float16 },
    std::pair{ &ddx_Float16x2, &SPIRV_ddx_Float16x2 },
    std::pair{ &ddx_Float16x3, &SPIRV_ddx_Float16x3 },
    std::pair{ &ddx_Float16x4, &SPIRV_ddx_Float16x4 },
    std::pair{ &ddy_Float32, &SPIRV_ddy_Float32 },
    std::pair{ &ddy_Float32x2, &SPIRV_ddy_Float32x2 },
    std::pair{ &ddy_Float32x3, &SPIRV_ddy_Float32x3 },
    std::pair{ &ddy_Float32x4, &SPIRV_ddy_Float32x4 },
    std::pair{ &ddy_Float16, &SPIRV_ddy_Float16 },
    std::pair{ &ddy_Float16x2, &SPIRV_ddy_Float16x2 },
    std::pair{ &ddy_Float16x3, &SPIRV_ddy_Float16x3 },
    std::pair{ &ddy_Float16x4, &SPIRV_ddy_Float16x4 },
    std::pair{ &fwidth_Float32, &SPIRV_fwidth_Float32 },
    std::pair{ &fwidth_Float32x2, &SPIRV_fwidth_Float32x2 },
    std::pair{ &fwidth_Float32x3, &SPIRV_fwidth_Float32x3 },
    std::pair{ &fwidth_Float32x4, &SPIRV_fwidth_Float32x4 },
    std::pair{ &fwidth_Float16, &SPIRV_fwidth_Float16 },
    std::pair{ &fwidth_Float16x2, &SPIRV_fwidth_Float16x2 },
    std::pair{ &fwidth_Float16x3, &SPIRV_fwidth_Float16x3 },
    std::pair{ &fwidth_Float16x4, &SPIRV_fwidth_Float16x4 },
    std::pair{ &sign_Int32, &SPIRV_sign_Int32 },
    std::pair{ &sign_Int32x2, &SPIRV_sign_Int32x2 },
    std::pair{ &sign_Int32x3, &SPIRV_sign_Int32x3 },
    std::pair{ &sign_Int32x4, &SPIRV_sign_Int32x4 },
    std::pair{ &sign_Int16, &SPIRV_sign_Int16 },
    std::pair{ &sign_Int16x2, &SPIRV_sign_Int16x2 },
    std::pair{ &sign_Int16x3, &SPIRV_sign_Int16x3 },
    std::pair{ &sign_Int16x4, &SPIRV_sign_Int16x4 },
    std::pair{ &sign_Float32, &SPIRV_sign_Float32 },
    std::pair{ &sign_Float32x2, &SPIRV_sign_Float32x2 },
    std::pair{ &sign_Float32x3, &SPIRV_sign_Float32x3 },
    std::pair{ &sign_Float32x4, &SPIRV_sign_Float32x4 },
    std::pair{ &sign_Float16, &SPIRV_sign_Float16 },
    std::pair{ &sign_Float16x2, &SPIRV_sign_Float16x2 },
    std::pair{ &sign_Float16x3, &SPIRV_sign_Float16x3 },
    std::pair{ &sign_Float16x4, &SPIRV_sign_Float16x4 },
    std::pair{ &abs_Int32, &SPIRV_abs_Int32 },
    std::pair{ &abs_Int32x2, &SPIRV_abs_Int32x2 },
    std::pair{ &abs_Int32x3, &SPIRV_abs_Int32x3 },
    std::pair{ &abs_Int32x4, &SPIRV_abs_Int32x4 },
    std::pair{ &abs_Int16, &SPIRV_abs_Int16 },
    std::pair{ &abs_Int16x2, &SPIRV_abs_Int16x2 },
    std::pair{ &abs_Int16x3, &SPIRV_abs_Int16x3 },
    std::pair{ &abs_Int16x4, &SPIRV_abs_Int16x4 },
    std::pair{ &abs_Float32, &SPIRV_abs_Float32 },
    std::pair{ &abs_Float32x2, &SPIRV_abs_Float32x2 },
    std::pair{ &abs_Float32x3, &SPIRV_abs_Float32x3 },
    std::pair{ &abs_Float32x4, &SPIRV_abs_Float32x4 },
    std::pair{ &abs_Float16, &SPIRV_abs_Float16 },
    std::pair{ &abs_Float16x2, &SPIRV_abs_Float16x2 },
    std::pair{ &abs_Float16x3, &SPIRV_abs_Float16x3 },
    std::pair{ &abs_Float16x4, &SPIRV_abs_Float16x4 },
    std::pair{ &castToF16_UInt16, &SPIRV_castToF16_UInt16 },
    std::pair{ &castToF16_Int16, &SPIRV_castToF16_Int16 },
    std::pair{ &castToU16_Float16, &SPIRV_castToU16_Float16 },
    std::pair{ &castToU16_Int16, &SPIRV_castToU16_Int16 },
    std::pair{ &castToI16_Float16, &SPIRV_castToI16_Float16 },
    std::pair{ &castToI16_UInt16, &SPIRV_castToI16_UInt16 },
    std::pair{ &castToF32_UInt32, &SPIRV_castToF32_UInt32 },
    std::pair{ &castToF32_Int32, &SPIRV_castToF32_Int32 },
    std::pair{ &castToU32_Float32, &SPIRV_castToU32_Float32 },
    std::pair{ &castToU32_Int32, &SPIRV_castToU32_Int32 },
    std::pair{ &castToI32_Float32, &SPIRV_castToI32_Float32 },
    std::pair{ &castToI32_UInt32, &SPIRV_castToI32_UInt32 },
    std::pair{ &any_Bool8, &SPIRV_any_Bool8 },
    std::pair{ &any_Bool8x2, &SPIRV_any_Bool8x2 },
    std::pair{ &any_Bool8x3, &SPIRV_any_Bool8x3 },
    std::pair{ &any_Bool8x4, &SPIRV_any_Bool8x4 },
    std::pair{ &all_Bool8, &SPIRV_all_Bool8 },
    std::pair{ &all_Bool8x2, &SPIRV_all_Bool8x2 },
    std::pair{ &all_Bool8x3, &SPIRV_all_Bool8x3 },
    std::pair{ &all_Bool8x4, &SPIRV_all_Bool8x4 },
    std::pair{ &transpose_Float32x2x2, &SPIRV_transpose_Float32x2x2 },
    std::pair{ &transpose_Float16x2x2, &SPIRV_transpose_Float16x2x2 },
    std::pair{ &transpose_Float32x2x3, &SPIRV_transpose_Float32x2x3 },
    std::pair{ &transpose_Float16x2x3, &SPIRV_transpose_Float16x2x3 },
    std::pair{ &transpose_Float32x2x4, &SPIRV_transpose_Float32x2x4 },
    std::pair{ &transpose_Float16x2x4, &SPIRV_transpose_Float16x2x4 },
    std::pair{ &transpose_Float32x3x2, &SPIRV_transpose_Float32x3x2 },
    std::pair{ &transpose_Float16x3x2, &SPIRV_transpose_Float16x3x2 },
    std::pair{ &transpose_Float32x3x3, &SPIRV_transpose_Float32x3x3 },
    std::pair{ &transpose_Float16x3x3, &SPIRV_transpose_Float16x3x3 },
    std::pair{ &transpose_Float32x3x4, &SPIRV_transpose_Float32x3x4 },
    std::pair{ &transpose_Float16x3x4, &SPIRV_transpose_Float16x3x4 },
    std::pair{ &transpose_Float32x4x2, &SPIRV_transpose_Float32x4x2 },
    std::pair{ &transpose_Float16x4x2, &SPIRV_transpose_Float16x4x2 },
    std::pair{ &transpose_Float32x4x3, &SPIRV_transpose_Float32x4x3 },
    std::pair{ &transpose_Float16x4x3, &SPIRV_transpose_Float16x4x3 },
    std::pair{ &transpose_Float32x4x4, &SPIRV_transpose_Float32x4x4 },
    std::pair{ &transpose_Float16x4x4, &SPIRV_transpose_Float16x4x4 },
    std::pair{ &inverse_Float32x2x2, &SPIRV_inverse_Float32x2x2 },
    std::pair{ &inverse_Float16x2x2, &SPIRV_inverse_Float16x2x2 },
    std::pair{ &inverse_Float32x2x3, &SPIRV_inverse_Float32x2x3 },
    std::pair{ &inverse_Float16x2x3, &SPIRV_inverse_Float16x2x3 },
    std::pair{ &inverse_Float32x2x4, &SPIRV_inverse_Float32x2x4 },
    std::pair{ &inverse_Float16x2x4, &SPIRV_inverse_Float16x2x4 },
    std::pair{ &inverse_Float32x3x2, &SPIRV_inverse_Float32x3x2 },
    std::pair{ &inverse_Float16x3x2, &SPIRV_inverse_Float16x3x2 },
    std::pair{ &inverse_Float32x3x3, &SPIRV_inverse_Float32x3x3 },
    std::pair{ &inverse_Float16x3x3, &SPIRV_inverse_Float16x3x3 },
    std::pair{ &inverse_Float32x3x4, &SPIRV_inverse_Float32x3x4 },
    std::pair{ &inverse_Float16x3x4, &SPIRV_inverse_Float16x3x4 },
    std::pair{ &inverse_Float32x4x2, &SPIRV_inverse_Float32x4x2 },
    std::pair{ &inverse_Float16x4x2, &SPIRV_inverse_Float16x4x2 },
    std::pair{ &inverse_Float32x4x3, &SPIRV_inverse_Float32x4x3 },
    std::pair{ &inverse_Float16x4x3, &SPIRV_inverse_Float16x4x3 },
    std::pair{ &inverse_Float32x4x4, &SPIRV_inverse_Float32x4x4 },
    std::pair{ &inverse_Float16x4x4, &SPIRV_inverse_Float16x4x4 },
    std::pair{ &VertexGetOutputLayer, &SPIRV_VertexGetOutputLayer },
    std::pair{ &VertexGetOutputViewport, &SPIRV_VertexGetOutputViewport },
    std::pair{ &VertexGetIndex, &SPIRV_VertexGetIndex },
    std::pair{ &VertexGetInstanceIndex, &SPIRV_VertexGetInstanceIndex },
    std::pair{ &VertexGetBaseIndex, &SPIRV_VertexGetBaseIndex },
    std::pair{ &VertexGetBaseInstanceIndex, &SPIRV_VertexGetBaseInstanceIndex },
    std::pair{ &VertexGetDrawIndex, &SPIRV_VertexGetDrawIndex },
    std::pair{ &VertexSetOutputLayer_UInt16, &SPIRV_VertexSetOutputLayer_UInt16 },
    std::pair{ &VertexSetOutputLayer_UInt32, &SPIRV_VertexSetOutputLayer_UInt32 },
    std::pair{ &VertexSetOutputViewport_UInt16, &SPIRV_VertexSetOutputViewport_UInt16 },
    std::pair{ &VertexSetOutputViewport_UInt32, &SPIRV_VertexSetOutputViewport_UInt32 },
    std::pair{ &VertexExportCoordinates_Float32x4, &SPIRV_VertexExportCoordinates_Float32x4 },
    std::pair{ &VertexExportCoordinates_Float16x4, &SPIRV_VertexExportCoordinates_Float16x4 },
    std::pair{ &GeometryExportVertex, &SPIRV_GeometryExportVertex },
    std::pair{ &GeometryExportPrimitive, &SPIRV_GeometryExportPrimitive },
    std::pair{ &PixelGetCoordinates_Float32x4, &SPIRV_PixelGetCoordinates_Float32x4 },
    std::pair{ &PixelGetCoordinates_Float16x4, &SPIRV_PixelGetCoordinates_Float16x4 },
    std::pair{ &PixelGetDepth, &SPIRV_PixelGetDepth },
    std::pair{ &PixelSetDepth, &SPIRV_PixelSetDepth },
    std::pair{ &PixelExportColor_Float32_Int32, &SPIRV_PixelExportColor_Float32_Int32 },
    std::pair{ &PixelExportColor_Float32_UInt32, &SPIRV_PixelExportColor_Float32_UInt32 },
    std::pair{ &PixelExportColor_Float32_Int16, &SPIRV_PixelExportColor_Float32_Int16 },
    std::pair{ &PixelExportColor_Float32_UInt16, &SPIRV_PixelExportColor_Float32_UInt16 },
    std::pair{ &PixelExportColor_Float32x2_Int32, &SPIRV_PixelExportColor_Float32x2_Int32 },
    std::pair{ &PixelExportColor_Float32x2_UInt32, &SPIRV_PixelExportColor_Float32x2_UInt32 },
    std::pair{ &PixelExportColor_Float32x2_Int16, &SPIRV_PixelExportColor_Float32x2_Int16 },
    std::pair{ &PixelExportColor_Float32x2_UInt16, &SPIRV_PixelExportColor_Float32x2_UInt16 },
    std::pair{ &PixelExportColor_Float32x3_Int32, &SPIRV_PixelExportColor_Float32x3_Int32 },
    std::pair{ &PixelExportColor_Float32x3_UInt32, &SPIRV_PixelExportColor_Float32x3_UInt32 },
    std::pair{ &PixelExportColor_Float32x3_Int16, &SPIRV_PixelExportColor_Float32x3_Int16 },
    std::pair{ &PixelExportColor_Float32x3_UInt16, &SPIRV_PixelExportColor_Float32x3_UInt16 },
    std::pair{ &PixelExportColor_Float32x4_Int32, &SPIRV_PixelExportColor_Float32x4_Int32 },
    std::pair{ &PixelExportColor_Float32x4_UInt32, &SPIRV_PixelExportColor_Float32x4_UInt32 },
    std::pair{ &PixelExportColor_Float32x4_Int16, &SPIRV_PixelExportColor_Float32x4_Int16 },
    std::pair{ &PixelExportColor_Float32x4_UInt16, &SPIRV_PixelExportColor_Float32x4_UInt16 },
    std::pair{ &PixelExportColor_Float16_Int32, &SPIRV_PixelExportColor_Float16_Int32 },
    std::pair{ &PixelExportColor_Float16_UInt32, &SPIRV_PixelExportColor_Float16_UInt32 },
    std::pair{ &PixelExportColor_Float16_Int16, &SPIRV_PixelExportColor_Float16_Int16 },
    std::pair{ &PixelExportColor_Float16_UInt16, &SPIRV_PixelExportColor_Float16_UInt16 },
    std::pair{ &PixelExportColor_Float16x2_Int32, &SPIRV_PixelExportColor_Float16x2_Int32 },
    std::pair{ &PixelExportColor_Float16x2_UInt32, &SPIRV_PixelExportColor_Float16x2_UInt32 },
    std::pair{ &PixelExportColor_Float16x2_Int16, &SPIRV_PixelExportColor_Float16x2_Int16 },
    std::pair{ &PixelExportColor_Float16x2_UInt16, &SPIRV_PixelExportColor_Float16x2_UInt16 },
    std::pair{ &PixelExportColor_Float16x3_Int32, &SPIRV_PixelExportColor_Float16x3_Int32 },
    std::pair{ &PixelExportColor_Float16x3_UInt32, &SPIRV_PixelExportColor_Float16x3_UInt32 },
    std::pair{ &PixelExportColor_Float16x3_Int16, &SPIRV_PixelExportColor_Float16x3_Int16 },
    std::pair{ &PixelExportColor_Float16x3_UInt16, &SPIRV_PixelExportColor_Float16x3_UInt16 },
    std::pair{ &PixelExportColor_Float16x4_Int32, &SPIRV_PixelExportColor_Float16x4_Int32 },
    std::pair{ &PixelExportColor_Float16x4_UInt32, &SPIRV_PixelExportColor_Float16x4_UInt32 },
    std::pair{ &PixelExportColor_Float16x4_Int16, &SPIRV_PixelExportColor_Float16x4_Int16 },
    std::pair{ &PixelExportColor_Float16x4_UInt16, &SPIRV_PixelExportColor_Float16x4_UInt16 },
    std::pair{ &PixelExportColor_Int32_Int32, &SPIRV_PixelExportColor_Int32_Int32 },
    std::pair{ &PixelExportColor_Int32_UInt32, &SPIRV_PixelExportColor_Int32_UInt32 },
    std::pair{ &PixelExportColor_Int32_Int16, &SPIRV_PixelExportColor_Int32_Int16 },
    std::pair{ &PixelExportColor_Int32_UInt16, &SPIRV_PixelExportColor_Int32_UInt16 },
    std::pair{ &PixelExportColor_Int32x2_Int32, &SPIRV_PixelExportColor_Int32x2_Int32 },
    std::pair{ &PixelExportColor_Int32x2_UInt32, &SPIRV_PixelExportColor_Int32x2_UInt32 },
    std::pair{ &PixelExportColor_Int32x2_Int16, &SPIRV_PixelExportColor_Int32x2_Int16 },
    std::pair{ &PixelExportColor_Int32x2_UInt16, &SPIRV_PixelExportColor_Int32x2_UInt16 },
    std::pair{ &PixelExportColor_Int32x3_Int32, &SPIRV_PixelExportColor_Int32x3_Int32 },
    std::pair{ &PixelExportColor_Int32x3_UInt32, &SPIRV_PixelExportColor_Int32x3_UInt32 },
    std::pair{ &PixelExportColor_Int32x3_Int16, &SPIRV_PixelExportColor_Int32x3_Int16 },
    std::pair{ &PixelExportColor_Int32x3_UInt16, &SPIRV_PixelExportColor_Int32x3_UInt16 },
    std::pair{ &PixelExportColor_Int32x4_Int32, &SPIRV_PixelExportColor_Int32x4_Int32 },
    std::pair{ &PixelExportColor_Int32x4_UInt32, &SPIRV_PixelExportColor_Int32x4_UInt32 },
    std::pair{ &PixelExportColor_Int32x4_Int16, &SPIRV_PixelExportColor_Int32x4_Int16 },
    std::pair{ &PixelExportColor_Int32x4_UInt16, &SPIRV_PixelExportColor_Int32x4_UInt16 },
    std::pair{ &PixelExportColor_Int16_Int32, &SPIRV_PixelExportColor_Int16_Int32 },
    std::pair{ &PixelExportColor_Int16_UInt32, &SPIRV_PixelExportColor_Int16_UInt32 },
    std::pair{ &PixelExportColor_Int16_Int16, &SPIRV_PixelExportColor_Int16_Int16 },
    std::pair{ &PixelExportColor_Int16_UInt16, &SPIRV_PixelExportColor_Int16_UInt16 },
    std::pair{ &PixelExportColor_Int16x2_Int32, &SPIRV_PixelExportColor_Int16x2_Int32 },
    std::pair{ &PixelExportColor_Int16x2_UInt32, &SPIRV_PixelExportColor_Int16x2_UInt32 },
    std::pair{ &PixelExportColor_Int16x2_Int16, &SPIRV_PixelExportColor_Int16x2_Int16 },
    std::pair{ &PixelExportColor_Int16x2_UInt16, &SPIRV_PixelExportColor_Int16x2_UInt16 },
    std::pair{ &PixelExportColor_Int16x3_Int32, &SPIRV_PixelExportColor_Int16x3_Int32 },
    std::pair{ &PixelExportColor_Int16x3_UInt32, &SPIRV_PixelExportColor_Int16x3_UInt32 },
    std::pair{ &PixelExportColor_Int16x3_Int16, &SPIRV_PixelExportColor_Int16x3_Int16 },
    std::pair{ &PixelExportColor_Int16x3_UInt16, &SPIRV_PixelExportColor_Int16x3_UInt16 },
    std::pair{ &PixelExportColor_Int16x4_Int32, &SPIRV_PixelExportColor_Int16x4_Int32 },
    std::pair{ &PixelExportColor_Int16x4_UInt32, &SPIRV_PixelExportColor_Int16x4_UInt32 },
    std::pair{ &PixelExportColor_Int16x4_Int16, &SPIRV_PixelExportColor_Int16x4_Int16 },
    std::pair{ &PixelExportColor_Int16x4_UInt16, &SPIRV_PixelExportColor_Int16x4_UInt16 },
    std::pair{ &PixelExportColor_UInt32_Int32, &SPIRV_PixelExportColor_UInt32_Int32 },
    std::pair{ &PixelExportColor_UInt32_UInt32, &SPIRV_PixelExportColor_UInt32_UInt32 },
    std::pair{ &PixelExportColor_UInt32_Int16, &SPIRV_PixelExportColor_UInt32_Int16 },
    std::pair{ &PixelExportColor_UInt32_UInt16, &SPIRV_PixelExportColor_UInt32_UInt16 },
    std::pair{ &PixelExportColor_UInt32x2_Int32, &SPIRV_PixelExportColor_UInt32x2_Int32 },
    std::pair{ &PixelExportColor_UInt32x2_UInt32, &SPIRV_PixelExportColor_UInt32x2_UInt32 },
    std::pair{ &PixelExportColor_UInt32x2_Int16, &SPIRV_PixelExportColor_UInt32x2_Int16 },
    std::pair{ &PixelExportColor_UInt32x2_UInt16, &SPIRV_PixelExportColor_UInt32x2_UInt16 },
    std::pair{ &PixelExportColor_UInt32x3_Int32, &SPIRV_PixelExportColor_UInt32x3_Int32 },
    std::pair{ &PixelExportColor_UInt32x3_UInt32, &SPIRV_PixelExportColor_UInt32x3_UInt32 },
    std::pair{ &PixelExportColor_UInt32x3_Int16, &SPIRV_PixelExportColor_UInt32x3_Int16 },
    std::pair{ &PixelExportColor_UInt32x3_UInt16, &SPIRV_PixelExportColor_UInt32x3_UInt16 },
    std::pair{ &PixelExportColor_UInt32x4_Int32, &SPIRV_PixelExportColor_UInt32x4_Int32 },
    std::pair{ &PixelExportColor_UInt32x4_UInt32, &SPIRV_PixelExportColor_UInt32x4_UInt32 },
    std::pair{ &PixelExportColor_UInt32x4_Int16, &SPIRV_PixelExportColor_UInt32x4_Int16 },
    std::pair{ &PixelExportColor_UInt32x4_UInt16, &SPIRV_PixelExportColor_UInt32x4_UInt16 },
    std::pair{ &PixelExportColor_UInt16_Int32, &SPIRV_PixelExportColor_UInt16_Int32 },
    std::pair{ &PixelExportColor_UInt16_UInt32, &SPIRV_PixelExportColor_UInt16_UInt32 },
    std::pair{ &PixelExportColor_UInt16_Int16, &SPIRV_PixelExportColor_UInt16_Int16 },
    std::pair{ &PixelExportColor_UInt16_UInt16, &SPIRV_PixelExportColor_UInt16_UInt16 },
    std::pair{ &PixelExportColor_UInt16x2_Int32, &SPIRV_PixelExportColor_UInt16x2_Int32 },
    std::pair{ &PixelExportColor_UInt16x2_UInt32, &SPIRV_PixelExportColor_UInt16x2_UInt32 },
    std::pair{ &PixelExportColor_UInt16x2_Int16, &SPIRV_PixelExportColor_UInt16x2_Int16 },
    std::pair{ &PixelExportColor_UInt16x2_UInt16, &SPIRV_PixelExportColor_UInt16x2_UInt16 },
    std::pair{ &PixelExportColor_UInt16x3_Int32, &SPIRV_PixelExportColor_UInt16x3_Int32 },
    std::pair{ &PixelExportColor_UInt16x3_UInt32, &SPIRV_PixelExportColor_UInt16x3_UInt32 },
    std::pair{ &PixelExportColor_UInt16x3_Int16, &SPIRV_PixelExportColor_UInt16x3_Int16 },
    std::pair{ &PixelExportColor_UInt16x3_UInt16, &SPIRV_PixelExportColor_UInt16x3_UInt16 },
    std::pair{ &PixelExportColor_UInt16x4_Int32, &SPIRV_PixelExportColor_UInt16x4_Int32 },
    std::pair{ &PixelExportColor_UInt16x4_UInt32, &SPIRV_PixelExportColor_UInt16x4_UInt32 },
    std::pair{ &PixelExportColor_UInt16x4_Int16, &SPIRV_PixelExportColor_UInt16x4_Int16 },
    std::pair{ &PixelExportColor_UInt16x4_UInt16, &SPIRV_PixelExportColor_UInt16x4_UInt16 },
    std::pair{ &ComputeGetLocalThreadIndices, &SPIRV_ComputeGetLocalThreadIndices },
    std::pair{ &ComputeGetGlobalThreadIndices, &SPIRV_ComputeGetGlobalThreadIndices },
    std::pair{ &ComputeGetWorkgroupIndices, &SPIRV_ComputeGetWorkgroupIndices },
    std::pair{ &ComputeGetWorkGroupDimensions, &SPIRV_ComputeGetWorkGroupDimensions },
    std::pair{ &ComputeGetIndexInWorkgroup, &SPIRV_ComputeGetIndexInWorkgroup },
    std::pair{ &SubgroupGetId, &SPIRV_SubgroupGetId },
    std::pair{ &SubgroupGetSize, &SPIRV_SubgroupGetSize },
    std::pair{ &SubgroupGetNum, &SPIRV_SubgroupGetNum },
    std::pair{ &SubgroupGetThreadMask, &SPIRV_SubgroupGetThreadMask },
    std::pair{ &SubgroupGetThreadAndLowerMask, &SPIRV_SubgroupGetThreadAndLowerMask },
    std::pair{ &SubgroupGetLowerMask, &SPIRV_SubgroupGetLowerMask },
    std::pair{ &SubgroupGetThreadAndGreaterMask, &SPIRV_SubgroupGetThreadAndGreaterMask },
    std::pair{ &SubgroupGetGreaterMask, &SPIRV_SubgroupGetGreaterMask },
    std::pair{ &SubgroupGetFirstActiveThread, &SPIRV_SubgroupGetFirstActiveThread },
    std::pair{ &SubgroupBroadcastFirstActiveThread_Float32, &SPIRV_SubgroupBroadcastFirstActiveThread_Float32 },
    std::pair{ &SubgroupBroadcastFirstActiveThread_Float32x2, &SPIRV_SubgroupBroadcastFirstActiveThread_Float32x2 },
    std::pair{ &SubgroupBroadcastFirstActiveThread_Float32x3, &SPIRV_SubgroupBroadcastFirstActiveThread_Float32x3 },
    std::pair{ &SubgroupBroadcastFirstActiveThread_Float32x4, &SPIRV_SubgroupBroadcastFirstActiveThread_Float32x4 },
    std::pair{ &SubgroupBroadcastFirstActiveThread_Float16, &SPIRV_SubgroupBroadcastFirstActiveThread_Float16 },
    std::pair{ &SubgroupBroadcastFirstActiveThread_Float16x2, &SPIRV_SubgroupBroadcastFirstActiveThread_Float16x2 },
    std::pair{ &SubgroupBroadcastFirstActiveThread_Float16x3, &SPIRV_SubgroupBroadcastFirstActiveThread_Float16x3 },
    std::pair{ &SubgroupBroadcastFirstActiveThread_Float16x4, &SPIRV_SubgroupBroadcastFirstActiveThread_Float16x4 },
    std::pair{ &SubgroupBroadcastFirstActiveThread_Int32, &SPIRV_SubgroupBroadcastFirstActiveThread_Int32 },
    std::pair{ &SubgroupBroadcastFirstActiveThread_Int32x2, &SPIRV_SubgroupBroadcastFirstActiveThread_Int32x2 },
    std::pair{ &SubgroupBroadcastFirstActiveThread_Int32x3, &SPIRV_SubgroupBroadcastFirstActiveThread_Int32x3 },
    std::pair{ &SubgroupBroadcastFirstActiveThread_Int32x4, &SPIRV_SubgroupBroadcastFirstActiveThread_Int32x4 },
    std::pair{ &SubgroupBroadcastFirstActiveThread_Int16, &SPIRV_SubgroupBroadcastFirstActiveThread_Int16 },
    std::pair{ &SubgroupBroadcastFirstActiveThread_Int16x2, &SPIRV_SubgroupBroadcastFirstActiveThread_Int16x2 },
    std::pair{ &SubgroupBroadcastFirstActiveThread_Int16x3, &SPIRV_SubgroupBroadcastFirstActiveThread_Int16x3 },
    std::pair{ &SubgroupBroadcastFirstActiveThread_Int16x4, &SPIRV_SubgroupBroadcastFirstActiveThread_Int16x4 },
    std::pair{ &SubgroupBroadcastFirstActiveThread_UInt32, &SPIRV_SubgroupBroadcastFirstActiveThread_UInt32 },
    std::pair{ &SubgroupBroadcastFirstActiveThread_UInt32x2, &SPIRV_SubgroupBroadcastFirstActiveThread_UInt32x2 },
    std::pair{ &SubgroupBroadcastFirstActiveThread_UInt32x3, &SPIRV_SubgroupBroadcastFirstActiveThread_UInt32x3 },
    std::pair{ &SubgroupBroadcastFirstActiveThread_UInt32x4, &SPIRV_SubgroupBroadcastFirstActiveThread_UInt32x4 },
    std::pair{ &SubgroupBroadcastFirstActiveThread_UInt16, &SPIRV_SubgroupBroadcastFirstActiveThread_UInt16 },
    std::pair{ &SubgroupBroadcastFirstActiveThread_UInt16x2, &SPIRV_SubgroupBroadcastFirstActiveThread_UInt16x2 },
    std::pair{ &SubgroupBroadcastFirstActiveThread_UInt16x3, &SPIRV_SubgroupBroadcastFirstActiveThread_UInt16x3 },
    std::pair{ &SubgroupBroadcastFirstActiveThread_UInt16x4, &SPIRV_SubgroupBroadcastFirstActiveThread_UInt16x4 },
    std::pair{ &SubgroupBallot, &SPIRV_SubgroupBallot },
    std::pair{ &SubgroupInverseBallot, &SPIRV_SubgroupInverseBallot },
    std::pair{ &SubgroupBallotBitCount, &SPIRV_SubgroupBallotBitCount },
    std::pair{ &SubgroupBallotFirstOne, &SPIRV_SubgroupBallotFirstOne },
    std::pair{ &SubgroupBallotLastOne, &SPIRV_SubgroupBallotLastOne },
    std::pair{ &SubgroupBallotBit, &SPIRV_SubgroupBallotBit },
    std::pair{ &SubgroupSwapDiagonal_Float32, &SPIRV_SubgroupSwapDiagonal_Float32 },
    std::pair{ &SubgroupSwapDiagonal_Float32x2, &SPIRV_SubgroupSwapDiagonal_Float32x2 },
    std::pair{ &SubgroupSwapDiagonal_Float32x3, &SPIRV_SubgroupSwapDiagonal_Float32x3 },
    std::pair{ &SubgroupSwapDiagonal_Float32x4, &SPIRV_SubgroupSwapDiagonal_Float32x4 },
    std::pair{ &SubgroupSwapDiagonal_Float16, &SPIRV_SubgroupSwapDiagonal_Float16 },
    std::pair{ &SubgroupSwapDiagonal_Float16x2, &SPIRV_SubgroupSwapDiagonal_Float16x2 },
    std::pair{ &SubgroupSwapDiagonal_Float16x3, &SPIRV_SubgroupSwapDiagonal_Float16x3 },
    std::pair{ &SubgroupSwapDiagonal_Float16x4, &SPIRV_SubgroupSwapDiagonal_Float16x4 },
    std::pair{ &SubgroupSwapDiagonal_Int32, &SPIRV_SubgroupSwapDiagonal_Int32 },
    std::pair{ &SubgroupSwapDiagonal_Int32x2, &SPIRV_SubgroupSwapDiagonal_Int32x2 },
    std::pair{ &SubgroupSwapDiagonal_Int32x3, &SPIRV_SubgroupSwapDiagonal_Int32x3 },
    std::pair{ &SubgroupSwapDiagonal_Int32x4, &SPIRV_SubgroupSwapDiagonal_Int32x4 },
    std::pair{ &SubgroupSwapDiagonal_Int16, &SPIRV_SubgroupSwapDiagonal_Int16 },
    std::pair{ &SubgroupSwapDiagonal_Int16x2, &SPIRV_SubgroupSwapDiagonal_Int16x2 },
    std::pair{ &SubgroupSwapDiagonal_Int16x3, &SPIRV_SubgroupSwapDiagonal_Int16x3 },
    std::pair{ &SubgroupSwapDiagonal_Int16x4, &SPIRV_SubgroupSwapDiagonal_Int16x4 },
    std::pair{ &SubgroupSwapDiagonal_UInt32, &SPIRV_SubgroupSwapDiagonal_UInt32 },
    std::pair{ &SubgroupSwapDiagonal_UInt32x2, &SPIRV_SubgroupSwapDiagonal_UInt32x2 },
    std::pair{ &SubgroupSwapDiagonal_UInt32x3, &SPIRV_SubgroupSwapDiagonal_UInt32x3 },
    std::pair{ &SubgroupSwapDiagonal_UInt32x4, &SPIRV_SubgroupSwapDiagonal_UInt32x4 },
    std::pair{ &SubgroupSwapDiagonal_UInt16, &SPIRV_SubgroupSwapDiagonal_UInt16 },
    std::pair{ &SubgroupSwapDiagonal_UInt16x2, &SPIRV_SubgroupSwapDiagonal_UInt16x2 },
    std::pair{ &SubgroupSwapDiagonal_UInt16x3, &SPIRV_SubgroupSwapDiagonal_UInt16x3 },
    std::pair{ &SubgroupSwapDiagonal_UInt16x4, &SPIRV_SubgroupSwapDiagonal_UInt16x4 },
    std::pair{ &SubgroupSwapVertical_Float32, &SPIRV_SubgroupSwapVertical_Float32 },
    std::pair{ &SubgroupSwapVertical_Float32x2, &SPIRV_SubgroupSwapVertical_Float32x2 },
    std::pair{ &SubgroupSwapVertical_Float32x3, &SPIRV_SubgroupSwapVertical_Float32x3 },
    std::pair{ &SubgroupSwapVertical_Float32x4, &SPIRV_SubgroupSwapVertical_Float32x4 },
    std::pair{ &SubgroupSwapVertical_Float16, &SPIRV_SubgroupSwapVertical_Float16 },
    std::pair{ &SubgroupSwapVertical_Float16x2, &SPIRV_SubgroupSwapVertical_Float16x2 },
    std::pair{ &SubgroupSwapVertical_Float16x3, &SPIRV_SubgroupSwapVertical_Float16x3 },
    std::pair{ &SubgroupSwapVertical_Float16x4, &SPIRV_SubgroupSwapVertical_Float16x4 },
    std::pair{ &SubgroupSwapVertical_Int32, &SPIRV_SubgroupSwapVertical_Int32 },
    std::pair{ &SubgroupSwapVertical_Int32x2, &SPIRV_SubgroupSwapVertical_Int32x2 },
    std::pair{ &SubgroupSwapVertical_Int32x3, &SPIRV_SubgroupSwapVertical_Int32x3 },
    std::pair{ &SubgroupSwapVertical_Int32x4, &SPIRV_SubgroupSwapVertical_Int32x4 },
    std::pair{ &SubgroupSwapVertical_Int16, &SPIRV_SubgroupSwapVertical_Int16 },
    std::pair{ &SubgroupSwapVertical_Int16x2, &SPIRV_SubgroupSwapVertical_Int16x2 },
    std::pair{ &SubgroupSwapVertical_Int16x3, &SPIRV_SubgroupSwapVertical_Int16x3 },
    std::pair{ &SubgroupSwapVertical_Int16x4, &SPIRV_SubgroupSwapVertical_Int16x4 },
    std::pair{ &SubgroupSwapVertical_UInt32, &SPIRV_SubgroupSwapVertical_UInt32 },
    std::pair{ &SubgroupSwapVertical_UInt32x2, &SPIRV_SubgroupSwapVertical_UInt32x2 },
    std::pair{ &SubgroupSwapVertical_UInt32x3, &SPIRV_SubgroupSwapVertical_UInt32x3 },
    std::pair{ &SubgroupSwapVertical_UInt32x4, &SPIRV_SubgroupSwapVertical_UInt32x4 },
    std::pair{ &SubgroupSwapVertical_UInt16, &SPIRV_SubgroupSwapVertical_UInt16 },
    std::pair{ &SubgroupSwapVertical_UInt16x2, &SPIRV_SubgroupSwapVertical_UInt16x2 },
    std::pair{ &SubgroupSwapVertical_UInt16x3, &SPIRV_SubgroupSwapVertical_UInt16x3 },
    std::pair{ &SubgroupSwapVertical_UInt16x4, &SPIRV_SubgroupSwapVertical_UInt16x4 },
    std::pair{ &SubgroupSwapHorizontal_Float32, &SPIRV_SubgroupSwapHorizontal_Float32 },
    std::pair{ &SubgroupSwapHorizontal_Float32x2, &SPIRV_SubgroupSwapHorizontal_Float32x2 },
    std::pair{ &SubgroupSwapHorizontal_Float32x3, &SPIRV_SubgroupSwapHorizontal_Float32x3 },
    std::pair{ &SubgroupSwapHorizontal_Float32x4, &SPIRV_SubgroupSwapHorizontal_Float32x4 },
    std::pair{ &SubgroupSwapHorizontal_Float16, &SPIRV_SubgroupSwapHorizontal_Float16 },
    std::pair{ &SubgroupSwapHorizontal_Float16x2, &SPIRV_SubgroupSwapHorizontal_Float16x2 },
    std::pair{ &SubgroupSwapHorizontal_Float16x3, &SPIRV_SubgroupSwapHorizontal_Float16x3 },
    std::pair{ &SubgroupSwapHorizontal_Float16x4, &SPIRV_SubgroupSwapHorizontal_Float16x4 },
    std::pair{ &SubgroupSwapHorizontal_Int32, &SPIRV_SubgroupSwapHorizontal_Int32 },
    std::pair{ &SubgroupSwapHorizontal_Int32x2, &SPIRV_SubgroupSwapHorizontal_Int32x2 },
    std::pair{ &SubgroupSwapHorizontal_Int32x3, &SPIRV_SubgroupSwapHorizontal_Int32x3 },
    std::pair{ &SubgroupSwapHorizontal_Int32x4, &SPIRV_SubgroupSwapHorizontal_Int32x4 },
    std::pair{ &SubgroupSwapHorizontal_Int16, &SPIRV_SubgroupSwapHorizontal_Int16 },
    std::pair{ &SubgroupSwapHorizontal_Int16x2, &SPIRV_SubgroupSwapHorizontal_Int16x2 },
    std::pair{ &SubgroupSwapHorizontal_Int16x3, &SPIRV_SubgroupSwapHorizontal_Int16x3 },
    std::pair{ &SubgroupSwapHorizontal_Int16x4, &SPIRV_SubgroupSwapHorizontal_Int16x4 },
    std::pair{ &SubgroupSwapHorizontal_UInt32, &SPIRV_SubgroupSwapHorizontal_UInt32 },
    std::pair{ &SubgroupSwapHorizontal_UInt32x2, &SPIRV_SubgroupSwapHorizontal_UInt32x2 },
    std::pair{ &SubgroupSwapHorizontal_UInt32x3, &SPIRV_SubgroupSwapHorizontal_UInt32x3 },
    std::pair{ &SubgroupSwapHorizontal_UInt32x4, &SPIRV_SubgroupSwapHorizontal_UInt32x4 },
    std::pair{ &SubgroupSwapHorizontal_UInt16, &SPIRV_SubgroupSwapHorizontal_UInt16 },
    std::pair{ &SubgroupSwapHorizontal_UInt16x2, &SPIRV_SubgroupSwapHorizontal_UInt16x2 },
    std::pair{ &SubgroupSwapHorizontal_UInt16x3, &SPIRV_SubgroupSwapHorizontal_UInt16x3 },
    std::pair{ &SubgroupSwapHorizontal_UInt16x4, &SPIRV_SubgroupSwapHorizontal_UInt16x4 },
    std::pair{ &AtomicLoad_UInt32, &SPIRV_AtomicLoad_UInt32 },
    std::pair{ &AtomicIncrement_UInt32, &SPIRV_AtomicIncrement_UInt32 },
    std::pair{ &AtomicDecrement_UInt32, &SPIRV_AtomicDecrement_UInt32 },
    std::pair{ &AtomicLoad_Int32, &SPIRV_AtomicLoad_Int32 },
    std::pair{ &AtomicIncrement_Int32, &SPIRV_AtomicIncrement_Int32 },
    std::pair{ &AtomicDecrement_Int32, &SPIRV_AtomicDecrement_Int32 },
    std::pair{ &AtomicLoad_UInt16, &SPIRV_AtomicLoad_UInt16 },
    std::pair{ &AtomicIncrement_UInt16, &SPIRV_AtomicIncrement_UInt16 },
    std::pair{ &AtomicDecrement_UInt16, &SPIRV_AtomicDecrement_UInt16 },
    std::pair{ &AtomicLoad_Int16, &SPIRV_AtomicLoad_Int16 },
    std::pair{ &AtomicIncrement_Int16, &SPIRV_AtomicIncrement_Int16 },
    std::pair{ &AtomicDecrement_Int16, &SPIRV_AtomicDecrement_Int16 },
    std::pair{ &AtomicStore_UInt32, &SPIRV_AtomicStore_UInt32 },
    std::pair{ &AtomicExchange_UInt32, &SPIRV_AtomicExchange_UInt32 },
    std::pair{ &AtomicAdd_UInt32, &SPIRV_AtomicAdd_UInt32 },
    std::pair{ &AtomicSubtract_UInt32, &SPIRV_AtomicSubtract_UInt32 },
    std::pair{ &AtomicAnd_UInt32, &SPIRV_AtomicAnd_UInt32 },
    std::pair{ &AtomicOr_UInt32, &SPIRV_AtomicOr_UInt32 },
    std::pair{ &AtomicXor_UInt32, &SPIRV_AtomicXor_UInt32 },
    std::pair{ &AtomicStore_Int32, &SPIRV_AtomicStore_Int32 },
    std::pair{ &AtomicExchange_Int32, &SPIRV_AtomicExchange_Int32 },
    std::pair{ &AtomicAdd_Int32, &SPIRV_AtomicAdd_Int32 },
    std::pair{ &AtomicSubtract_Int32, &SPIRV_AtomicSubtract_Int32 },
    std::pair{ &AtomicAnd_Int32, &SPIRV_AtomicAnd_Int32 },
    std::pair{ &AtomicOr_Int32, &SPIRV_AtomicOr_Int32 },
    std::pair{ &AtomicXor_Int32, &SPIRV_AtomicXor_Int32 },
    std::pair{ &AtomicStore_UInt16, &SPIRV_AtomicStore_UInt16 },
    std::pair{ &AtomicExchange_UInt16, &SPIRV_AtomicExchange_UInt16 },
    std::pair{ &AtomicAdd_UInt16, &SPIRV_AtomicAdd_UInt16 },
    std::pair{ &AtomicSubtract_UInt16, &SPIRV_AtomicSubtract_UInt16 },
    std::pair{ &AtomicAnd_UInt16, &SPIRV_AtomicAnd_UInt16 },
    std::pair{ &AtomicOr_UInt16, &SPIRV_AtomicOr_UInt16 },
    std::pair{ &AtomicXor_UInt16, &SPIRV_AtomicXor_UInt16 },
    std::pair{ &AtomicStore_Int16, &SPIRV_AtomicStore_Int16 },
    std::pair{ &AtomicExchange_Int16, &SPIRV_AtomicExchange_Int16 },
    std::pair{ &AtomicAdd_Int16, &SPIRV_AtomicAdd_Int16 },
    std::pair{ &AtomicSubtract_Int16, &SPIRV_AtomicSubtract_Int16 },
    std::pair{ &AtomicAnd_Int16, &SPIRV_AtomicAnd_Int16 },
    std::pair{ &AtomicOr_Int16, &SPIRV_AtomicOr_Int16 },
    std::pair{ &AtomicXor_Int16, &SPIRV_AtomicXor_Int16 },
    std::pair{ &AtomicCompareExchange_UInt32, &SPIRV_AtomicCompareExchange_UInt32 },
    std::pair{ &AtomicCompareExchange_Int32, &SPIRV_AtomicCompareExchange_Int32 },
    std::pair{ &AtomicCompareExchange_UInt16, &SPIRV_AtomicCompareExchange_UInt16 },
    std::pair{ &AtomicCompareExchange_Int16, &SPIRV_AtomicCompareExchange_Int16 },
    std::pair{ &BitInsert_UInt16, &SPIRV_BitInsert_UInt16 },
    std::pair{ &BitInsert_UInt32, &SPIRV_BitInsert_UInt32 },
    std::pair{ &BitExtract_UInt32, &SPIRV_BitExtract_UInt32 },
    std::pair{ &BitExtract_Int32, &SPIRV_BitExtract_Int32 },
    std::pair{ &BitExtract_UInt16, &SPIRV_BitExtract_UInt16 },
    std::pair{ &BitExtract_Int16, &SPIRV_BitExtract_Int16 },
    std::pair{ &BitReverse_UInt32, &SPIRV_BitReverse_UInt32 },
    std::pair{ &BitReverse_Int32, &SPIRV_BitReverse_Int32 },
    std::pair{ &BitReverse_UInt16, &SPIRV_BitReverse_UInt16 },
    std::pair{ &BitReverse_Int16, &SPIRV_BitReverse_Int16 },
    std::pair{ &BitCount_UInt32, &SPIRV_BitCount_UInt32 },
    std::pair{ &BitCount_Int32, &SPIRV_BitCount_Int32 },
    std::pair{ &BitCount_UInt16, &SPIRV_BitCount_UInt16 },
    std::pair{ &BitCount_Int16, &SPIRV_BitCount_Int16 },
    std::pair{ &ExecutionBarrier, &SPIRV_ExecutionBarrier },
    std::pair{ &ExecutionBarrierSubgroup, &SPIRV_ExecutionBarrierSubgroup },
    std::pair{ &ExecutionBarrierWorkgroup, &SPIRV_ExecutionBarrierWorkgroup },
    std::pair{ &MemoryBarrier, &SPIRV_MemoryBarrier },
    std::pair{ &MemoryBarrierBuffer, &SPIRV_MemoryBarrierBuffer },
    std::pair{ &MemoryBarrierTexture, &SPIRV_MemoryBarrierTexture },
    std::pair{ &MemoryBarrierAtomic, &SPIRV_MemoryBarrierAtomic },
    std::pair{ &MemoryBarrierSubgroup, &SPIRV_MemoryBarrierSubgroup },
    std::pair{ &MemoryBarrierWorkgroup, &SPIRV_MemoryBarrierWorkgroup },
    std::pair{ &TextureGetSize_Texture1D, &SPIRV_TextureGetSize_Texture1D },
    std::pair{ &TextureGetSize_Texture2D, &SPIRV_TextureGetSize_Texture2D },
    std::pair{ &TextureGetSize_Texture3D, &SPIRV_TextureGetSize_Texture3D },
    std::pair{ &TextureGetSize_TextureCube, &SPIRV_TextureGetSize_TextureCube },
    std::pair{ &TextureGetSize_Texture1DArray, &SPIRV_TextureGetSize_Texture1DArray },
    std::pair{ &TextureGetSize_Texture2DArray, &SPIRV_TextureGetSize_Texture2DArray },
    std::pair{ &TextureGetSize_TextureCubeArray, &SPIRV_TextureGetSize_TextureCubeArray },
    std::pair{ &TextureGetSizeMip_Texture1D, &SPIRV_TextureGetSizeMip_Texture1D },
    std::pair{ &TextureGetSizeMip_Texture2D, &SPIRV_TextureGetSizeMip_Texture2D },
    std::pair{ &TextureGetSizeMip_Texture3D, &SPIRV_TextureGetSizeMip_Texture3D },
    std::pair{ &TextureGetSizeMip_TextureCube, &SPIRV_TextureGetSizeMip_TextureCube },
    std::pair{ &TextureGetSizeMip_Texture1DArray, &SPIRV_TextureGetSizeMip_Texture1DArray },
    std::pair{ &TextureGetSizeMip_Texture2DArray, &SPIRV_TextureGetSizeMip_Texture2DArray },
    std::pair{ &TextureGetSizeMip_TextureCubeArray, &SPIRV_TextureGetSizeMip_TextureCubeArray },
    std::pair{ &TextureGetMips_Texture1D, &SPIRV_TextureGetMips_Texture1D },
    std::pair{ &TextureGetMips_Texture2D, &SPIRV_TextureGetMips_Texture2D },
    std::pair{ &TextureGetMips_Texture3D, &SPIRV_TextureGetMips_Texture3D },
    std::pair{ &TextureGetMips_TextureCube, &SPIRV_TextureGetMips_TextureCube },
    std::pair{ &TextureGetMips_Texture1DArray, &SPIRV_TextureGetMips_Texture1DArray },
    std::pair{ &TextureGetMips_Texture2DArray, &SPIRV_TextureGetMips_Texture2DArray },
    std::pair{ &TextureGetMips_TextureCubeArray, &SPIRV_TextureGetMips_TextureCubeArray },
    std::pair{ &TextureGetSamples_Texture2DMS, &SPIRV_TextureGetSamples_Texture2DMS },
    std::pair{ &TextureGetSamples_Texture2DMSArray, &SPIRV_TextureGetSamples_Texture2DMSArray },
    std::pair{ &TextureGetSampledMip_Texture1D, &SPIRV_TextureGetSampledMip_Texture1D },
    std::pair{ &SampledTextureGetSampledMip_Texture1D, &SPIRV_SampledTextureGetSampledMip_Texture1D },
    std::pair{ &TextureGetSampledMip_Texture2D, &SPIRV_TextureGetSampledMip_Texture2D },
    std::pair{ &SampledTextureGetSampledMip_Texture2D, &SPIRV_SampledTextureGetSampledMip_Texture2D },
    std::pair{ &TextureGetSampledMip_Texture3D, &SPIRV_TextureGetSampledMip_Texture3D },
    std::pair{ &SampledTextureGetSampledMip_Texture3D, &SPIRV_SampledTextureGetSampledMip_Texture3D },
    std::pair{ &TextureGetSampledMip_TextureCube, &SPIRV_TextureGetSampledMip_TextureCube },
    std::pair{ &SampledTextureGetSampledMip_TextureCube, &SPIRV_SampledTextureGetSampledMip_TextureCube },
    std::pair{ &TextureGetSampledMip_Texture1DArray, &SPIRV_TextureGetSampledMip_Texture1DArray },
    std::pair{ &SampledTextureGetSampledMip_Texture1DArray, &SPIRV_SampledTextureGetSampledMip_Texture1DArray },
    std::pair{ &TextureGetSampledMip_Texture2DArray, &SPIRV_TextureGetSampledMip_Texture2DArray },
    std::pair{ &SampledTextureGetSampledMip_Texture2DArray, &SPIRV_SampledTextureGetSampledMip_Texture2DArray },
    std::pair{ &TextureGetSampledMip_TextureCubeArray, &SPIRV_TextureGetSampledMip_TextureCubeArray },
    std::pair{ &SampledTextureGetSampledMip_TextureCubeArray, &SPIRV_SampledTextureGetSampledMip_TextureCubeArray },
    std::pair{ &TextureLoad_Texture1D, &SPIRV_TextureLoad_Texture1D },
    std::pair{ &TextureLoadMip_Texture1D, &SPIRV_TextureLoadMip_Texture1D },
    std::pair{ &TextureStore_Texture1D, &SPIRV_TextureStore_Texture1D },
    std::pair{ &TextureStoreMip_Texture1D, &SPIRV_TextureStoreMip_Texture1D },
    std::pair{ &TextureLoad_Texture2D, &SPIRV_TextureLoad_Texture2D },
    std::pair{ &TextureLoadMip_Texture2D, &SPIRV_TextureLoadMip_Texture2D },
    std::pair{ &TextureStore_Texture2D, &SPIRV_TextureStore_Texture2D },
    std::pair{ &TextureStoreMip_Texture2D, &SPIRV_TextureStoreMip_Texture2D },
    std::pair{ &TextureLoad_Texture3D, &SPIRV_TextureLoad_Texture3D },
    std::pair{ &TextureLoadMip_Texture3D, &SPIRV_TextureLoadMip_Texture3D },
    std::pair{ &TextureStore_Texture3D, &SPIRV_TextureStore_Texture3D },
    std::pair{ &TextureStoreMip_Texture3D, &SPIRV_TextureStoreMip_Texture3D },
    std::pair{ &TextureLoad_TextureCube, &SPIRV_TextureLoad_TextureCube },
    std::pair{ &TextureLoadMip_TextureCube, &SPIRV_TextureLoadMip_TextureCube },
    std::pair{ &TextureStore_TextureCube, &SPIRV_TextureStore_TextureCube },
    std::pair{ &TextureStoreMip_TextureCube, &SPIRV_TextureStoreMip_TextureCube },
    std::pair{ &TextureLoad_Texture1DArray, &SPIRV_TextureLoad_Texture1DArray },
    std::pair{ &TextureLoadMip_Texture1DArray, &SPIRV_TextureLoadMip_Texture1DArray },
    std::pair{ &TextureStore_Texture1DArray, &SPIRV_TextureStore_Texture1DArray },
    std::pair{ &TextureStoreMip_Texture1DArray, &SPIRV_TextureStoreMip_Texture1DArray },
    std::pair{ &TextureLoad_Texture2DArray, &SPIRV_TextureLoad_Texture2DArray },
    std::pair{ &TextureLoadMip_Texture2DArray, &SPIRV_TextureLoadMip_Texture2DArray },
    std::pair{ &TextureStore_Texture2DArray, &SPIRV_TextureStore_Texture2DArray },
    std::pair{ &TextureStoreMip_Texture2DArray, &SPIRV_TextureStoreMip_Texture2DArray },
    std::pair{ &TextureLoad_TextureCubeArray, &SPIRV_TextureLoad_TextureCubeArray },
    std::pair{ &TextureLoadMip_TextureCubeArray, &SPIRV_TextureLoadMip_TextureCubeArray },
    std::pair{ &TextureStore_TextureCubeArray, &SPIRV_TextureStore_TextureCubeArray },
    std::pair{ &TextureStoreMip_TextureCubeArray, &SPIRV_TextureStoreMip_TextureCubeArray },
    std::pair{ &TextureLoad_Texture2DMS, &SPIRV_TextureLoad_Texture2DMS },
    std::pair{ &TextureLoadMip_Texture2DMS, &SPIRV_TextureLoadMip_Texture2DMS },
    std::pair{ &TextureStore_Texture2DMS, &SPIRV_TextureStore_Texture2DMS },
    std::pair{ &TextureStoreMip_Texture2DMS, &SPIRV_TextureStoreMip_Texture2DMS },
    std::pair{ &TextureLoad_Texture2DMSArray, &SPIRV_TextureLoad_Texture2DMSArray },
    std::pair{ &TextureLoadMip_Texture2DMSArray, &SPIRV_TextureLoadMip_Texture2DMSArray },
    std::pair{ &TextureStore_Texture2DMSArray, &SPIRV_TextureStore_Texture2DMSArray },
    std::pair{ &TextureStoreMip_Texture2DMSArray, &SPIRV_TextureStoreMip_Texture2DMSArray },
    std::pair{ &TextureFetch_Texture1D, &SPIRV_TextureFetch_Texture1D },
    std::pair{ &TextureFetchSample_Texture1D, &SPIRV_TextureFetchSample_Texture1D },
    std::pair{ &TextureFetch_Texture2D, &SPIRV_TextureFetch_Texture2D },
    std::pair{ &TextureFetchSample_Texture2D, &SPIRV_TextureFetchSample_Texture2D },
    std::pair{ &TextureFetch_Texture3D, &SPIRV_TextureFetch_Texture3D },
    std::pair{ &TextureFetchSample_Texture3D, &SPIRV_TextureFetchSample_Texture3D },
    std::pair{ &TextureFetch_Texture1DArray, &SPIRV_TextureFetch_Texture1DArray },
    std::pair{ &TextureFetchSample_Texture1DArray, &SPIRV_TextureFetchSample_Texture1DArray },
    std::pair{ &TextureFetch_Texture2DArray, &SPIRV_TextureFetch_Texture2DArray },
    std::pair{ &TextureFetchSample_Texture2DArray, &SPIRV_TextureFetchSample_Texture2DArray },
    std::pair{ &TextureFetch_Texture2DMS, &SPIRV_TextureFetch_Texture2DMS },
    std::pair{ &TextureFetchSample_Texture2DMS, &SPIRV_TextureFetchSample_Texture2DMS },
    std::pair{ &TextureFetch_Texture2DMSArray, &SPIRV_TextureFetch_Texture2DMSArray },
    std::pair{ &TextureFetchSample_Texture2DMSArray, &SPIRV_TextureFetchSample_Texture2DMSArray },
    std::pair{ &TextureGather_Texture2D, &SPIRV_TextureGather_Texture2D },
    std::pair{ &SampledTextureGather_Texture2D, &SPIRV_SampledTextureGather_Texture2D },
    std::pair{ &TextureGatherOffset_Texture2D, &SPIRV_TextureGatherOffset_Texture2D },
    std::pair{ &SampledTextureGatherOffset_Texture2D, &SPIRV_SampledTextureGatherOffset_Texture2D },
    std::pair{ &TextureGather_TextureCube, &SPIRV_TextureGather_TextureCube },
    std::pair{ &SampledTextureGather_TextureCube, &SPIRV_SampledTextureGather_TextureCube },
    std::pair{ &TextureGatherOffset_TextureCube, &SPIRV_TextureGatherOffset_TextureCube },
    std::pair{ &SampledTextureGatherOffset_TextureCube, &SPIRV_SampledTextureGatherOffset_TextureCube },
    std::pair{ &TextureGather_Texture2DArray, &SPIRV_TextureGather_Texture2DArray },
    std::pair{ &SampledTextureGather_Texture2DArray, &SPIRV_SampledTextureGather_Texture2DArray },
    std::pair{ &TextureGatherOffset_Texture2DArray, &SPIRV_TextureGatherOffset_Texture2DArray },
    std::pair{ &SampledTextureGatherOffset_Texture2DArray, &SPIRV_SampledTextureGatherOffset_Texture2DArray },
    std::pair{ &TextureGather_TextureCubeArray, &SPIRV_TextureGather_TextureCubeArray },
    std::pair{ &SampledTextureGather_TextureCubeArray, &SPIRV_SampledTextureGather_TextureCubeArray },
    std::pair{ &TextureGatherOffset_TextureCubeArray, &SPIRV_TextureGatherOffset_TextureCubeArray },
    std::pair{ &SampledTextureGatherOffset_TextureCubeArray, &SPIRV_SampledTextureGatherOffset_TextureCubeArray },
    std::pair{ &TextureSample_Texture1D, &SPIRV_TextureSample_Texture1D },
    std::pair{ &SampledTextureSample_Texture1D, &SPIRV_SampledTextureSample_Texture1D },
    std::pair{ &TextureSample_Texture2D, &SPIRV_TextureSample_Texture2D },
    std::pair{ &SampledTextureSample_Texture2D, &SPIRV_SampledTextureSample_Texture2D },
    std::pair{ &TextureSample_Texture3D, &SPIRV_TextureSample_Texture3D },
    std::pair{ &SampledTextureSample_Texture3D, &SPIRV_SampledTextureSample_Texture3D },
    std::pair{ &TextureSample_TextureCube, &SPIRV_TextureSample_TextureCube },
    std::pair{ &SampledTextureSample_TextureCube, &SPIRV_SampledTextureSample_TextureCube },
    std::pair{ &TextureSample_Texture1DArray, &SPIRV_TextureSample_Texture1DArray },
    std::pair{ &SampledTextureSample_Texture1DArray, &SPIRV_SampledTextureSample_Texture1DArray },
    std::pair{ &TextureSample_Texture2DArray, &SPIRV_TextureSample_Texture2DArray },
    std::pair{ &SampledTextureSample_Texture2DArray, &SPIRV_SampledTextureSample_Texture2DArray },
    std::pair{ &TextureSample_TextureCubeArray, &SPIRV_TextureSample_TextureCubeArray },
    std::pair{ &SampledTextureSample_TextureCubeArray, &SPIRV_SampledTextureSample_TextureCubeArray },
    std::pair{ &TextureSampleOffset_Texture1D, &SPIRV_TextureSampleOffset_Texture1D },
    std::pair{ &SampledTextureSampleOffset_Texture1D, &SPIRV_SampledTextureSampleOffset_Texture1D },
    std::pair{ &TextureSampleOffset_Texture2D, &SPIRV_TextureSampleOffset_Texture2D },
    std::pair{ &SampledTextureSampleOffset_Texture2D, &SPIRV_SampledTextureSampleOffset_Texture2D },
    std::pair{ &TextureSampleOffset_Texture3D, &SPIRV_TextureSampleOffset_Texture3D },
    std::pair{ &SampledTextureSampleOffset_Texture3D, &SPIRV_SampledTextureSampleOffset_Texture3D },
    std::pair{ &TextureSampleOffset_Texture1DArray, &SPIRV_TextureSampleOffset_Texture1DArray },
    std::pair{ &SampledTextureSampleOffset_Texture1DArray, &SPIRV_SampledTextureSampleOffset_Texture1DArray },
    std::pair{ &TextureSampleOffset_Texture2DArray, &SPIRV_TextureSampleOffset_Texture2DArray },
    std::pair{ &SampledTextureSampleOffset_Texture2DArray, &SPIRV_SampledTextureSampleOffset_Texture2DArray },
    std::pair{ &TextureSampleProj_Texture1D, &SPIRV_TextureSampleProj_Texture1D },
    std::pair{ &SampledTextureSampleProj_Texture1D, &SPIRV_SampledTextureSampleProj_Texture1D },
    std::pair{ &TextureSampleProj_Texture2D, &SPIRV_TextureSampleProj_Texture2D },
    std::pair{ &SampledTextureSampleProj_Texture2D, &SPIRV_SampledTextureSampleProj_Texture2D },
    std::pair{ &TextureSampleProj_Texture3D, &SPIRV_TextureSampleProj_Texture3D },
    std::pair{ &SampledTextureSampleProj_Texture3D, &SPIRV_SampledTextureSampleProj_Texture3D },
    std::pair{ &TextureSampleProjOffset_Texture1D, &SPIRV_TextureSampleProjOffset_Texture1D },
    std::pair{ &SampledTextureSampleProjOffset_Texture1D, &SPIRV_SampledTextureSampleProjOffset_Texture1D },
    std::pair{ &TextureSampleProjOffset_Texture2D, &SPIRV_TextureSampleProjOffset_Texture2D },
    std::pair{ &SampledTextureSampleProjOffset_Texture2D, &SPIRV_SampledTextureSampleProjOffset_Texture2D },
    std::pair{ &TextureSampleProjOffset_Texture3D, &SPIRV_TextureSampleProjOffset_Texture3D },
    std::pair{ &SampledTextureSampleProjOffset_Texture3D, &SPIRV_SampledTextureSampleProjOffset_Texture3D },
    std::pair{ &TextureSampleCompare_Texture1D, &SPIRV_TextureSampleCompare_Texture1D },
    std::pair{ &SampledTextureSampleCompare_Texture1D, &SPIRV_SampledTextureSampleCompare_Texture1D },
    std::pair{ &TextureSampleCompare_Texture2D, &SPIRV_TextureSampleCompare_Texture2D },
    std::pair{ &SampledTextureSampleCompare_Texture2D, &SPIRV_SampledTextureSampleCompare_Texture2D },
    std::pair{ &TextureSampleCompare_Texture3D, &SPIRV_TextureSampleCompare_Texture3D },
    std::pair{ &SampledTextureSampleCompare_Texture3D, &SPIRV_SampledTextureSampleCompare_Texture3D },
    std::pair{ &TextureSampleCompare_Texture1DArray, &SPIRV_TextureSampleCompare_Texture1DArray },
    std::pair{ &SampledTextureSampleCompare_Texture1DArray, &SPIRV_SampledTextureSampleCompare_Texture1DArray },
    std::pair{ &TextureSampleCompare_Texture2DArray, &SPIRV_TextureSampleCompare_Texture2DArray },
    std::pair{ &SampledTextureSampleCompare_Texture2DArray, &SPIRV_SampledTextureSampleCompare_Texture2DArray },
    std::pair{ &TextureSampleCompareOffset_Texture1D, &SPIRV_TextureSampleCompareOffset_Texture1D },
    std::pair{ &SampledTextureSampleCompareOffset_Texture1D, &SPIRV_SampledTextureSampleCompareOffset_Texture1D },
    std::pair{ &TextureSampleCompareOffset_Texture2D, &SPIRV_TextureSampleCompareOffset_Texture2D },
    std::pair{ &SampledTextureSampleCompareOffset_Texture2D, &SPIRV_SampledTextureSampleCompareOffset_Texture2D },
    std::pair{ &TextureSampleCompareOffset_Texture3D, &SPIRV_TextureSampleCompareOffset_Texture3D },
    std::pair{ &SampledTextureSampleCompareOffset_Texture3D, &SPIRV_SampledTextureSampleCompareOffset_Texture3D },
    std::pair{ &TextureSampleCompareOffset_Texture1DArray, &SPIRV_TextureSampleCompareOffset_Texture1DArray },
    std::pair{ &SampledTextureSampleCompareOffset_Texture1DArray, &SPIRV_SampledTextureSampleCompareOffset_Texture1DArray },
    std::pair{ &TextureSampleCompareOffset_Texture2DArray, &SPIRV_TextureSampleCompareOffset_Texture2DArray },
    std::pair{ &SampledTextureSampleCompareOffset_Texture2DArray, &SPIRV_SampledTextureSampleCompareOffset_Texture2DArray },
    std::pair{ &TextureSampleProjCompare_Texture1D, &SPIRV_TextureSampleProjCompare_Texture1D },
    std::pair{ &SampledTextureSampleProjCompare_Texture1D, &SPIRV_SampledTextureSampleProjCompare_Texture1D },
    std::pair{ &TextureSampleProjCompare_Texture2D, &SPIRV_TextureSampleProjCompare_Texture2D },
    std::pair{ &SampledTextureSampleProjCompare_Texture2D, &SPIRV_SampledTextureSampleProjCompare_Texture2D },
    std::pair{ &TextureSampleProjCompare_Texture3D, &SPIRV_TextureSampleProjCompare_Texture3D },
    std::pair{ &SampledTextureSampleProjCompare_Texture3D, &SPIRV_SampledTextureSampleProjCompare_Texture3D },
    std::pair{ &TextureSampleProjCompareOffset_Texture1D, &SPIRV_TextureSampleProjCompareOffset_Texture1D },
    std::pair{ &SampledTextureSampleProjCompareOffset_Texture1D, &SPIRV_SampledTextureSampleProjCompareOffset_Texture1D },
    std::pair{ &TextureSampleProjCompareOffset_Texture2D, &SPIRV_TextureSampleProjCompareOffset_Texture2D },
    std::pair{ &SampledTextureSampleProjCompareOffset_Texture2D, &SPIRV_SampledTextureSampleProjCompareOffset_Texture2D },
    std::pair{ &TextureSampleProjCompareOffset_Texture3D, &SPIRV_TextureSampleProjCompareOffset_Texture3D },
    std::pair{ &SampledTextureSampleProjCompareOffset_Texture3D, &SPIRV_SampledTextureSampleProjCompareOffset_Texture3D },
    std::pair{ &TextureSampleLod_Texture1D, &SPIRV_TextureSampleLod_Texture1D },
    std::pair{ &SampledTextureSampleLod_Texture1D, &SPIRV_SampledTextureSampleLod_Texture1D },
    std::pair{ &TextureSampleLod_Texture2D, &SPIRV_TextureSampleLod_Texture2D },
    std::pair{ &SampledTextureSampleLod_Texture2D, &SPIRV_SampledTextureSampleLod_Texture2D },
    std::pair{ &TextureSampleLod_Texture3D, &SPIRV_TextureSampleLod_Texture3D },
    std::pair{ &SampledTextureSampleLod_Texture3D, &SPIRV_SampledTextureSampleLod_Texture3D },
    std::pair{ &TextureSampleLod_TextureCube, &SPIRV_TextureSampleLod_TextureCube },
    std::pair{ &SampledTextureSampleLod_TextureCube, &SPIRV_SampledTextureSampleLod_TextureCube },
    std::pair{ &TextureSampleLod_Texture1DArray, &SPIRV_TextureSampleLod_Texture1DArray },
    std::pair{ &SampledTextureSampleLod_Texture1DArray, &SPIRV_SampledTextureSampleLod_Texture1DArray },
    std::pair{ &TextureSampleLod_Texture2DArray, &SPIRV_TextureSampleLod_Texture2DArray },
    std::pair{ &SampledTextureSampleLod_Texture2DArray, &SPIRV_SampledTextureSampleLod_Texture2DArray },
    std::pair{ &TextureSampleLod_TextureCubeArray, &SPIRV_TextureSampleLod_TextureCubeArray },
    std::pair{ &SampledTextureSampleLod_TextureCubeArray, &SPIRV_SampledTextureSampleLod_TextureCubeArray },
    std::pair{ &TextureSampleLodOffset_Texture1D, &SPIRV_TextureSampleLodOffset_Texture1D },
    std::pair{ &SampledTextureSampleLodOffset_Texture1D, &SPIRV_SampledTextureSampleLodOffset_Texture1D },
    std::pair{ &TextureSampleLodOffset_Texture2D, &SPIRV_TextureSampleLodOffset_Texture2D },
    std::pair{ &SampledTextureSampleLodOffset_Texture2D, &SPIRV_SampledTextureSampleLodOffset_Texture2D },
    std::pair{ &TextureSampleLodOffset_Texture3D, &SPIRV_TextureSampleLodOffset_Texture3D },
    std::pair{ &SampledTextureSampleLodOffset_Texture3D, &SPIRV_SampledTextureSampleLodOffset_Texture3D },
    std::pair{ &TextureSampleLodOffset_Texture1DArray, &SPIRV_TextureSampleLodOffset_Texture1DArray },
    std::pair{ &SampledTextureSampleLodOffset_Texture1DArray, &SPIRV_SampledTextureSampleLodOffset_Texture1DArray },
    std::pair{ &TextureSampleLodOffset_Texture2DArray, &SPIRV_TextureSampleLodOffset_Texture2DArray },
    std::pair{ &SampledTextureSampleLodOffset_Texture2DArray, &SPIRV_SampledTextureSampleLodOffset_Texture2DArray },
    std::pair{ &TextureSampleLodProj_Texture1D, &SPIRV_TextureSampleLodProj_Texture1D },
    std::pair{ &SampledTextureSampleLodProj_Texture1D, &SPIRV_SampledTextureSampleLodProj_Texture1D },
    std::pair{ &TextureSampleLodProj_Texture2D, &SPIRV_TextureSampleLodProj_Texture2D },
    std::pair{ &SampledTextureSampleLodProj_Texture2D, &SPIRV_SampledTextureSampleLodProj_Texture2D },
    std::pair{ &TextureSampleLodProj_Texture3D, &SPIRV_TextureSampleLodProj_Texture3D },
    std::pair{ &SampledTextureSampleLodProj_Texture3D, &SPIRV_SampledTextureSampleLodProj_Texture3D },
    std::pair{ &TextureSampleLodProjOffset_Texture1D, &SPIRV_TextureSampleLodProjOffset_Texture1D },
    std::pair{ &SampledTextureSampleLodProjOffset_Texture1D, &SPIRV_SampledTextureSampleLodProjOffset_Texture1D },
    std::pair{ &TextureSampleLodProjOffset_Texture2D, &SPIRV_TextureSampleLodProjOffset_Texture2D },
    std::pair{ &SampledTextureSampleLodProjOffset_Texture2D, &SPIRV_SampledTextureSampleLodProjOffset_Texture2D },
    std::pair{ &TextureSampleLodProjOffset_Texture3D, &SPIRV_TextureSampleLodProjOffset_Texture3D },
    std::pair{ &SampledTextureSampleLodProjOffset_Texture3D, &SPIRV_SampledTextureSampleLodProjOffset_Texture3D },
    std::pair{ &TextureSampleLodCompare_Texture1D, &SPIRV_TextureSampleLodCompare_Texture1D },
    std::pair{ &SampledTextureSampleLodCompare_Texture1D, &SPIRV_SampledTextureSampleLodCompare_Texture1D },
    std::pair{ &TextureSampleLodCompare_Texture2D, &SPIRV_TextureSampleLodCompare_Texture2D },
    std::pair{ &SampledTextureSampleLodCompare_Texture2D, &SPIRV_SampledTextureSampleLodCompare_Texture2D },
    std::pair{ &TextureSampleLodCompare_Texture3D, &SPIRV_TextureSampleLodCompare_Texture3D },
    std::pair{ &SampledTextureSampleLodCompare_Texture3D, &SPIRV_SampledTextureSampleLodCompare_Texture3D },
    std::pair{ &TextureSampleLodCompare_Texture1DArray, &SPIRV_TextureSampleLodCompare_Texture1DArray },
    std::pair{ &SampledTextureSampleLodCompare_Texture1DArray, &SPIRV_SampledTextureSampleLodCompare_Texture1DArray },
    std::pair{ &TextureSampleLodCompare_Texture2DArray, &SPIRV_TextureSampleLodCompare_Texture2DArray },
    std::pair{ &SampledTextureSampleLodCompare_Texture2DArray, &SPIRV_SampledTextureSampleLodCompare_Texture2DArray },
    std::pair{ &TextureSampleLodCompareOffset_Texture1D, &SPIRV_TextureSampleLodCompareOffset_Texture1D },
    std::pair{ &SampledTextureSampleLodCompareOffset_Texture1D, &SPIRV_SampledTextureSampleLodCompareOffset_Texture1D },
    std::pair{ &TextureSampleLodCompareOffset_Texture2D, &SPIRV_TextureSampleLodCompareOffset_Texture2D },
    std::pair{ &SampledTextureSampleLodCompareOffset_Texture2D, &SPIRV_SampledTextureSampleLodCompareOffset_Texture2D },
    std::pair{ &TextureSampleLodCompareOffset_Texture3D, &SPIRV_TextureSampleLodCompareOffset_Texture3D },
    std::pair{ &SampledTextureSampleLodCompareOffset_Texture3D, &SPIRV_SampledTextureSampleLodCompareOffset_Texture3D },
    std::pair{ &TextureSampleLodCompareOffset_Texture1DArray, &SPIRV_TextureSampleLodCompareOffset_Texture1DArray },
    std::pair{ &SampledTextureSampleLodCompareOffset_Texture1DArray, &SPIRV_SampledTextureSampleLodCompareOffset_Texture1DArray },
    std::pair{ &TextureSampleLodCompareOffset_Texture2DArray, &SPIRV_TextureSampleLodCompareOffset_Texture2DArray },
    std::pair{ &SampledTextureSampleLodCompareOffset_Texture2DArray, &SPIRV_SampledTextureSampleLodCompareOffset_Texture2DArray },
    std::pair{ &TextureSampleLodProjCompare_Texture1D, &SPIRV_TextureSampleLodProjCompare_Texture1D },
    std::pair{ &SampledTextureSampleLodProjCompare_Texture1D, &SPIRV_SampledTextureSampleLodProjCompare_Texture1D },
    std::pair{ &TextureSampleLodProjCompare_Texture2D, &SPIRV_TextureSampleLodProjCompare_Texture2D },
    std::pair{ &SampledTextureSampleLodProjCompare_Texture2D, &SPIRV_SampledTextureSampleLodProjCompare_Texture2D },
    std::pair{ &TextureSampleLodProjCompare_Texture3D, &SPIRV_TextureSampleLodProjCompare_Texture3D },
    std::pair{ &SampledTextureSampleLodProjCompare_Texture3D, &SPIRV_SampledTextureSampleLodProjCompare_Texture3D },
    std::pair{ &TextureSampleLodProjCompareOffset_Texture1D, &SPIRV_TextureSampleLodProjCompareOffset_Texture1D },
    std::pair{ &SampledTextureSampleLodProjCompareOffset_Texture1D, &SPIRV_SampledTextureSampleLodProjCompareOffset_Texture1D },
    std::pair{ &TextureSampleLodProjCompareOffset_Texture2D, &SPIRV_TextureSampleLodProjCompareOffset_Texture2D },
    std::pair{ &SampledTextureSampleLodProjCompareOffset_Texture2D, &SPIRV_SampledTextureSampleLodProjCompareOffset_Texture2D },
    std::pair{ &TextureSampleLodProjCompareOffset_Texture3D, &SPIRV_TextureSampleLodProjCompareOffset_Texture3D },
    std::pair{ &SampledTextureSampleLodProjCompareOffset_Texture3D, &SPIRV_SampledTextureSampleLodProjCompareOffset_Texture3D },
    std::pair{ &TextureSampleGrad_Texture1D, &SPIRV_TextureSampleGrad_Texture1D },
    std::pair{ &SampledTextureSampleGrad_Texture1D, &SPIRV_SampledTextureSampleGrad_Texture1D },
    std::pair{ &TextureSampleGrad_Texture2D, &SPIRV_TextureSampleGrad_Texture2D },
    std::pair{ &SampledTextureSampleGrad_Texture2D, &SPIRV_SampledTextureSampleGrad_Texture2D },
    std::pair{ &TextureSampleGrad_Texture3D, &SPIRV_TextureSampleGrad_Texture3D },
    std::pair{ &SampledTextureSampleGrad_Texture3D, &SPIRV_SampledTextureSampleGrad_Texture3D },
    std::pair{ &TextureSampleGrad_TextureCube, &SPIRV_TextureSampleGrad_TextureCube },
    std::pair{ &SampledTextureSampleGrad_TextureCube, &SPIRV_SampledTextureSampleGrad_TextureCube },
    std::pair{ &TextureSampleGrad_Texture1DArray, &SPIRV_TextureSampleGrad_Texture1DArray },
    std::pair{ &SampledTextureSampleGrad_Texture1DArray, &SPIRV_SampledTextureSampleGrad_Texture1DArray },
    std::pair{ &TextureSampleGrad_Texture2DArray, &SPIRV_TextureSampleGrad_Texture2DArray },
    std::pair{ &SampledTextureSampleGrad_Texture2DArray, &SPIRV_SampledTextureSampleGrad_Texture2DArray },
    std::pair{ &TextureSampleGrad_TextureCubeArray, &SPIRV_TextureSampleGrad_TextureCubeArray },
    std::pair{ &SampledTextureSampleGrad_TextureCubeArray, &SPIRV_SampledTextureSampleGrad_TextureCubeArray },
    std::pair{ &TextureSampleGradOffset_Texture1D, &SPIRV_TextureSampleGradOffset_Texture1D },
    std::pair{ &SampledTextureSampleGradOffset_Texture1D, &SPIRV_SampledTextureSampleGradOffset_Texture1D },
    std::pair{ &TextureSampleGradOffset_Texture2D, &SPIRV_TextureSampleGradOffset_Texture2D },
    std::pair{ &SampledTextureSampleGradOffset_Texture2D, &SPIRV_SampledTextureSampleGradOffset_Texture2D },
    std::pair{ &TextureSampleGradOffset_Texture3D, &SPIRV_TextureSampleGradOffset_Texture3D },
    std::pair{ &SampledTextureSampleGradOffset_Texture3D, &SPIRV_SampledTextureSampleGradOffset_Texture3D },
    std::pair{ &TextureSampleGradOffset_Texture1DArray, &SPIRV_TextureSampleGradOffset_Texture1DArray },
    std::pair{ &SampledTextureSampleGradOffset_Texture1DArray, &SPIRV_SampledTextureSampleGradOffset_Texture1DArray },
    std::pair{ &TextureSampleGradOffset_Texture2DArray, &SPIRV_TextureSampleGradOffset_Texture2DArray },
    std::pair{ &SampledTextureSampleGradOffset_Texture2DArray, &SPIRV_SampledTextureSampleGradOffset_Texture2DArray },
    std::pair{ &TextureSampleGradProj_Texture1D, &SPIRV_TextureSampleGradProj_Texture1D },
    std::pair{ &SampledTextureSampleGradProj_Texture1D, &SPIRV_SampledTextureSampleGradProj_Texture1D },
    std::pair{ &TextureSampleGradProj_Texture2D, &SPIRV_TextureSampleGradProj_Texture2D },
    std::pair{ &SampledTextureSampleGradProj_Texture2D, &SPIRV_SampledTextureSampleGradProj_Texture2D },
    std::pair{ &TextureSampleGradProj_Texture3D, &SPIRV_TextureSampleGradProj_Texture3D },
    std::pair{ &SampledTextureSampleGradProj_Texture3D, &SPIRV_SampledTextureSampleGradProj_Texture3D },
    std::pair{ &TextureSampleGradProjOffset_Texture1D, &SPIRV_TextureSampleGradProjOffset_Texture1D },
    std::pair{ &SampledTextureSampleGradProjOffset_Texture1D, &SPIRV_SampledTextureSampleGradProjOffset_Texture1D },
    std::pair{ &TextureSampleGradProjOffset_Texture2D, &SPIRV_TextureSampleGradProjOffset_Texture2D },
    std::pair{ &SampledTextureSampleGradProjOffset_Texture2D, &SPIRV_SampledTextureSampleGradProjOffset_Texture2D },
    std::pair{ &TextureSampleGradProjOffset_Texture3D, &SPIRV_TextureSampleGradProjOffset_Texture3D },
    std::pair{ &SampledTextureSampleGradProjOffset_Texture3D, &SPIRV_SampledTextureSampleGradProjOffset_Texture3D },
    std::pair{ &TextureSampleGradCompare_Texture1D, &SPIRV_TextureSampleGradCompare_Texture1D },
    std::pair{ &SampledTextureSampleGradCompare_Texture1D, &SPIRV_SampledTextureSampleGradCompare_Texture1D },
    std::pair{ &TextureSampleGradCompare_Texture2D, &SPIRV_TextureSampleGradCompare_Texture2D },
    std::pair{ &SampledTextureSampleGradCompare_Texture2D, &SPIRV_SampledTextureSampleGradCompare_Texture2D },
    std::pair{ &TextureSampleGradCompare_Texture3D, &SPIRV_TextureSampleGradCompare_Texture3D },
    std::pair{ &SampledTextureSampleGradCompare_Texture3D, &SPIRV_SampledTextureSampleGradCompare_Texture3D },
    std::pair{ &TextureSampleGradCompare_Texture1DArray, &SPIRV_TextureSampleGradCompare_Texture1DArray },
    std::pair{ &SampledTextureSampleGradCompare_Texture1DArray, &SPIRV_SampledTextureSampleGradCompare_Texture1DArray },
    std::pair{ &TextureSampleGradCompare_Texture2DArray, &SPIRV_TextureSampleGradCompare_Texture2DArray },
    std::pair{ &SampledTextureSampleGradCompare_Texture2DArray, &SPIRV_SampledTextureSampleGradCompare_Texture2DArray },
    std::pair{ &TextureSampleGradCompareOffset_Texture1D, &SPIRV_TextureSampleGradCompareOffset_Texture1D },
    std::pair{ &SampledTextureSampleGradCompareOffset_Texture1D, &SPIRV_SampledTextureSampleGradCompareOffset_Texture1D },
    std::pair{ &TextureSampleGradCompareOffset_Texture2D, &SPIRV_TextureSampleGradCompareOffset_Texture2D },
    std::pair{ &SampledTextureSampleGradCompareOffset_Texture2D, &SPIRV_SampledTextureSampleGradCompareOffset_Texture2D },
    std::pair{ &TextureSampleGradCompareOffset_Texture3D, &SPIRV_TextureSampleGradCompareOffset_Texture3D },
    std::pair{ &SampledTextureSampleGradCompareOffset_Texture3D, &SPIRV_SampledTextureSampleGradCompareOffset_Texture3D },
    std::pair{ &TextureSampleGradCompareOffset_Texture1DArray, &SPIRV_TextureSampleGradCompareOffset_Texture1DArray },
    std::pair{ &SampledTextureSampleGradCompareOffset_Texture1DArray, &SPIRV_SampledTextureSampleGradCompareOffset_Texture1DArray },
    std::pair{ &TextureSampleGradCompareOffset_Texture2DArray, &SPIRV_TextureSampleGradCompareOffset_Texture2DArray },
    std::pair{ &SampledTextureSampleGradCompareOffset_Texture2DArray, &SPIRV_SampledTextureSampleGradCompareOffset_Texture2DArray },
    std::pair{ &TextureSampleGradProjCompare_Texture1D, &SPIRV_TextureSampleGradProjCompare_Texture1D },
    std::pair{ &SampledTextureSampleGradProjCompare_Texture1D, &SPIRV_SampledTextureSampleGradProjCompare_Texture1D },
    std::pair{ &TextureSampleGradProjCompare_Texture2D, &SPIRV_TextureSampleGradProjCompare_Texture2D },
    std::pair{ &SampledTextureSampleGradProjCompare_Texture2D, &SPIRV_SampledTextureSampleGradProjCompare_Texture2D },
    std::pair{ &TextureSampleGradProjCompare_Texture3D, &SPIRV_TextureSampleGradProjCompare_Texture3D },
    std::pair{ &SampledTextureSampleGradProjCompare_Texture3D, &SPIRV_SampledTextureSampleGradProjCompare_Texture3D },
    std::pair{ &TextureSampleGradProjCompareOffset_Texture1D, &SPIRV_TextureSampleGradProjCompareOffset_Texture1D },
    std::pair{ &SampledTextureSampleGradProjCompareOffset_Texture1D, &SPIRV_SampledTextureSampleGradProjCompareOffset_Texture1D },
    std::pair{ &TextureSampleGradProjCompareOffset_Texture2D, &SPIRV_TextureSampleGradProjCompareOffset_Texture2D },
    std::pair{ &SampledTextureSampleGradProjCompareOffset_Texture2D, &SPIRV_SampledTextureSampleGradProjCompareOffset_Texture2D },
    std::pair{ &TextureSampleGradProjCompareOffset_Texture3D, &SPIRV_TextureSampleGradProjCompareOffset_Texture3D },
    std::pair{ &SampledTextureSampleGradProjCompareOffset_Texture3D, &SPIRV_SampledTextureSampleGradProjCompareOffset_Texture3D },
    std::pair{ &TextureSampleBias_Texture1D, &SPIRV_TextureSampleBias_Texture1D },
    std::pair{ &SampledTextureSampleBias_Texture1D, &SPIRV_SampledTextureSampleBias_Texture1D },
    std::pair{ &TextureSampleBias_Texture2D, &SPIRV_TextureSampleBias_Texture2D },
    std::pair{ &SampledTextureSampleBias_Texture2D, &SPIRV_SampledTextureSampleBias_Texture2D },
    std::pair{ &TextureSampleBias_Texture3D, &SPIRV_TextureSampleBias_Texture3D },
    std::pair{ &SampledTextureSampleBias_Texture3D, &SPIRV_SampledTextureSampleBias_Texture3D },
    std::pair{ &TextureSampleBias_TextureCube, &SPIRV_TextureSampleBias_TextureCube },
    std::pair{ &SampledTextureSampleBias_TextureCube, &SPIRV_SampledTextureSampleBias_TextureCube },
    std::pair{ &TextureSampleBias_Texture1DArray, &SPIRV_TextureSampleBias_Texture1DArray },
    std::pair{ &SampledTextureSampleBias_Texture1DArray, &SPIRV_SampledTextureSampleBias_Texture1DArray },
    std::pair{ &TextureSampleBias_Texture2DArray, &SPIRV_TextureSampleBias_Texture2DArray },
    std::pair{ &SampledTextureSampleBias_Texture2DArray, &SPIRV_SampledTextureSampleBias_Texture2DArray },
    std::pair{ &TextureSampleBias_TextureCubeArray, &SPIRV_TextureSampleBias_TextureCubeArray },
    std::pair{ &SampledTextureSampleBias_TextureCubeArray, &SPIRV_SampledTextureSampleBias_TextureCubeArray },
    std::pair{ &TextureSampleBiasOffset_Texture1D, &SPIRV_TextureSampleBiasOffset_Texture1D },
    std::pair{ &SampledTextureSampleBiasOffset_Texture1D, &SPIRV_SampledTextureSampleBiasOffset_Texture1D },
    std::pair{ &TextureSampleBiasOffset_Texture2D, &SPIRV_TextureSampleBiasOffset_Texture2D },
    std::pair{ &SampledTextureSampleBiasOffset_Texture2D, &SPIRV_SampledTextureSampleBiasOffset_Texture2D },
    std::pair{ &TextureSampleBiasOffset_Texture3D, &SPIRV_TextureSampleBiasOffset_Texture3D },
    std::pair{ &SampledTextureSampleBiasOffset_Texture3D, &SPIRV_SampledTextureSampleBiasOffset_Texture3D },
    std::pair{ &TextureSampleBiasOffset_Texture1DArray, &SPIRV_TextureSampleBiasOffset_Texture1DArray },
    std::pair{ &SampledTextureSampleBiasOffset_Texture1DArray, &SPIRV_SampledTextureSampleBiasOffset_Texture1DArray },
    std::pair{ &TextureSampleBiasOffset_Texture2DArray, &SPIRV_TextureSampleBiasOffset_Texture2DArray },
    std::pair{ &SampledTextureSampleBiasOffset_Texture2DArray, &SPIRV_SampledTextureSampleBiasOffset_Texture2DArray },
    std::pair{ &TextureSampleBiasProj_Texture1D, &SPIRV_TextureSampleBiasProj_Texture1D },
    std::pair{ &SampledTextureSampleBiasProj_Texture1D, &SPIRV_SampledTextureSampleBiasProj_Texture1D },
    std::pair{ &TextureSampleBiasProj_Texture2D, &SPIRV_TextureSampleBiasProj_Texture2D },
    std::pair{ &SampledTextureSampleBiasProj_Texture2D, &SPIRV_SampledTextureSampleBiasProj_Texture2D },
    std::pair{ &TextureSampleBiasProj_Texture3D, &SPIRV_TextureSampleBiasProj_Texture3D },
    std::pair{ &SampledTextureSampleBiasProj_Texture3D, &SPIRV_SampledTextureSampleBiasProj_Texture3D },
    std::pair{ &TextureSampleBiasProjOffset_Texture1D, &SPIRV_TextureSampleBiasProjOffset_Texture1D },
    std::pair{ &SampledTextureSampleBiasProjOffset_Texture1D, &SPIRV_SampledTextureSampleBiasProjOffset_Texture1D },
    std::pair{ &TextureSampleBiasProjOffset_Texture2D, &SPIRV_TextureSampleBiasProjOffset_Texture2D },
    std::pair{ &SampledTextureSampleBiasProjOffset_Texture2D, &SPIRV_SampledTextureSampleBiasProjOffset_Texture2D },
    std::pair{ &TextureSampleBiasProjOffset_Texture3D, &SPIRV_TextureSampleBiasProjOffset_Texture3D },
    std::pair{ &SampledTextureSampleBiasProjOffset_Texture3D, &SPIRV_SampledTextureSampleBiasProjOffset_Texture3D },
    std::pair{ &TextureSampleBiasCompare_Texture1D, &SPIRV_TextureSampleBiasCompare_Texture1D },
    std::pair{ &SampledTextureSampleBiasCompare_Texture1D, &SPIRV_SampledTextureSampleBiasCompare_Texture1D },
    std::pair{ &TextureSampleBiasCompare_Texture2D, &SPIRV_TextureSampleBiasCompare_Texture2D },
    std::pair{ &SampledTextureSampleBiasCompare_Texture2D, &SPIRV_SampledTextureSampleBiasCompare_Texture2D },
    std::pair{ &TextureSampleBiasCompare_Texture3D, &SPIRV_TextureSampleBiasCompare_Texture3D },
    std::pair{ &SampledTextureSampleBiasCompare_Texture3D, &SPIRV_SampledTextureSampleBiasCompare_Texture3D },
    std::pair{ &TextureSampleBiasCompare_Texture1DArray, &SPIRV_TextureSampleBiasCompare_Texture1DArray },
    std::pair{ &SampledTextureSampleBiasCompare_Texture1DArray, &SPIRV_SampledTextureSampleBiasCompare_Texture1DArray },
    std::pair{ &TextureSampleBiasCompare_Texture2DArray, &SPIRV_TextureSampleBiasCompare_Texture2DArray },
    std::pair{ &SampledTextureSampleBiasCompare_Texture2DArray, &SPIRV_SampledTextureSampleBiasCompare_Texture2DArray },
    std::pair{ &TextureSampleBiasCompareOffset_Texture1D, &SPIRV_TextureSampleBiasCompareOffset_Texture1D },
    std::pair{ &SampledTextureSampleBiasCompareOffset_Texture1D, &SPIRV_SampledTextureSampleBiasCompareOffset_Texture1D },
    std::pair{ &TextureSampleBiasCompareOffset_Texture2D, &SPIRV_TextureSampleBiasCompareOffset_Texture2D },
    std::pair{ &SampledTextureSampleBiasCompareOffset_Texture2D, &SPIRV_SampledTextureSampleBiasCompareOffset_Texture2D },
    std::pair{ &TextureSampleBiasCompareOffset_Texture3D, &SPIRV_TextureSampleBiasCompareOffset_Texture3D },
    std::pair{ &SampledTextureSampleBiasCompareOffset_Texture3D, &SPIRV_SampledTextureSampleBiasCompareOffset_Texture3D },
    std::pair{ &TextureSampleBiasCompareOffset_Texture1DArray, &SPIRV_TextureSampleBiasCompareOffset_Texture1DArray },
    std::pair{ &SampledTextureSampleBiasCompareOffset_Texture1DArray, &SPIRV_SampledTextureSampleBiasCompareOffset_Texture1DArray },
    std::pair{ &TextureSampleBiasCompareOffset_Texture2DArray, &SPIRV_TextureSampleBiasCompareOffset_Texture2DArray },
    std::pair{ &SampledTextureSampleBiasCompareOffset_Texture2DArray, &SPIRV_SampledTextureSampleBiasCompareOffset_Texture2DArray },
    std::pair{ &TextureSampleBiasProjCompare_Texture1D, &SPIRV_TextureSampleBiasProjCompare_Texture1D },
    std::pair{ &SampledTextureSampleBiasProjCompare_Texture1D, &SPIRV_SampledTextureSampleBiasProjCompare_Texture1D },
    std::pair{ &TextureSampleBiasProjCompare_Texture2D, &SPIRV_TextureSampleBiasProjCompare_Texture2D },
    std::pair{ &SampledTextureSampleBiasProjCompare_Texture2D, &SPIRV_SampledTextureSampleBiasProjCompare_Texture2D },
    std::pair{ &TextureSampleBiasProjCompare_Texture3D, &SPIRV_TextureSampleBiasProjCompare_Texture3D },
    std::pair{ &SampledTextureSampleBiasProjCompare_Texture3D, &SPIRV_SampledTextureSampleBiasProjCompare_Texture3D },
    std::pair{ &TextureSampleBiasProjCompareOffset_Texture1D, &SPIRV_TextureSampleBiasProjCompareOffset_Texture1D },
    std::pair{ &SampledTextureSampleBiasProjCompareOffset_Texture1D, &SPIRV_SampledTextureSampleBiasProjCompareOffset_Texture1D },
    std::pair{ &TextureSampleBiasProjCompareOffset_Texture2D, &SPIRV_TextureSampleBiasProjCompareOffset_Texture2D },
    std::pair{ &SampledTextureSampleBiasProjCompareOffset_Texture2D, &SPIRV_SampledTextureSampleBiasProjCompareOffset_Texture2D },
    std::pair{ &TextureSampleBiasProjCompareOffset_Texture3D, &SPIRV_TextureSampleBiasProjCompareOffset_Texture3D },
    std::pair{ &SampledTextureSampleBiasProjCompareOffset_Texture3D, &SPIRV_SampledTextureSampleBiasProjCompareOffset_Texture3D }
};
