#pragma once
//-------------------------------------------------
// *** Generated by type_gen.py. ***
//       DO NOT MODIFY!!!
//-------------------------------------------------
#include "compiler.h"
#include "generators/spirvgenerator.h"
#include "containers.h"
#include "types.h"
namespace GPULang
{
struct SPIRVGenerator;
struct Compiler;
struct SPIRVResult;
SPIRVResult GenerateConversionSPIRV(const Compiler* compiler, SPIRVGenerator* generator, ConversionTable conversion, uint32_t vectorSize, SPIRVResult inArg);
SPIRVResult GenerateSplatCompositeSPIRV(const Compiler* compiler, SPIRVGenerator* generator, uint32_t returnType, uint32_t num, SPIRVResult arg);
static auto CreateSampledImageSPIRV = [](const Compiler* c, SPIRVGenerator* g, SPIRVResult img, SPIRVResult samp) -> SPIRVResult
{
        assert(img.parentTypes.size() > 0);
        SPIRVResult image = LoadValueSPIRV(c, g, img, true);
        SPIRVResult sampler = LoadValueSPIRV(c, g, samp, true);
        uint32_t typeSymbol = AddType(g, TStr::Compact("sampledImage_", img.parentTypes[0]), OpTypeSampledImage, SPVArg{img.parentTypes[0]});
        uint32_t sampledImage = g->writer->MappedInstruction(OpSampledImage, SPVWriter::Section::LocalFunction, typeSymbol, image, sampler);
        return SPIRVResult(sampledImage, typeSymbol, true);
};

constexpr ConverterTable = StaticMap{ std::array{
    { TypeConversionTable::Float32ToUInt32, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt32(value.literalValue.f32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpConvertFToU, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Float32ToInt32, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(value.literalValue.f32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpConvertFToS, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Float32ToFloat16, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float16(value.literalValue.f32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpFConvert, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Float32ToUInt16, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt16(value.literalValue.f32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpConvertFToU, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Float32ToInt16, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int16(value.literalValue.f32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpConvertFToS, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::UInt32ToFloat32, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float32(value.literalValue.u32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpConvertUToF, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::UInt32ToInt32, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(value.literalValue.u32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::UInt32ToBool8, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Bool8(value.literalValue.u32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Bool8, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Bool8);
            value = LoadValueSPIRV(c, g, value);
            SPIRVResult falseValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt32(0), vectorSize);
            res = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, type, value, falseValue);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::UInt32ToFloat16, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float16(value.literalValue.u32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpConvertUToF, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::UInt32ToUInt16, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt16(value.literalValue.u32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpUConvert, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::UInt32ToInt16, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int16(value.literalValue.u32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Int32ToFloat32, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float32(value.literalValue.i32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpConvertSToF, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Int32ToUInt32, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt32(value.literalValue.i32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Int32ToBool8, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Bool8(value.literalValue.i32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Bool8, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Bool8);
            value = LoadValueSPIRV(c, g, value);
            SPIRVResult falseValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), vectorSize);
            res = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, type, value, falseValue);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Int32ToFloat16, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float16(value.literalValue.i32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpConvertSToF, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Int32ToUInt16, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt16(value.literalValue.i32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Int32ToInt16, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int16(value.literalValue.i32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpSConvert, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Bool8ToUInt32, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt32(value.literalValue.b8));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32);
            SPIRVResult trueValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt32(1), vectorSize);
            SPIRVResult falseValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt32(0), vectorSize);
            res = g->writer->MappedInstruction(OpSelect, SPVWriter::Section::LocalFunction, type, trueValue, falseValue);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Bool8ToInt32, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(value.literalValue.b8));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32);
            SPIRVResult trueValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(1), vectorSize);
            SPIRVResult falseValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), vectorSize);
            res = g->writer->MappedInstruction(OpSelect, SPVWriter::Section::LocalFunction, type, trueValue, falseValue);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Bool8ToUInt16, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt16(value.literalValue.b8));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16);
            SPIRVResult trueValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt16(1), vectorSize);
            SPIRVResult falseValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt16(0), vectorSize);
            res = g->writer->MappedInstruction(OpSelect, SPVWriter::Section::LocalFunction, type, trueValue, falseValue);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Bool8ToInt16, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int16(value.literalValue.b8));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16);
            SPIRVResult trueValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int16(1), vectorSize);
            SPIRVResult falseValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int16(0), vectorSize);
            res = g->writer->MappedInstruction(OpSelect, SPVWriter::Section::LocalFunction, type, trueValue, falseValue);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Float16ToFloat32, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float32(value.literalValue.f16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpFConvert, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Float16ToUInt32, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt32(value.literalValue.f16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpConvertFToU, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Float16ToInt32, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(value.literalValue.f16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpConvertFToS, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Float16ToUInt16, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt16(value.literalValue.f16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpConvertFToU, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Float16ToInt16, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int16(value.literalValue.f16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpConvertFToS, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::UInt16ToFloat32, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float32(value.literalValue.u16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpConvertUToF, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::UInt16ToUInt32, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt32(value.literalValue.u16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpUConvert, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::UInt16ToInt32, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(value.literalValue.u16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::UInt16ToBool8, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Bool8(value.literalValue.u16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Bool8, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Bool8);
            value = LoadValueSPIRV(c, g, value);
            SPIRVResult falseValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt16(0), vectorSize);
            res = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, type, value, falseValue);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::UInt16ToFloat16, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float16(value.literalValue.u16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpConvertUToF, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::UInt16ToInt16, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int16(value.literalValue.u16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Int16ToFloat32, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float32(value.literalValue.i16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpConvertSToF, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Int16ToUInt32, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt32(value.literalValue.i16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Int16ToInt32, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(value.literalValue.i16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpSConvert, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Int16ToBool8, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Bool8(value.literalValue.i16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Bool8, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Bool8);
            value = LoadValueSPIRV(c, g, value);
            SPIRVResult falseValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int16(0), vectorSize);
            res = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, type, value, falseValue);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Int16ToFloat16, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float16(value.literalValue.i16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpConvertSToF, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Int16ToUInt16, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt16(value.literalValue.i16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } }
}};

static const uint32_t SemanticsTable[] =
{
    0x0,
    0x1,
    0x2,
    0x4,
    0x8,
    0x10,
    0x20,
    0x40,
    0x80,
    0x100
};

static auto ScopeToAtomicScope = [](SPIRVResult::Storage scope) -> uint32_t
{
    switch (scope)
    {
        case SPIRVResult::Storage::Function:
        case SPIRVResult::Storage::Input:
        case SPIRVResult::Storage::Output:
        case SPIRVResult::Storage::PushConstant:
        case SPIRVResult::Storage::Private:
            return 4;
        case SPIRVResult::Storage::WorkGroup:
            return 2;
        case SPIRVResult::Storage::Device:
        case SPIRVResult::Storage::Uniform:
        case SPIRVResult::Storage::UniformConstant:
        case SPIRVResult::Storage::StorageBuffer:
        case SPIRVResult::Storage::MutableImage:
            return 1;
        case SPIRVResult::Storage::Sampler:
        case SPIRVResult::Storage::Image:
            assert(false);
    }
    return 0;
};

static auto ScopeToMemorySemantics = [](SPIRVResult::Storage scope) -> uint32_t
{
    switch (scope)
    {
        case SPIRVResult::Storage::WorkGroup:
            return 0x100; // WorkgroupMemory
        case SPIRVResult::Storage::Uniform:
        case SPIRVResult::Storage::UniformConstant:
        case SPIRVResult::Storage::StorageBuffer:
        case SPIRVResult::Storage::Sampler:
            return 0x40; // UniformMemory
        case SPIRVResult::Storage::Image:
        case SPIRVResult::Storage::MutableImage:
            return 0x800; // ImageMemory
    }
    return 0x0;
};
StaticMap default_intrinsics = std::array{
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_ctor0_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_ctor0_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_ctor0_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_ctor0_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_ctor0_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_ctor0_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_ctor0_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_ctor0_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_ctor0_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_ctor0_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_ctor0_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_ctor0_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_ctor0_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_ctor0_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_ctor0_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_ctor0_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_ctor0_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_ctor0_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_ctor0_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_ctor0_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_ctor0_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_ctor0_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_ctor0_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_ctor0_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_ctor0_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_ctor0_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_ctor0_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_ctor0_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x3_ctor1_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_ctor2_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_ctor0_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_ctor0_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_ctor0_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_ctor0_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_ctor0_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_ctor0_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_ctor0_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x3_ctor1_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_ctor2_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt32, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_ctor0_UInt32_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x3_ctor1_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_ctor2_UInt32_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_ctor0_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_ctor0_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_ctor0_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_ctor0_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_ctor0_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_ctor0_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_ctor0_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x3_ctor1_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_ctor2_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt32, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_ctor0_UInt32_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x3_ctor1_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_ctor2_UInt32_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt32, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_ctor0_Int32_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x3_ctor1_Int32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_ctor2_Int32_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_ctor0_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_ctor0_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_ctor0_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_ctor0_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_ctor0_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_ctor0_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_ctor0_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x3_ctor1_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_ctor2_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt32, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_ctor0_UInt32_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x3_ctor1_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_ctor2_UInt32_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt32, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_ctor0_Int32_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x3_ctor1_Int32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_ctor2_Int32_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_ctor0_Bool8_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x3_ctor1_Bool8x2_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_ctor2_Bool8_Bool8x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_ctor0_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_ctor0_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_ctor0_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_ctor0_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_ctor0_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_ctor0_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_ctor0_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x3_ctor1_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_ctor2_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt32, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_ctor0_UInt32_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x3_ctor1_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_ctor2_UInt32_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt32, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_ctor0_Int32_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x3_ctor1_Int32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_ctor2_Int32_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_ctor0_Bool8_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x3_ctor1_Bool8x2_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_ctor2_Bool8_Bool8x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 3, args[0]);
}},
std::pair{ &Float16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat16, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 3, args[0]);
}},
std::pair{ &Float16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_ctor0_Float16_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float16x3_ctor1_Float16x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x3_ctor2_Float16_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_ctor0_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_ctor0_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_ctor0_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_ctor0_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_ctor0_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_ctor0_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_ctor0_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x3_ctor1_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_ctor2_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt32, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_ctor0_UInt32_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x3_ctor1_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_ctor2_UInt32_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt32, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_ctor0_Int32_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x3_ctor1_Int32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_ctor2_Int32_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_ctor0_Bool8_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x3_ctor1_Bool8x2_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_ctor2_Bool8_Bool8x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 3, args[0]);
}},
std::pair{ &Float16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat16, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 3, args[0]);
}},
std::pair{ &Float16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_ctor0_Float16_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float16x3_ctor1_Float16x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x3_ctor2_Float16_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt16, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_ctor0_UInt16_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt16x3_ctor1_UInt16x2_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x3_ctor2_UInt16_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_ctor0_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_ctor0_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_ctor0_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_ctor0_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_ctor0_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_ctor0_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_ctor0_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x3_ctor1_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_ctor2_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt32, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_ctor0_UInt32_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x3_ctor1_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_ctor2_UInt32_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt32, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_ctor0_Int32_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x3_ctor1_Int32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_ctor2_Int32_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_ctor0_Bool8_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x3_ctor1_Bool8x2_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_ctor2_Bool8_Bool8x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 3, args[0]);
}},
std::pair{ &Float16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat16, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 3, args[0]);
}},
std::pair{ &Float16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_ctor0_Float16_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float16x3_ctor1_Float16x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x3_ctor2_Float16_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt16, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_ctor0_UInt16_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt16x3_ctor1_UInt16x2_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x3_ctor2_UInt16_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 3, args[0]);
}},
std::pair{ &Int16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 3, args[0]);
}},
std::pair{ &Int16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt16, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_ctor0_Int16_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int16x3_ctor1_Int16x2_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x3_ctor2_Int16_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_ctor0_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_ctor0_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_ctor0_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_ctor0_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_ctor0_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_ctor0_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_ctor0_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x3_ctor1_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_ctor2_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt32, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_ctor0_UInt32_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x3_ctor1_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_ctor2_UInt32_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt32, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_ctor0_Int32_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x3_ctor1_Int32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_ctor2_Int32_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_ctor0_Bool8_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x3_ctor1_Bool8x2_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_ctor2_Bool8_Bool8x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 3, args[0]);
}},
std::pair{ &Float16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat16, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 3, args[0]);
}},
std::pair{ &Float16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_ctor0_Float16_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float16x3_ctor1_Float16x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x3_ctor2_Float16_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt16, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_ctor0_UInt16_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt16x3_ctor1_UInt16x2_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x3_ctor2_UInt16_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 3, args[0]);
}},
std::pair{ &Int16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 3, args[0]);
}},
std::pair{ &Int16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt16, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_ctor0_Int16_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int16x3_ctor1_Int16x2_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x3_ctor2_Int16_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 4, args[0]);
}},
std::pair{ &Float32x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 4, args[0]);
}},
std::pair{ &Float32x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_ctor0_Float32_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &Float32x4_ctor1_Float32x2_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor2_Float32_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor3_Float32_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor4_Float32x3_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x4_ctor5_Float32_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_ctor0_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_ctor0_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_ctor0_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_ctor0_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_ctor0_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_ctor0_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_ctor0_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x3_ctor1_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_ctor2_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt32, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_ctor0_UInt32_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x3_ctor1_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_ctor2_UInt32_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt32, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_ctor0_Int32_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x3_ctor1_Int32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_ctor2_Int32_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_ctor0_Bool8_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x3_ctor1_Bool8x2_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_ctor2_Bool8_Bool8x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 3, args[0]);
}},
std::pair{ &Float16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat16, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 3, args[0]);
}},
std::pair{ &Float16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_ctor0_Float16_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float16x3_ctor1_Float16x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x3_ctor2_Float16_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt16, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_ctor0_UInt16_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt16x3_ctor1_UInt16x2_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x3_ctor2_UInt16_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 3, args[0]);
}},
std::pair{ &Int16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 3, args[0]);
}},
std::pair{ &Int16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt16, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_ctor0_Int16_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int16x3_ctor1_Int16x2_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x3_ctor2_Int16_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 4, args[0]);
}},
std::pair{ &Float32x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 4, args[0]);
}},
std::pair{ &Float32x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_ctor0_Float32_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &Float32x4_ctor1_Float32x2_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor2_Float32_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor3_Float32_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor4_Float32x3_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x4_ctor5_Float32_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt32, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_ctor0_UInt32_UInt32_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &UInt32x4_ctor1_UInt32x2_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x4_ctor2_UInt32_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x4_ctor3_UInt32_UInt32_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x4_ctor4_UInt32x3_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x4_ctor5_UInt32_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_ctor0_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_ctor0_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_ctor0_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_ctor0_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_ctor0_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_ctor0_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_ctor0_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x3_ctor1_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_ctor2_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt32, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_ctor0_UInt32_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x3_ctor1_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_ctor2_UInt32_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt32, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_ctor0_Int32_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x3_ctor1_Int32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_ctor2_Int32_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_ctor0_Bool8_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x3_ctor1_Bool8x2_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_ctor2_Bool8_Bool8x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 3, args[0]);
}},
std::pair{ &Float16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat16, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 3, args[0]);
}},
std::pair{ &Float16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_ctor0_Float16_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float16x3_ctor1_Float16x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x3_ctor2_Float16_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt16, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_ctor0_UInt16_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt16x3_ctor1_UInt16x2_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x3_ctor2_UInt16_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 3, args[0]);
}},
std::pair{ &Int16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 3, args[0]);
}},
std::pair{ &Int16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt16, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_ctor0_Int16_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int16x3_ctor1_Int16x2_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x3_ctor2_Int16_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 4, args[0]);
}},
std::pair{ &Float32x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 4, args[0]);
}},
std::pair{ &Float32x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_ctor0_Float32_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &Float32x4_ctor1_Float32x2_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor2_Float32_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor3_Float32_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor4_Float32x3_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x4_ctor5_Float32_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt32, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_ctor0_UInt32_UInt32_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &UInt32x4_ctor1_UInt32x2_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x4_ctor2_UInt32_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x4_ctor3_UInt32_UInt32_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x4_ctor4_UInt32x3_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x4_ctor5_UInt32_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 4, args[0]);
}},
std::pair{ &Int32x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 4, args[0]);
}},
std::pair{ &Int32x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt32, 4, args[0]);
}},
std::pair{ &Int32x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 4, args[0]);
}},
std::pair{ &Int32x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 4, args[0]);
}},
std::pair{ &Int32x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 4, args[0]);
}},
std::pair{ &Int32x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_ctor0_Int32_Int32_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &Int32x4_ctor1_Int32x2_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x4_ctor2_Int32_Int32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x4_ctor3_Int32_Int32_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x4_ctor4_Int32x3_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x4_ctor5_Int32_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_ctor0_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_ctor0_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_ctor0_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_ctor0_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_ctor0_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_ctor0_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_ctor0_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x3_ctor1_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_ctor2_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt32, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_ctor0_UInt32_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x3_ctor1_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_ctor2_UInt32_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt32, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_ctor0_Int32_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x3_ctor1_Int32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_ctor2_Int32_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_ctor0_Bool8_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x3_ctor1_Bool8x2_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_ctor2_Bool8_Bool8x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 3, args[0]);
}},
std::pair{ &Float16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat16, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 3, args[0]);
}},
std::pair{ &Float16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_ctor0_Float16_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float16x3_ctor1_Float16x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x3_ctor2_Float16_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt16, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_ctor0_UInt16_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt16x3_ctor1_UInt16x2_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x3_ctor2_UInt16_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 3, args[0]);
}},
std::pair{ &Int16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 3, args[0]);
}},
std::pair{ &Int16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt16, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_ctor0_Int16_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int16x3_ctor1_Int16x2_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x3_ctor2_Int16_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 4, args[0]);
}},
std::pair{ &Float32x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 4, args[0]);
}},
std::pair{ &Float32x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_ctor0_Float32_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &Float32x4_ctor1_Float32x2_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor2_Float32_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor3_Float32_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor4_Float32x3_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x4_ctor5_Float32_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt32, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_ctor0_UInt32_UInt32_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &UInt32x4_ctor1_UInt32x2_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x4_ctor2_UInt32_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x4_ctor3_UInt32_UInt32_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x4_ctor4_UInt32x3_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x4_ctor5_UInt32_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 4, args[0]);
}},
std::pair{ &Int32x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 4, args[0]);
}},
std::pair{ &Int32x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt32, 4, args[0]);
}},
std::pair{ &Int32x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 4, args[0]);
}},
std::pair{ &Int32x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 4, args[0]);
}},
std::pair{ &Int32x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 4, args[0]);
}},
std::pair{ &Int32x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_ctor0_Int32_Int32_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &Int32x4_ctor1_Int32x2_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x4_ctor2_Int32_Int32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x4_ctor3_Int32_Int32_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x4_ctor4_Int32x3_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x4_ctor5_Int32_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 4, args[0]);
}},
std::pair{ &Bool8x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Bool8x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 4, args[0]);
}},
std::pair{ &Bool8x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Bool8x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 4, args[0]);
}},
std::pair{ &Bool8x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Bool8x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 4, args[0]);
}},
std::pair{ &Bool8x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Bool8x4_ctor0_Bool8_Bool8_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &Bool8x4_ctor1_Bool8x2_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x4_ctor2_Bool8_Bool8x2_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x4_ctor3_Bool8_Bool8_Bool8x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x4_ctor4_Bool8x3_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x4_ctor5_Bool8_Bool8x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_ctor0_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_ctor0_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_ctor0_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_ctor0_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_ctor0_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_ctor0_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_ctor0_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x3_ctor1_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_ctor2_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt32, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_ctor0_UInt32_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x3_ctor1_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_ctor2_UInt32_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt32, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_ctor0_Int32_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x3_ctor1_Int32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_ctor2_Int32_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_ctor0_Bool8_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x3_ctor1_Bool8x2_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_ctor2_Bool8_Bool8x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 3, args[0]);
}},
std::pair{ &Float16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat16, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 3, args[0]);
}},
std::pair{ &Float16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_ctor0_Float16_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float16x3_ctor1_Float16x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x3_ctor2_Float16_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt16, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_ctor0_UInt16_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt16x3_ctor1_UInt16x2_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x3_ctor2_UInt16_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 3, args[0]);
}},
std::pair{ &Int16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 3, args[0]);
}},
std::pair{ &Int16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt16, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_ctor0_Int16_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int16x3_ctor1_Int16x2_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x3_ctor2_Int16_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 4, args[0]);
}},
std::pair{ &Float32x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 4, args[0]);
}},
std::pair{ &Float32x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_ctor0_Float32_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &Float32x4_ctor1_Float32x2_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor2_Float32_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor3_Float32_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor4_Float32x3_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x4_ctor5_Float32_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt32, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_ctor0_UInt32_UInt32_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &UInt32x4_ctor1_UInt32x2_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x4_ctor2_UInt32_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x4_ctor3_UInt32_UInt32_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x4_ctor4_UInt32x3_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x4_ctor5_UInt32_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 4, args[0]);
}},
std::pair{ &Int32x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 4, args[0]);
}},
std::pair{ &Int32x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt32, 4, args[0]);
}},
std::pair{ &Int32x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 4, args[0]);
}},
std::pair{ &Int32x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 4, args[0]);
}},
std::pair{ &Int32x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 4, args[0]);
}},
std::pair{ &Int32x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_ctor0_Int32_Int32_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &Int32x4_ctor1_Int32x2_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x4_ctor2_Int32_Int32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x4_ctor3_Int32_Int32_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x4_ctor4_Int32x3_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x4_ctor5_Int32_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 4, args[0]);
}},
std::pair{ &Bool8x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Bool8x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 4, args[0]);
}},
std::pair{ &Bool8x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Bool8x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 4, args[0]);
}},
std::pair{ &Bool8x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Bool8x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 4, args[0]);
}},
std::pair{ &Bool8x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Bool8x4_ctor0_Bool8_Bool8_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &Bool8x4_ctor1_Bool8x2_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x4_ctor2_Bool8_Bool8x2_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x4_ctor3_Bool8_Bool8_Bool8x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x4_ctor4_Bool8x3_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x4_ctor5_Bool8_Bool8x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 4, args[0]);
}},
std::pair{ &Float16x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float16x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 4, args[0]);
}},
std::pair{ &Float16x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float16x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 4, args[0]);
}},
std::pair{ &Float16x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float16x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat16, 4, args[0]);
}},
std::pair{ &Float16x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float16x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 4, args[0]);
}},
std::pair{ &Float16x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float16x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 4, args[0]);
}},
std::pair{ &Float16x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float16x4_ctor0_Float16_Float16_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &Float16x4_ctor1_Float16x2_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float16x4_ctor2_Float16_Float16x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float16x4_ctor3_Float16_Float16_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float16x4_ctor4_Float16x3_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x4_ctor5_Float16_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_ctor0_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_ctor0_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_ctor0_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_ctor0_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_ctor0_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_ctor0_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_ctor0_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x3_ctor1_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_ctor2_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt32, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_ctor0_UInt32_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x3_ctor1_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_ctor2_UInt32_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt32, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_ctor0_Int32_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x3_ctor1_Int32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_ctor2_Int32_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_ctor0_Bool8_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x3_ctor1_Bool8x2_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_ctor2_Bool8_Bool8x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 3, args[0]);
}},
std::pair{ &Float16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat16, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 3, args[0]);
}},
std::pair{ &Float16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_ctor0_Float16_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float16x3_ctor1_Float16x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x3_ctor2_Float16_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt16, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_ctor0_UInt16_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt16x3_ctor1_UInt16x2_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x3_ctor2_UInt16_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 3, args[0]);
}},
std::pair{ &Int16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 3, args[0]);
}},
std::pair{ &Int16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt16, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_ctor0_Int16_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int16x3_ctor1_Int16x2_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x3_ctor2_Int16_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 4, args[0]);
}},
std::pair{ &Float32x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 4, args[0]);
}},
std::pair{ &Float32x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_ctor0_Float32_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &Float32x4_ctor1_Float32x2_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor2_Float32_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor3_Float32_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor4_Float32x3_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x4_ctor5_Float32_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt32, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_ctor0_UInt32_UInt32_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &UInt32x4_ctor1_UInt32x2_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x4_ctor2_UInt32_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x4_ctor3_UInt32_UInt32_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x4_ctor4_UInt32x3_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x4_ctor5_UInt32_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 4, args[0]);
}},
std::pair{ &Int32x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 4, args[0]);
}},
std::pair{ &Int32x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt32, 4, args[0]);
}},
std::pair{ &Int32x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 4, args[0]);
}},
std::pair{ &Int32x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 4, args[0]);
}},
std::pair{ &Int32x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 4, args[0]);
}},
std::pair{ &Int32x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_ctor0_Int32_Int32_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &Int32x4_ctor1_Int32x2_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x4_ctor2_Int32_Int32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x4_ctor3_Int32_Int32_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x4_ctor4_Int32x3_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x4_ctor5_Int32_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 4, args[0]);
}},
std::pair{ &Bool8x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Bool8x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 4, args[0]);
}},
std::pair{ &Bool8x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Bool8x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 4, args[0]);
}},
std::pair{ &Bool8x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Bool8x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 4, args[0]);
}},
std::pair{ &Bool8x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Bool8x4_ctor0_Bool8_Bool8_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &Bool8x4_ctor1_Bool8x2_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x4_ctor2_Bool8_Bool8x2_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x4_ctor3_Bool8_Bool8_Bool8x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x4_ctor4_Bool8x3_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x4_ctor5_Bool8_Bool8x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 4, args[0]);
}},
std::pair{ &Float16x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float16x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 4, args[0]);
}},
std::pair{ &Float16x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float16x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 4, args[0]);
}},
std::pair{ &Float16x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float16x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat16, 4, args[0]);
}},
std::pair{ &Float16x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float16x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 4, args[0]);
}},
std::pair{ &Float16x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float16x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 4, args[0]);
}},
std::pair{ &Float16x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float16x4_ctor0_Float16_Float16_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &Float16x4_ctor1_Float16x2_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float16x4_ctor2_Float16_Float16x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float16x4_ctor3_Float16_Float16_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float16x4_ctor4_Float16x3_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x4_ctor5_Float16_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 4, args[0]);
}},
std::pair{ &UInt16x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt16x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 4, args[0]);
}},
std::pair{ &UInt16x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt16x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 4, args[0]);
}},
std::pair{ &UInt16x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt16x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 4, args[0]);
}},
std::pair{ &UInt16x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt16x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt16, 4, args[0]);
}},
std::pair{ &UInt16x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt16x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 4, args[0]);
}},
std::pair{ &UInt16x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt16x4_ctor0_UInt16_UInt16_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &UInt16x4_ctor1_UInt16x2_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt16x4_ctor2_UInt16_UInt16x2_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt16x4_ctor3_UInt16_UInt16_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt16x4_ctor4_UInt16x3_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x4_ctor5_UInt16_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, args[0]);
}},
std::pair{ &Float32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, args[0]);
}},
std::pair{ &Float32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, args[0]);
}},
std::pair{ &Float32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, args[0]);
}},
std::pair{ &Float32_ctor0_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, args[0]);
}},
std::pair{ &UInt32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, args[0]);
}},
std::pair{ &UInt32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, args[0]);
}},
std::pair{ &UInt32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, args[0]);
}},
std::pair{ &UInt32_ctor0_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int32_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, args[0]);
}},
std::pair{ &Int32_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, args[0]);
}},
std::pair{ &Int32_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, args[0]);
}},
std::pair{ &Int32_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, args[0]);
}},
std::pair{ &Int32_ctor0_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Bool8_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 1, args[0]);
}},
std::pair{ &Bool8_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 1, args[0]);
}},
std::pair{ &Bool8_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 1, args[0]);
}},
std::pair{ &Bool8_ctor0_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, args[0]);
}},
std::pair{ &Float16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, args[0]);
}},
std::pair{ &Float16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, args[0]);
}},
std::pair{ &Float16_ctor0_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &UInt16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, args[0]);
}},
std::pair{ &UInt16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, args[0]);
}},
std::pair{ &UInt16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, args[0]);
}},
std::pair{ &UInt16_convert_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, args[0]);
}},
std::pair{ &UInt16_ctor0_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Int16_convert_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, args[0]);
}},
std::pair{ &Int16_convert_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, args[0]);
}},
std::pair{ &Int16_convert_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, args[0]);
}},
std::pair{ &Int16_ctor0_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0]});
}},
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 2, args[0]);
}},
std::pair{ &Float32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float32x2_ctor0_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 2, args[0]);
}},
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt32x2_ctor0_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt32, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 2, args[0]);
}},
std::pair{ &Int32x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int32x2_ctor0_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 2, args[0]);
}},
std::pair{ &Bool8x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Bool8x2_ctor0_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 2, args[0]);
}},
std::pair{ &Float16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Float16x2_ctor0_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 2, args[0]);
}},
std::pair{ &UInt16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &UInt16x2_ctor0_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x2_convert_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_convert_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt16, 2, args[0]);
}},
std::pair{ &Int16x2_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 2, val);
}},
std::pair{ &Int16x2_ctor0_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 3, args[0]);
}},
std::pair{ &Float32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float32x3_ctor0_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x3_ctor1_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x3_ctor2_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt32, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 3, args[0]);
}},
std::pair{ &UInt32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt32x3_ctor0_UInt32_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x3_ctor1_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x3_ctor2_UInt32_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt32, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 3, args[0]);
}},
std::pair{ &Int32x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 3, args[0]);
}},
std::pair{ &Int32x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int32x3_ctor0_Int32_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x3_ctor1_Int32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x3_ctor2_Int32_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 3, args[0]);
}},
std::pair{ &Bool8x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Bool8x3_ctor0_Bool8_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x3_ctor1_Bool8x2_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x3_ctor2_Bool8_Bool8x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 3, args[0]);
}},
std::pair{ &Float16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat16, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 3, args[0]);
}},
std::pair{ &Float16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 3, args[0]);
}},
std::pair{ &Float16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Float16x3_ctor0_Float16_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float16x3_ctor1_Float16x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x3_ctor2_Float16_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt16, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 3, args[0]);
}},
std::pair{ &UInt16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &UInt16x3_ctor0_UInt16_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt16x3_ctor1_UInt16x2_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x3_ctor2_UInt16_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x3_convert_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 3, args[0]);
}},
std::pair{ &Int16x3_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 3, args[0]);
}},
std::pair{ &Int16x3_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_convert_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt16, 3, args[0]);
}},
std::pair{ &Int16x3_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 3, val);
}},
std::pair{ &Int16x3_ctor0_Int16_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int16x3_ctor1_Int16x2_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x3_ctor2_Int16_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat32, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 4, args[0]);
}},
std::pair{ &Float32x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 4, args[0]);
}},
std::pair{ &Float32x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 4, args[0]);
}},
std::pair{ &Float32x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float32x4_ctor0_Float32_Float32_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &Float32x4_ctor1_Float32x2_Float32_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor2_Float32_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor3_Float32_Float32_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float32x4_ctor4_Float32x3_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32x4_ctor5_Float32_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat32, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt32, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 4, args[0]);
}},
std::pair{ &UInt32x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt32x4_ctor0_UInt32_UInt32_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &UInt32x4_ctor1_UInt32x2_UInt32_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x4_ctor2_UInt32_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x4_ctor3_UInt32_UInt32_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt32x4_ctor4_UInt32x3_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt32x4_ctor5_UInt32_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat32, 4, args[0]);
}},
std::pair{ &Int32x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt32, 4, args[0]);
}},
std::pair{ &Int32x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt32, 4, args[0]);
}},
std::pair{ &Int32x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 4, args[0]);
}},
std::pair{ &Int32x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 4, args[0]);
}},
std::pair{ &Int32x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 4, args[0]);
}},
std::pair{ &Int32x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int32x4_ctor0_Int32_Int32_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &Int32x4_ctor1_Int32x2_Int32_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x4_ctor2_Int32_Int32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x4_ctor3_Int32_Int32_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int32x4_ctor4_Int32x3_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int32x4_ctor5_Int32_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt32, 4, args[0]);
}},
std::pair{ &Bool8x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Bool8x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt32, 4, args[0]);
}},
std::pair{ &Bool8x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Bool8x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToUInt16, 4, args[0]);
}},
std::pair{ &Bool8x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Bool8x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Bool8ToInt16, 4, args[0]);
}},
std::pair{ &Bool8x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToBool8, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Bool8x4_ctor0_Bool8_Bool8_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &Bool8x4_ctor1_Bool8x2_Bool8_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x4_ctor2_Bool8_Bool8x2_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x4_ctor3_Bool8_Bool8_Bool8x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Bool8x4_ctor4_Bool8x3_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Bool8x4_ctor5_Bool8_Bool8x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat32, 4, args[0]);
}},
std::pair{ &Float16x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float16x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt32, 4, args[0]);
}},
std::pair{ &Float16x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float16x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt32, 4, args[0]);
}},
std::pair{ &Float16x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float16x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToFloat16, 4, args[0]);
}},
std::pair{ &Float16x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float16x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 4, args[0]);
}},
std::pair{ &Float16x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float16x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 4, args[0]);
}},
std::pair{ &Float16x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Float16x4_ctor0_Float16_Float16_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &Float16x4_ctor1_Float16x2_Float16_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float16x4_ctor2_Float16_Float16x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float16x4_ctor3_Float16_Float16_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Float16x4_ctor4_Float16x3_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float16x4_ctor5_Float16_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat32, 4, args[0]);
}},
std::pair{ &UInt16x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt16x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt32, 4, args[0]);
}},
std::pair{ &UInt16x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt16x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt32, 4, args[0]);
}},
std::pair{ &UInt16x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt16x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToFloat16, 4, args[0]);
}},
std::pair{ &UInt16x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt16x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToUInt16, 4, args[0]);
}},
std::pair{ &UInt16x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt16x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 4, args[0]);
}},
std::pair{ &UInt16x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &UInt16x4_ctor0_UInt16_UInt16_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &UInt16x4_ctor1_UInt16x2_UInt16_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt16x4_ctor2_UInt16_UInt16x2_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt16x4_ctor3_UInt16_UInt16_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &UInt16x4_ctor4_UInt16x3_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &UInt16x4_ctor5_UInt16_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x4_convert_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat32, 4, args[0]);
}},
std::pair{ &Int16x4_splat_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int16x4_convert_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt32, 4, args[0]);
}},
std::pair{ &Int16x4_splat_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int16x4_convert_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt32, 4, args[0]);
}},
std::pair{ &Int16x4_splat_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Int32ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int16x4_convert_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToFloat16, 4, args[0]);
}},
std::pair{ &Int16x4_splat_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::Float16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int16x4_convert_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToUInt16, 4, args[0]);
}},
std::pair{ &Int16x4_splat_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    val = GenerateConversionSPIRV(c, g, TypeConversionTable::UInt16ToInt16, 1, val);
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int16x4_convert_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateConversionSPIRV(c, g, TypeConversionTable::Int16ToInt16, 4, args[0]);
}},
std::pair{ &Int16x4_splat_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = args[0];
    return GenerateSplatCompositeSPIRV(c, g, returnType, 4, val);
}},
std::pair{ &Int16x4_ctor0_Int16_Int16_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2], args[3]});
}},
std::pair{ &Int16x4_ctor1_Int16x2_Int16_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int16x4_ctor2_Int16_Int16x2_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int16x4_ctor3_Int16_Int16_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1], args[2]});
}},
std::pair{ &Int16x4_ctor4_Int16x3_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Int16x4_ctor5_Int16_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    return GenerateCompositeSPIRV(c, g, returnType, {args[0], args[1]});
}},
std::pair{ &Float32_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32_operator_index_Int32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32_operator_index_UInt32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32_operator_index_Int16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32_operator_index_UInt16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32_operator_add_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32_operator_sub_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32_operator_mul_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32_operator_div_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32_operator_mod_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32_operator_addasg_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32_operator_subasg_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32_operator_mulasg_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32_operator_divasg_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32_operator_lt_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32_operator_lte_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32_operator_gt_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32_operator_gte_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32_operator_eq_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32_operator_neq_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFNotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32_operator_index_Int32.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt32_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32_operator_index_UInt32.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt32_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32_operator_index_Int16.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt32_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32_operator_index_UInt16.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt32_operator_add_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_sub_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_mul_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_div_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_mod_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_addasg_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_subasg_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_mulasg_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_divasg_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_lt_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_lte_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_gt_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_gte_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_eq_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_neq_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_or_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_and_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_xor_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_lsh_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_rsh_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_orasg_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_andasg_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_xorasg_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_lshasg_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32_operator_rhsasg_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32_operator_index_Int32.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int32_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32_operator_index_UInt32.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int32_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32_operator_index_Int16.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int32_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32_operator_index_UInt16.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int32_operator_add_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_sub_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_mul_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_div_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_mod_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_addasg_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_subasg_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_mulasg_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_divasg_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_lt_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_lte_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_gt_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_gte_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_eq_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_neq_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_or_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_and_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_xor_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_lsh_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_rsh_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_orasg_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_andasg_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_xorasg_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_lshasg_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32_operator_rhsasg_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Bool8_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8_operator_index_Int32.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Bool8_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8_operator_index_UInt32.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Bool8_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8_operator_index_Int16.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Bool8_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8_operator_index_UInt16.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Bool8_operator_oror_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpLogicalOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Bool8_operator_andand_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpLogicalAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Bool8_operator_eq_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Bool8_operator_neq_Bool8 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16_operator_index_Int32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16_operator_index_UInt32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16_operator_index_Int16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16_operator_index_UInt16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16_operator_add_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16_operator_sub_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16_operator_mul_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16_operator_div_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16_operator_mod_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16_operator_addasg_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16_operator_subasg_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16_operator_mulasg_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16_operator_divasg_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16_operator_lt_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16_operator_lte_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16_operator_gt_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16_operator_gte_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16_operator_eq_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16_operator_neq_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFNotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16_operator_index_Int32.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt16_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16_operator_index_UInt32.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt16_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16_operator_index_Int16.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt16_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16_operator_index_UInt16.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt16_operator_add_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_sub_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_mul_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_div_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_mod_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_addasg_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_subasg_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_mulasg_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_divasg_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_lt_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_lte_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_gt_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_gte_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_eq_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_neq_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_or_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_and_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_xor_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_lsh_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_rsh_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_orasg_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_andasg_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_xorasg_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_lshasg_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16_operator_rhsasg_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16_operator_index_Int32.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int16_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16_operator_index_UInt32.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int16_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16_operator_index_Int16.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int16_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16_operator_index_UInt16.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int16_operator_add_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_sub_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_mul_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_div_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_mod_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_addasg_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_subasg_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_mulasg_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_divasg_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_lt_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_lte_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_gt_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_gte_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_eq_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_neq_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_or_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_and_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_xor_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_lsh_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_rsh_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_orasg_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_andasg_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_xorasg_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_lshasg_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16_operator_rhsasg_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2_operator_index_Int32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x2_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2_operator_index_UInt32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x2_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2_operator_index_Int16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x2_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2_operator_index_UInt16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x2_operator_add_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_sub_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_mul_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_div_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_mod_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_addasg_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_subasg_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_mulasg_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_divasg_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_lt_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_lte_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_gt_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_gte_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_eq_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_neq_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFNotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_scale_Float32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_scale_Float32x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_scale_Float32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_scale_Float32x2_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_scale_Float32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_scale_Float32x2_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_mul_Float32x2x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_mul_Float32x2x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2_operator_mul_Float32x2x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32x2_operator_index_Int32.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt32x2_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32x2_operator_index_UInt32.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt32x2_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32x2_operator_index_Int16.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt32x2_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32x2_operator_index_UInt16.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt32x2_operator_add_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_sub_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_mul_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_div_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_mod_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_addasg_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_subasg_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_mulasg_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_divasg_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_lt_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_lte_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_gt_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_gte_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_eq_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_neq_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_scale_UInt32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_scale_UInt32x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_scale_UInt32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_scale_UInt32x2_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_scale_UInt32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_scale_UInt32x2_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_or_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_and_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_xor_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_lsh_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_rsh_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_orasg_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_andasg_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_xorasg_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_lshasg_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x2_operator_rhsasg_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32x2_operator_index_Int32.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int32x2_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32x2_operator_index_UInt32.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int32x2_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32x2_operator_index_Int16.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int32x2_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32x2_operator_index_UInt16.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int32x2_operator_add_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_sub_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_mul_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_div_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_mod_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_addasg_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_subasg_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_mulasg_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_divasg_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_lt_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_lte_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_gt_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_gte_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_eq_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_neq_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_scale_Int32x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_scale_Int32x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_scale_Int32x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_scale_Int32x2_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_scale_Int32x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_scale_Int32x2_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_or_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_and_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_xor_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_lsh_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_rsh_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_orasg_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_andasg_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_xorasg_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_lshasg_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x2_operator_rhsasg_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Bool8x2_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8x2_operator_index_Int32.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Bool8x2_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8x2_operator_index_UInt32.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Bool8x2_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8x2_operator_index_Int16.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Bool8x2_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8x2_operator_index_UInt16.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Bool8x2_operator_oror_Bool8x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpLogicalOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Bool8x2_operator_andand_Bool8x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpLogicalAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Bool8x2_operator_eq_Bool8x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Bool8x2_operator_neq_Bool8x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2_operator_index_Int32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x2_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2_operator_index_UInt32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x2_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2_operator_index_Int16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x2_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2_operator_index_UInt16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x2_operator_add_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_sub_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_mul_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_div_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_mod_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_addasg_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_subasg_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_mulasg_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_divasg_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_lt_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_lte_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_gt_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_gte_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_eq_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_neq_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFNotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_scale_Float16x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_scale_Float16x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_scale_Float16x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_scale_Float16x2_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_scale_Float16x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_scale_Float16x2_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_mul_Float32x2x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_mul_Float32x2x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2_operator_mul_Float32x2x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16x2_operator_index_Int32.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt16x2_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16x2_operator_index_UInt32.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt16x2_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16x2_operator_index_Int16.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt16x2_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16x2_operator_index_UInt16.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt16x2_operator_add_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_sub_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_mul_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_div_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_mod_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_addasg_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_subasg_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_mulasg_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_divasg_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_lt_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_lte_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_gt_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_gte_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_eq_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_neq_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_scale_UInt16x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_scale_UInt16x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_scale_UInt16x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_scale_UInt16x2_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_scale_UInt16x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_scale_UInt16x2_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_or_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_and_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_xor_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_lsh_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_rsh_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_orasg_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_andasg_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_xorasg_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_lshasg_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x2_operator_rhsasg_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16x2_operator_index_Int32.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int16x2_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16x2_operator_index_UInt32.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int16x2_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16x2_operator_index_Int16.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int16x2_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16x2_operator_index_UInt16.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int16x2_operator_add_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_sub_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_mul_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_div_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_mod_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_addasg_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_subasg_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_mulasg_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_divasg_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_lt_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_lte_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_gt_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_gte_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_eq_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_neq_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_scale_Int16x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_scale_Int16x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_scale_Int16x2_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_scale_Int16x2_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_scale_Int16x2_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_scale_Int16x2_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {2}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_or_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_and_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_xor_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_lsh_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_rsh_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_orasg_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_andasg_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_xorasg_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_lshasg_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x2_operator_rhsasg_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3_operator_index_Int32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x3_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3_operator_index_UInt32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x3_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3_operator_index_Int16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x3_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3_operator_index_UInt16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x3_operator_add_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_sub_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_mul_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_div_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_mod_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_addasg_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_subasg_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_mulasg_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_divasg_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_lt_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_lte_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_gt_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_gte_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_eq_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_neq_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFNotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_scale_Float32x3_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_scale_Float32x3_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_scale_Float32x3_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_scale_Float32x3_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_scale_Float32x3_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_scale_Float32x3_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_mul_Float32x3x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_mul_Float32x3x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3_operator_mul_Float32x3x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32x3_operator_index_Int32.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt32x3_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32x3_operator_index_UInt32.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt32x3_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32x3_operator_index_Int16.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt32x3_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32x3_operator_index_UInt16.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt32x3_operator_add_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_sub_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_mul_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_div_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_mod_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_addasg_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_subasg_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_mulasg_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_divasg_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_lt_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_lte_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_gt_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_gte_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_eq_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_neq_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_scale_UInt32x3_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_scale_UInt32x3_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_scale_UInt32x3_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_scale_UInt32x3_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_scale_UInt32x3_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_scale_UInt32x3_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_or_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_and_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_xor_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_lsh_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_rsh_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_orasg_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_andasg_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_xorasg_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_lshasg_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x3_operator_rhsasg_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32x3_operator_index_Int32.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int32x3_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32x3_operator_index_UInt32.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int32x3_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32x3_operator_index_Int16.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int32x3_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32x3_operator_index_UInt16.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int32x3_operator_add_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_sub_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_mul_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_div_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_mod_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_addasg_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_subasg_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_mulasg_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_divasg_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_lt_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_lte_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_gt_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_gte_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_eq_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_neq_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_scale_Int32x3_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_scale_Int32x3_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_scale_Int32x3_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_scale_Int32x3_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_scale_Int32x3_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_scale_Int32x3_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_or_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_and_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_xor_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_lsh_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_rsh_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_orasg_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_andasg_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_xorasg_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_lshasg_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x3_operator_rhsasg_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Bool8x3_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8x3_operator_index_Int32.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Bool8x3_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8x3_operator_index_UInt32.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Bool8x3_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8x3_operator_index_Int16.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Bool8x3_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8x3_operator_index_UInt16.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Bool8x3_operator_oror_Bool8x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpLogicalOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Bool8x3_operator_andand_Bool8x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpLogicalAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Bool8x3_operator_eq_Bool8x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Bool8x3_operator_neq_Bool8x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3_operator_index_Int32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x3_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3_operator_index_UInt32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x3_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3_operator_index_Int16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x3_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3_operator_index_UInt16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x3_operator_add_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_sub_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_mul_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_div_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_mod_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_addasg_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_subasg_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_mulasg_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_divasg_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_lt_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_lte_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_gt_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_gte_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_eq_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_neq_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFNotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_scale_Float16x3_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_scale_Float16x3_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_scale_Float16x3_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_scale_Float16x3_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_scale_Float16x3_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_scale_Float16x3_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_mul_Float32x3x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_mul_Float32x3x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3_operator_mul_Float32x3x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16x3_operator_index_Int32.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt16x3_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16x3_operator_index_UInt32.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt16x3_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16x3_operator_index_Int16.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt16x3_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16x3_operator_index_UInt16.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt16x3_operator_add_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_sub_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_mul_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_div_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_mod_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_addasg_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_subasg_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_mulasg_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_divasg_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_lt_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_lte_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_gt_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_gte_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_eq_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_neq_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_scale_UInt16x3_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_scale_UInt16x3_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_scale_UInt16x3_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_scale_UInt16x3_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_scale_UInt16x3_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_scale_UInt16x3_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_or_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_and_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_xor_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_lsh_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_rsh_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_orasg_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_andasg_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_xorasg_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_lshasg_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x3_operator_rhsasg_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16x3_operator_index_Int32.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int16x3_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16x3_operator_index_UInt32.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int16x3_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16x3_operator_index_Int16.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int16x3_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16x3_operator_index_UInt16.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int16x3_operator_add_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_sub_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_mul_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_div_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_mod_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_addasg_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_subasg_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_mulasg_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_divasg_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_lt_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_lte_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_gt_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_gte_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_eq_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_neq_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_scale_Int16x3_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_scale_Int16x3_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_scale_Int16x3_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_scale_Int16x3_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_scale_Int16x3_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_scale_Int16x3_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {3}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_or_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_and_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_xor_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_lsh_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_rsh_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_orasg_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_andasg_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_xorasg_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_lshasg_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x3_operator_rhsasg_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4_operator_index_Int32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x4_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4_operator_index_UInt32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x4_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4_operator_index_Int16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x4_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4_operator_index_UInt16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x4_operator_add_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_sub_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_mul_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_div_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_mod_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_addasg_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_subasg_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_mulasg_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_divasg_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_lt_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_lte_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_gt_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_gte_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_eq_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_neq_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFNotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_scale_Float32x4_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_scale_Float32x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_scale_Float32x4_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_scale_Float32x4_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_scale_Float32x4_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_scale_Float32x4_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_mul_Float32x4x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_mul_Float32x4x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4_operator_mul_Float32x4x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32x4_operator_index_Int32.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt32x4_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32x4_operator_index_UInt32.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt32x4_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32x4_operator_index_Int16.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt32x4_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt32x4_operator_index_UInt16.returnType, &UInt32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt32x4_operator_add_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_sub_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_mul_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_div_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_mod_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_addasg_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_subasg_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_mulasg_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_divasg_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_lt_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_lte_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_gt_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_gte_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_eq_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_neq_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_scale_UInt32x4_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_scale_UInt32x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_scale_UInt32x4_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_scale_UInt32x4_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_scale_UInt32x4_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_scale_UInt32x4_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_or_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_and_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_xor_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_lsh_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_rsh_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_orasg_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_andasg_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_xorasg_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_lshasg_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt32x4_operator_rhsasg_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32x4_operator_index_Int32.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int32x4_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32x4_operator_index_UInt32.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int32x4_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32x4_operator_index_Int16.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int32x4_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int32x4_operator_index_UInt16.returnType, &Int32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int32x4_operator_add_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_sub_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_mul_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_div_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_mod_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_addasg_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_subasg_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_mulasg_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_divasg_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_lt_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_lte_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_gt_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_gte_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_eq_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_neq_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_scale_Int32x4_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_scale_Int32x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_scale_Int32x4_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_scale_Int32x4_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_scale_Int32x4_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_scale_Int32x4_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_or_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_and_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_xor_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_lsh_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_rsh_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_orasg_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_andasg_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_xorasg_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_lshasg_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int32x4_operator_rhsasg_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Bool8x4_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8x4_operator_index_Int32.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Bool8x4_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8x4_operator_index_UInt32.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Bool8x4_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8x4_operator_index_Int16.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Bool8x4_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Bool8x4_operator_index_UInt16.returnType, &Bool8Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Bool8x4_operator_oror_Bool8x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpLogicalOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Bool8x4_operator_andand_Bool8x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpLogicalAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Bool8x4_operator_eq_Bool8x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Bool8x4_operator_neq_Bool8x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4_operator_index_Int32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x4_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4_operator_index_UInt32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x4_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4_operator_index_Int16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x4_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4_operator_index_UInt16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x4_operator_add_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_sub_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_mul_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_div_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_mod_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_addasg_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_subasg_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_mulasg_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_divasg_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_lt_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_lte_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_gt_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_gte_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_eq_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_neq_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpFNotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_scale_Float16x4_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_scale_Float16x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_scale_Float16x4_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_scale_Float16x4_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_scale_Float16x4_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_scale_Float16x4_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_mul_Float32x4x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_mul_Float32x4x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4_operator_mul_Float32x4x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16x4_operator_index_Int32.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt16x4_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16x4_operator_index_UInt32.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt16x4_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16x4_operator_index_Int16.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt16x4_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, UInt16x4_operator_index_UInt16.returnType, &UInt16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &UInt16x4_operator_add_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_sub_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_mul_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_div_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_mod_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_addasg_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_subasg_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_mulasg_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_divasg_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_lt_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_lte_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_gt_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_gte_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_eq_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_neq_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_scale_UInt16x4_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_scale_UInt16x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_scale_UInt16x4_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_scale_UInt16x4_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_scale_UInt16x4_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_scale_UInt16x4_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_or_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_and_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_xor_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_lsh_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_rsh_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_orasg_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_andasg_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_xorasg_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_lshasg_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &UInt16x4_operator_rhsasg_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16x4_operator_index_Int32.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int16x4_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16x4_operator_index_UInt32.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int16x4_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16x4_operator_index_Int16.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int16x4_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Int16x4_operator_index_UInt16.returnType, &Int16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Int16x4_operator_add_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_sub_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_mul_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_div_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_mod_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSMod, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_addasg_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIAdd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_subasg_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpISub, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_mulasg_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_divasg_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIDiv, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_lt_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_lte_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSLessThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_gt_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThan, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_gte_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpSGreaterThanEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_eq_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_neq_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_scale_Int16x4_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_scale_Int16x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_scale_Int16x4_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_scale_Int16x4_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_scale_Int16x4_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_scale_Int16x4_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {4}, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_or_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseOr, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_and_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseAnd, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_xor_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpBitwiseXor, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_lsh_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftLeftLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_rsh_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_orasg_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_andasg_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_xorasg_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_lshasg_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Int16x4_operator_rhsasg_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpShiftRightLogical, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x2_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2x2_operator_index_Int32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x2x2_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2x2_operator_index_UInt32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x2x2_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2x2_operator_index_Int16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x2x2_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2x2_operator_index_UInt16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x2x2_operator_add_Float32x2x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x2_operator_sub_Float32x2x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x2_operator_mul_Float32x2x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x2_operator_addasg_Float32x2x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x2_operator_subasg_Float32x2x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x2_operator_mulasg_Float32x2x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x2_operator_scale_Float32x2x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x3_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2x3_operator_index_Int32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x2x3_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2x3_operator_index_UInt32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x2x3_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2x3_operator_index_Int16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x2x3_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2x3_operator_index_UInt16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x2x3_operator_add_Float32x2x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x3_operator_sub_Float32x2x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x3_operator_mul_Float32x2x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x3_operator_addasg_Float32x2x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x3_operator_subasg_Float32x2x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x3_operator_mulasg_Float32x2x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x3_operator_scale_Float32x2x3_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x4_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2x4_operator_index_Int32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x2x4_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2x4_operator_index_UInt32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x2x4_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2x4_operator_index_Int16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x2x4_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x2x4_operator_index_UInt16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x2x4_operator_add_Float32x2x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x4_operator_sub_Float32x2x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x4_operator_mul_Float32x2x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x4_operator_addasg_Float32x2x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x4_operator_subasg_Float32x2x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x4_operator_mulasg_Float32x2x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x2x4_operator_scale_Float32x2x4_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x2_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3x2_operator_index_Int32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x3x2_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3x2_operator_index_UInt32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x3x2_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3x2_operator_index_Int16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x3x2_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3x2_operator_index_UInt16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x3x2_operator_add_Float32x3x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x2_operator_sub_Float32x3x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x2_operator_mul_Float32x3x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x2_operator_addasg_Float32x3x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x2_operator_subasg_Float32x3x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x2_operator_mulasg_Float32x3x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x2_operator_scale_Float32x3x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x3_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3x3_operator_index_Int32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x3x3_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3x3_operator_index_UInt32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x3x3_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3x3_operator_index_Int16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x3x3_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3x3_operator_index_UInt16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x3x3_operator_add_Float32x3x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x3_operator_sub_Float32x3x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x3_operator_mul_Float32x3x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x3_operator_addasg_Float32x3x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x3_operator_subasg_Float32x3x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x3_operator_mulasg_Float32x3x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x3_operator_scale_Float32x3x3_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x4_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3x4_operator_index_Int32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x3x4_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3x4_operator_index_UInt32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x3x4_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3x4_operator_index_Int16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x3x4_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x3x4_operator_index_UInt16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x3x4_operator_add_Float32x3x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x4_operator_sub_Float32x3x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x4_operator_mul_Float32x3x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x4_operator_addasg_Float32x3x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x4_operator_subasg_Float32x3x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x4_operator_mulasg_Float32x3x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x3x4_operator_scale_Float32x3x4_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x2_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4x2_operator_index_Int32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x4x2_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4x2_operator_index_UInt32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x4x2_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4x2_operator_index_Int16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x4x2_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4x2_operator_index_UInt16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x4x2_operator_add_Float32x4x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x2_operator_sub_Float32x4x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x2_operator_mul_Float32x4x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x2_operator_addasg_Float32x4x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x2_operator_subasg_Float32x4x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x2_operator_mulasg_Float32x4x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x2_operator_scale_Float32x4x2_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x3_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4x3_operator_index_Int32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x4x3_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4x3_operator_index_UInt32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x4x3_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4x3_operator_index_Int16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x4x3_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4x3_operator_index_UInt16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x4x3_operator_add_Float32x4x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x3_operator_sub_Float32x4x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x3_operator_mul_Float32x4x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x3_operator_addasg_Float32x4x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x3_operator_subasg_Float32x4x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x3_operator_mulasg_Float32x4x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x3_operator_scale_Float32x4x3_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x4_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4x4_operator_index_Int32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x4x4_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4x4_operator_index_UInt32.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x4x4_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4x4_operator_index_Int16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x4x4_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float32x4x4_operator_index_UInt16.returnType, &Float32Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float32x4x4_operator_add_Float32x4x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x4_operator_sub_Float32x4x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x4_operator_mul_Float32x4x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x4_operator_addasg_Float32x4x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x4_operator_subasg_Float32x4x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x4_operator_mulasg_Float32x4x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float32x4x4_operator_scale_Float32x4x4_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x2_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2x2_operator_index_Int32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x2x2_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2x2_operator_index_UInt32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x2x2_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2x2_operator_index_Int16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x2x2_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2x2_operator_index_UInt16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x2x2_operator_add_Float16x2x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x2_operator_sub_Float16x2x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x2_operator_mul_Float16x2x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x2_operator_addasg_Float16x2x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x2_operator_subasg_Float16x2x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x2_operator_mulasg_Float16x2x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x2_operator_scale_Float16x2x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x3_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2x3_operator_index_Int32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x2x3_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2x3_operator_index_UInt32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x2x3_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2x3_operator_index_Int16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x2x3_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2x3_operator_index_UInt16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x2x3_operator_add_Float16x2x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x3_operator_sub_Float16x2x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x3_operator_mul_Float16x2x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x3_operator_addasg_Float16x2x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x3_operator_subasg_Float16x2x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x3_operator_mulasg_Float16x2x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x3_operator_scale_Float16x2x3_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x4_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2x4_operator_index_Int32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x2x4_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2x4_operator_index_UInt32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x2x4_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2x4_operator_index_Int16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x2x4_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x2x4_operator_index_UInt16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x2x4_operator_add_Float16x2x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x4_operator_sub_Float16x2x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x4_operator_mul_Float16x2x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x4_operator_addasg_Float16x2x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x4_operator_subasg_Float16x2x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x4_operator_mulasg_Float16x2x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x2x4_operator_scale_Float16x2x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x2_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3x2_operator_index_Int32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x3x2_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3x2_operator_index_UInt32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x3x2_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3x2_operator_index_Int16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x3x2_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3x2_operator_index_UInt16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x3x2_operator_add_Float16x3x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x2_operator_sub_Float16x3x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x2_operator_mul_Float16x3x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x2_operator_addasg_Float16x3x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x2_operator_subasg_Float16x3x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x2_operator_mulasg_Float16x3x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x2_operator_scale_Float16x3x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x3_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3x3_operator_index_Int32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x3x3_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3x3_operator_index_UInt32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x3x3_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3x3_operator_index_Int16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x3x3_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3x3_operator_index_UInt16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x3x3_operator_add_Float16x3x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x3_operator_sub_Float16x3x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x3_operator_mul_Float16x3x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x3_operator_addasg_Float16x3x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x3_operator_subasg_Float16x3x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x3_operator_mulasg_Float16x3x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x3_operator_scale_Float16x3x3_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x4_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3x4_operator_index_Int32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x3x4_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3x4_operator_index_UInt32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x3x4_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3x4_operator_index_Int16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x3x4_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x3x4_operator_index_UInt16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x3x4_operator_add_Float16x3x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x4_operator_sub_Float16x3x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x4_operator_mul_Float16x3x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x4_operator_addasg_Float16x3x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x4_operator_subasg_Float16x3x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x4_operator_mulasg_Float16x3x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x3x4_operator_scale_Float16x3x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x2_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4x2_operator_index_Int32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x4x2_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4x2_operator_index_UInt32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x4x2_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4x2_operator_index_Int16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x4x2_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4x2_operator_index_UInt16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x4x2_operator_add_Float16x4x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x2_operator_sub_Float16x4x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x2_operator_mul_Float16x4x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x2_operator_addasg_Float16x4x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x2_operator_subasg_Float16x4x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 2);
    TransientArray<SPVArg> intermediateArgs(2);
    for (uint32_t i = 0; i < 2; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x2_operator_mulasg_Float16x4x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x2_operator_scale_Float16x4x2_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x3_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4x3_operator_index_Int32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x4x3_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4x3_operator_index_UInt32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x4x3_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4x3_operator_index_Int16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x4x3_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4x3_operator_index_UInt16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x4x3_operator_add_Float16x4x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x3_operator_sub_Float16x4x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x3_operator_mul_Float16x4x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x3_operator_addasg_Float16x4x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x3_operator_subasg_Float16x4x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 3);
    TransientArray<SPVArg> intermediateArgs(3);
    for (uint32_t i = 0; i < 3; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x3_operator_mulasg_Float16x4x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x3_operator_scale_Float16x4x3_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_index_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4x4_operator_index_Int32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x4x4_operator_index_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4x4_operator_index_UInt32.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x4x4_operator_index_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4x4_operator_index_Int16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x4x4_operator_index_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, Float16x4x4_operator_index_UInt16.returnType, &Float16Type, args[0].scope);
    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult ret = args[0];
    ret.AddAccessChainLink({loadedIndex});
    ret.typeName = returnTypePtr.typeName;
    ret.parentTypes = returnTypePtr.parentTypes;
    ret.scope = args[0].scope;
    ret.isValue = false;
    return ret;
}},
std::pair{ &Float16x4x4_operator_add_Float16x4x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_sub_Float16x4x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_mul_Float16x4x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_addasg_Float16x4x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_subasg_Float16x4x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, 4);
    TransientArray<SPVArg> intermediateArgs(4);
    for (uint32_t i = 0; i < 4; i++);
    {
        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);
        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);
        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));
        intermediateArgs.Append(SPVArg(res));
    }
    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_mulasg_Float16x4x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acos, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acos, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acos, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acos, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acos, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acos, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acos, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acos, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acosh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acosh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acosh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acosh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acosh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acosh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acosh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Acosh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asin, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asin, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asin, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asin, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asin, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asin, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asin, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asin, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asinh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asinh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asinh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asinh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asinh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asinh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asinh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Asinh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atanh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atanh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atanh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atanh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atanh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atanh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atanh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atanh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cos, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cos, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cos, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cos, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cos, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cos, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cos, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cos, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cosh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cosh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cosh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cosh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cosh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cosh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cosh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cosh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp2, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp2, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp2, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp2, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp2, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp2, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp2, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Exp2, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), InverseSqrt, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), InverseSqrt, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), InverseSqrt, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), InverseSqrt, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), InverseSqrt, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), InverseSqrt, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), InverseSqrt, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), InverseSqrt, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log2, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log2, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log2, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log2, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log2, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log2, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log2, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Log2, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sin, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sin, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sin, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sin, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sin, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sin, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sin, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sin, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sinh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sinh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sinh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sinh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sinh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sinh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sinh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sinh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sqrt, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sqrt, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sqrt, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sqrt, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sqrt, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sqrt, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sqrt, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Sqrt, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tan, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tan, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tan, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tan, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tan, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tan, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tan, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tan, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tanh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tanh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tanh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tanh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tanh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tanh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tanh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Tanh, arg);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult y = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan2, y, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult y = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan2, y, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult y = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan2, y, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult y = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan2, y, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult y = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan2, y, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult y = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan2, y, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult y = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan2, y, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult y = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan2, y, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult exponent = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Pow, val, exponent);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult exponent = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Pow, val, exponent);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult exponent = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Pow, val, exponent);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult exponent = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Pow, val, exponent);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult exponent = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Pow, val, exponent);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult exponent = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Pow, val, exponent);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult exponent = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Pow, val, exponent);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult exponent = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Pow, val, exponent);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult x = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult y = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpDot, SPVWriter::Section::LocalFunction, returnType, x, y);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult x = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult y = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpDot, SPVWriter::Section::LocalFunction, returnType, x, y);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult x = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult y = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpDot, SPVWriter::Section::LocalFunction, returnType, x, y);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult x = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult y = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpDot, SPVWriter::Section::LocalFunction, returnType, x, y);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult x = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult y = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpDot, SPVWriter::Section::LocalFunction, returnType, x, y);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult x = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult y = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpDot, SPVWriter::Section::LocalFunction, returnType, x, y);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult incident = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult normal = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Reflect, incident, normal);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult incident = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult normal = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Reflect, incident, normal);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult incident = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult normal = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Reflect, incident, normal);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult incident = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult normal = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Reflect, incident, normal);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult incident = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult normal = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Reflect, incident, normal);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult incident = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult normal = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Reflect, incident, normal);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult incident = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult normal = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult ior = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Refract, incident, normal, ior);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult incident = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult normal = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult ior = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Refract, incident, normal, ior);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult incident = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult normal = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult ior = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Refract, incident, normal, ior);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult incident = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult normal = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult ior = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Refract, incident, normal, ior);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult incident = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult normal = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult ior = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Refract, incident, normal, ior);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult incident = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult normal = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult ior = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Refract, incident, normal, ior);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult x = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult y = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cross, x, y);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult x = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult y = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cross, x, y);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult vec = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Length, vec);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult vec = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Length, vec);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult vec = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Length, vec);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult vec = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Length, vec);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult vec = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Length, vec);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult vec = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Length, vec);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult vec = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Normalize, vec);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult vec = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Normalize, vec);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult vec = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Normalize, vec);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult vec = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Normalize, vec);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult vec = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Normalize, vec);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult vec = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Normalize, vec);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult v0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult v1 = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Distance, v0, v1);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult v0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult v1 = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Distance, v0, v1);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult v0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult v1 = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Distance, v0, v1);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult v0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult v1 = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Distance, v0, v1);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult v0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult v1 = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Distance, v0, v1);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult v0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult v1 = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Distance, v0, v1);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMin, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UMax, val, limit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), UClamp, val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult a = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult b = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult t = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMix, a, b, t);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult a = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult b = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult t = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMix, a, b, t);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult a = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult b = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult t = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMix, a, b, t);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult a = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult b = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult t = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMix, a, b, t);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult a = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult b = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult t = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMix, a, b, t);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult a = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult b = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult t = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMix, a, b, t);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult edge = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Step, edge, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult edge = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Step, edge, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult edge = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Step, edge, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult edge = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Step, edge, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult edge = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Step, edge, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult edge = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Step, edge, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult edge = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Step, edge, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult edge = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Step, edge, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult edge0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult edge1 = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Max, edge0, edge1, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult edge0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult edge1 = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Max, edge0, edge1, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult edge0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult edge1 = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Max, edge0, edge1, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult edge0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult edge1 = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Max, edge0, edge1, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult edge0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult edge1 = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Max, edge0, edge1, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult edge0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult edge1 = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Max, edge0, edge1, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult edge0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult edge1 = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Max, edge0, edge1, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult edge0 = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult edge1 = LoadValueSPIRV(c, g, args[1]);
    SPIRVResult x = LoadValueSPIRV(c, g, args[2]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Max, edge0, edge1, x);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Ceil, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Ceil, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Ceil, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Ceil, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Ceil, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Ceil, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Ceil, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Ceil, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Floor, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Floor, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Floor, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Floor, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Floor, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Floor, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Floor, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Floor, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fract, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fract, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fract, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fract, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fract, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fract, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fract, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fract, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Saturate, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Saturate, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Saturate, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Saturate, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Saturate, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Saturate, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Saturate, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Saturate, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Trunc, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Trunc, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Trunc, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Trunc, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Trunc, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Trunc, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Trunc, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Trunc, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), DPdx, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), DPdx, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), DPdx, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), DPdx, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), DPdx, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), DPdx, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), DPdx, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), DPdx, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), DPdy, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), DPdy, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), DPdy, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), DPdy, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), DPdy, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), DPdy, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), DPdy, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), DPdy, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fwidth, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fwidth, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fwidth, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fwidth, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fwidth, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fwidth, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fwidth, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fwidth, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SSign val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SSign val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SSign val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SSign val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SSign val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SSign val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SSign val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SSign val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FSign val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FSign val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FSign val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FSign val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FSign val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FSign val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FSign val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FSign val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SAbs val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SAbs val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SAbs val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SAbs val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SAbs val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SAbs val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SAbs val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SAbs val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FAbs val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FAbs val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FAbs val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FAbs val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FAbs val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FAbs val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FAbs val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FAbs val, min, max);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(Any, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(Any, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(Any, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(Any, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(All, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(All, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(All, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(All, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(Transpose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(Transpose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(Transpose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(Transpose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(Transpose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(Transpose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(Transpose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(Transpose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(Transpose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(Transpose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(Transpose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(Transpose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(Transpose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(Transpose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(Transpose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(Transpose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(Transpose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(Transpose, SPVWriter::Section::LocalFunction, returnType, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Inverse, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Inverse, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Inverse, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Inverse, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Inverse, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Inverse, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Inverse, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Inverse, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Inverse, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Inverse, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Inverse, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Inverse, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Inverse, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Inverse, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Inverse, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Inverse, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Inverse, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Inverse, val);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::ShaderLayer);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplOutputLayer"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::Layer);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::ShaderViewportIndex);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplOutputViewport"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::ViewportIndex);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplIndex"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::VertexId);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplInstanceIndex"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::InstanceId);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplBaseIndex"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::BaseVertex);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplBaseInstanceIndex"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::BaseInstance);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplDrawIndex"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::DrawIndex);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::ShaderLayer);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplOutputLayer"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::Layer);
    g->interfaceVariables.Insert(ret);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, args[0]);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::ShaderLayer);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplOutputLayer"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::Layer);
    g->interfaceVariables.Insert(ret);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, args[0]);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::ShaderViewportIndex);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplOutputViewport"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::ViewportIndex);
    g->interfaceVariables.Insert(ret);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, args[0]);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::ShaderViewportIndex);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplOutputViewport"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::ViewportIndex);
    g->interfaceVariables.Insert(ret);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, args[0]);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplOutputViewport"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::Position);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplOutputViewport"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::Position);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Geometry);
    g->writer->Instruction(OpEmitVertex, SPVWriter::Section::LocalFunction);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Geometry);
    g->writer->Instruction(OpEndPrimitive, SPVWriter::Section::LocalFunction);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelGetCoordinates_Float32x4"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::FragCoord);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelGetCoordinates_Float16x4"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::FragCoord);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelGetDepth"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::FragDepth);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32_Input"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelSetDepth"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::FragDepth);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32x2_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32x2_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32x2_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32x2_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32x3_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32x3_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32x3_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32x3_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32x4_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32x4_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32x4_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float32x4_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16x2_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16x2_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16x2_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16x2_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16x3_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16x3_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16x3_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16x3_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16x4_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16x4_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16x4_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Float16x4_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32x2_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32x2_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32x2_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32x2_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32x3_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32x3_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32x3_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32x3_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32x4_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32x4_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32x4_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int32x4_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16x2_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16x2_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16x2_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16x2_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16x3_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16x3_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16x3_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16x3_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16x4_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16x4_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16x4_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_Int16x4_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32x2_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32x2_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32x2_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32x2_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32x3_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32x3_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32x3_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32x3_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32x4_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32x4_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32x4_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt32x4_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16x2_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16x2_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16x2_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16x2_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16x3_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16x3_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16x3_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16x3_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16x4_Int32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16x4_UInt32"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16x4_Int16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::Shader);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplPixelExportColor_UInt16x4_UInt16"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Index, args[1].literalValue.i);
    g->writer->Decorate(SPVArg{{ret}}, Decorations::Location, args[1].literalValue.i);
    g->interfaceVariables.Insert(ret);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);
    return SPIRVResult::Invalid();
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x3_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplComputeGetLocalThreadIndices"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::LocalInvocationId);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x3_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplComputeGetGlobalThreadIndices"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::GlobalInvocationId);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x3_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplComputeGetWorkgroupIndices"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::WorkgroupId);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x3_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplComputeGetWorkGroupDimensions"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::WorkgroupSize);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &Float16x4x4_operator_scale_Float16x4x4_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplComputeGetIndexInWorkgroup"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::LocalInvocationIndex);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &SubgroupGetId , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniform);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x3_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplSubgroupGetId"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::LocalInvocationIndex);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &SubgroupGetSize , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniform);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x3_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplSubgroupGetSize"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::LocalInvocationIndex);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &SubgroupGetNum , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniform);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 3);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x3_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplSubgroupGetNum"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::LocalInvocationIndex);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &SubgroupGetThreadMask , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniform);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplSubgroupGetThreadMask"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::SubgroupEqMask);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &SubgroupGetThreadAndLowerMask , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniform);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplSubgroupGetThreadAndLowerMask"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::SubgroupLeMask);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &SubgroupGetLowerMask , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniform);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplSubgroupGetLowerMask"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::SubgroupLtMask);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &SubgroupGetThreadAndGreaterMask , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniform);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplSubgroupGetThreadAndGreaterMask"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::SubgroupGeMask);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &SubgroupGetGreaterMask , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniform);
    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 4);
    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));
    uint32_t ret = GPULang::AddSymbol(g, TStr("gplSubgroupGetGreaterMask"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);
    g->writer->Decorate(SPVArg{ret}, Decorations::BuiltIn, Builtins::SubgroupGtMask);
    g->interfaceVariables.Insert(ret);
    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);
    res.parentTypes.push_back(baseType);
    return res;
}},
std::pair{ &SubgroupFirstActiveThread , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniform);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformElect, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupBroadcastFirstActiveThread , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBroadcastFirst, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupBallot , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(['GroupNonUniformBallot', 'GroupNonUniformInverseBallot'], SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupInverseBallot , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(['GroupNonUniformBallot', 'GroupNonUniformInverseBallot'], SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupBallotBitCount , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitCount, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, 0, loaded);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupBallotFirstOne , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotFindLSB, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupBallotLastOne , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotFindMSB, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupBallotBit , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformBallot);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult bit = LoadValueSPIRV(c, g, args[1]);
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, bit);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapDiagonal_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(2));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapVertical_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(1));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_Float32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_Float32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_Float32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_Float32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_Float16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_Float16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_Float16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_Float16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_Int32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_Int32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_Int32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_Int32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_Int16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_Int16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_Int16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_Int16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_UInt32 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_UInt32x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_UInt32x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_UInt32x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_UInt16 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_UInt16x2 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_UInt16x3 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SubgroupSwapHorizontal_UInt16x4 , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    g->writer->Capability(Capabilities::GroupNonUniformQuad);
    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);
    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int(0));
    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGetSampledMip_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = args[2];
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret;
    ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureGetSampledMip_Texture1D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult sampledImage = args[0];
    SPIRVResult coord = args[1];
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret;
    ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGetSampledMip_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = args[2];
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret;
    ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureGetSampledMip_Texture2D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult sampledImage = args[0];
    SPIRVResult coord = args[1];
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret;
    ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGetSampledMip_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = args[2];
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret;
    ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureGetSampledMip_Texture3D , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult sampledImage = args[0];
    SPIRVResult coord = args[1];
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret;
    ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGetSampledMip_TextureCube , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = args[2];
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret;
    ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureGetSampledMip_TextureCube , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult sampledImage = args[0];
    SPIRVResult coord = args[1];
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret;
    ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGetSampledMip_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = args[2];
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret;
    ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureGetSampledMip_Texture1DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult sampledImage = args[0];
    SPIRVResult coord = args[1];
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret;
    ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGetSampledMip_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = args[2];
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret;
    ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureGetSampledMip_Texture2DArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult sampledImage = args[0];
    SPIRVResult coord = args[1];
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret;
    ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &TextureGetSampledMip_TextureCubeArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);
    SPIRVResult coord = args[2];
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret;
    ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}},
std::pair{ &SampledTextureGetSampledMip_TextureCubeArray , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult
{
    SPIRVResult sampledImage = args[0];
    SPIRVResult coord = args[1];
    g->writer->Capability(Capabilities::ImageQuery);
    uint32_t ret;
    ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);
    return SPIRVResult(ret, returnType, true);
}},
};
} // namespace GPULang

