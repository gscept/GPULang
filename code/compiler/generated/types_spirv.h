//-------------------------------------------------
// *** Generated by type_gen.py. ***
//       DO NOT MODIFY!!!
//-------------------------------------------------
#include "compiler.h"
#include "generators/spirvgenerator.h"
#include "util/containers.h"
namespace GPULang
{
constexpr ConverterTable = StaticMap{ std::array{
    { TypeConversionTable::Float32ToUInt32, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt32(value.literalValue.f32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpConvertFToU, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Float32ToInt32, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(value.literalValue.f32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpConvertFToS, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Float32ToFloat16, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float16(value.literalValue.f32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpFConvert, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Float32ToUInt16, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt16(value.literalValue.f32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpConvertFToU, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Float32ToInt16, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int16(value.literalValue.f32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpConvertFToS, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::UInt32ToFloat32, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float32(value.literalValue.u32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpConvertUToF, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::UInt32ToInt32, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(value.literalValue.u32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::UInt32ToBool8, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Bool8(value.literalValue.u32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Bool8, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Bool8);
            value = LoadValueSPIRV(c, g, value);
            SPIRVResult falseValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt32(0), vectorSize);
            res = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, type, value, falseValue);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::UInt32ToFloat16, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float16(value.literalValue.u32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpConvertUToF, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::UInt32ToUInt16, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt16(value.literalValue.u32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpUConvert, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::UInt32ToInt16, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int16(value.literalValue.u32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Int32ToFloat32, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float32(value.literalValue.i32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpConvertSToF, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Int32ToUInt32, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt32(value.literalValue.i32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Int32ToBool8, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Bool8(value.literalValue.i32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Bool8, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Bool8);
            value = LoadValueSPIRV(c, g, value);
            SPIRVResult falseValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), vectorSize);
            res = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, type, value, falseValue);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Int32ToFloat16, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float16(value.literalValue.i32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpConvertSToF, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Int32ToUInt16, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt16(value.literalValue.i32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Int32ToInt16, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int16(value.literalValue.i32));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpSConvert, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Bool8ToUInt32, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt32(value.literalValue.b8));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32);
            SPIRVResult trueValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt32(1), vectorSize);
            SPIRVResult falseValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt32(0), vectorSize);
            res = g->writer->MappedInstruction(OpSelect, SPVWriter::Section::LocalFunction, type, trueValue, falseValue);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Bool8ToInt32, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(value.literalValue.b8));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32);
            SPIRVResult trueValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(1), vectorSize);
            SPIRVResult falseValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), vectorSize);
            res = g->writer->MappedInstruction(OpSelect, SPVWriter::Section::LocalFunction, type, trueValue, falseValue);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Bool8ToUInt16, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt16(value.literalValue.b8));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16);
            SPIRVResult trueValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt16(1), vectorSize);
            SPIRVResult falseValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt16(0), vectorSize);
            res = g->writer->MappedInstruction(OpSelect, SPVWriter::Section::LocalFunction, type, trueValue, falseValue);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Bool8ToInt16, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int16(value.literalValue.b8));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16);
            SPIRVResult trueValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int16(1), vectorSize);
            SPIRVResult falseValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int16(0), vectorSize);
            res = g->writer->MappedInstruction(OpSelect, SPVWriter::Section::LocalFunction, type, trueValue, falseValue);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Float16ToFloat32, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float32(value.literalValue.f16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpFConvert, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Float16ToUInt32, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt32(value.literalValue.f16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpConvertFToU, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Float16ToInt32, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(value.literalValue.f16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpConvertFToS, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Float16ToUInt16, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt16(value.literalValue.f16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpConvertFToU, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Float16ToInt16, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int16(value.literalValue.f16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpConvertFToS, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::UInt16ToFloat32, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float32(value.literalValue.u16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpConvertUToF, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::UInt16ToUInt32, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt32(value.literalValue.u16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpUConvert, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::UInt16ToInt32, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(value.literalValue.u16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::UInt16ToBool8, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Bool8(value.literalValue.u16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Bool8, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Bool8);
            value = LoadValueSPIRV(c, g, value);
            SPIRVResult falseValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt16(0), vectorSize);
            res = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, type, value, falseValue);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::UInt16ToFloat16, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float16(value.literalValue.u16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpConvertUToF, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::UInt16ToInt16, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int16(value.literalValue.u16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Int16ToFloat32, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float32(value.literalValue.i16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpConvertSToF, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Int16ToUInt32, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt32(value.literalValue.i16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Int16ToInt32, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(value.literalValue.i16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Int32);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpSConvert, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Int16ToBool8, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Bool8(value.literalValue.i16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Bool8, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Bool8);
            value = LoadValueSPIRV(c, g, value);
            SPIRVResult falseValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int16(0), vectorSize);
            res = g->writer->MappedInstruction(OpINotEqual, SPVWriter::Section::LocalFunction, type, value, falseValue);
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Int16ToFloat16, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float16(value.literalValue.i16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::Float16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpConvertSToF, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } },
    { TypeConversionTable::Int16ToUInt16, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {
        if (value.isLiteral)
        {
            assert(vectorSize == 1);
            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt16(value.literalValue.i16));
        }
        else
        {
            uint32_t type;
            if (vectorSize > 1)
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16, vectorSize);
            else
                type = GeneratePODTypeSPIRV(c, g, TypeCode::UInt16);
            value = LoadValueSPIRV(c, g, value);
            uint32_t res = value.name;
            res = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, type, SPVArg{res});
            return SPIRVResult(res, type, true);
        }
    } }
}};

StaticMap default_intrinsics = std::array{
std::pair{ &Float32_convert_UInt32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float32_convert_Int32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float32_convert_Float16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float32_convert_UInt16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float32_convert_Int16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt32_convert_Float32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt32_convert_Int32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt32_convert_Float16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt32_convert_UInt16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt32_convert_Int16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int32_convert_Float32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int32_convert_UInt32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int32_convert_Float16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int32_convert_UInt16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int32_convert_Int16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Bool8_convert_UInt32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Bool8_convert_Int32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Bool8_convert_UInt16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Bool8_convert_Int16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float16_convert_Float32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float16_convert_UInt32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float16_convert_Int32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float16_convert_UInt16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float16_convert_Int16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt16_convert_Float32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt16_convert_UInt32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt16_convert_Int32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt16_convert_Float16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt16_convert_Int16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int16_convert_Float32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int16_convert_UInt32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int16_convert_Int32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int16_convert_Float16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int16_convert_UInt16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float32x2_convert_Float32x2 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float32x2_splat_Float32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[0]);
};
std::pair{ &Float32x2_convert_UInt32x2 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float32x2_splat_UInt32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[0]);
};
std::pair{ &Float32x2_convert_Int32x2 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float32x2_splat_Int32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[0]);
};
std::pair{ &Float32x2_convert_Float16x2 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float32x2_splat_Float16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[0]);
};
std::pair{ &Float32x2_convert_UInt16x2 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float32x2_splat_UInt16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[0]);
};
std::pair{ &Float32x2_convert_Int16x2 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float32x2_splat_Int16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[0]);
};
std::pair{ &UInt32x2_convert_Float32x2 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt32x2_splat_Float32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[0]);
};
std::pair{ &UInt32x2_convert_UInt32x2 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt32x2_splat_UInt32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[0]);
};
std::pair{ &UInt32x2_convert_Int32x2 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt32x2_splat_Int32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[0]);
};
std::pair{ &UInt32x2_convert_Float16x2 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt32x2_splat_Float16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[0]);
};
std::pair{ &UInt32x2_convert_UInt16x2 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt32x2_splat_UInt16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[0]);
};
std::pair{ &UInt32x2_convert_Int16x2 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt32x2_splat_Int16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[0]);
};
std::pair{ &Int32x2_convert_Float32x2 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int32x2_splat_Float32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[0]);
};
std::pair{ &Int32x2_convert_UInt32x2 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int32x2_splat_UInt32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[0]);
};
std::pair{ &Int32x2_convert_Int32x2 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int32x2_splat_Int32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[0]);
};
std::pair{ &Int32x2_convert_Float16x2 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int32x2_splat_Float16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[0]);
};
std::pair{ &Int32x2_convert_UInt16x2 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int32x2_splat_UInt16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[0]);
};
std::pair{ &Int32x2_convert_Int16x2 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int32x2_splat_Int16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[0]);
};
std::pair{ &Bool8x2_convert_UInt32x2 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Bool8x2_splat_UInt32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[0]);
};
std::pair{ &Bool8x2_convert_Int32x2 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Bool8x2_splat_Int32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[0]);
};
std::pair{ &Bool8x2_convert_UInt16x2 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Bool8x2_splat_UInt16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[0]);
};
std::pair{ &Bool8x2_convert_Int16x2 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Bool8x2_splat_Int16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[0]);
};
std::pair{ &Float16x2_convert_Float32x2 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float16x2_splat_Float32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[0]);
};
std::pair{ &Float16x2_convert_UInt32x2 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float16x2_splat_UInt32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[0]);
};
std::pair{ &Float16x2_convert_Int32x2 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float16x2_splat_Int32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[0]);
};
std::pair{ &Float16x2_convert_Float16x2 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float16x2_splat_Float16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[0]);
};
std::pair{ &Float16x2_convert_UInt16x2 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float16x2_splat_UInt16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[0]);
};
std::pair{ &Float16x2_convert_Int16x2 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float16x2_splat_Int16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[0]);
};
std::pair{ &UInt16x2_convert_Float32x2 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt16x2_splat_Float32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[0]);
};
std::pair{ &UInt16x2_convert_UInt32x2 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt16x2_splat_UInt32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[0]);
};
std::pair{ &UInt16x2_convert_Int32x2 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt16x2_splat_Int32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[0]);
};
std::pair{ &UInt16x2_convert_Float16x2 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt16x2_splat_Float16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[0]);
};
std::pair{ &UInt16x2_convert_UInt16x2 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt16x2_splat_UInt16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[0]);
};
std::pair{ &UInt16x2_convert_Int16x2 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt16x2_splat_Int16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[0]);
};
std::pair{ &Int16x2_convert_Float32x2 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int16x2_splat_Float32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[0]);
};
std::pair{ &Int16x2_convert_UInt32x2 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int16x2_splat_UInt32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[0]);
};
std::pair{ &Int16x2_convert_Int32x2 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int16x2_splat_Int32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[0]);
};
std::pair{ &Int16x2_convert_Float16x2 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int16x2_splat_Float16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[0]);
};
std::pair{ &Int16x2_convert_UInt16x2 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int16x2_splat_UInt16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[0]);
};
std::pair{ &Int16x2_convert_Int16x2 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int16x2_splat_Int16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 2, args[0]);
};
std::pair{ &Float32x3_convert_Float32x3 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float32x3_splat_Float32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[0]);
};
std::pair{ &Float32x3_convert_UInt32x3 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float32x3_splat_UInt32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[0]);
};
std::pair{ &Float32x3_convert_Int32x3 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float32x3_splat_Int32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[0]);
};
std::pair{ &Float32x3_convert_Float16x3 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float32x3_splat_Float16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[0]);
};
std::pair{ &Float32x3_convert_UInt16x3 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float32x3_splat_UInt16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[0]);
};
std::pair{ &Float32x3_convert_Int16x3 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float32x3_splat_Int16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[0]);
};
std::pair{ &UInt32x3_convert_Float32x3 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt32x3_splat_Float32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[0]);
};
std::pair{ &UInt32x3_convert_UInt32x3 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt32x3_splat_UInt32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[0]);
};
std::pair{ &UInt32x3_convert_Int32x3 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt32x3_splat_Int32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[0]);
};
std::pair{ &UInt32x3_convert_Float16x3 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt32x3_splat_Float16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[0]);
};
std::pair{ &UInt32x3_convert_UInt16x3 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt32x3_splat_UInt16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[0]);
};
std::pair{ &UInt32x3_convert_Int16x3 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt32x3_splat_Int16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[0]);
};
std::pair{ &Int32x3_convert_Float32x3 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int32x3_splat_Float32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[0]);
};
std::pair{ &Int32x3_convert_UInt32x3 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int32x3_splat_UInt32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[0]);
};
std::pair{ &Int32x3_convert_Int32x3 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int32x3_splat_Int32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[0]);
};
std::pair{ &Int32x3_convert_Float16x3 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int32x3_splat_Float16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[0]);
};
std::pair{ &Int32x3_convert_UInt16x3 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int32x3_splat_UInt16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[0]);
};
std::pair{ &Int32x3_convert_Int16x3 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int32x3_splat_Int16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[0]);
};
std::pair{ &Bool8x3_convert_UInt32x3 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Bool8x3_splat_UInt32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[0]);
};
std::pair{ &Bool8x3_convert_Int32x3 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Bool8x3_splat_Int32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[0]);
};
std::pair{ &Bool8x3_convert_UInt16x3 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Bool8x3_splat_UInt16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[0]);
};
std::pair{ &Bool8x3_convert_Int16x3 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Bool8x3_splat_Int16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[0]);
};
std::pair{ &Float16x3_convert_Float32x3 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float16x3_splat_Float32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[0]);
};
std::pair{ &Float16x3_convert_UInt32x3 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float16x3_splat_UInt32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[0]);
};
std::pair{ &Float16x3_convert_Int32x3 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float16x3_splat_Int32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[0]);
};
std::pair{ &Float16x3_convert_Float16x3 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float16x3_splat_Float16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[0]);
};
std::pair{ &Float16x3_convert_UInt16x3 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float16x3_splat_UInt16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[0]);
};
std::pair{ &Float16x3_convert_Int16x3 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float16x3_splat_Int16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[0]);
};
std::pair{ &UInt16x3_convert_Float32x3 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt16x3_splat_Float32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[0]);
};
std::pair{ &UInt16x3_convert_UInt32x3 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt16x3_splat_UInt32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[0]);
};
std::pair{ &UInt16x3_convert_Int32x3 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt16x3_splat_Int32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[0]);
};
std::pair{ &UInt16x3_convert_Float16x3 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt16x3_splat_Float16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[0]);
};
std::pair{ &UInt16x3_convert_UInt16x3 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt16x3_splat_UInt16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[0]);
};
std::pair{ &UInt16x3_convert_Int16x3 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt16x3_splat_Int16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[0]);
};
std::pair{ &Int16x3_convert_Float32x3 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int16x3_splat_Float32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[0]);
};
std::pair{ &Int16x3_convert_UInt32x3 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int16x3_splat_UInt32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[0]);
};
std::pair{ &Int16x3_convert_Int32x3 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int16x3_splat_Int32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[0]);
};
std::pair{ &Int16x3_convert_Float16x3 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int16x3_splat_Float16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[0]);
};
std::pair{ &Int16x3_convert_UInt16x3 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int16x3_splat_UInt16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[0]);
};
std::pair{ &Int16x3_convert_Int16x3 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int16x3_splat_Int16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 3, args[0]);
};
std::pair{ &Float32x4_convert_Float32x4 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float32x4_splat_Float32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[0]);
};
std::pair{ &Float32x4_convert_UInt32x4 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float32x4_splat_UInt32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[0]);
};
std::pair{ &Float32x4_convert_Int32x4 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float32x4_splat_Int32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[0]);
};
std::pair{ &Float32x4_convert_Float16x4 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float32x4_splat_Float16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[0]);
};
std::pair{ &Float32x4_convert_UInt16x4 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float32x4_splat_UInt16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[0]);
};
std::pair{ &Float32x4_convert_Int16x4 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float32x4_splat_Int16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[0]);
};
std::pair{ &UInt32x4_convert_Float32x4 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt32x4_splat_Float32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[0]);
};
std::pair{ &UInt32x4_convert_UInt32x4 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt32x4_splat_UInt32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[0]);
};
std::pair{ &UInt32x4_convert_Int32x4 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt32x4_splat_Int32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[0]);
};
std::pair{ &UInt32x4_convert_Float16x4 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt32x4_splat_Float16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[0]);
};
std::pair{ &UInt32x4_convert_UInt16x4 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt32x4_splat_UInt16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[0]);
};
std::pair{ &UInt32x4_convert_Int16x4 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt32x4_splat_Int16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[0]);
};
std::pair{ &Int32x4_convert_Float32x4 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int32x4_splat_Float32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[0]);
};
std::pair{ &Int32x4_convert_UInt32x4 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int32x4_splat_UInt32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[0]);
};
std::pair{ &Int32x4_convert_Int32x4 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int32x4_splat_Int32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[0]);
};
std::pair{ &Int32x4_convert_Float16x4 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int32x4_splat_Float16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[0]);
};
std::pair{ &Int32x4_convert_UInt16x4 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int32x4_splat_UInt16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[0]);
};
std::pair{ &Int32x4_convert_Int16x4 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int32x4_splat_Int16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[0]);
};
std::pair{ &Bool8x4_convert_UInt32x4 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Bool8x4_splat_UInt32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[0]);
};
std::pair{ &Bool8x4_convert_Int32x4 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Bool8x4_splat_Int32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[0]);
};
std::pair{ &Bool8x4_convert_UInt16x4 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Bool8x4_splat_UInt16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[0]);
};
std::pair{ &Bool8x4_convert_Int16x4 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Bool8x4_splat_Int16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[0]);
};
std::pair{ &Float16x4_convert_Float32x4 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float16x4_splat_Float32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[0]);
};
std::pair{ &Float16x4_convert_UInt32x4 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float16x4_splat_UInt32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[0]);
};
std::pair{ &Float16x4_convert_Int32x4 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float16x4_splat_Int32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[0]);
};
std::pair{ &Float16x4_convert_Float16x4 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float16x4_splat_Float16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[0]);
};
std::pair{ &Float16x4_convert_UInt16x4 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float16x4_splat_UInt16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[0]);
};
std::pair{ &Float16x4_convert_Int16x4 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Float16x4_splat_Int16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[0]);
};
std::pair{ &UInt16x4_convert_Float32x4 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt16x4_splat_Float32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[0]);
};
std::pair{ &UInt16x4_convert_UInt32x4 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt16x4_splat_UInt32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[0]);
};
std::pair{ &UInt16x4_convert_Int32x4 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt16x4_splat_Int32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[0]);
};
std::pair{ &UInt16x4_convert_Float16x4 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt16x4_splat_Float16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[0]);
};
std::pair{ &UInt16x4_convert_UInt16x4 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt16x4_splat_UInt16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[0]);
};
std::pair{ &UInt16x4_convert_Int16x4 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &UInt16x4_splat_Int16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[0]);
};
std::pair{ &Int16x4_convert_Float32x4 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int16x4_splat_Float32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[0]);
};
std::pair{ &Int16x4_convert_UInt32x4 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int16x4_splat_UInt32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[0]);
};
std::pair{ &Int16x4_convert_Int32x4 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int16x4_splat_Int32 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[0]);
};
std::pair{ &Int16x4_convert_Float16x4 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int16x4_splat_Float16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[0]);
};
std::pair{ &Int16x4_convert_UInt16x4 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int16x4_splat_UInt16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[0]);
};
std::pair{ &Int16x4_convert_Int16x4 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});
};
std::pair{ &Int16x4_splat_Int16 , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;
{
    GenerateSplatCompositeSPIRV(c, g, returnType, 4, args[0]);
};
};} // namespace GPULang

