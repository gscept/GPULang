//-------------------------------------------------
// *** Generated by type_gen.py. ***
//       DO NOT MODIFY!!!
//-------------------------------------------------
#include "ast/function.h"
#include "ast/variable.h"
#include "types.h"
#include "intrinsics.h"
#include "compiler.h"
namespace GPULang
{
/// atomicStore with Int16, Int16, MemorySemantics
Variable AtomicStore_Uniform_Int16_ptr;
inline constexpr std::array AtomicStore_Uniform_Int16_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicStore_Uniform_Int16_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicStore_Uniform_Int16_value;
Variable AtomicStore_Uniform_Int16_semantics;
Function AtomicStore_Uniform_Int16;
inline constexpr std::array AtomicStore_Uniform_Int16_args = { &AtomicStore_Uniform_Int16_ptr, &AtomicStore_Uniform_Int16_value, &AtomicStore_Uniform_Int16_semantics };

/// atomicStore with Int16, Int16, MemorySemantics
Variable AtomicStore_Workgroup_Int16_ptr;
inline constexpr std::array AtomicStore_Workgroup_Int16_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicStore_Workgroup_Int16_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicStore_Workgroup_Int16_value;
Variable AtomicStore_Workgroup_Int16_semantics;
Function AtomicStore_Workgroup_Int16;
inline constexpr std::array AtomicStore_Workgroup_Int16_args = { &AtomicStore_Workgroup_Int16_ptr, &AtomicStore_Workgroup_Int16_value, &AtomicStore_Workgroup_Int16_semantics };

/// atomicExchange with Int16, Int16, MemorySemantics
Variable AtomicExchange_Uniform_Int16_ptr;
inline constexpr std::array AtomicExchange_Uniform_Int16_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicExchange_Uniform_Int16_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicExchange_Uniform_Int16_value;
Variable AtomicExchange_Uniform_Int16_semantics;
Function AtomicExchange_Uniform_Int16;
inline constexpr std::array AtomicExchange_Uniform_Int16_args = { &AtomicExchange_Uniform_Int16_ptr, &AtomicExchange_Uniform_Int16_value, &AtomicExchange_Uniform_Int16_semantics };

/// atomicExchange with Int16, Int16, MemorySemantics
Variable AtomicExchange_Workgroup_Int16_ptr;
inline constexpr std::array AtomicExchange_Workgroup_Int16_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicExchange_Workgroup_Int16_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicExchange_Workgroup_Int16_value;
Variable AtomicExchange_Workgroup_Int16_semantics;
Function AtomicExchange_Workgroup_Int16;
inline constexpr std::array AtomicExchange_Workgroup_Int16_args = { &AtomicExchange_Workgroup_Int16_ptr, &AtomicExchange_Workgroup_Int16_value, &AtomicExchange_Workgroup_Int16_semantics };

/// atomicAdd with Int16, Int16, MemorySemantics
Variable AtomicAdd_Uniform_Int16_ptr;
inline constexpr std::array AtomicAdd_Uniform_Int16_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicAdd_Uniform_Int16_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicAdd_Uniform_Int16_value;
Variable AtomicAdd_Uniform_Int16_semantics;
Function AtomicAdd_Uniform_Int16;
inline constexpr std::array AtomicAdd_Uniform_Int16_args = { &AtomicAdd_Uniform_Int16_ptr, &AtomicAdd_Uniform_Int16_value, &AtomicAdd_Uniform_Int16_semantics };

/// atomicAdd with Int16, Int16, MemorySemantics
Variable AtomicAdd_Workgroup_Int16_ptr;
inline constexpr std::array AtomicAdd_Workgroup_Int16_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicAdd_Workgroup_Int16_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicAdd_Workgroup_Int16_value;
Variable AtomicAdd_Workgroup_Int16_semantics;
Function AtomicAdd_Workgroup_Int16;
inline constexpr std::array AtomicAdd_Workgroup_Int16_args = { &AtomicAdd_Workgroup_Int16_ptr, &AtomicAdd_Workgroup_Int16_value, &AtomicAdd_Workgroup_Int16_semantics };

/// atomicSubtract with Int16, Int16, MemorySemantics
Variable AtomicSubtract_Uniform_Int16_ptr;
inline constexpr std::array AtomicSubtract_Uniform_Int16_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicSubtract_Uniform_Int16_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicSubtract_Uniform_Int16_value;
Variable AtomicSubtract_Uniform_Int16_semantics;
Function AtomicSubtract_Uniform_Int16;
inline constexpr std::array AtomicSubtract_Uniform_Int16_args = { &AtomicSubtract_Uniform_Int16_ptr, &AtomicSubtract_Uniform_Int16_value, &AtomicSubtract_Uniform_Int16_semantics };

/// atomicSubtract with Int16, Int16, MemorySemantics
Variable AtomicSubtract_Workgroup_Int16_ptr;
inline constexpr std::array AtomicSubtract_Workgroup_Int16_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicSubtract_Workgroup_Int16_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicSubtract_Workgroup_Int16_value;
Variable AtomicSubtract_Workgroup_Int16_semantics;
Function AtomicSubtract_Workgroup_Int16;
inline constexpr std::array AtomicSubtract_Workgroup_Int16_args = { &AtomicSubtract_Workgroup_Int16_ptr, &AtomicSubtract_Workgroup_Int16_value, &AtomicSubtract_Workgroup_Int16_semantics };

/// atomicAnd with Int16, Int16, MemorySemantics
Variable AtomicAnd_Uniform_Int16_ptr;
inline constexpr std::array AtomicAnd_Uniform_Int16_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicAnd_Uniform_Int16_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicAnd_Uniform_Int16_value;
Variable AtomicAnd_Uniform_Int16_semantics;
Function AtomicAnd_Uniform_Int16;
inline constexpr std::array AtomicAnd_Uniform_Int16_args = { &AtomicAnd_Uniform_Int16_ptr, &AtomicAnd_Uniform_Int16_value, &AtomicAnd_Uniform_Int16_semantics };

/// atomicAnd with Int16, Int16, MemorySemantics
Variable AtomicAnd_Workgroup_Int16_ptr;
inline constexpr std::array AtomicAnd_Workgroup_Int16_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicAnd_Workgroup_Int16_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicAnd_Workgroup_Int16_value;
Variable AtomicAnd_Workgroup_Int16_semantics;
Function AtomicAnd_Workgroup_Int16;
inline constexpr std::array AtomicAnd_Workgroup_Int16_args = { &AtomicAnd_Workgroup_Int16_ptr, &AtomicAnd_Workgroup_Int16_value, &AtomicAnd_Workgroup_Int16_semantics };

/// atomicOr with Int16, Int16, MemorySemantics
Variable AtomicOr_Uniform_Int16_ptr;
inline constexpr std::array AtomicOr_Uniform_Int16_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicOr_Uniform_Int16_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicOr_Uniform_Int16_value;
Variable AtomicOr_Uniform_Int16_semantics;
Function AtomicOr_Uniform_Int16;
inline constexpr std::array AtomicOr_Uniform_Int16_args = { &AtomicOr_Uniform_Int16_ptr, &AtomicOr_Uniform_Int16_value, &AtomicOr_Uniform_Int16_semantics };

/// atomicOr with Int16, Int16, MemorySemantics
Variable AtomicOr_Workgroup_Int16_ptr;
inline constexpr std::array AtomicOr_Workgroup_Int16_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicOr_Workgroup_Int16_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicOr_Workgroup_Int16_value;
Variable AtomicOr_Workgroup_Int16_semantics;
Function AtomicOr_Workgroup_Int16;
inline constexpr std::array AtomicOr_Workgroup_Int16_args = { &AtomicOr_Workgroup_Int16_ptr, &AtomicOr_Workgroup_Int16_value, &AtomicOr_Workgroup_Int16_semantics };

/// atomicXor with Int16, Int16, MemorySemantics
Variable AtomicXor_Uniform_Int16_ptr;
inline constexpr std::array AtomicXor_Uniform_Int16_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicXor_Uniform_Int16_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicXor_Uniform_Int16_value;
Variable AtomicXor_Uniform_Int16_semantics;
Function AtomicXor_Uniform_Int16;
inline constexpr std::array AtomicXor_Uniform_Int16_args = { &AtomicXor_Uniform_Int16_ptr, &AtomicXor_Uniform_Int16_value, &AtomicXor_Uniform_Int16_semantics };

/// atomicXor with Int16, Int16, MemorySemantics
Variable AtomicXor_Workgroup_Int16_ptr;
inline constexpr std::array AtomicXor_Workgroup_Int16_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicXor_Workgroup_Int16_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicXor_Workgroup_Int16_value;
Variable AtomicXor_Workgroup_Int16_semantics;
Function AtomicXor_Workgroup_Int16;
inline constexpr std::array AtomicXor_Workgroup_Int16_args = { &AtomicXor_Workgroup_Int16_ptr, &AtomicXor_Workgroup_Int16_value, &AtomicXor_Workgroup_Int16_semantics };

/// atomicStore with Float32, Float32, MemorySemantics
Variable AtomicStore_Uniform_Float32_ptr;
inline constexpr std::array AtomicStore_Uniform_Float32_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicStore_Uniform_Float32_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicStore_Uniform_Float32_value;
Variable AtomicStore_Uniform_Float32_semantics;
Function AtomicStore_Uniform_Float32;
inline constexpr std::array AtomicStore_Uniform_Float32_args = { &AtomicStore_Uniform_Float32_ptr, &AtomicStore_Uniform_Float32_value, &AtomicStore_Uniform_Float32_semantics };

/// atomicStore with Float32, Float32, MemorySemantics
Variable AtomicStore_Workgroup_Float32_ptr;
inline constexpr std::array AtomicStore_Workgroup_Float32_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicStore_Workgroup_Float32_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicStore_Workgroup_Float32_value;
Variable AtomicStore_Workgroup_Float32_semantics;
Function AtomicStore_Workgroup_Float32;
inline constexpr std::array AtomicStore_Workgroup_Float32_args = { &AtomicStore_Workgroup_Float32_ptr, &AtomicStore_Workgroup_Float32_value, &AtomicStore_Workgroup_Float32_semantics };

/// atomicExchange with Float32, Float32, MemorySemantics
Variable AtomicExchange_Uniform_Float32_ptr;
inline constexpr std::array AtomicExchange_Uniform_Float32_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicExchange_Uniform_Float32_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicExchange_Uniform_Float32_value;
Variable AtomicExchange_Uniform_Float32_semantics;
Function AtomicExchange_Uniform_Float32;
inline constexpr std::array AtomicExchange_Uniform_Float32_args = { &AtomicExchange_Uniform_Float32_ptr, &AtomicExchange_Uniform_Float32_value, &AtomicExchange_Uniform_Float32_semantics };

/// atomicExchange with Float32, Float32, MemorySemantics
Variable AtomicExchange_Workgroup_Float32_ptr;
inline constexpr std::array AtomicExchange_Workgroup_Float32_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicExchange_Workgroup_Float32_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicExchange_Workgroup_Float32_value;
Variable AtomicExchange_Workgroup_Float32_semantics;
Function AtomicExchange_Workgroup_Float32;
inline constexpr std::array AtomicExchange_Workgroup_Float32_args = { &AtomicExchange_Workgroup_Float32_ptr, &AtomicExchange_Workgroup_Float32_value, &AtomicExchange_Workgroup_Float32_semantics };

/// atomicStore with Float16, Float16, MemorySemantics
Variable AtomicStore_Uniform_Float16_ptr;
inline constexpr std::array AtomicStore_Uniform_Float16_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicStore_Uniform_Float16_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicStore_Uniform_Float16_value;
Variable AtomicStore_Uniform_Float16_semantics;
Function AtomicStore_Uniform_Float16;
inline constexpr std::array AtomicStore_Uniform_Float16_args = { &AtomicStore_Uniform_Float16_ptr, &AtomicStore_Uniform_Float16_value, &AtomicStore_Uniform_Float16_semantics };

/// atomicStore with Float16, Float16, MemorySemantics
Variable AtomicStore_Workgroup_Float16_ptr;
inline constexpr std::array AtomicStore_Workgroup_Float16_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicStore_Workgroup_Float16_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicStore_Workgroup_Float16_value;
Variable AtomicStore_Workgroup_Float16_semantics;
Function AtomicStore_Workgroup_Float16;
inline constexpr std::array AtomicStore_Workgroup_Float16_args = { &AtomicStore_Workgroup_Float16_ptr, &AtomicStore_Workgroup_Float16_value, &AtomicStore_Workgroup_Float16_semantics };

/// atomicExchange with Float16, Float16, MemorySemantics
Variable AtomicExchange_Uniform_Float16_ptr;
inline constexpr std::array AtomicExchange_Uniform_Float16_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicExchange_Uniform_Float16_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicExchange_Uniform_Float16_value;
Variable AtomicExchange_Uniform_Float16_semantics;
Function AtomicExchange_Uniform_Float16;
inline constexpr std::array AtomicExchange_Uniform_Float16_args = { &AtomicExchange_Uniform_Float16_ptr, &AtomicExchange_Uniform_Float16_value, &AtomicExchange_Uniform_Float16_semantics };

/// atomicExchange with Float16, Float16, MemorySemantics
Variable AtomicExchange_Workgroup_Float16_ptr;
inline constexpr std::array AtomicExchange_Workgroup_Float16_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicExchange_Workgroup_Float16_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicExchange_Workgroup_Float16_value;
Variable AtomicExchange_Workgroup_Float16_semantics;
Function AtomicExchange_Workgroup_Float16;
inline constexpr std::array AtomicExchange_Workgroup_Float16_args = { &AtomicExchange_Workgroup_Float16_ptr, &AtomicExchange_Workgroup_Float16_value, &AtomicExchange_Workgroup_Float16_semantics };

/// atomicMin with UInt32, UInt32, MemorySemantics
Variable AtomicMin_Uniform_UInt32_ptr;
inline constexpr std::array AtomicMin_Uniform_UInt32_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicMin_Uniform_UInt32_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicMin_Uniform_UInt32_compare;
Variable AtomicMin_Uniform_UInt32_semantics;
Function AtomicMin_Uniform_UInt32;
inline constexpr std::array AtomicMin_Uniform_UInt32_args = { &AtomicMin_Uniform_UInt32_ptr, &AtomicMin_Uniform_UInt32_compare, &AtomicMin_Uniform_UInt32_semantics };

/// atomicMin with UInt32, UInt32, MemorySemantics
Variable AtomicMin_Workgroup_UInt32_ptr;
inline constexpr std::array AtomicMin_Workgroup_UInt32_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicMin_Workgroup_UInt32_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicMin_Workgroup_UInt32_compare;
Variable AtomicMin_Workgroup_UInt32_semantics;
Function AtomicMin_Workgroup_UInt32;
inline constexpr std::array AtomicMin_Workgroup_UInt32_args = { &AtomicMin_Workgroup_UInt32_ptr, &AtomicMin_Workgroup_UInt32_compare, &AtomicMin_Workgroup_UInt32_semantics };

/// atomicMax with UInt32, UInt32, MemorySemantics
Variable AtomicMax_Uniform_UInt32_ptr;
inline constexpr std::array AtomicMax_Uniform_UInt32_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicMax_Uniform_UInt32_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicMax_Uniform_UInt32_compare;
Variable AtomicMax_Uniform_UInt32_semantics;
Function AtomicMax_Uniform_UInt32;
inline constexpr std::array AtomicMax_Uniform_UInt32_args = { &AtomicMax_Uniform_UInt32_ptr, &AtomicMax_Uniform_UInt32_compare, &AtomicMax_Uniform_UInt32_semantics };

/// atomicMax with UInt32, UInt32, MemorySemantics
Variable AtomicMax_Workgroup_UInt32_ptr;
inline constexpr std::array AtomicMax_Workgroup_UInt32_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicMax_Workgroup_UInt32_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicMax_Workgroup_UInt32_compare;
Variable AtomicMax_Workgroup_UInt32_semantics;
Function AtomicMax_Workgroup_UInt32;
inline constexpr std::array AtomicMax_Workgroup_UInt32_args = { &AtomicMax_Workgroup_UInt32_ptr, &AtomicMax_Workgroup_UInt32_compare, &AtomicMax_Workgroup_UInt32_semantics };

/// atomicMin with Int32, Int32, MemorySemantics
Variable AtomicMin_Uniform_Int32_ptr;
inline constexpr std::array AtomicMin_Uniform_Int32_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicMin_Uniform_Int32_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicMin_Uniform_Int32_compare;
Variable AtomicMin_Uniform_Int32_semantics;
Function AtomicMin_Uniform_Int32;
inline constexpr std::array AtomicMin_Uniform_Int32_args = { &AtomicMin_Uniform_Int32_ptr, &AtomicMin_Uniform_Int32_compare, &AtomicMin_Uniform_Int32_semantics };

/// atomicMin with Int32, Int32, MemorySemantics
Variable AtomicMin_Workgroup_Int32_ptr;
inline constexpr std::array AtomicMin_Workgroup_Int32_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicMin_Workgroup_Int32_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicMin_Workgroup_Int32_compare;
Variable AtomicMin_Workgroup_Int32_semantics;
Function AtomicMin_Workgroup_Int32;
inline constexpr std::array AtomicMin_Workgroup_Int32_args = { &AtomicMin_Workgroup_Int32_ptr, &AtomicMin_Workgroup_Int32_compare, &AtomicMin_Workgroup_Int32_semantics };

/// atomicMax with Int32, Int32, MemorySemantics
Variable AtomicMax_Uniform_Int32_ptr;
inline constexpr std::array AtomicMax_Uniform_Int32_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicMax_Uniform_Int32_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicMax_Uniform_Int32_compare;
Variable AtomicMax_Uniform_Int32_semantics;
Function AtomicMax_Uniform_Int32;
inline constexpr std::array AtomicMax_Uniform_Int32_args = { &AtomicMax_Uniform_Int32_ptr, &AtomicMax_Uniform_Int32_compare, &AtomicMax_Uniform_Int32_semantics };

/// atomicMax with Int32, Int32, MemorySemantics
Variable AtomicMax_Workgroup_Int32_ptr;
inline constexpr std::array AtomicMax_Workgroup_Int32_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicMax_Workgroup_Int32_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicMax_Workgroup_Int32_compare;
Variable AtomicMax_Workgroup_Int32_semantics;
Function AtomicMax_Workgroup_Int32;
inline constexpr std::array AtomicMax_Workgroup_Int32_args = { &AtomicMax_Workgroup_Int32_ptr, &AtomicMax_Workgroup_Int32_compare, &AtomicMax_Workgroup_Int32_semantics };

/// atomicMin with UInt16, UInt16, MemorySemantics
Variable AtomicMin_Uniform_UInt16_ptr;
inline constexpr std::array AtomicMin_Uniform_UInt16_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicMin_Uniform_UInt16_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicMin_Uniform_UInt16_compare;
Variable AtomicMin_Uniform_UInt16_semantics;
Function AtomicMin_Uniform_UInt16;
inline constexpr std::array AtomicMin_Uniform_UInt16_args = { &AtomicMin_Uniform_UInt16_ptr, &AtomicMin_Uniform_UInt16_compare, &AtomicMin_Uniform_UInt16_semantics };

/// atomicMin with UInt16, UInt16, MemorySemantics
Variable AtomicMin_Workgroup_UInt16_ptr;
inline constexpr std::array AtomicMin_Workgroup_UInt16_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicMin_Workgroup_UInt16_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicMin_Workgroup_UInt16_compare;
Variable AtomicMin_Workgroup_UInt16_semantics;
Function AtomicMin_Workgroup_UInt16;
inline constexpr std::array AtomicMin_Workgroup_UInt16_args = { &AtomicMin_Workgroup_UInt16_ptr, &AtomicMin_Workgroup_UInt16_compare, &AtomicMin_Workgroup_UInt16_semantics };

/// atomicMax with UInt16, UInt16, MemorySemantics
Variable AtomicMax_Uniform_UInt16_ptr;
inline constexpr std::array AtomicMax_Uniform_UInt16_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicMax_Uniform_UInt16_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicMax_Uniform_UInt16_compare;
Variable AtomicMax_Uniform_UInt16_semantics;
Function AtomicMax_Uniform_UInt16;
inline constexpr std::array AtomicMax_Uniform_UInt16_args = { &AtomicMax_Uniform_UInt16_ptr, &AtomicMax_Uniform_UInt16_compare, &AtomicMax_Uniform_UInt16_semantics };

/// atomicMax with UInt16, UInt16, MemorySemantics
Variable AtomicMax_Workgroup_UInt16_ptr;
inline constexpr std::array AtomicMax_Workgroup_UInt16_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicMax_Workgroup_UInt16_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicMax_Workgroup_UInt16_compare;
Variable AtomicMax_Workgroup_UInt16_semantics;
Function AtomicMax_Workgroup_UInt16;
inline constexpr std::array AtomicMax_Workgroup_UInt16_args = { &AtomicMax_Workgroup_UInt16_ptr, &AtomicMax_Workgroup_UInt16_compare, &AtomicMax_Workgroup_UInt16_semantics };

/// atomicMin with Int16, Int16, MemorySemantics
Variable AtomicMin_Uniform_Int16_ptr;
inline constexpr std::array AtomicMin_Uniform_Int16_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicMin_Uniform_Int16_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicMin_Uniform_Int16_compare;
Variable AtomicMin_Uniform_Int16_semantics;
Function AtomicMin_Uniform_Int16;
inline constexpr std::array AtomicMin_Uniform_Int16_args = { &AtomicMin_Uniform_Int16_ptr, &AtomicMin_Uniform_Int16_compare, &AtomicMin_Uniform_Int16_semantics };

/// atomicMin with Int16, Int16, MemorySemantics
Variable AtomicMin_Workgroup_Int16_ptr;
inline constexpr std::array AtomicMin_Workgroup_Int16_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicMin_Workgroup_Int16_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicMin_Workgroup_Int16_compare;
Variable AtomicMin_Workgroup_Int16_semantics;
Function AtomicMin_Workgroup_Int16;
inline constexpr std::array AtomicMin_Workgroup_Int16_args = { &AtomicMin_Workgroup_Int16_ptr, &AtomicMin_Workgroup_Int16_compare, &AtomicMin_Workgroup_Int16_semantics };

/// atomicMax with Int16, Int16, MemorySemantics
Variable AtomicMax_Uniform_Int16_ptr;
inline constexpr std::array AtomicMax_Uniform_Int16_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicMax_Uniform_Int16_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicMax_Uniform_Int16_compare;
Variable AtomicMax_Uniform_Int16_semantics;
Function AtomicMax_Uniform_Int16;
inline constexpr std::array AtomicMax_Uniform_Int16_args = { &AtomicMax_Uniform_Int16_ptr, &AtomicMax_Uniform_Int16_compare, &AtomicMax_Uniform_Int16_semantics };

/// atomicMax with Int16, Int16, MemorySemantics
Variable AtomicMax_Workgroup_Int16_ptr;
inline constexpr std::array AtomicMax_Workgroup_Int16_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicMax_Workgroup_Int16_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicMax_Workgroup_Int16_compare;
Variable AtomicMax_Workgroup_Int16_semantics;
Function AtomicMax_Workgroup_Int16;
inline constexpr std::array AtomicMax_Workgroup_Int16_args = { &AtomicMax_Workgroup_Int16_ptr, &AtomicMax_Workgroup_Int16_compare, &AtomicMax_Workgroup_Int16_semantics };

/// atomicCompareExchange with UInt32, UInt32, UInt32, MemorySemantics
Variable AtomicCompareExchange_Uniform_UInt32_ptr;
inline constexpr std::array AtomicCompareExchange_Uniform_UInt32_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicCompareExchange_Uniform_UInt32_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicCompareExchange_Uniform_UInt32_value;
Variable AtomicCompareExchange_Uniform_UInt32_compare;
Variable AtomicCompareExchange_Uniform_UInt32_semantics;
Function AtomicCompareExchange_Uniform_UInt32;
inline constexpr std::array AtomicCompareExchange_Uniform_UInt32_args = { &AtomicCompareExchange_Uniform_UInt32_ptr, &AtomicCompareExchange_Uniform_UInt32_value, &AtomicCompareExchange_Uniform_UInt32_compare, &AtomicCompareExchange_Uniform_UInt32_semantics };

/// atomicCompareExchange with UInt32, UInt32, UInt32, MemorySemantics
Variable AtomicCompareExchange_Workgroup_UInt32_ptr;
inline constexpr std::array AtomicCompareExchange_Workgroup_UInt32_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicCompareExchange_Workgroup_UInt32_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicCompareExchange_Workgroup_UInt32_value;
Variable AtomicCompareExchange_Workgroup_UInt32_compare;
Variable AtomicCompareExchange_Workgroup_UInt32_semantics;
Function AtomicCompareExchange_Workgroup_UInt32;
inline constexpr std::array AtomicCompareExchange_Workgroup_UInt32_args = { &AtomicCompareExchange_Workgroup_UInt32_ptr, &AtomicCompareExchange_Workgroup_UInt32_value, &AtomicCompareExchange_Workgroup_UInt32_compare, &AtomicCompareExchange_Workgroup_UInt32_semantics };

/// atomicCompareExchange with Int32, Int32, Int32, MemorySemantics
Variable AtomicCompareExchange_Uniform_Int32_ptr;
inline constexpr std::array AtomicCompareExchange_Uniform_Int32_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicCompareExchange_Uniform_Int32_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicCompareExchange_Uniform_Int32_value;
Variable AtomicCompareExchange_Uniform_Int32_compare;
Variable AtomicCompareExchange_Uniform_Int32_semantics;
Function AtomicCompareExchange_Uniform_Int32;
inline constexpr std::array AtomicCompareExchange_Uniform_Int32_args = { &AtomicCompareExchange_Uniform_Int32_ptr, &AtomicCompareExchange_Uniform_Int32_value, &AtomicCompareExchange_Uniform_Int32_compare, &AtomicCompareExchange_Uniform_Int32_semantics };

/// atomicCompareExchange with Int32, Int32, Int32, MemorySemantics
Variable AtomicCompareExchange_Workgroup_Int32_ptr;
inline constexpr std::array AtomicCompareExchange_Workgroup_Int32_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicCompareExchange_Workgroup_Int32_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicCompareExchange_Workgroup_Int32_value;
Variable AtomicCompareExchange_Workgroup_Int32_compare;
Variable AtomicCompareExchange_Workgroup_Int32_semantics;
Function AtomicCompareExchange_Workgroup_Int32;
inline constexpr std::array AtomicCompareExchange_Workgroup_Int32_args = { &AtomicCompareExchange_Workgroup_Int32_ptr, &AtomicCompareExchange_Workgroup_Int32_value, &AtomicCompareExchange_Workgroup_Int32_compare, &AtomicCompareExchange_Workgroup_Int32_semantics };

/// atomicCompareExchange with UInt16, UInt16, UInt16, MemorySemantics
Variable AtomicCompareExchange_Uniform_UInt16_ptr;
inline constexpr std::array AtomicCompareExchange_Uniform_UInt16_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicCompareExchange_Uniform_UInt16_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicCompareExchange_Uniform_UInt16_value;
Variable AtomicCompareExchange_Uniform_UInt16_compare;
Variable AtomicCompareExchange_Uniform_UInt16_semantics;
Function AtomicCompareExchange_Uniform_UInt16;
inline constexpr std::array AtomicCompareExchange_Uniform_UInt16_args = { &AtomicCompareExchange_Uniform_UInt16_ptr, &AtomicCompareExchange_Uniform_UInt16_value, &AtomicCompareExchange_Uniform_UInt16_compare, &AtomicCompareExchange_Uniform_UInt16_semantics };

/// atomicCompareExchange with UInt16, UInt16, UInt16, MemorySemantics
Variable AtomicCompareExchange_Workgroup_UInt16_ptr;
inline constexpr std::array AtomicCompareExchange_Workgroup_UInt16_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicCompareExchange_Workgroup_UInt16_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicCompareExchange_Workgroup_UInt16_value;
Variable AtomicCompareExchange_Workgroup_UInt16_compare;
Variable AtomicCompareExchange_Workgroup_UInt16_semantics;
Function AtomicCompareExchange_Workgroup_UInt16;
inline constexpr std::array AtomicCompareExchange_Workgroup_UInt16_args = { &AtomicCompareExchange_Workgroup_UInt16_ptr, &AtomicCompareExchange_Workgroup_UInt16_value, &AtomicCompareExchange_Workgroup_UInt16_compare, &AtomicCompareExchange_Workgroup_UInt16_semantics };

/// atomicCompareExchange with Int16, Int16, Int16, MemorySemantics
Variable AtomicCompareExchange_Uniform_Int16_ptr;
inline constexpr std::array AtomicCompareExchange_Uniform_Int16_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicCompareExchange_Uniform_Int16_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicCompareExchange_Uniform_Int16_value;
Variable AtomicCompareExchange_Uniform_Int16_compare;
Variable AtomicCompareExchange_Uniform_Int16_semantics;
Function AtomicCompareExchange_Uniform_Int16;
inline constexpr std::array AtomicCompareExchange_Uniform_Int16_args = { &AtomicCompareExchange_Uniform_Int16_ptr, &AtomicCompareExchange_Uniform_Int16_value, &AtomicCompareExchange_Uniform_Int16_compare, &AtomicCompareExchange_Uniform_Int16_semantics };

/// atomicCompareExchange with Int16, Int16, Int16, MemorySemantics
Variable AtomicCompareExchange_Workgroup_Int16_ptr;
inline constexpr std::array AtomicCompareExchange_Workgroup_Int16_ptr_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array AtomicCompareExchange_Workgroup_Int16_ptr_modifierValues = {(Expression*)nullptr};
Variable AtomicCompareExchange_Workgroup_Int16_value;
Variable AtomicCompareExchange_Workgroup_Int16_compare;
Variable AtomicCompareExchange_Workgroup_Int16_semantics;
Function AtomicCompareExchange_Workgroup_Int16;
inline constexpr std::array AtomicCompareExchange_Workgroup_Int16_args = { &AtomicCompareExchange_Workgroup_Int16_ptr, &AtomicCompareExchange_Workgroup_Int16_value, &AtomicCompareExchange_Workgroup_Int16_compare, &AtomicCompareExchange_Workgroup_Int16_semantics };

/// bitInsert with UInt16, UInt16, UInt16, UInt16
Variable BitInsert_UInt16_base;
Variable BitInsert_UInt16_value;
Variable BitInsert_UInt16_offset;
Variable BitInsert_UInt16_count;
Function BitInsert_UInt16;
inline constexpr std::array BitInsert_UInt16_args = { &BitInsert_UInt16_base, &BitInsert_UInt16_value, &BitInsert_UInt16_offset, &BitInsert_UInt16_count };

/// bitInsert with UInt32, UInt32, UInt32, UInt32
Variable BitInsert_UInt32_base;
Variable BitInsert_UInt32_value;
Variable BitInsert_UInt32_offset;
Variable BitInsert_UInt32_count;
Function BitInsert_UInt32;
inline constexpr std::array BitInsert_UInt32_args = { &BitInsert_UInt32_base, &BitInsert_UInt32_value, &BitInsert_UInt32_offset, &BitInsert_UInt32_count };

/// bitExtract with UInt32, UInt32, UInt32
Variable BitExtract_UInt32_base;
Variable BitExtract_UInt32_offset;
Variable BitExtract_UInt32_count;
Function BitExtract_UInt32;
inline constexpr std::array BitExtract_UInt32_args = { &BitExtract_UInt32_base, &BitExtract_UInt32_offset, &BitExtract_UInt32_count };

/// bitExtract with Int32, Int32, Int32
Variable BitExtract_Int32_base;
Variable BitExtract_Int32_offset;
Variable BitExtract_Int32_count;
Function BitExtract_Int32;
inline constexpr std::array BitExtract_Int32_args = { &BitExtract_Int32_base, &BitExtract_Int32_offset, &BitExtract_Int32_count };

/// bitExtract with UInt16, UInt16, UInt16
Variable BitExtract_UInt16_base;
Variable BitExtract_UInt16_offset;
Variable BitExtract_UInt16_count;
Function BitExtract_UInt16;
inline constexpr std::array BitExtract_UInt16_args = { &BitExtract_UInt16_base, &BitExtract_UInt16_offset, &BitExtract_UInt16_count };

/// bitExtract with Int16, Int16, Int16
Variable BitExtract_Int16_base;
Variable BitExtract_Int16_offset;
Variable BitExtract_Int16_count;
Function BitExtract_Int16;
inline constexpr std::array BitExtract_Int16_args = { &BitExtract_Int16_base, &BitExtract_Int16_offset, &BitExtract_Int16_count };

/// bitReverse with UInt32
Variable BitReverse_UInt32_base;
Function BitReverse_UInt32;
inline constexpr std::array BitReverse_UInt32_args = { &BitReverse_UInt32_base };

/// bitReverse with Int32
Variable BitReverse_Int32_base;
Function BitReverse_Int32;
inline constexpr std::array BitReverse_Int32_args = { &BitReverse_Int32_base };

/// bitReverse with UInt16
Variable BitReverse_UInt16_base;
Function BitReverse_UInt16;
inline constexpr std::array BitReverse_UInt16_args = { &BitReverse_UInt16_base };

/// bitReverse with Int16
Variable BitReverse_Int16_base;
Function BitReverse_Int16;
inline constexpr std::array BitReverse_Int16_args = { &BitReverse_Int16_base };

/// bitCount with UInt32
Variable BitCount_UInt32_base;
Function BitCount_UInt32;
inline constexpr std::array BitCount_UInt32_args = { &BitCount_UInt32_base };

/// bitCount with Int32
Variable BitCount_Int32_base;
Function BitCount_Int32;
inline constexpr std::array BitCount_Int32_args = { &BitCount_Int32_base };

/// bitCount with UInt16
Variable BitCount_UInt16_base;
Function BitCount_UInt16;
inline constexpr std::array BitCount_UInt16_args = { &BitCount_UInt16_base };

/// bitCount with Int16
Variable BitCount_Int16_base;
Function BitCount_Int16;
inline constexpr std::array BitCount_Int16_args = { &BitCount_Int16_base };

/// executionBarrier
Function ExecutionBarrier;

/// executionBarrierSubgroup
Function ExecutionBarrierSubgroup;

/// executionBarrierWorkgroup
Function ExecutionBarrierWorkgroup;

/// memoryBarrier
Function MemoryBarrier;

/// memoryBarrierBuffer
Function MemoryBarrierBuffer;

/// memoryBarrierTexture
Function MemoryBarrierTexture;

/// memoryBarrierAtomic
Function MemoryBarrierAtomic;

/// memoryBarrierSubgroup
Function MemoryBarrierSubgroup;

/// memoryBarrierWorkgroup
Function MemoryBarrierWorkgroup;

/// textureGetSize with Texture1D
Variable TextureGetSize_Texture1D_texture;
inline constexpr std::array TextureGetSize_Texture1D_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureGetSize_Texture1D_texture_modifierValues = {(Expression*)nullptr};
Function TextureGetSize_Texture1D;
inline constexpr std::array TextureGetSize_Texture1D_args = { &TextureGetSize_Texture1D_texture };

/// textureGetSize with Texture2D
Variable TextureGetSize_Texture2D_texture;
inline constexpr std::array TextureGetSize_Texture2D_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureGetSize_Texture2D_texture_modifierValues = {(Expression*)nullptr};
Function TextureGetSize_Texture2D;
inline constexpr std::array TextureGetSize_Texture2D_args = { &TextureGetSize_Texture2D_texture };

/// textureGetSize with Texture3D
Variable TextureGetSize_Texture3D_texture;
inline constexpr std::array TextureGetSize_Texture3D_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureGetSize_Texture3D_texture_modifierValues = {(Expression*)nullptr};
Function TextureGetSize_Texture3D;
inline constexpr std::array TextureGetSize_Texture3D_args = { &TextureGetSize_Texture3D_texture };

/// textureGetSize with TextureCube
Variable TextureGetSize_TextureCube_texture;
inline constexpr std::array TextureGetSize_TextureCube_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureGetSize_TextureCube_texture_modifierValues = {(Expression*)nullptr};
Function TextureGetSize_TextureCube;
inline constexpr std::array TextureGetSize_TextureCube_args = { &TextureGetSize_TextureCube_texture };

/// textureGetSize with Texture1DArray
Variable TextureGetSize_Texture1DArray_texture;
inline constexpr std::array TextureGetSize_Texture1DArray_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureGetSize_Texture1DArray_texture_modifierValues = {(Expression*)nullptr};
Function TextureGetSize_Texture1DArray;
inline constexpr std::array TextureGetSize_Texture1DArray_args = { &TextureGetSize_Texture1DArray_texture };

/// textureGetSize with Texture2DArray
Variable TextureGetSize_Texture2DArray_texture;
inline constexpr std::array TextureGetSize_Texture2DArray_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureGetSize_Texture2DArray_texture_modifierValues = {(Expression*)nullptr};
Function TextureGetSize_Texture2DArray;
inline constexpr std::array TextureGetSize_Texture2DArray_args = { &TextureGetSize_Texture2DArray_texture };

/// textureGetSize with TextureCubeArray
Variable TextureGetSize_TextureCubeArray_texture;
inline constexpr std::array TextureGetSize_TextureCubeArray_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureGetSize_TextureCubeArray_texture_modifierValues = {(Expression*)nullptr};
Function TextureGetSize_TextureCubeArray;
inline constexpr std::array TextureGetSize_TextureCubeArray_args = { &TextureGetSize_TextureCubeArray_texture };

/// textureGetSizeMip with Texture1D, UInt32
Variable TextureGetSizeMip_Texture1D_texture;
inline constexpr std::array TextureGetSizeMip_Texture1D_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureGetSizeMip_Texture1D_texture_modifierValues = {(Expression*)nullptr};
Variable TextureGetSizeMip_Texture1D_mip;
Function TextureGetSizeMip_Texture1D;
inline constexpr std::array TextureGetSizeMip_Texture1D_args = { &TextureGetSizeMip_Texture1D_texture, &TextureGetSizeMip_Texture1D_mip };

/// textureGetSizeMip with Texture2D, UInt32
Variable TextureGetSizeMip_Texture2D_texture;
inline constexpr std::array TextureGetSizeMip_Texture2D_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureGetSizeMip_Texture2D_texture_modifierValues = {(Expression*)nullptr};
Variable TextureGetSizeMip_Texture2D_mip;
Function TextureGetSizeMip_Texture2D;
inline constexpr std::array TextureGetSizeMip_Texture2D_args = { &TextureGetSizeMip_Texture2D_texture, &TextureGetSizeMip_Texture2D_mip };

/// textureGetSizeMip with Texture3D, UInt32
Variable TextureGetSizeMip_Texture3D_texture;
inline constexpr std::array TextureGetSizeMip_Texture3D_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureGetSizeMip_Texture3D_texture_modifierValues = {(Expression*)nullptr};
Variable TextureGetSizeMip_Texture3D_mip;
Function TextureGetSizeMip_Texture3D;
inline constexpr std::array TextureGetSizeMip_Texture3D_args = { &TextureGetSizeMip_Texture3D_texture, &TextureGetSizeMip_Texture3D_mip };

/// textureGetSizeMip with TextureCube, UInt32
Variable TextureGetSizeMip_TextureCube_texture;
inline constexpr std::array TextureGetSizeMip_TextureCube_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureGetSizeMip_TextureCube_texture_modifierValues = {(Expression*)nullptr};
Variable TextureGetSizeMip_TextureCube_mip;
Function TextureGetSizeMip_TextureCube;
inline constexpr std::array TextureGetSizeMip_TextureCube_args = { &TextureGetSizeMip_TextureCube_texture, &TextureGetSizeMip_TextureCube_mip };

/// textureGetSizeMip with Texture1DArray, UInt32
Variable TextureGetSizeMip_Texture1DArray_texture;
inline constexpr std::array TextureGetSizeMip_Texture1DArray_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureGetSizeMip_Texture1DArray_texture_modifierValues = {(Expression*)nullptr};
Variable TextureGetSizeMip_Texture1DArray_mip;
Function TextureGetSizeMip_Texture1DArray;
inline constexpr std::array TextureGetSizeMip_Texture1DArray_args = { &TextureGetSizeMip_Texture1DArray_texture, &TextureGetSizeMip_Texture1DArray_mip };

/// textureGetSizeMip with Texture2DArray, UInt32
Variable TextureGetSizeMip_Texture2DArray_texture;
inline constexpr std::array TextureGetSizeMip_Texture2DArray_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureGetSizeMip_Texture2DArray_texture_modifierValues = {(Expression*)nullptr};
Variable TextureGetSizeMip_Texture2DArray_mip;
Function TextureGetSizeMip_Texture2DArray;
inline constexpr std::array TextureGetSizeMip_Texture2DArray_args = { &TextureGetSizeMip_Texture2DArray_texture, &TextureGetSizeMip_Texture2DArray_mip };

/// textureGetSizeMip with TextureCubeArray, UInt32
Variable TextureGetSizeMip_TextureCubeArray_texture;
inline constexpr std::array TextureGetSizeMip_TextureCubeArray_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureGetSizeMip_TextureCubeArray_texture_modifierValues = {(Expression*)nullptr};
Variable TextureGetSizeMip_TextureCubeArray_mip;
Function TextureGetSizeMip_TextureCubeArray;
inline constexpr std::array TextureGetSizeMip_TextureCubeArray_args = { &TextureGetSizeMip_TextureCubeArray_texture, &TextureGetSizeMip_TextureCubeArray_mip };

/// textureGetMips with Texture1D
Variable TextureGetMips_Texture1D_texture;
inline constexpr std::array TextureGetMips_Texture1D_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureGetMips_Texture1D_texture_modifierValues = {(Expression*)nullptr};
Function TextureGetMips_Texture1D;
inline constexpr std::array TextureGetMips_Texture1D_args = { &TextureGetMips_Texture1D_texture };

/// textureGetMips with Texture2D
Variable TextureGetMips_Texture2D_texture;
inline constexpr std::array TextureGetMips_Texture2D_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureGetMips_Texture2D_texture_modifierValues = {(Expression*)nullptr};
Function TextureGetMips_Texture2D;
inline constexpr std::array TextureGetMips_Texture2D_args = { &TextureGetMips_Texture2D_texture };

/// textureGetMips with Texture3D
Variable TextureGetMips_Texture3D_texture;
inline constexpr std::array TextureGetMips_Texture3D_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureGetMips_Texture3D_texture_modifierValues = {(Expression*)nullptr};
Function TextureGetMips_Texture3D;
inline constexpr std::array TextureGetMips_Texture3D_args = { &TextureGetMips_Texture3D_texture };

/// textureGetMips with TextureCube
Variable TextureGetMips_TextureCube_texture;
inline constexpr std::array TextureGetMips_TextureCube_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureGetMips_TextureCube_texture_modifierValues = {(Expression*)nullptr};
Function TextureGetMips_TextureCube;
inline constexpr std::array TextureGetMips_TextureCube_args = { &TextureGetMips_TextureCube_texture };

/// textureGetMips with Texture1DArray
Variable TextureGetMips_Texture1DArray_texture;
inline constexpr std::array TextureGetMips_Texture1DArray_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureGetMips_Texture1DArray_texture_modifierValues = {(Expression*)nullptr};
Function TextureGetMips_Texture1DArray;
inline constexpr std::array TextureGetMips_Texture1DArray_args = { &TextureGetMips_Texture1DArray_texture };

/// textureGetMips with Texture2DArray
Variable TextureGetMips_Texture2DArray_texture;
inline constexpr std::array TextureGetMips_Texture2DArray_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureGetMips_Texture2DArray_texture_modifierValues = {(Expression*)nullptr};
Function TextureGetMips_Texture2DArray;
inline constexpr std::array TextureGetMips_Texture2DArray_args = { &TextureGetMips_Texture2DArray_texture };

/// textureGetMips with TextureCubeArray
Variable TextureGetMips_TextureCubeArray_texture;
inline constexpr std::array TextureGetMips_TextureCubeArray_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureGetMips_TextureCubeArray_texture_modifierValues = {(Expression*)nullptr};
Function TextureGetMips_TextureCubeArray;
inline constexpr std::array TextureGetMips_TextureCubeArray_args = { &TextureGetMips_TextureCubeArray_texture };

/// textureGetSamples with Texture2DMS
Variable TextureGetSamples_Texture2DMS_texture;
inline constexpr std::array TextureGetSamples_Texture2DMS_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureGetSamples_Texture2DMS_texture_modifierValues = {(Expression*)nullptr};
Function TextureGetSamples_Texture2DMS;
inline constexpr std::array TextureGetSamples_Texture2DMS_args = { &TextureGetSamples_Texture2DMS_texture };

/// textureGetSamples with Texture2DMSArray
Variable TextureGetSamples_Texture2DMSArray_texture;
inline constexpr std::array TextureGetSamples_Texture2DMSArray_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureGetSamples_Texture2DMSArray_texture_modifierValues = {(Expression*)nullptr};
Function TextureGetSamples_Texture2DMSArray;
inline constexpr std::array TextureGetSamples_Texture2DMSArray_args = { &TextureGetSamples_Texture2DMSArray_texture };

/// textureGetSampledMip with Texture1D, Sampler, Float32
Variable TextureGetSampledMip_Texture1D_texture;
inline constexpr std::array TextureGetSampledMip_Texture1D_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureGetSampledMip_Texture1D_texture_modifierValues = {(Expression*)nullptr};
Variable TextureGetSampledMip_Texture1D_sampler;
inline constexpr std::array TextureGetSampledMip_Texture1D_sampler_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureGetSampledMip_Texture1D_sampler_modifierValues = {(Expression*)nullptr};
Variable TextureGetSampledMip_Texture1D_coordinate;
Function TextureGetSampledMip_Texture1D;
inline constexpr std::array TextureGetSampledMip_Texture1D_args = { &TextureGetSampledMip_Texture1D_texture, &TextureGetSampledMip_Texture1D_sampler, &TextureGetSampledMip_Texture1D_coordinate };

/// textureGetSampledMip with SampledTexture1D, Float32
Variable SampledTextureGetSampledMip_Texture1D_texture;
inline constexpr std::array SampledTextureGetSampledMip_Texture1D_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array SampledTextureGetSampledMip_Texture1D_texture_modifierValues = {(Expression*)nullptr};
Variable SampledTextureGetSampledMip_Texture1D_coordinate;
Function SampledTextureGetSampledMip_Texture1D;
inline constexpr std::array SampledTextureGetSampledMip_Texture1D_args = { &SampledTextureGetSampledMip_Texture1D_texture, &SampledTextureGetSampledMip_Texture1D_coordinate };

/// textureGetSampledMip with Texture2D, Sampler, Float32x2
Variable TextureGetSampledMip_Texture2D_texture;
inline constexpr std::array TextureGetSampledMip_Texture2D_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureGetSampledMip_Texture2D_texture_modifierValues = {(Expression*)nullptr};
Variable TextureGetSampledMip_Texture2D_sampler;
inline constexpr std::array TextureGetSampledMip_Texture2D_sampler_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureGetSampledMip_Texture2D_sampler_modifierValues = {(Expression*)nullptr};
Variable TextureGetSampledMip_Texture2D_coordinate;
Function TextureGetSampledMip_Texture2D;
inline constexpr std::array TextureGetSampledMip_Texture2D_args = { &TextureGetSampledMip_Texture2D_texture, &TextureGetSampledMip_Texture2D_sampler, &TextureGetSampledMip_Texture2D_coordinate };

/// textureGetSampledMip with SampledTexture2D, Float32x2
Variable SampledTextureGetSampledMip_Texture2D_texture;
inline constexpr std::array SampledTextureGetSampledMip_Texture2D_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array SampledTextureGetSampledMip_Texture2D_texture_modifierValues = {(Expression*)nullptr};
Variable SampledTextureGetSampledMip_Texture2D_coordinate;
Function SampledTextureGetSampledMip_Texture2D;
inline constexpr std::array SampledTextureGetSampledMip_Texture2D_args = { &SampledTextureGetSampledMip_Texture2D_texture, &SampledTextureGetSampledMip_Texture2D_coordinate };

/// textureGetSampledMip with Texture3D, Sampler, Float32x3
Variable TextureGetSampledMip_Texture3D_texture;
inline constexpr std::array TextureGetSampledMip_Texture3D_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureGetSampledMip_Texture3D_texture_modifierValues = {(Expression*)nullptr};
Variable TextureGetSampledMip_Texture3D_sampler;
inline constexpr std::array TextureGetSampledMip_Texture3D_sampler_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureGetSampledMip_Texture3D_sampler_modifierValues = {(Expression*)nullptr};
Variable TextureGetSampledMip_Texture3D_coordinate;
Function TextureGetSampledMip_Texture3D;
inline constexpr std::array TextureGetSampledMip_Texture3D_args = { &TextureGetSampledMip_Texture3D_texture, &TextureGetSampledMip_Texture3D_sampler, &TextureGetSampledMip_Texture3D_coordinate };

/// textureGetSampledMip with SampledTexture3D, Float32x3
Variable SampledTextureGetSampledMip_Texture3D_texture;
inline constexpr std::array SampledTextureGetSampledMip_Texture3D_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array SampledTextureGetSampledMip_Texture3D_texture_modifierValues = {(Expression*)nullptr};
Variable SampledTextureGetSampledMip_Texture3D_coordinate;
Function SampledTextureGetSampledMip_Texture3D;
inline constexpr std::array SampledTextureGetSampledMip_Texture3D_args = { &SampledTextureGetSampledMip_Texture3D_texture, &SampledTextureGetSampledMip_Texture3D_coordinate };

/// textureGetSampledMip with TextureCube, Sampler, Float32x3
Variable TextureGetSampledMip_TextureCube_texture;
inline constexpr std::array TextureGetSampledMip_TextureCube_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureGetSampledMip_TextureCube_texture_modifierValues = {(Expression*)nullptr};
Variable TextureGetSampledMip_TextureCube_sampler;
inline constexpr std::array TextureGetSampledMip_TextureCube_sampler_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureGetSampledMip_TextureCube_sampler_modifierValues = {(Expression*)nullptr};
Variable TextureGetSampledMip_TextureCube_coordinate;
Function TextureGetSampledMip_TextureCube;
inline constexpr std::array TextureGetSampledMip_TextureCube_args = { &TextureGetSampledMip_TextureCube_texture, &TextureGetSampledMip_TextureCube_sampler, &TextureGetSampledMip_TextureCube_coordinate };

/// textureGetSampledMip with SampledTextureCube, Float32x3
Variable SampledTextureGetSampledMip_TextureCube_texture;
inline constexpr std::array SampledTextureGetSampledMip_TextureCube_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array SampledTextureGetSampledMip_TextureCube_texture_modifierValues = {(Expression*)nullptr};
Variable SampledTextureGetSampledMip_TextureCube_coordinate;
Function SampledTextureGetSampledMip_TextureCube;
inline constexpr std::array SampledTextureGetSampledMip_TextureCube_args = { &SampledTextureGetSampledMip_TextureCube_texture, &SampledTextureGetSampledMip_TextureCube_coordinate };

/// textureGetSampledMip with Texture1DArray, Sampler, Float32x2
Variable TextureGetSampledMip_Texture1DArray_texture;
inline constexpr std::array TextureGetSampledMip_Texture1DArray_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureGetSampledMip_Texture1DArray_texture_modifierValues = {(Expression*)nullptr};
Variable TextureGetSampledMip_Texture1DArray_sampler;
inline constexpr std::array TextureGetSampledMip_Texture1DArray_sampler_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureGetSampledMip_Texture1DArray_sampler_modifierValues = {(Expression*)nullptr};
Variable TextureGetSampledMip_Texture1DArray_coordinate;
Function TextureGetSampledMip_Texture1DArray;
inline constexpr std::array TextureGetSampledMip_Texture1DArray_args = { &TextureGetSampledMip_Texture1DArray_texture, &TextureGetSampledMip_Texture1DArray_sampler, &TextureGetSampledMip_Texture1DArray_coordinate };

/// textureGetSampledMip with SampledTexture1DArray, Float32x2
Variable SampledTextureGetSampledMip_Texture1DArray_texture;
inline constexpr std::array SampledTextureGetSampledMip_Texture1DArray_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array SampledTextureGetSampledMip_Texture1DArray_texture_modifierValues = {(Expression*)nullptr};
Variable SampledTextureGetSampledMip_Texture1DArray_coordinate;
Function SampledTextureGetSampledMip_Texture1DArray;
inline constexpr std::array SampledTextureGetSampledMip_Texture1DArray_args = { &SampledTextureGetSampledMip_Texture1DArray_texture, &SampledTextureGetSampledMip_Texture1DArray_coordinate };

/// textureGetSampledMip with Texture2DArray, Sampler, Float32x3
Variable TextureGetSampledMip_Texture2DArray_texture;
inline constexpr std::array TextureGetSampledMip_Texture2DArray_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureGetSampledMip_Texture2DArray_texture_modifierValues = {(Expression*)nullptr};
Variable TextureGetSampledMip_Texture2DArray_sampler;
inline constexpr std::array TextureGetSampledMip_Texture2DArray_sampler_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureGetSampledMip_Texture2DArray_sampler_modifierValues = {(Expression*)nullptr};
Variable TextureGetSampledMip_Texture2DArray_coordinate;
Function TextureGetSampledMip_Texture2DArray;
inline constexpr std::array TextureGetSampledMip_Texture2DArray_args = { &TextureGetSampledMip_Texture2DArray_texture, &TextureGetSampledMip_Texture2DArray_sampler, &TextureGetSampledMip_Texture2DArray_coordinate };

/// textureGetSampledMip with SampledTexture2DArray, Float32x3
Variable SampledTextureGetSampledMip_Texture2DArray_texture;
inline constexpr std::array SampledTextureGetSampledMip_Texture2DArray_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array SampledTextureGetSampledMip_Texture2DArray_texture_modifierValues = {(Expression*)nullptr};
Variable SampledTextureGetSampledMip_Texture2DArray_coordinate;
Function SampledTextureGetSampledMip_Texture2DArray;
inline constexpr std::array SampledTextureGetSampledMip_Texture2DArray_args = { &SampledTextureGetSampledMip_Texture2DArray_texture, &SampledTextureGetSampledMip_Texture2DArray_coordinate };

/// textureGetSampledMip with TextureCubeArray, Sampler, Float32x4
Variable TextureGetSampledMip_TextureCubeArray_texture;
inline constexpr std::array TextureGetSampledMip_TextureCubeArray_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureGetSampledMip_TextureCubeArray_texture_modifierValues = {(Expression*)nullptr};
Variable TextureGetSampledMip_TextureCubeArray_sampler;
inline constexpr std::array TextureGetSampledMip_TextureCubeArray_sampler_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureGetSampledMip_TextureCubeArray_sampler_modifierValues = {(Expression*)nullptr};
Variable TextureGetSampledMip_TextureCubeArray_coordinate;
Function TextureGetSampledMip_TextureCubeArray;
inline constexpr std::array TextureGetSampledMip_TextureCubeArray_args = { &TextureGetSampledMip_TextureCubeArray_texture, &TextureGetSampledMip_TextureCubeArray_sampler, &TextureGetSampledMip_TextureCubeArray_coordinate };

/// textureGetSampledMip with SampledTextureCubeArray, Float32x4
Variable SampledTextureGetSampledMip_TextureCubeArray_texture;
inline constexpr std::array SampledTextureGetSampledMip_TextureCubeArray_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array SampledTextureGetSampledMip_TextureCubeArray_texture_modifierValues = {(Expression*)nullptr};
Variable SampledTextureGetSampledMip_TextureCubeArray_coordinate;
Function SampledTextureGetSampledMip_TextureCubeArray;
inline constexpr std::array SampledTextureGetSampledMip_TextureCubeArray_args = { &SampledTextureGetSampledMip_TextureCubeArray_texture, &SampledTextureGetSampledMip_TextureCubeArray_coordinate };

/// textureLoad with Texture1D, Int32
Variable TextureLoad_Texture1D_texture;
inline constexpr std::array TextureLoad_Texture1D_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureLoad_Texture1D_texture_modifierValues = {(Expression*)nullptr};
Variable TextureLoad_Texture1D_coordinate;
Function TextureLoad_Texture1D;
inline constexpr std::array TextureLoad_Texture1D_args = { &TextureLoad_Texture1D_texture, &TextureLoad_Texture1D_coordinate };

/// textureLoadMip with Texture1D, Int32, Int32
Variable TextureLoadMip_Texture1D_texture;
inline constexpr std::array TextureLoadMip_Texture1D_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureLoadMip_Texture1D_texture_modifierValues = {(Expression*)nullptr};
Variable TextureLoadMip_Texture1D_coordinate;
Variable TextureLoadMip_Texture1D_mip;
Function TextureLoadMip_Texture1D;
inline constexpr std::array TextureLoadMip_Texture1D_args = { &TextureLoadMip_Texture1D_texture, &TextureLoadMip_Texture1D_coordinate, &TextureLoadMip_Texture1D_mip };

/// textureStore with Texture1D, Int32, Float32x4
Variable TextureStore_Texture1D_texture;
inline constexpr std::array TextureStore_Texture1D_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureStore_Texture1D_texture_modifierValues = {(Expression*)nullptr};
Variable TextureStore_Texture1D_coordinate;
Variable TextureStore_Texture1D_value;
Function TextureStore_Texture1D;
inline constexpr std::array TextureStore_Texture1D_args = { &TextureStore_Texture1D_texture, &TextureStore_Texture1D_coordinate, &TextureStore_Texture1D_value };

/// textureStoreMip with Texture1D, Int32, Int32, Float32x4
Variable TextureStoreMip_Texture1D_texture;
inline constexpr std::array TextureStoreMip_Texture1D_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureStoreMip_Texture1D_texture_modifierValues = {(Expression*)nullptr};
Variable TextureStoreMip_Texture1D_coordinate;
Variable TextureStoreMip_Texture1D_mip;
Variable TextureStoreMip_Texture1D_value;
Function TextureStoreMip_Texture1D;
inline constexpr std::array TextureStoreMip_Texture1D_args = { &TextureStoreMip_Texture1D_texture, &TextureStoreMip_Texture1D_coordinate, &TextureStoreMip_Texture1D_mip, &TextureStoreMip_Texture1D_value };

/// textureLoad with Texture2D, Int32x2
Variable TextureLoad_Texture2D_texture;
inline constexpr std::array TextureLoad_Texture2D_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureLoad_Texture2D_texture_modifierValues = {(Expression*)nullptr};
Variable TextureLoad_Texture2D_coordinate;
Function TextureLoad_Texture2D;
inline constexpr std::array TextureLoad_Texture2D_args = { &TextureLoad_Texture2D_texture, &TextureLoad_Texture2D_coordinate };

/// textureLoadMip with Texture2D, Int32x2, Int32
Variable TextureLoadMip_Texture2D_texture;
inline constexpr std::array TextureLoadMip_Texture2D_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureLoadMip_Texture2D_texture_modifierValues = {(Expression*)nullptr};
Variable TextureLoadMip_Texture2D_coordinate;
Variable TextureLoadMip_Texture2D_mip;
Function TextureLoadMip_Texture2D;
inline constexpr std::array TextureLoadMip_Texture2D_args = { &TextureLoadMip_Texture2D_texture, &TextureLoadMip_Texture2D_coordinate, &TextureLoadMip_Texture2D_mip };

/// textureStore with Texture2D, Int32x2, Float32x4
Variable TextureStore_Texture2D_texture;
inline constexpr std::array TextureStore_Texture2D_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureStore_Texture2D_texture_modifierValues = {(Expression*)nullptr};
Variable TextureStore_Texture2D_coordinate;
Variable TextureStore_Texture2D_value;
Function TextureStore_Texture2D;
inline constexpr std::array TextureStore_Texture2D_args = { &TextureStore_Texture2D_texture, &TextureStore_Texture2D_coordinate, &TextureStore_Texture2D_value };

/// textureStoreMip with Texture2D, Int32x2, Int32, Float32x4
Variable TextureStoreMip_Texture2D_texture;
inline constexpr std::array TextureStoreMip_Texture2D_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureStoreMip_Texture2D_texture_modifierValues = {(Expression*)nullptr};
Variable TextureStoreMip_Texture2D_coordinate;
Variable TextureStoreMip_Texture2D_mip;
Variable TextureStoreMip_Texture2D_value;
Function TextureStoreMip_Texture2D;
inline constexpr std::array TextureStoreMip_Texture2D_args = { &TextureStoreMip_Texture2D_texture, &TextureStoreMip_Texture2D_coordinate, &TextureStoreMip_Texture2D_mip, &TextureStoreMip_Texture2D_value };

/// textureLoad with Texture3D, Int32x3
Variable TextureLoad_Texture3D_texture;
inline constexpr std::array TextureLoad_Texture3D_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureLoad_Texture3D_texture_modifierValues = {(Expression*)nullptr};
Variable TextureLoad_Texture3D_coordinate;
Function TextureLoad_Texture3D;
inline constexpr std::array TextureLoad_Texture3D_args = { &TextureLoad_Texture3D_texture, &TextureLoad_Texture3D_coordinate };

/// textureLoadMip with Texture3D, Int32x3, Int32
Variable TextureLoadMip_Texture3D_texture;
inline constexpr std::array TextureLoadMip_Texture3D_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureLoadMip_Texture3D_texture_modifierValues = {(Expression*)nullptr};
Variable TextureLoadMip_Texture3D_coordinate;
Variable TextureLoadMip_Texture3D_mip;
Function TextureLoadMip_Texture3D;
inline constexpr std::array TextureLoadMip_Texture3D_args = { &TextureLoadMip_Texture3D_texture, &TextureLoadMip_Texture3D_coordinate, &TextureLoadMip_Texture3D_mip };

/// textureStore with Texture3D, Int32x3, Float32x4
Variable TextureStore_Texture3D_texture;
inline constexpr std::array TextureStore_Texture3D_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureStore_Texture3D_texture_modifierValues = {(Expression*)nullptr};
Variable TextureStore_Texture3D_coordinate;
Variable TextureStore_Texture3D_value;
Function TextureStore_Texture3D;
inline constexpr std::array TextureStore_Texture3D_args = { &TextureStore_Texture3D_texture, &TextureStore_Texture3D_coordinate, &TextureStore_Texture3D_value };

/// textureStoreMip with Texture3D, Int32x3, Int32, Float32x4
Variable TextureStoreMip_Texture3D_texture;
inline constexpr std::array TextureStoreMip_Texture3D_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureStoreMip_Texture3D_texture_modifierValues = {(Expression*)nullptr};
Variable TextureStoreMip_Texture3D_coordinate;
Variable TextureStoreMip_Texture3D_mip;
Variable TextureStoreMip_Texture3D_value;
Function TextureStoreMip_Texture3D;
inline constexpr std::array TextureStoreMip_Texture3D_args = { &TextureStoreMip_Texture3D_texture, &TextureStoreMip_Texture3D_coordinate, &TextureStoreMip_Texture3D_mip, &TextureStoreMip_Texture3D_value };

/// textureLoad with TextureCube, Int32x3
Variable TextureLoad_TextureCube_texture;
inline constexpr std::array TextureLoad_TextureCube_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureLoad_TextureCube_texture_modifierValues = {(Expression*)nullptr};
Variable TextureLoad_TextureCube_coordinate;
Function TextureLoad_TextureCube;
inline constexpr std::array TextureLoad_TextureCube_args = { &TextureLoad_TextureCube_texture, &TextureLoad_TextureCube_coordinate };

/// textureLoadMip with TextureCube, Int32x3, Int32
Variable TextureLoadMip_TextureCube_texture;
inline constexpr std::array TextureLoadMip_TextureCube_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureLoadMip_TextureCube_texture_modifierValues = {(Expression*)nullptr};
Variable TextureLoadMip_TextureCube_coordinate;
Variable TextureLoadMip_TextureCube_mip;
Function TextureLoadMip_TextureCube;
inline constexpr std::array TextureLoadMip_TextureCube_args = { &TextureLoadMip_TextureCube_texture, &TextureLoadMip_TextureCube_coordinate, &TextureLoadMip_TextureCube_mip };

/// textureStore with TextureCube, Int32x3, Float32x4
Variable TextureStore_TextureCube_texture;
inline constexpr std::array TextureStore_TextureCube_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureStore_TextureCube_texture_modifierValues = {(Expression*)nullptr};
Variable TextureStore_TextureCube_coordinate;
Variable TextureStore_TextureCube_value;
Function TextureStore_TextureCube;
inline constexpr std::array TextureStore_TextureCube_args = { &TextureStore_TextureCube_texture, &TextureStore_TextureCube_coordinate, &TextureStore_TextureCube_value };

/// textureStoreMip with TextureCube, Int32x3, Int32, Float32x4
Variable TextureStoreMip_TextureCube_texture;
inline constexpr std::array TextureStoreMip_TextureCube_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureStoreMip_TextureCube_texture_modifierValues = {(Expression*)nullptr};
Variable TextureStoreMip_TextureCube_coordinate;
Variable TextureStoreMip_TextureCube_mip;
Variable TextureStoreMip_TextureCube_value;
Function TextureStoreMip_TextureCube;
inline constexpr std::array TextureStoreMip_TextureCube_args = { &TextureStoreMip_TextureCube_texture, &TextureStoreMip_TextureCube_coordinate, &TextureStoreMip_TextureCube_mip, &TextureStoreMip_TextureCube_value };

/// textureLoad with Texture1DArray, Int32x2
Variable TextureLoad_Texture1DArray_texture;
inline constexpr std::array TextureLoad_Texture1DArray_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureLoad_Texture1DArray_texture_modifierValues = {(Expression*)nullptr};
Variable TextureLoad_Texture1DArray_coordinate;
Function TextureLoad_Texture1DArray;
inline constexpr std::array TextureLoad_Texture1DArray_args = { &TextureLoad_Texture1DArray_texture, &TextureLoad_Texture1DArray_coordinate };

/// textureLoadMip with Texture1DArray, Int32x2, Int32
Variable TextureLoadMip_Texture1DArray_texture;
inline constexpr std::array TextureLoadMip_Texture1DArray_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureLoadMip_Texture1DArray_texture_modifierValues = {(Expression*)nullptr};
Variable TextureLoadMip_Texture1DArray_coordinate;
Variable TextureLoadMip_Texture1DArray_mip;
Function TextureLoadMip_Texture1DArray;
inline constexpr std::array TextureLoadMip_Texture1DArray_args = { &TextureLoadMip_Texture1DArray_texture, &TextureLoadMip_Texture1DArray_coordinate, &TextureLoadMip_Texture1DArray_mip };

/// textureStore with Texture1DArray, Int32x2, Float32x4
Variable TextureStore_Texture1DArray_texture;
inline constexpr std::array TextureStore_Texture1DArray_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureStore_Texture1DArray_texture_modifierValues = {(Expression*)nullptr};
Variable TextureStore_Texture1DArray_coordinate;
Variable TextureStore_Texture1DArray_value;
Function TextureStore_Texture1DArray;
inline constexpr std::array TextureStore_Texture1DArray_args = { &TextureStore_Texture1DArray_texture, &TextureStore_Texture1DArray_coordinate, &TextureStore_Texture1DArray_value };

/// textureStoreMip with Texture1DArray, Int32x2, Int32, Float32x4
Variable TextureStoreMip_Texture1DArray_texture;
inline constexpr std::array TextureStoreMip_Texture1DArray_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureStoreMip_Texture1DArray_texture_modifierValues = {(Expression*)nullptr};
Variable TextureStoreMip_Texture1DArray_coordinate;
Variable TextureStoreMip_Texture1DArray_mip;
Variable TextureStoreMip_Texture1DArray_value;
Function TextureStoreMip_Texture1DArray;
inline constexpr std::array TextureStoreMip_Texture1DArray_args = { &TextureStoreMip_Texture1DArray_texture, &TextureStoreMip_Texture1DArray_coordinate, &TextureStoreMip_Texture1DArray_mip, &TextureStoreMip_Texture1DArray_value };

/// textureLoad with Texture2DArray, Int32x3
Variable TextureLoad_Texture2DArray_texture;
inline constexpr std::array TextureLoad_Texture2DArray_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureLoad_Texture2DArray_texture_modifierValues = {(Expression*)nullptr};
Variable TextureLoad_Texture2DArray_coordinate;
Function TextureLoad_Texture2DArray;
inline constexpr std::array TextureLoad_Texture2DArray_args = { &TextureLoad_Texture2DArray_texture, &TextureLoad_Texture2DArray_coordinate };

/// textureLoadMip with Texture2DArray, Int32x3, Int32
Variable TextureLoadMip_Texture2DArray_texture;
inline constexpr std::array TextureLoadMip_Texture2DArray_texture_modifiers = {Type::FullType::Modifier::Pointer};
inline constexpr std::array TextureLoadMip_Texture2DArray_texture_modifierValues = {(Expression*)nullptr};
Variable TextureLoadMip_Texture2DArray_coordinate;
Variable TextureLoadMip_Texture2DArray_mip;
Function TextureLoadMip_Texture2DArray;
inline constexpr std::array TextureLoadMip_Texture2DArray_args = { &TextureLoadMip_Texture2DArray_texture, &TextureLoadMip_Texture2DArray_coordinate, &TextureLoadMip_Texture2DArray_mip };

void SetupIntrinsics10()
{
    /// atomicStore with Int16, Int16, MemorySemantics
    AtomicStore_Uniform_Int16_ptr.name = "ptr"_c;
    AtomicStore_Uniform_Int16_ptr.type = Type::FullType{ Int16Type.name };
    AtomicStore_Uniform_Int16_ptr.type.strict = true;
    AtomicStore_Uniform_Int16_ptr.type.mut = true;
    AtomicStore_Uniform_Int16_ptr.type.modifiers = AtomicStore_Uniform_Int16_ptr_modifiers;
    AtomicStore_Uniform_Int16_ptr.type.modifierValues = AtomicStore_Uniform_Int16_ptr_modifierValues;
    AtomicStore_Uniform_Int16_value.name = "value"_c;
    AtomicStore_Uniform_Int16_value.type = Type::FullType{ Int16Type.name };
    AtomicStore_Uniform_Int16_semantics.name = "semantics"_c;
    AtomicStore_Uniform_Int16_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicStore_Uniform_Int16_semantics.type.literal = true;
    AtomicStore_Uniform_Int16.documentation = "Stores the value at the pointer location with the specified memory semantics, returns the old value"_c;
    AtomicStore_Uniform_Int16.name = AtomicStore_Uniform_Int16_name;
    AtomicStore_Uniform_Int16.backendIndex = 2217;
    AtomicStore_Uniform_Int16.returnType = Type::FullType { VoidType.name };
    AtomicStore_Uniform_Int16.parameters = AtomicStore_Uniform_Int16_args;
    Symbol::Resolved(&AtomicStore_Uniform_Int16_ptr)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicStore_Uniform_Int16_ptr)->storage = Storage::Uniform;
    Symbol::Resolved(&AtomicStore_Uniform_Int16_value)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicStore_Uniform_Int16_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicStore_Uniform_Int16)->signature = "atomicStore(uniform *mutable i16,i16,literal MemorySemantics) void"_c;
    Symbol::Resolved(&AtomicStore_Uniform_Int16)->name = "atomicStore(uniform *mutable i16,i16,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicStore_Uniform_Int16)->nameWithVarNames = "atomicStore(ptr : uniform *mutable i16, value : i16, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicStore_Uniform_Int16)->returnTypeSymbol = &VoidType;

    /// atomicStore with Int16, Int16, MemorySemantics
    AtomicStore_Workgroup_Int16_ptr.name = "ptr"_c;
    AtomicStore_Workgroup_Int16_ptr.type = Type::FullType{ Int16Type.name };
    AtomicStore_Workgroup_Int16_ptr.type.strict = true;
    AtomicStore_Workgroup_Int16_ptr.type.modifiers = AtomicStore_Workgroup_Int16_ptr_modifiers;
    AtomicStore_Workgroup_Int16_ptr.type.modifierValues = AtomicStore_Workgroup_Int16_ptr_modifierValues;
    AtomicStore_Workgroup_Int16_value.name = "value"_c;
    AtomicStore_Workgroup_Int16_value.type = Type::FullType{ Int16Type.name };
    AtomicStore_Workgroup_Int16_semantics.name = "semantics"_c;
    AtomicStore_Workgroup_Int16_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicStore_Workgroup_Int16_semantics.type.literal = true;
    AtomicStore_Workgroup_Int16.documentation = "Stores the value at the pointer location with the specified memory semantics, returns the old value"_c;
    AtomicStore_Workgroup_Int16.name = AtomicStore_Workgroup_Int16_name;
    AtomicStore_Workgroup_Int16.backendIndex = 2218;
    AtomicStore_Workgroup_Int16.returnType = Type::FullType { VoidType.name };
    AtomicStore_Workgroup_Int16.parameters = AtomicStore_Workgroup_Int16_args;
    Symbol::Resolved(&AtomicStore_Workgroup_Int16_ptr)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicStore_Workgroup_Int16_ptr)->storage = Storage::Workgroup;
    Symbol::Resolved(&AtomicStore_Workgroup_Int16_value)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicStore_Workgroup_Int16_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicStore_Workgroup_Int16)->signature = "atomicStore(workgroup *i16,i16,literal MemorySemantics) void"_c;
    Symbol::Resolved(&AtomicStore_Workgroup_Int16)->name = "atomicStore(workgroup *i16,i16,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicStore_Workgroup_Int16)->nameWithVarNames = "atomicStore(ptr : workgroup *i16, value : i16, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicStore_Workgroup_Int16)->returnTypeSymbol = &VoidType;

    /// atomicExchange with Int16, Int16, MemorySemantics
    AtomicExchange_Uniform_Int16_ptr.name = "ptr"_c;
    AtomicExchange_Uniform_Int16_ptr.type = Type::FullType{ Int16Type.name };
    AtomicExchange_Uniform_Int16_ptr.type.strict = true;
    AtomicExchange_Uniform_Int16_ptr.type.mut = true;
    AtomicExchange_Uniform_Int16_ptr.type.modifiers = AtomicExchange_Uniform_Int16_ptr_modifiers;
    AtomicExchange_Uniform_Int16_ptr.type.modifierValues = AtomicExchange_Uniform_Int16_ptr_modifierValues;
    AtomicExchange_Uniform_Int16_value.name = "value"_c;
    AtomicExchange_Uniform_Int16_value.type = Type::FullType{ Int16Type.name };
    AtomicExchange_Uniform_Int16_semantics.name = "semantics"_c;
    AtomicExchange_Uniform_Int16_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicExchange_Uniform_Int16_semantics.type.literal = true;
    AtomicExchange_Uniform_Int16.documentation = "Exchanges the value at the pointer location with the specified value and memory semantics, returns the old value"_c;
    AtomicExchange_Uniform_Int16.name = AtomicExchange_Uniform_Int16_name;
    AtomicExchange_Uniform_Int16.backendIndex = 2219;
    AtomicExchange_Uniform_Int16.returnType = Type::FullType { Int16Type.name };
    AtomicExchange_Uniform_Int16.parameters = AtomicExchange_Uniform_Int16_args;
    Symbol::Resolved(&AtomicExchange_Uniform_Int16_ptr)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicExchange_Uniform_Int16_ptr)->storage = Storage::Uniform;
    Symbol::Resolved(&AtomicExchange_Uniform_Int16_value)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicExchange_Uniform_Int16_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicExchange_Uniform_Int16)->signature = "atomicExchange(uniform *mutable i16,i16,literal MemorySemantics) i16"_c;
    Symbol::Resolved(&AtomicExchange_Uniform_Int16)->name = "atomicExchange(uniform *mutable i16,i16,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicExchange_Uniform_Int16)->nameWithVarNames = "atomicExchange(ptr : uniform *mutable i16, value : i16, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicExchange_Uniform_Int16)->returnTypeSymbol = &Int16Type;

    /// atomicExchange with Int16, Int16, MemorySemantics
    AtomicExchange_Workgroup_Int16_ptr.name = "ptr"_c;
    AtomicExchange_Workgroup_Int16_ptr.type = Type::FullType{ Int16Type.name };
    AtomicExchange_Workgroup_Int16_ptr.type.strict = true;
    AtomicExchange_Workgroup_Int16_ptr.type.modifiers = AtomicExchange_Workgroup_Int16_ptr_modifiers;
    AtomicExchange_Workgroup_Int16_ptr.type.modifierValues = AtomicExchange_Workgroup_Int16_ptr_modifierValues;
    AtomicExchange_Workgroup_Int16_value.name = "value"_c;
    AtomicExchange_Workgroup_Int16_value.type = Type::FullType{ Int16Type.name };
    AtomicExchange_Workgroup_Int16_semantics.name = "semantics"_c;
    AtomicExchange_Workgroup_Int16_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicExchange_Workgroup_Int16_semantics.type.literal = true;
    AtomicExchange_Workgroup_Int16.documentation = "Exchanges the value at the pointer location with the specified value and memory semantics, returns the old value"_c;
    AtomicExchange_Workgroup_Int16.name = AtomicExchange_Workgroup_Int16_name;
    AtomicExchange_Workgroup_Int16.backendIndex = 2220;
    AtomicExchange_Workgroup_Int16.returnType = Type::FullType { Int16Type.name };
    AtomicExchange_Workgroup_Int16.parameters = AtomicExchange_Workgroup_Int16_args;
    Symbol::Resolved(&AtomicExchange_Workgroup_Int16_ptr)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicExchange_Workgroup_Int16_ptr)->storage = Storage::Workgroup;
    Symbol::Resolved(&AtomicExchange_Workgroup_Int16_value)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicExchange_Workgroup_Int16_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicExchange_Workgroup_Int16)->signature = "atomicExchange(workgroup *i16,i16,literal MemorySemantics) i16"_c;
    Symbol::Resolved(&AtomicExchange_Workgroup_Int16)->name = "atomicExchange(workgroup *i16,i16,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicExchange_Workgroup_Int16)->nameWithVarNames = "atomicExchange(ptr : workgroup *i16, value : i16, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicExchange_Workgroup_Int16)->returnTypeSymbol = &Int16Type;

    /// atomicAdd with Int16, Int16, MemorySemantics
    AtomicAdd_Uniform_Int16_ptr.name = "ptr"_c;
    AtomicAdd_Uniform_Int16_ptr.type = Type::FullType{ Int16Type.name };
    AtomicAdd_Uniform_Int16_ptr.type.strict = true;
    AtomicAdd_Uniform_Int16_ptr.type.mut = true;
    AtomicAdd_Uniform_Int16_ptr.type.modifiers = AtomicAdd_Uniform_Int16_ptr_modifiers;
    AtomicAdd_Uniform_Int16_ptr.type.modifierValues = AtomicAdd_Uniform_Int16_ptr_modifierValues;
    AtomicAdd_Uniform_Int16_value.name = "value"_c;
    AtomicAdd_Uniform_Int16_value.type = Type::FullType{ Int16Type.name };
    AtomicAdd_Uniform_Int16_semantics.name = "semantics"_c;
    AtomicAdd_Uniform_Int16_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicAdd_Uniform_Int16_semantics.type.literal = true;
    AtomicAdd_Uniform_Int16.documentation = "Adds the value to the pointer location with the specified memory semantics, returns the old value"_c;
    AtomicAdd_Uniform_Int16.name = AtomicAdd_Uniform_Int16_name;
    AtomicAdd_Uniform_Int16.backendIndex = 2221;
    AtomicAdd_Uniform_Int16.returnType = Type::FullType { Int16Type.name };
    AtomicAdd_Uniform_Int16.parameters = AtomicAdd_Uniform_Int16_args;
    Symbol::Resolved(&AtomicAdd_Uniform_Int16_ptr)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicAdd_Uniform_Int16_ptr)->storage = Storage::Uniform;
    Symbol::Resolved(&AtomicAdd_Uniform_Int16_value)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicAdd_Uniform_Int16_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicAdd_Uniform_Int16)->signature = "atomicAdd(uniform *mutable i16,i16,literal MemorySemantics) i16"_c;
    Symbol::Resolved(&AtomicAdd_Uniform_Int16)->name = "atomicAdd(uniform *mutable i16,i16,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicAdd_Uniform_Int16)->nameWithVarNames = "atomicAdd(ptr : uniform *mutable i16, value : i16, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicAdd_Uniform_Int16)->returnTypeSymbol = &Int16Type;

    /// atomicAdd with Int16, Int16, MemorySemantics
    AtomicAdd_Workgroup_Int16_ptr.name = "ptr"_c;
    AtomicAdd_Workgroup_Int16_ptr.type = Type::FullType{ Int16Type.name };
    AtomicAdd_Workgroup_Int16_ptr.type.strict = true;
    AtomicAdd_Workgroup_Int16_ptr.type.modifiers = AtomicAdd_Workgroup_Int16_ptr_modifiers;
    AtomicAdd_Workgroup_Int16_ptr.type.modifierValues = AtomicAdd_Workgroup_Int16_ptr_modifierValues;
    AtomicAdd_Workgroup_Int16_value.name = "value"_c;
    AtomicAdd_Workgroup_Int16_value.type = Type::FullType{ Int16Type.name };
    AtomicAdd_Workgroup_Int16_semantics.name = "semantics"_c;
    AtomicAdd_Workgroup_Int16_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicAdd_Workgroup_Int16_semantics.type.literal = true;
    AtomicAdd_Workgroup_Int16.documentation = "Adds the value to the pointer location with the specified memory semantics, returns the old value"_c;
    AtomicAdd_Workgroup_Int16.name = AtomicAdd_Workgroup_Int16_name;
    AtomicAdd_Workgroup_Int16.backendIndex = 2222;
    AtomicAdd_Workgroup_Int16.returnType = Type::FullType { Int16Type.name };
    AtomicAdd_Workgroup_Int16.parameters = AtomicAdd_Workgroup_Int16_args;
    Symbol::Resolved(&AtomicAdd_Workgroup_Int16_ptr)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicAdd_Workgroup_Int16_ptr)->storage = Storage::Workgroup;
    Symbol::Resolved(&AtomicAdd_Workgroup_Int16_value)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicAdd_Workgroup_Int16_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicAdd_Workgroup_Int16)->signature = "atomicAdd(workgroup *i16,i16,literal MemorySemantics) i16"_c;
    Symbol::Resolved(&AtomicAdd_Workgroup_Int16)->name = "atomicAdd(workgroup *i16,i16,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicAdd_Workgroup_Int16)->nameWithVarNames = "atomicAdd(ptr : workgroup *i16, value : i16, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicAdd_Workgroup_Int16)->returnTypeSymbol = &Int16Type;

    /// atomicSubtract with Int16, Int16, MemorySemantics
    AtomicSubtract_Uniform_Int16_ptr.name = "ptr"_c;
    AtomicSubtract_Uniform_Int16_ptr.type = Type::FullType{ Int16Type.name };
    AtomicSubtract_Uniform_Int16_ptr.type.strict = true;
    AtomicSubtract_Uniform_Int16_ptr.type.mut = true;
    AtomicSubtract_Uniform_Int16_ptr.type.modifiers = AtomicSubtract_Uniform_Int16_ptr_modifiers;
    AtomicSubtract_Uniform_Int16_ptr.type.modifierValues = AtomicSubtract_Uniform_Int16_ptr_modifierValues;
    AtomicSubtract_Uniform_Int16_value.name = "value"_c;
    AtomicSubtract_Uniform_Int16_value.type = Type::FullType{ Int16Type.name };
    AtomicSubtract_Uniform_Int16_semantics.name = "semantics"_c;
    AtomicSubtract_Uniform_Int16_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicSubtract_Uniform_Int16_semantics.type.literal = true;
    AtomicSubtract_Uniform_Int16.documentation = "Subtracts the value from the pointer location with the specified memory semantics, returns the old value"_c;
    AtomicSubtract_Uniform_Int16.name = AtomicSubtract_Uniform_Int16_name;
    AtomicSubtract_Uniform_Int16.backendIndex = 2223;
    AtomicSubtract_Uniform_Int16.returnType = Type::FullType { Int16Type.name };
    AtomicSubtract_Uniform_Int16.parameters = AtomicSubtract_Uniform_Int16_args;
    Symbol::Resolved(&AtomicSubtract_Uniform_Int16_ptr)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicSubtract_Uniform_Int16_ptr)->storage = Storage::Uniform;
    Symbol::Resolved(&AtomicSubtract_Uniform_Int16_value)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicSubtract_Uniform_Int16_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicSubtract_Uniform_Int16)->signature = "atomicSubtract(uniform *mutable i16,i16,literal MemorySemantics) i16"_c;
    Symbol::Resolved(&AtomicSubtract_Uniform_Int16)->name = "atomicSubtract(uniform *mutable i16,i16,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicSubtract_Uniform_Int16)->nameWithVarNames = "atomicSubtract(ptr : uniform *mutable i16, value : i16, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicSubtract_Uniform_Int16)->returnTypeSymbol = &Int16Type;

    /// atomicSubtract with Int16, Int16, MemorySemantics
    AtomicSubtract_Workgroup_Int16_ptr.name = "ptr"_c;
    AtomicSubtract_Workgroup_Int16_ptr.type = Type::FullType{ Int16Type.name };
    AtomicSubtract_Workgroup_Int16_ptr.type.strict = true;
    AtomicSubtract_Workgroup_Int16_ptr.type.modifiers = AtomicSubtract_Workgroup_Int16_ptr_modifiers;
    AtomicSubtract_Workgroup_Int16_ptr.type.modifierValues = AtomicSubtract_Workgroup_Int16_ptr_modifierValues;
    AtomicSubtract_Workgroup_Int16_value.name = "value"_c;
    AtomicSubtract_Workgroup_Int16_value.type = Type::FullType{ Int16Type.name };
    AtomicSubtract_Workgroup_Int16_semantics.name = "semantics"_c;
    AtomicSubtract_Workgroup_Int16_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicSubtract_Workgroup_Int16_semantics.type.literal = true;
    AtomicSubtract_Workgroup_Int16.documentation = "Subtracts the value from the pointer location with the specified memory semantics, returns the old value"_c;
    AtomicSubtract_Workgroup_Int16.name = AtomicSubtract_Workgroup_Int16_name;
    AtomicSubtract_Workgroup_Int16.backendIndex = 2224;
    AtomicSubtract_Workgroup_Int16.returnType = Type::FullType { Int16Type.name };
    AtomicSubtract_Workgroup_Int16.parameters = AtomicSubtract_Workgroup_Int16_args;
    Symbol::Resolved(&AtomicSubtract_Workgroup_Int16_ptr)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicSubtract_Workgroup_Int16_ptr)->storage = Storage::Workgroup;
    Symbol::Resolved(&AtomicSubtract_Workgroup_Int16_value)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicSubtract_Workgroup_Int16_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicSubtract_Workgroup_Int16)->signature = "atomicSubtract(workgroup *i16,i16,literal MemorySemantics) i16"_c;
    Symbol::Resolved(&AtomicSubtract_Workgroup_Int16)->name = "atomicSubtract(workgroup *i16,i16,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicSubtract_Workgroup_Int16)->nameWithVarNames = "atomicSubtract(ptr : workgroup *i16, value : i16, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicSubtract_Workgroup_Int16)->returnTypeSymbol = &Int16Type;

    /// atomicAnd with Int16, Int16, MemorySemantics
    AtomicAnd_Uniform_Int16_ptr.name = "ptr"_c;
    AtomicAnd_Uniform_Int16_ptr.type = Type::FullType{ Int16Type.name };
    AtomicAnd_Uniform_Int16_ptr.type.strict = true;
    AtomicAnd_Uniform_Int16_ptr.type.mut = true;
    AtomicAnd_Uniform_Int16_ptr.type.modifiers = AtomicAnd_Uniform_Int16_ptr_modifiers;
    AtomicAnd_Uniform_Int16_ptr.type.modifierValues = AtomicAnd_Uniform_Int16_ptr_modifierValues;
    AtomicAnd_Uniform_Int16_value.name = "value"_c;
    AtomicAnd_Uniform_Int16_value.type = Type::FullType{ Int16Type.name };
    AtomicAnd_Uniform_Int16_semantics.name = "semantics"_c;
    AtomicAnd_Uniform_Int16_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicAnd_Uniform_Int16_semantics.type.literal = true;
    AtomicAnd_Uniform_Int16.documentation = "Performs a bitwise AND operation with the value at the pointer location with the specified memory semantics, returns the old value"_c;
    AtomicAnd_Uniform_Int16.name = AtomicAnd_Uniform_Int16_name;
    AtomicAnd_Uniform_Int16.backendIndex = 2225;
    AtomicAnd_Uniform_Int16.returnType = Type::FullType { Int16Type.name };
    AtomicAnd_Uniform_Int16.parameters = AtomicAnd_Uniform_Int16_args;
    Symbol::Resolved(&AtomicAnd_Uniform_Int16_ptr)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicAnd_Uniform_Int16_ptr)->storage = Storage::Uniform;
    Symbol::Resolved(&AtomicAnd_Uniform_Int16_value)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicAnd_Uniform_Int16_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicAnd_Uniform_Int16)->signature = "atomicAnd(uniform *mutable i16,i16,literal MemorySemantics) i16"_c;
    Symbol::Resolved(&AtomicAnd_Uniform_Int16)->name = "atomicAnd(uniform *mutable i16,i16,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicAnd_Uniform_Int16)->nameWithVarNames = "atomicAnd(ptr : uniform *mutable i16, value : i16, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicAnd_Uniform_Int16)->returnTypeSymbol = &Int16Type;

    /// atomicAnd with Int16, Int16, MemorySemantics
    AtomicAnd_Workgroup_Int16_ptr.name = "ptr"_c;
    AtomicAnd_Workgroup_Int16_ptr.type = Type::FullType{ Int16Type.name };
    AtomicAnd_Workgroup_Int16_ptr.type.strict = true;
    AtomicAnd_Workgroup_Int16_ptr.type.modifiers = AtomicAnd_Workgroup_Int16_ptr_modifiers;
    AtomicAnd_Workgroup_Int16_ptr.type.modifierValues = AtomicAnd_Workgroup_Int16_ptr_modifierValues;
    AtomicAnd_Workgroup_Int16_value.name = "value"_c;
    AtomicAnd_Workgroup_Int16_value.type = Type::FullType{ Int16Type.name };
    AtomicAnd_Workgroup_Int16_semantics.name = "semantics"_c;
    AtomicAnd_Workgroup_Int16_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicAnd_Workgroup_Int16_semantics.type.literal = true;
    AtomicAnd_Workgroup_Int16.documentation = "Performs a bitwise AND operation with the value at the pointer location with the specified memory semantics, returns the old value"_c;
    AtomicAnd_Workgroup_Int16.name = AtomicAnd_Workgroup_Int16_name;
    AtomicAnd_Workgroup_Int16.backendIndex = 2226;
    AtomicAnd_Workgroup_Int16.returnType = Type::FullType { Int16Type.name };
    AtomicAnd_Workgroup_Int16.parameters = AtomicAnd_Workgroup_Int16_args;
    Symbol::Resolved(&AtomicAnd_Workgroup_Int16_ptr)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicAnd_Workgroup_Int16_ptr)->storage = Storage::Workgroup;
    Symbol::Resolved(&AtomicAnd_Workgroup_Int16_value)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicAnd_Workgroup_Int16_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicAnd_Workgroup_Int16)->signature = "atomicAnd(workgroup *i16,i16,literal MemorySemantics) i16"_c;
    Symbol::Resolved(&AtomicAnd_Workgroup_Int16)->name = "atomicAnd(workgroup *i16,i16,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicAnd_Workgroup_Int16)->nameWithVarNames = "atomicAnd(ptr : workgroup *i16, value : i16, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicAnd_Workgroup_Int16)->returnTypeSymbol = &Int16Type;

    /// atomicOr with Int16, Int16, MemorySemantics
    AtomicOr_Uniform_Int16_ptr.name = "ptr"_c;
    AtomicOr_Uniform_Int16_ptr.type = Type::FullType{ Int16Type.name };
    AtomicOr_Uniform_Int16_ptr.type.strict = true;
    AtomicOr_Uniform_Int16_ptr.type.mut = true;
    AtomicOr_Uniform_Int16_ptr.type.modifiers = AtomicOr_Uniform_Int16_ptr_modifiers;
    AtomicOr_Uniform_Int16_ptr.type.modifierValues = AtomicOr_Uniform_Int16_ptr_modifierValues;
    AtomicOr_Uniform_Int16_value.name = "value"_c;
    AtomicOr_Uniform_Int16_value.type = Type::FullType{ Int16Type.name };
    AtomicOr_Uniform_Int16_semantics.name = "semantics"_c;
    AtomicOr_Uniform_Int16_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicOr_Uniform_Int16_semantics.type.literal = true;
    AtomicOr_Uniform_Int16.documentation = "Performs a bitwise OR operation with the value at the pointer location with the specified memory semantics, returns the old value"_c;
    AtomicOr_Uniform_Int16.name = AtomicOr_Uniform_Int16_name;
    AtomicOr_Uniform_Int16.backendIndex = 2227;
    AtomicOr_Uniform_Int16.returnType = Type::FullType { Int16Type.name };
    AtomicOr_Uniform_Int16.parameters = AtomicOr_Uniform_Int16_args;
    Symbol::Resolved(&AtomicOr_Uniform_Int16_ptr)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicOr_Uniform_Int16_ptr)->storage = Storage::Uniform;
    Symbol::Resolved(&AtomicOr_Uniform_Int16_value)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicOr_Uniform_Int16_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicOr_Uniform_Int16)->signature = "atomicOr(uniform *mutable i16,i16,literal MemorySemantics) i16"_c;
    Symbol::Resolved(&AtomicOr_Uniform_Int16)->name = "atomicOr(uniform *mutable i16,i16,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicOr_Uniform_Int16)->nameWithVarNames = "atomicOr(ptr : uniform *mutable i16, value : i16, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicOr_Uniform_Int16)->returnTypeSymbol = &Int16Type;

    /// atomicOr with Int16, Int16, MemorySemantics
    AtomicOr_Workgroup_Int16_ptr.name = "ptr"_c;
    AtomicOr_Workgroup_Int16_ptr.type = Type::FullType{ Int16Type.name };
    AtomicOr_Workgroup_Int16_ptr.type.strict = true;
    AtomicOr_Workgroup_Int16_ptr.type.modifiers = AtomicOr_Workgroup_Int16_ptr_modifiers;
    AtomicOr_Workgroup_Int16_ptr.type.modifierValues = AtomicOr_Workgroup_Int16_ptr_modifierValues;
    AtomicOr_Workgroup_Int16_value.name = "value"_c;
    AtomicOr_Workgroup_Int16_value.type = Type::FullType{ Int16Type.name };
    AtomicOr_Workgroup_Int16_semantics.name = "semantics"_c;
    AtomicOr_Workgroup_Int16_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicOr_Workgroup_Int16_semantics.type.literal = true;
    AtomicOr_Workgroup_Int16.documentation = "Performs a bitwise OR operation with the value at the pointer location with the specified memory semantics, returns the old value"_c;
    AtomicOr_Workgroup_Int16.name = AtomicOr_Workgroup_Int16_name;
    AtomicOr_Workgroup_Int16.backendIndex = 2228;
    AtomicOr_Workgroup_Int16.returnType = Type::FullType { Int16Type.name };
    AtomicOr_Workgroup_Int16.parameters = AtomicOr_Workgroup_Int16_args;
    Symbol::Resolved(&AtomicOr_Workgroup_Int16_ptr)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicOr_Workgroup_Int16_ptr)->storage = Storage::Workgroup;
    Symbol::Resolved(&AtomicOr_Workgroup_Int16_value)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicOr_Workgroup_Int16_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicOr_Workgroup_Int16)->signature = "atomicOr(workgroup *i16,i16,literal MemorySemantics) i16"_c;
    Symbol::Resolved(&AtomicOr_Workgroup_Int16)->name = "atomicOr(workgroup *i16,i16,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicOr_Workgroup_Int16)->nameWithVarNames = "atomicOr(ptr : workgroup *i16, value : i16, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicOr_Workgroup_Int16)->returnTypeSymbol = &Int16Type;

    /// atomicXor with Int16, Int16, MemorySemantics
    AtomicXor_Uniform_Int16_ptr.name = "ptr"_c;
    AtomicXor_Uniform_Int16_ptr.type = Type::FullType{ Int16Type.name };
    AtomicXor_Uniform_Int16_ptr.type.strict = true;
    AtomicXor_Uniform_Int16_ptr.type.mut = true;
    AtomicXor_Uniform_Int16_ptr.type.modifiers = AtomicXor_Uniform_Int16_ptr_modifiers;
    AtomicXor_Uniform_Int16_ptr.type.modifierValues = AtomicXor_Uniform_Int16_ptr_modifierValues;
    AtomicXor_Uniform_Int16_value.name = "value"_c;
    AtomicXor_Uniform_Int16_value.type = Type::FullType{ Int16Type.name };
    AtomicXor_Uniform_Int16_semantics.name = "semantics"_c;
    AtomicXor_Uniform_Int16_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicXor_Uniform_Int16_semantics.type.literal = true;
    AtomicXor_Uniform_Int16.documentation = "Performs a bitwise XOR operation with the value at the pointer location with the specified memory semantics, returns the old value"_c;
    AtomicXor_Uniform_Int16.name = AtomicXor_Uniform_Int16_name;
    AtomicXor_Uniform_Int16.backendIndex = 2229;
    AtomicXor_Uniform_Int16.returnType = Type::FullType { Int16Type.name };
    AtomicXor_Uniform_Int16.parameters = AtomicXor_Uniform_Int16_args;
    Symbol::Resolved(&AtomicXor_Uniform_Int16_ptr)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicXor_Uniform_Int16_ptr)->storage = Storage::Uniform;
    Symbol::Resolved(&AtomicXor_Uniform_Int16_value)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicXor_Uniform_Int16_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicXor_Uniform_Int16)->signature = "atomicXor(uniform *mutable i16,i16,literal MemorySemantics) i16"_c;
    Symbol::Resolved(&AtomicXor_Uniform_Int16)->name = "atomicXor(uniform *mutable i16,i16,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicXor_Uniform_Int16)->nameWithVarNames = "atomicXor(ptr : uniform *mutable i16, value : i16, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicXor_Uniform_Int16)->returnTypeSymbol = &Int16Type;

    /// atomicXor with Int16, Int16, MemorySemantics
    AtomicXor_Workgroup_Int16_ptr.name = "ptr"_c;
    AtomicXor_Workgroup_Int16_ptr.type = Type::FullType{ Int16Type.name };
    AtomicXor_Workgroup_Int16_ptr.type.strict = true;
    AtomicXor_Workgroup_Int16_ptr.type.modifiers = AtomicXor_Workgroup_Int16_ptr_modifiers;
    AtomicXor_Workgroup_Int16_ptr.type.modifierValues = AtomicXor_Workgroup_Int16_ptr_modifierValues;
    AtomicXor_Workgroup_Int16_value.name = "value"_c;
    AtomicXor_Workgroup_Int16_value.type = Type::FullType{ Int16Type.name };
    AtomicXor_Workgroup_Int16_semantics.name = "semantics"_c;
    AtomicXor_Workgroup_Int16_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicXor_Workgroup_Int16_semantics.type.literal = true;
    AtomicXor_Workgroup_Int16.documentation = "Performs a bitwise XOR operation with the value at the pointer location with the specified memory semantics, returns the old value"_c;
    AtomicXor_Workgroup_Int16.name = AtomicXor_Workgroup_Int16_name;
    AtomicXor_Workgroup_Int16.backendIndex = 2230;
    AtomicXor_Workgroup_Int16.returnType = Type::FullType { Int16Type.name };
    AtomicXor_Workgroup_Int16.parameters = AtomicXor_Workgroup_Int16_args;
    Symbol::Resolved(&AtomicXor_Workgroup_Int16_ptr)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicXor_Workgroup_Int16_ptr)->storage = Storage::Workgroup;
    Symbol::Resolved(&AtomicXor_Workgroup_Int16_value)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicXor_Workgroup_Int16_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicXor_Workgroup_Int16)->signature = "atomicXor(workgroup *i16,i16,literal MemorySemantics) i16"_c;
    Symbol::Resolved(&AtomicXor_Workgroup_Int16)->name = "atomicXor(workgroup *i16,i16,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicXor_Workgroup_Int16)->nameWithVarNames = "atomicXor(ptr : workgroup *i16, value : i16, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicXor_Workgroup_Int16)->returnTypeSymbol = &Int16Type;

    /// atomicStore with Float32, Float32, MemorySemantics
    AtomicStore_Uniform_Float32_ptr.name = "ptr"_c;
    AtomicStore_Uniform_Float32_ptr.type = Type::FullType{ Float32Type.name };
    AtomicStore_Uniform_Float32_ptr.type.strict = true;
    AtomicStore_Uniform_Float32_ptr.type.mut = true;
    AtomicStore_Uniform_Float32_ptr.type.modifiers = AtomicStore_Uniform_Float32_ptr_modifiers;
    AtomicStore_Uniform_Float32_ptr.type.modifierValues = AtomicStore_Uniform_Float32_ptr_modifierValues;
    AtomicStore_Uniform_Float32_value.name = "value"_c;
    AtomicStore_Uniform_Float32_value.type = Type::FullType{ Float32Type.name };
    AtomicStore_Uniform_Float32_semantics.name = "semantics"_c;
    AtomicStore_Uniform_Float32_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicStore_Uniform_Float32_semantics.type.literal = true;
    AtomicStore_Uniform_Float32.documentation = "Stores the value at the pointer location with the specified memory semantics, returns the old value"_c;
    AtomicStore_Uniform_Float32.name = AtomicStore_Uniform_Float32_name;
    AtomicStore_Uniform_Float32.backendIndex = 2231;
    AtomicStore_Uniform_Float32.returnType = Type::FullType { VoidType.name };
    AtomicStore_Uniform_Float32.parameters = AtomicStore_Uniform_Float32_args;
    Symbol::Resolved(&AtomicStore_Uniform_Float32_ptr)->typeSymbol = &Float32Type;
    Symbol::Resolved(&AtomicStore_Uniform_Float32_ptr)->storage = Storage::Uniform;
    Symbol::Resolved(&AtomicStore_Uniform_Float32_value)->typeSymbol = &Float32Type;
    Symbol::Resolved(&AtomicStore_Uniform_Float32_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicStore_Uniform_Float32)->signature = "atomicStore(uniform *mutable f32,f32,literal MemorySemantics) void"_c;
    Symbol::Resolved(&AtomicStore_Uniform_Float32)->name = "atomicStore(uniform *mutable f32,f32,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicStore_Uniform_Float32)->nameWithVarNames = "atomicStore(ptr : uniform *mutable f32, value : f32, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicStore_Uniform_Float32)->returnTypeSymbol = &VoidType;

    /// atomicStore with Float32, Float32, MemorySemantics
    AtomicStore_Workgroup_Float32_ptr.name = "ptr"_c;
    AtomicStore_Workgroup_Float32_ptr.type = Type::FullType{ Float32Type.name };
    AtomicStore_Workgroup_Float32_ptr.type.strict = true;
    AtomicStore_Workgroup_Float32_ptr.type.modifiers = AtomicStore_Workgroup_Float32_ptr_modifiers;
    AtomicStore_Workgroup_Float32_ptr.type.modifierValues = AtomicStore_Workgroup_Float32_ptr_modifierValues;
    AtomicStore_Workgroup_Float32_value.name = "value"_c;
    AtomicStore_Workgroup_Float32_value.type = Type::FullType{ Float32Type.name };
    AtomicStore_Workgroup_Float32_semantics.name = "semantics"_c;
    AtomicStore_Workgroup_Float32_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicStore_Workgroup_Float32_semantics.type.literal = true;
    AtomicStore_Workgroup_Float32.documentation = "Stores the value at the pointer location with the specified memory semantics, returns the old value"_c;
    AtomicStore_Workgroup_Float32.name = AtomicStore_Workgroup_Float32_name;
    AtomicStore_Workgroup_Float32.backendIndex = 2232;
    AtomicStore_Workgroup_Float32.returnType = Type::FullType { VoidType.name };
    AtomicStore_Workgroup_Float32.parameters = AtomicStore_Workgroup_Float32_args;
    Symbol::Resolved(&AtomicStore_Workgroup_Float32_ptr)->typeSymbol = &Float32Type;
    Symbol::Resolved(&AtomicStore_Workgroup_Float32_ptr)->storage = Storage::Workgroup;
    Symbol::Resolved(&AtomicStore_Workgroup_Float32_value)->typeSymbol = &Float32Type;
    Symbol::Resolved(&AtomicStore_Workgroup_Float32_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicStore_Workgroup_Float32)->signature = "atomicStore(workgroup *f32,f32,literal MemorySemantics) void"_c;
    Symbol::Resolved(&AtomicStore_Workgroup_Float32)->name = "atomicStore(workgroup *f32,f32,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicStore_Workgroup_Float32)->nameWithVarNames = "atomicStore(ptr : workgroup *f32, value : f32, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicStore_Workgroup_Float32)->returnTypeSymbol = &VoidType;

    /// atomicExchange with Float32, Float32, MemorySemantics
    AtomicExchange_Uniform_Float32_ptr.name = "ptr"_c;
    AtomicExchange_Uniform_Float32_ptr.type = Type::FullType{ Float32Type.name };
    AtomicExchange_Uniform_Float32_ptr.type.strict = true;
    AtomicExchange_Uniform_Float32_ptr.type.mut = true;
    AtomicExchange_Uniform_Float32_ptr.type.modifiers = AtomicExchange_Uniform_Float32_ptr_modifiers;
    AtomicExchange_Uniform_Float32_ptr.type.modifierValues = AtomicExchange_Uniform_Float32_ptr_modifierValues;
    AtomicExchange_Uniform_Float32_value.name = "value"_c;
    AtomicExchange_Uniform_Float32_value.type = Type::FullType{ Float32Type.name };
    AtomicExchange_Uniform_Float32_semantics.name = "semantics"_c;
    AtomicExchange_Uniform_Float32_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicExchange_Uniform_Float32_semantics.type.literal = true;
    AtomicExchange_Uniform_Float32.documentation = "Exchanges the value at the pointer location with the specified value and memory semantics, returns the old value"_c;
    AtomicExchange_Uniform_Float32.name = AtomicExchange_Uniform_Float32_name;
    AtomicExchange_Uniform_Float32.backendIndex = 2233;
    AtomicExchange_Uniform_Float32.returnType = Type::FullType { Float32Type.name };
    AtomicExchange_Uniform_Float32.parameters = AtomicExchange_Uniform_Float32_args;
    Symbol::Resolved(&AtomicExchange_Uniform_Float32_ptr)->typeSymbol = &Float32Type;
    Symbol::Resolved(&AtomicExchange_Uniform_Float32_ptr)->storage = Storage::Uniform;
    Symbol::Resolved(&AtomicExchange_Uniform_Float32_value)->typeSymbol = &Float32Type;
    Symbol::Resolved(&AtomicExchange_Uniform_Float32_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicExchange_Uniform_Float32)->signature = "atomicExchange(uniform *mutable f32,f32,literal MemorySemantics) f32"_c;
    Symbol::Resolved(&AtomicExchange_Uniform_Float32)->name = "atomicExchange(uniform *mutable f32,f32,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicExchange_Uniform_Float32)->nameWithVarNames = "atomicExchange(ptr : uniform *mutable f32, value : f32, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicExchange_Uniform_Float32)->returnTypeSymbol = &Float32Type;

    /// atomicExchange with Float32, Float32, MemorySemantics
    AtomicExchange_Workgroup_Float32_ptr.name = "ptr"_c;
    AtomicExchange_Workgroup_Float32_ptr.type = Type::FullType{ Float32Type.name };
    AtomicExchange_Workgroup_Float32_ptr.type.strict = true;
    AtomicExchange_Workgroup_Float32_ptr.type.modifiers = AtomicExchange_Workgroup_Float32_ptr_modifiers;
    AtomicExchange_Workgroup_Float32_ptr.type.modifierValues = AtomicExchange_Workgroup_Float32_ptr_modifierValues;
    AtomicExchange_Workgroup_Float32_value.name = "value"_c;
    AtomicExchange_Workgroup_Float32_value.type = Type::FullType{ Float32Type.name };
    AtomicExchange_Workgroup_Float32_semantics.name = "semantics"_c;
    AtomicExchange_Workgroup_Float32_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicExchange_Workgroup_Float32_semantics.type.literal = true;
    AtomicExchange_Workgroup_Float32.documentation = "Exchanges the value at the pointer location with the specified value and memory semantics, returns the old value"_c;
    AtomicExchange_Workgroup_Float32.name = AtomicExchange_Workgroup_Float32_name;
    AtomicExchange_Workgroup_Float32.backendIndex = 2234;
    AtomicExchange_Workgroup_Float32.returnType = Type::FullType { Float32Type.name };
    AtomicExchange_Workgroup_Float32.parameters = AtomicExchange_Workgroup_Float32_args;
    Symbol::Resolved(&AtomicExchange_Workgroup_Float32_ptr)->typeSymbol = &Float32Type;
    Symbol::Resolved(&AtomicExchange_Workgroup_Float32_ptr)->storage = Storage::Workgroup;
    Symbol::Resolved(&AtomicExchange_Workgroup_Float32_value)->typeSymbol = &Float32Type;
    Symbol::Resolved(&AtomicExchange_Workgroup_Float32_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicExchange_Workgroup_Float32)->signature = "atomicExchange(workgroup *f32,f32,literal MemorySemantics) f32"_c;
    Symbol::Resolved(&AtomicExchange_Workgroup_Float32)->name = "atomicExchange(workgroup *f32,f32,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicExchange_Workgroup_Float32)->nameWithVarNames = "atomicExchange(ptr : workgroup *f32, value : f32, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicExchange_Workgroup_Float32)->returnTypeSymbol = &Float32Type;

    /// atomicStore with Float16, Float16, MemorySemantics
    AtomicStore_Uniform_Float16_ptr.name = "ptr"_c;
    AtomicStore_Uniform_Float16_ptr.type = Type::FullType{ Float16Type.name };
    AtomicStore_Uniform_Float16_ptr.type.strict = true;
    AtomicStore_Uniform_Float16_ptr.type.mut = true;
    AtomicStore_Uniform_Float16_ptr.type.modifiers = AtomicStore_Uniform_Float16_ptr_modifiers;
    AtomicStore_Uniform_Float16_ptr.type.modifierValues = AtomicStore_Uniform_Float16_ptr_modifierValues;
    AtomicStore_Uniform_Float16_value.name = "value"_c;
    AtomicStore_Uniform_Float16_value.type = Type::FullType{ Float16Type.name };
    AtomicStore_Uniform_Float16_semantics.name = "semantics"_c;
    AtomicStore_Uniform_Float16_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicStore_Uniform_Float16_semantics.type.literal = true;
    AtomicStore_Uniform_Float16.documentation = "Stores the value at the pointer location with the specified memory semantics, returns the old value"_c;
    AtomicStore_Uniform_Float16.name = AtomicStore_Uniform_Float16_name;
    AtomicStore_Uniform_Float16.backendIndex = 2235;
    AtomicStore_Uniform_Float16.returnType = Type::FullType { VoidType.name };
    AtomicStore_Uniform_Float16.parameters = AtomicStore_Uniform_Float16_args;
    Symbol::Resolved(&AtomicStore_Uniform_Float16_ptr)->typeSymbol = &Float16Type;
    Symbol::Resolved(&AtomicStore_Uniform_Float16_ptr)->storage = Storage::Uniform;
    Symbol::Resolved(&AtomicStore_Uniform_Float16_value)->typeSymbol = &Float16Type;
    Symbol::Resolved(&AtomicStore_Uniform_Float16_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicStore_Uniform_Float16)->signature = "atomicStore(uniform *mutable f16,f16,literal MemorySemantics) void"_c;
    Symbol::Resolved(&AtomicStore_Uniform_Float16)->name = "atomicStore(uniform *mutable f16,f16,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicStore_Uniform_Float16)->nameWithVarNames = "atomicStore(ptr : uniform *mutable f16, value : f16, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicStore_Uniform_Float16)->returnTypeSymbol = &VoidType;

    /// atomicStore with Float16, Float16, MemorySemantics
    AtomicStore_Workgroup_Float16_ptr.name = "ptr"_c;
    AtomicStore_Workgroup_Float16_ptr.type = Type::FullType{ Float16Type.name };
    AtomicStore_Workgroup_Float16_ptr.type.strict = true;
    AtomicStore_Workgroup_Float16_ptr.type.modifiers = AtomicStore_Workgroup_Float16_ptr_modifiers;
    AtomicStore_Workgroup_Float16_ptr.type.modifierValues = AtomicStore_Workgroup_Float16_ptr_modifierValues;
    AtomicStore_Workgroup_Float16_value.name = "value"_c;
    AtomicStore_Workgroup_Float16_value.type = Type::FullType{ Float16Type.name };
    AtomicStore_Workgroup_Float16_semantics.name = "semantics"_c;
    AtomicStore_Workgroup_Float16_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicStore_Workgroup_Float16_semantics.type.literal = true;
    AtomicStore_Workgroup_Float16.documentation = "Stores the value at the pointer location with the specified memory semantics, returns the old value"_c;
    AtomicStore_Workgroup_Float16.name = AtomicStore_Workgroup_Float16_name;
    AtomicStore_Workgroup_Float16.backendIndex = 2236;
    AtomicStore_Workgroup_Float16.returnType = Type::FullType { VoidType.name };
    AtomicStore_Workgroup_Float16.parameters = AtomicStore_Workgroup_Float16_args;
    Symbol::Resolved(&AtomicStore_Workgroup_Float16_ptr)->typeSymbol = &Float16Type;
    Symbol::Resolved(&AtomicStore_Workgroup_Float16_ptr)->storage = Storage::Workgroup;
    Symbol::Resolved(&AtomicStore_Workgroup_Float16_value)->typeSymbol = &Float16Type;
    Symbol::Resolved(&AtomicStore_Workgroup_Float16_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicStore_Workgroup_Float16)->signature = "atomicStore(workgroup *f16,f16,literal MemorySemantics) void"_c;
    Symbol::Resolved(&AtomicStore_Workgroup_Float16)->name = "atomicStore(workgroup *f16,f16,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicStore_Workgroup_Float16)->nameWithVarNames = "atomicStore(ptr : workgroup *f16, value : f16, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicStore_Workgroup_Float16)->returnTypeSymbol = &VoidType;

    /// atomicExchange with Float16, Float16, MemorySemantics
    AtomicExchange_Uniform_Float16_ptr.name = "ptr"_c;
    AtomicExchange_Uniform_Float16_ptr.type = Type::FullType{ Float16Type.name };
    AtomicExchange_Uniform_Float16_ptr.type.strict = true;
    AtomicExchange_Uniform_Float16_ptr.type.mut = true;
    AtomicExchange_Uniform_Float16_ptr.type.modifiers = AtomicExchange_Uniform_Float16_ptr_modifiers;
    AtomicExchange_Uniform_Float16_ptr.type.modifierValues = AtomicExchange_Uniform_Float16_ptr_modifierValues;
    AtomicExchange_Uniform_Float16_value.name = "value"_c;
    AtomicExchange_Uniform_Float16_value.type = Type::FullType{ Float16Type.name };
    AtomicExchange_Uniform_Float16_semantics.name = "semantics"_c;
    AtomicExchange_Uniform_Float16_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicExchange_Uniform_Float16_semantics.type.literal = true;
    AtomicExchange_Uniform_Float16.documentation = "Exchanges the value at the pointer location with the specified value and memory semantics, returns the old value"_c;
    AtomicExchange_Uniform_Float16.name = AtomicExchange_Uniform_Float16_name;
    AtomicExchange_Uniform_Float16.backendIndex = 2237;
    AtomicExchange_Uniform_Float16.returnType = Type::FullType { Float16Type.name };
    AtomicExchange_Uniform_Float16.parameters = AtomicExchange_Uniform_Float16_args;
    Symbol::Resolved(&AtomicExchange_Uniform_Float16_ptr)->typeSymbol = &Float16Type;
    Symbol::Resolved(&AtomicExchange_Uniform_Float16_ptr)->storage = Storage::Uniform;
    Symbol::Resolved(&AtomicExchange_Uniform_Float16_value)->typeSymbol = &Float16Type;
    Symbol::Resolved(&AtomicExchange_Uniform_Float16_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicExchange_Uniform_Float16)->signature = "atomicExchange(uniform *mutable f16,f16,literal MemorySemantics) f16"_c;
    Symbol::Resolved(&AtomicExchange_Uniform_Float16)->name = "atomicExchange(uniform *mutable f16,f16,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicExchange_Uniform_Float16)->nameWithVarNames = "atomicExchange(ptr : uniform *mutable f16, value : f16, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicExchange_Uniform_Float16)->returnTypeSymbol = &Float16Type;

    /// atomicExchange with Float16, Float16, MemorySemantics
    AtomicExchange_Workgroup_Float16_ptr.name = "ptr"_c;
    AtomicExchange_Workgroup_Float16_ptr.type = Type::FullType{ Float16Type.name };
    AtomicExchange_Workgroup_Float16_ptr.type.strict = true;
    AtomicExchange_Workgroup_Float16_ptr.type.modifiers = AtomicExchange_Workgroup_Float16_ptr_modifiers;
    AtomicExchange_Workgroup_Float16_ptr.type.modifierValues = AtomicExchange_Workgroup_Float16_ptr_modifierValues;
    AtomicExchange_Workgroup_Float16_value.name = "value"_c;
    AtomicExchange_Workgroup_Float16_value.type = Type::FullType{ Float16Type.name };
    AtomicExchange_Workgroup_Float16_semantics.name = "semantics"_c;
    AtomicExchange_Workgroup_Float16_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicExchange_Workgroup_Float16_semantics.type.literal = true;
    AtomicExchange_Workgroup_Float16.documentation = "Exchanges the value at the pointer location with the specified value and memory semantics, returns the old value"_c;
    AtomicExchange_Workgroup_Float16.name = AtomicExchange_Workgroup_Float16_name;
    AtomicExchange_Workgroup_Float16.backendIndex = 2238;
    AtomicExchange_Workgroup_Float16.returnType = Type::FullType { Float16Type.name };
    AtomicExchange_Workgroup_Float16.parameters = AtomicExchange_Workgroup_Float16_args;
    Symbol::Resolved(&AtomicExchange_Workgroup_Float16_ptr)->typeSymbol = &Float16Type;
    Symbol::Resolved(&AtomicExchange_Workgroup_Float16_ptr)->storage = Storage::Workgroup;
    Symbol::Resolved(&AtomicExchange_Workgroup_Float16_value)->typeSymbol = &Float16Type;
    Symbol::Resolved(&AtomicExchange_Workgroup_Float16_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicExchange_Workgroup_Float16)->signature = "atomicExchange(workgroup *f16,f16,literal MemorySemantics) f16"_c;
    Symbol::Resolved(&AtomicExchange_Workgroup_Float16)->name = "atomicExchange(workgroup *f16,f16,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicExchange_Workgroup_Float16)->nameWithVarNames = "atomicExchange(ptr : workgroup *f16, value : f16, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicExchange_Workgroup_Float16)->returnTypeSymbol = &Float16Type;

    /// atomicMin with UInt32, UInt32, MemorySemantics
    AtomicMin_Uniform_UInt32_ptr.name = "ptr"_c;
    AtomicMin_Uniform_UInt32_ptr.type = Type::FullType{ UInt32Type.name };
    AtomicMin_Uniform_UInt32_ptr.type.strict = true;
    AtomicMin_Uniform_UInt32_ptr.type.mut = true;
    AtomicMin_Uniform_UInt32_ptr.type.modifiers = AtomicMin_Uniform_UInt32_ptr_modifiers;
    AtomicMin_Uniform_UInt32_ptr.type.modifierValues = AtomicMin_Uniform_UInt32_ptr_modifierValues;
    AtomicMin_Uniform_UInt32_compare.name = "compare"_c;
    AtomicMin_Uniform_UInt32_compare.type = Type::FullType{ UInt32Type.name };
    AtomicMin_Uniform_UInt32_semantics.name = "semantics"_c;
    AtomicMin_Uniform_UInt32_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicMin_Uniform_UInt32_semantics.type.literal = true;
    AtomicMin_Uniform_UInt32.documentation = "Compares the value at the pointer with the comparand, and stores the smallest value in the pointer, returns old value"_c;
    AtomicMin_Uniform_UInt32.name = AtomicMin_Uniform_UInt32_name;
    AtomicMin_Uniform_UInt32.backendIndex = 2239;
    AtomicMin_Uniform_UInt32.returnType = Type::FullType { UInt32Type.name };
    AtomicMin_Uniform_UInt32.parameters = AtomicMin_Uniform_UInt32_args;
    Symbol::Resolved(&AtomicMin_Uniform_UInt32_ptr)->typeSymbol = &UInt32Type;
    Symbol::Resolved(&AtomicMin_Uniform_UInt32_ptr)->storage = Storage::Uniform;
    Symbol::Resolved(&AtomicMin_Uniform_UInt32_compare)->typeSymbol = &UInt32Type;
    Symbol::Resolved(&AtomicMin_Uniform_UInt32_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicMin_Uniform_UInt32)->signature = "atomicMin(uniform *mutable u32,u32,literal MemorySemantics) u32"_c;
    Symbol::Resolved(&AtomicMin_Uniform_UInt32)->name = "atomicMin(uniform *mutable u32,u32,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicMin_Uniform_UInt32)->nameWithVarNames = "atomicMin(ptr : uniform *mutable u32, compare : u32, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicMin_Uniform_UInt32)->returnTypeSymbol = &UInt32Type;

    /// atomicMin with UInt32, UInt32, MemorySemantics
    AtomicMin_Workgroup_UInt32_ptr.name = "ptr"_c;
    AtomicMin_Workgroup_UInt32_ptr.type = Type::FullType{ UInt32Type.name };
    AtomicMin_Workgroup_UInt32_ptr.type.strict = true;
    AtomicMin_Workgroup_UInt32_ptr.type.modifiers = AtomicMin_Workgroup_UInt32_ptr_modifiers;
    AtomicMin_Workgroup_UInt32_ptr.type.modifierValues = AtomicMin_Workgroup_UInt32_ptr_modifierValues;
    AtomicMin_Workgroup_UInt32_compare.name = "compare"_c;
    AtomicMin_Workgroup_UInt32_compare.type = Type::FullType{ UInt32Type.name };
    AtomicMin_Workgroup_UInt32_semantics.name = "semantics"_c;
    AtomicMin_Workgroup_UInt32_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicMin_Workgroup_UInt32_semantics.type.literal = true;
    AtomicMin_Workgroup_UInt32.documentation = "Compares the value at the pointer with the comparand, and stores the smallest value in the pointer, returns old value"_c;
    AtomicMin_Workgroup_UInt32.name = AtomicMin_Workgroup_UInt32_name;
    AtomicMin_Workgroup_UInt32.backendIndex = 2240;
    AtomicMin_Workgroup_UInt32.returnType = Type::FullType { UInt32Type.name };
    AtomicMin_Workgroup_UInt32.parameters = AtomicMin_Workgroup_UInt32_args;
    Symbol::Resolved(&AtomicMin_Workgroup_UInt32_ptr)->typeSymbol = &UInt32Type;
    Symbol::Resolved(&AtomicMin_Workgroup_UInt32_ptr)->storage = Storage::Workgroup;
    Symbol::Resolved(&AtomicMin_Workgroup_UInt32_compare)->typeSymbol = &UInt32Type;
    Symbol::Resolved(&AtomicMin_Workgroup_UInt32_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicMin_Workgroup_UInt32)->signature = "atomicMin(workgroup *u32,u32,literal MemorySemantics) u32"_c;
    Symbol::Resolved(&AtomicMin_Workgroup_UInt32)->name = "atomicMin(workgroup *u32,u32,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicMin_Workgroup_UInt32)->nameWithVarNames = "atomicMin(ptr : workgroup *u32, compare : u32, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicMin_Workgroup_UInt32)->returnTypeSymbol = &UInt32Type;

    /// atomicMax with UInt32, UInt32, MemorySemantics
    AtomicMax_Uniform_UInt32_ptr.name = "ptr"_c;
    AtomicMax_Uniform_UInt32_ptr.type = Type::FullType{ UInt32Type.name };
    AtomicMax_Uniform_UInt32_ptr.type.strict = true;
    AtomicMax_Uniform_UInt32_ptr.type.mut = true;
    AtomicMax_Uniform_UInt32_ptr.type.modifiers = AtomicMax_Uniform_UInt32_ptr_modifiers;
    AtomicMax_Uniform_UInt32_ptr.type.modifierValues = AtomicMax_Uniform_UInt32_ptr_modifierValues;
    AtomicMax_Uniform_UInt32_compare.name = "compare"_c;
    AtomicMax_Uniform_UInt32_compare.type = Type::FullType{ UInt32Type.name };
    AtomicMax_Uniform_UInt32_semantics.name = "semantics"_c;
    AtomicMax_Uniform_UInt32_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicMax_Uniform_UInt32_semantics.type.literal = true;
    AtomicMax_Uniform_UInt32.documentation = "Compares the value at the pointer with the comparand, and stores the largest value in the pointer, returns old value"_c;
    AtomicMax_Uniform_UInt32.name = AtomicMax_Uniform_UInt32_name;
    AtomicMax_Uniform_UInt32.backendIndex = 2241;
    AtomicMax_Uniform_UInt32.returnType = Type::FullType { UInt32Type.name };
    AtomicMax_Uniform_UInt32.parameters = AtomicMax_Uniform_UInt32_args;
    Symbol::Resolved(&AtomicMax_Uniform_UInt32_ptr)->typeSymbol = &UInt32Type;
    Symbol::Resolved(&AtomicMax_Uniform_UInt32_ptr)->storage = Storage::Uniform;
    Symbol::Resolved(&AtomicMax_Uniform_UInt32_compare)->typeSymbol = &UInt32Type;
    Symbol::Resolved(&AtomicMax_Uniform_UInt32_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicMax_Uniform_UInt32)->signature = "atomicMax(uniform *mutable u32,u32,literal MemorySemantics) u32"_c;
    Symbol::Resolved(&AtomicMax_Uniform_UInt32)->name = "atomicMax(uniform *mutable u32,u32,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicMax_Uniform_UInt32)->nameWithVarNames = "atomicMax(ptr : uniform *mutable u32, compare : u32, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicMax_Uniform_UInt32)->returnTypeSymbol = &UInt32Type;

    /// atomicMax with UInt32, UInt32, MemorySemantics
    AtomicMax_Workgroup_UInt32_ptr.name = "ptr"_c;
    AtomicMax_Workgroup_UInt32_ptr.type = Type::FullType{ UInt32Type.name };
    AtomicMax_Workgroup_UInt32_ptr.type.strict = true;
    AtomicMax_Workgroup_UInt32_ptr.type.modifiers = AtomicMax_Workgroup_UInt32_ptr_modifiers;
    AtomicMax_Workgroup_UInt32_ptr.type.modifierValues = AtomicMax_Workgroup_UInt32_ptr_modifierValues;
    AtomicMax_Workgroup_UInt32_compare.name = "compare"_c;
    AtomicMax_Workgroup_UInt32_compare.type = Type::FullType{ UInt32Type.name };
    AtomicMax_Workgroup_UInt32_semantics.name = "semantics"_c;
    AtomicMax_Workgroup_UInt32_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicMax_Workgroup_UInt32_semantics.type.literal = true;
    AtomicMax_Workgroup_UInt32.documentation = "Compares the value at the pointer with the comparand, and stores the largest value in the pointer, returns old value"_c;
    AtomicMax_Workgroup_UInt32.name = AtomicMax_Workgroup_UInt32_name;
    AtomicMax_Workgroup_UInt32.backendIndex = 2242;
    AtomicMax_Workgroup_UInt32.returnType = Type::FullType { UInt32Type.name };
    AtomicMax_Workgroup_UInt32.parameters = AtomicMax_Workgroup_UInt32_args;
    Symbol::Resolved(&AtomicMax_Workgroup_UInt32_ptr)->typeSymbol = &UInt32Type;
    Symbol::Resolved(&AtomicMax_Workgroup_UInt32_ptr)->storage = Storage::Workgroup;
    Symbol::Resolved(&AtomicMax_Workgroup_UInt32_compare)->typeSymbol = &UInt32Type;
    Symbol::Resolved(&AtomicMax_Workgroup_UInt32_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicMax_Workgroup_UInt32)->signature = "atomicMax(workgroup *u32,u32,literal MemorySemantics) u32"_c;
    Symbol::Resolved(&AtomicMax_Workgroup_UInt32)->name = "atomicMax(workgroup *u32,u32,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicMax_Workgroup_UInt32)->nameWithVarNames = "atomicMax(ptr : workgroup *u32, compare : u32, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicMax_Workgroup_UInt32)->returnTypeSymbol = &UInt32Type;

    /// atomicMin with Int32, Int32, MemorySemantics
    AtomicMin_Uniform_Int32_ptr.name = "ptr"_c;
    AtomicMin_Uniform_Int32_ptr.type = Type::FullType{ Int32Type.name };
    AtomicMin_Uniform_Int32_ptr.type.strict = true;
    AtomicMin_Uniform_Int32_ptr.type.mut = true;
    AtomicMin_Uniform_Int32_ptr.type.modifiers = AtomicMin_Uniform_Int32_ptr_modifiers;
    AtomicMin_Uniform_Int32_ptr.type.modifierValues = AtomicMin_Uniform_Int32_ptr_modifierValues;
    AtomicMin_Uniform_Int32_compare.name = "compare"_c;
    AtomicMin_Uniform_Int32_compare.type = Type::FullType{ Int32Type.name };
    AtomicMin_Uniform_Int32_semantics.name = "semantics"_c;
    AtomicMin_Uniform_Int32_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicMin_Uniform_Int32_semantics.type.literal = true;
    AtomicMin_Uniform_Int32.documentation = "Compares the value at the pointer with the comparand, and stores the smallest value in the pointer, returns old value"_c;
    AtomicMin_Uniform_Int32.name = AtomicMin_Uniform_Int32_name;
    AtomicMin_Uniform_Int32.backendIndex = 2243;
    AtomicMin_Uniform_Int32.returnType = Type::FullType { Int32Type.name };
    AtomicMin_Uniform_Int32.parameters = AtomicMin_Uniform_Int32_args;
    Symbol::Resolved(&AtomicMin_Uniform_Int32_ptr)->typeSymbol = &Int32Type;
    Symbol::Resolved(&AtomicMin_Uniform_Int32_ptr)->storage = Storage::Uniform;
    Symbol::Resolved(&AtomicMin_Uniform_Int32_compare)->typeSymbol = &Int32Type;
    Symbol::Resolved(&AtomicMin_Uniform_Int32_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicMin_Uniform_Int32)->signature = "atomicMin(uniform *mutable i32,i32,literal MemorySemantics) i32"_c;
    Symbol::Resolved(&AtomicMin_Uniform_Int32)->name = "atomicMin(uniform *mutable i32,i32,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicMin_Uniform_Int32)->nameWithVarNames = "atomicMin(ptr : uniform *mutable i32, compare : i32, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicMin_Uniform_Int32)->returnTypeSymbol = &Int32Type;

    /// atomicMin with Int32, Int32, MemorySemantics
    AtomicMin_Workgroup_Int32_ptr.name = "ptr"_c;
    AtomicMin_Workgroup_Int32_ptr.type = Type::FullType{ Int32Type.name };
    AtomicMin_Workgroup_Int32_ptr.type.strict = true;
    AtomicMin_Workgroup_Int32_ptr.type.modifiers = AtomicMin_Workgroup_Int32_ptr_modifiers;
    AtomicMin_Workgroup_Int32_ptr.type.modifierValues = AtomicMin_Workgroup_Int32_ptr_modifierValues;
    AtomicMin_Workgroup_Int32_compare.name = "compare"_c;
    AtomicMin_Workgroup_Int32_compare.type = Type::FullType{ Int32Type.name };
    AtomicMin_Workgroup_Int32_semantics.name = "semantics"_c;
    AtomicMin_Workgroup_Int32_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicMin_Workgroup_Int32_semantics.type.literal = true;
    AtomicMin_Workgroup_Int32.documentation = "Compares the value at the pointer with the comparand, and stores the smallest value in the pointer, returns old value"_c;
    AtomicMin_Workgroup_Int32.name = AtomicMin_Workgroup_Int32_name;
    AtomicMin_Workgroup_Int32.backendIndex = 2244;
    AtomicMin_Workgroup_Int32.returnType = Type::FullType { Int32Type.name };
    AtomicMin_Workgroup_Int32.parameters = AtomicMin_Workgroup_Int32_args;
    Symbol::Resolved(&AtomicMin_Workgroup_Int32_ptr)->typeSymbol = &Int32Type;
    Symbol::Resolved(&AtomicMin_Workgroup_Int32_ptr)->storage = Storage::Workgroup;
    Symbol::Resolved(&AtomicMin_Workgroup_Int32_compare)->typeSymbol = &Int32Type;
    Symbol::Resolved(&AtomicMin_Workgroup_Int32_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicMin_Workgroup_Int32)->signature = "atomicMin(workgroup *i32,i32,literal MemorySemantics) i32"_c;
    Symbol::Resolved(&AtomicMin_Workgroup_Int32)->name = "atomicMin(workgroup *i32,i32,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicMin_Workgroup_Int32)->nameWithVarNames = "atomicMin(ptr : workgroup *i32, compare : i32, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicMin_Workgroup_Int32)->returnTypeSymbol = &Int32Type;

    /// atomicMax with Int32, Int32, MemorySemantics
    AtomicMax_Uniform_Int32_ptr.name = "ptr"_c;
    AtomicMax_Uniform_Int32_ptr.type = Type::FullType{ Int32Type.name };
    AtomicMax_Uniform_Int32_ptr.type.strict = true;
    AtomicMax_Uniform_Int32_ptr.type.mut = true;
    AtomicMax_Uniform_Int32_ptr.type.modifiers = AtomicMax_Uniform_Int32_ptr_modifiers;
    AtomicMax_Uniform_Int32_ptr.type.modifierValues = AtomicMax_Uniform_Int32_ptr_modifierValues;
    AtomicMax_Uniform_Int32_compare.name = "compare"_c;
    AtomicMax_Uniform_Int32_compare.type = Type::FullType{ Int32Type.name };
    AtomicMax_Uniform_Int32_semantics.name = "semantics"_c;
    AtomicMax_Uniform_Int32_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicMax_Uniform_Int32_semantics.type.literal = true;
    AtomicMax_Uniform_Int32.documentation = "Compares the value at the pointer with the comparand, and stores the largest value in the pointer, returns old value"_c;
    AtomicMax_Uniform_Int32.name = AtomicMax_Uniform_Int32_name;
    AtomicMax_Uniform_Int32.backendIndex = 2245;
    AtomicMax_Uniform_Int32.returnType = Type::FullType { Int32Type.name };
    AtomicMax_Uniform_Int32.parameters = AtomicMax_Uniform_Int32_args;
    Symbol::Resolved(&AtomicMax_Uniform_Int32_ptr)->typeSymbol = &Int32Type;
    Symbol::Resolved(&AtomicMax_Uniform_Int32_ptr)->storage = Storage::Uniform;
    Symbol::Resolved(&AtomicMax_Uniform_Int32_compare)->typeSymbol = &Int32Type;
    Symbol::Resolved(&AtomicMax_Uniform_Int32_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicMax_Uniform_Int32)->signature = "atomicMax(uniform *mutable i32,i32,literal MemorySemantics) i32"_c;
    Symbol::Resolved(&AtomicMax_Uniform_Int32)->name = "atomicMax(uniform *mutable i32,i32,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicMax_Uniform_Int32)->nameWithVarNames = "atomicMax(ptr : uniform *mutable i32, compare : i32, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicMax_Uniform_Int32)->returnTypeSymbol = &Int32Type;

    /// atomicMax with Int32, Int32, MemorySemantics
    AtomicMax_Workgroup_Int32_ptr.name = "ptr"_c;
    AtomicMax_Workgroup_Int32_ptr.type = Type::FullType{ Int32Type.name };
    AtomicMax_Workgroup_Int32_ptr.type.strict = true;
    AtomicMax_Workgroup_Int32_ptr.type.modifiers = AtomicMax_Workgroup_Int32_ptr_modifiers;
    AtomicMax_Workgroup_Int32_ptr.type.modifierValues = AtomicMax_Workgroup_Int32_ptr_modifierValues;
    AtomicMax_Workgroup_Int32_compare.name = "compare"_c;
    AtomicMax_Workgroup_Int32_compare.type = Type::FullType{ Int32Type.name };
    AtomicMax_Workgroup_Int32_semantics.name = "semantics"_c;
    AtomicMax_Workgroup_Int32_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicMax_Workgroup_Int32_semantics.type.literal = true;
    AtomicMax_Workgroup_Int32.documentation = "Compares the value at the pointer with the comparand, and stores the largest value in the pointer, returns old value"_c;
    AtomicMax_Workgroup_Int32.name = AtomicMax_Workgroup_Int32_name;
    AtomicMax_Workgroup_Int32.backendIndex = 2246;
    AtomicMax_Workgroup_Int32.returnType = Type::FullType { Int32Type.name };
    AtomicMax_Workgroup_Int32.parameters = AtomicMax_Workgroup_Int32_args;
    Symbol::Resolved(&AtomicMax_Workgroup_Int32_ptr)->typeSymbol = &Int32Type;
    Symbol::Resolved(&AtomicMax_Workgroup_Int32_ptr)->storage = Storage::Workgroup;
    Symbol::Resolved(&AtomicMax_Workgroup_Int32_compare)->typeSymbol = &Int32Type;
    Symbol::Resolved(&AtomicMax_Workgroup_Int32_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicMax_Workgroup_Int32)->signature = "atomicMax(workgroup *i32,i32,literal MemorySemantics) i32"_c;
    Symbol::Resolved(&AtomicMax_Workgroup_Int32)->name = "atomicMax(workgroup *i32,i32,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicMax_Workgroup_Int32)->nameWithVarNames = "atomicMax(ptr : workgroup *i32, compare : i32, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicMax_Workgroup_Int32)->returnTypeSymbol = &Int32Type;

    /// atomicMin with UInt16, UInt16, MemorySemantics
    AtomicMin_Uniform_UInt16_ptr.name = "ptr"_c;
    AtomicMin_Uniform_UInt16_ptr.type = Type::FullType{ UInt16Type.name };
    AtomicMin_Uniform_UInt16_ptr.type.strict = true;
    AtomicMin_Uniform_UInt16_ptr.type.mut = true;
    AtomicMin_Uniform_UInt16_ptr.type.modifiers = AtomicMin_Uniform_UInt16_ptr_modifiers;
    AtomicMin_Uniform_UInt16_ptr.type.modifierValues = AtomicMin_Uniform_UInt16_ptr_modifierValues;
    AtomicMin_Uniform_UInt16_compare.name = "compare"_c;
    AtomicMin_Uniform_UInt16_compare.type = Type::FullType{ UInt16Type.name };
    AtomicMin_Uniform_UInt16_semantics.name = "semantics"_c;
    AtomicMin_Uniform_UInt16_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicMin_Uniform_UInt16_semantics.type.literal = true;
    AtomicMin_Uniform_UInt16.documentation = "Compares the value at the pointer with the comparand, and stores the smallest value in the pointer, returns old value"_c;
    AtomicMin_Uniform_UInt16.name = AtomicMin_Uniform_UInt16_name;
    AtomicMin_Uniform_UInt16.backendIndex = 2247;
    AtomicMin_Uniform_UInt16.returnType = Type::FullType { UInt16Type.name };
    AtomicMin_Uniform_UInt16.parameters = AtomicMin_Uniform_UInt16_args;
    Symbol::Resolved(&AtomicMin_Uniform_UInt16_ptr)->typeSymbol = &UInt16Type;
    Symbol::Resolved(&AtomicMin_Uniform_UInt16_ptr)->storage = Storage::Uniform;
    Symbol::Resolved(&AtomicMin_Uniform_UInt16_compare)->typeSymbol = &UInt16Type;
    Symbol::Resolved(&AtomicMin_Uniform_UInt16_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicMin_Uniform_UInt16)->signature = "atomicMin(uniform *mutable u16,u16,literal MemorySemantics) u16"_c;
    Symbol::Resolved(&AtomicMin_Uniform_UInt16)->name = "atomicMin(uniform *mutable u16,u16,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicMin_Uniform_UInt16)->nameWithVarNames = "atomicMin(ptr : uniform *mutable u16, compare : u16, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicMin_Uniform_UInt16)->returnTypeSymbol = &UInt16Type;

    /// atomicMin with UInt16, UInt16, MemorySemantics
    AtomicMin_Workgroup_UInt16_ptr.name = "ptr"_c;
    AtomicMin_Workgroup_UInt16_ptr.type = Type::FullType{ UInt16Type.name };
    AtomicMin_Workgroup_UInt16_ptr.type.strict = true;
    AtomicMin_Workgroup_UInt16_ptr.type.modifiers = AtomicMin_Workgroup_UInt16_ptr_modifiers;
    AtomicMin_Workgroup_UInt16_ptr.type.modifierValues = AtomicMin_Workgroup_UInt16_ptr_modifierValues;
    AtomicMin_Workgroup_UInt16_compare.name = "compare"_c;
    AtomicMin_Workgroup_UInt16_compare.type = Type::FullType{ UInt16Type.name };
    AtomicMin_Workgroup_UInt16_semantics.name = "semantics"_c;
    AtomicMin_Workgroup_UInt16_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicMin_Workgroup_UInt16_semantics.type.literal = true;
    AtomicMin_Workgroup_UInt16.documentation = "Compares the value at the pointer with the comparand, and stores the smallest value in the pointer, returns old value"_c;
    AtomicMin_Workgroup_UInt16.name = AtomicMin_Workgroup_UInt16_name;
    AtomicMin_Workgroup_UInt16.backendIndex = 2248;
    AtomicMin_Workgroup_UInt16.returnType = Type::FullType { UInt16Type.name };
    AtomicMin_Workgroup_UInt16.parameters = AtomicMin_Workgroup_UInt16_args;
    Symbol::Resolved(&AtomicMin_Workgroup_UInt16_ptr)->typeSymbol = &UInt16Type;
    Symbol::Resolved(&AtomicMin_Workgroup_UInt16_ptr)->storage = Storage::Workgroup;
    Symbol::Resolved(&AtomicMin_Workgroup_UInt16_compare)->typeSymbol = &UInt16Type;
    Symbol::Resolved(&AtomicMin_Workgroup_UInt16_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicMin_Workgroup_UInt16)->signature = "atomicMin(workgroup *u16,u16,literal MemorySemantics) u16"_c;
    Symbol::Resolved(&AtomicMin_Workgroup_UInt16)->name = "atomicMin(workgroup *u16,u16,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicMin_Workgroup_UInt16)->nameWithVarNames = "atomicMin(ptr : workgroup *u16, compare : u16, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicMin_Workgroup_UInt16)->returnTypeSymbol = &UInt16Type;

    /// atomicMax with UInt16, UInt16, MemorySemantics
    AtomicMax_Uniform_UInt16_ptr.name = "ptr"_c;
    AtomicMax_Uniform_UInt16_ptr.type = Type::FullType{ UInt16Type.name };
    AtomicMax_Uniform_UInt16_ptr.type.strict = true;
    AtomicMax_Uniform_UInt16_ptr.type.mut = true;
    AtomicMax_Uniform_UInt16_ptr.type.modifiers = AtomicMax_Uniform_UInt16_ptr_modifiers;
    AtomicMax_Uniform_UInt16_ptr.type.modifierValues = AtomicMax_Uniform_UInt16_ptr_modifierValues;
    AtomicMax_Uniform_UInt16_compare.name = "compare"_c;
    AtomicMax_Uniform_UInt16_compare.type = Type::FullType{ UInt16Type.name };
    AtomicMax_Uniform_UInt16_semantics.name = "semantics"_c;
    AtomicMax_Uniform_UInt16_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicMax_Uniform_UInt16_semantics.type.literal = true;
    AtomicMax_Uniform_UInt16.documentation = "Compares the value at the pointer with the comparand, and stores the largest value in the pointer, returns old value"_c;
    AtomicMax_Uniform_UInt16.name = AtomicMax_Uniform_UInt16_name;
    AtomicMax_Uniform_UInt16.backendIndex = 2249;
    AtomicMax_Uniform_UInt16.returnType = Type::FullType { UInt16Type.name };
    AtomicMax_Uniform_UInt16.parameters = AtomicMax_Uniform_UInt16_args;
    Symbol::Resolved(&AtomicMax_Uniform_UInt16_ptr)->typeSymbol = &UInt16Type;
    Symbol::Resolved(&AtomicMax_Uniform_UInt16_ptr)->storage = Storage::Uniform;
    Symbol::Resolved(&AtomicMax_Uniform_UInt16_compare)->typeSymbol = &UInt16Type;
    Symbol::Resolved(&AtomicMax_Uniform_UInt16_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicMax_Uniform_UInt16)->signature = "atomicMax(uniform *mutable u16,u16,literal MemorySemantics) u16"_c;
    Symbol::Resolved(&AtomicMax_Uniform_UInt16)->name = "atomicMax(uniform *mutable u16,u16,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicMax_Uniform_UInt16)->nameWithVarNames = "atomicMax(ptr : uniform *mutable u16, compare : u16, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicMax_Uniform_UInt16)->returnTypeSymbol = &UInt16Type;

    /// atomicMax with UInt16, UInt16, MemorySemantics
    AtomicMax_Workgroup_UInt16_ptr.name = "ptr"_c;
    AtomicMax_Workgroup_UInt16_ptr.type = Type::FullType{ UInt16Type.name };
    AtomicMax_Workgroup_UInt16_ptr.type.strict = true;
    AtomicMax_Workgroup_UInt16_ptr.type.modifiers = AtomicMax_Workgroup_UInt16_ptr_modifiers;
    AtomicMax_Workgroup_UInt16_ptr.type.modifierValues = AtomicMax_Workgroup_UInt16_ptr_modifierValues;
    AtomicMax_Workgroup_UInt16_compare.name = "compare"_c;
    AtomicMax_Workgroup_UInt16_compare.type = Type::FullType{ UInt16Type.name };
    AtomicMax_Workgroup_UInt16_semantics.name = "semantics"_c;
    AtomicMax_Workgroup_UInt16_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicMax_Workgroup_UInt16_semantics.type.literal = true;
    AtomicMax_Workgroup_UInt16.documentation = "Compares the value at the pointer with the comparand, and stores the largest value in the pointer, returns old value"_c;
    AtomicMax_Workgroup_UInt16.name = AtomicMax_Workgroup_UInt16_name;
    AtomicMax_Workgroup_UInt16.backendIndex = 2250;
    AtomicMax_Workgroup_UInt16.returnType = Type::FullType { UInt16Type.name };
    AtomicMax_Workgroup_UInt16.parameters = AtomicMax_Workgroup_UInt16_args;
    Symbol::Resolved(&AtomicMax_Workgroup_UInt16_ptr)->typeSymbol = &UInt16Type;
    Symbol::Resolved(&AtomicMax_Workgroup_UInt16_ptr)->storage = Storage::Workgroup;
    Symbol::Resolved(&AtomicMax_Workgroup_UInt16_compare)->typeSymbol = &UInt16Type;
    Symbol::Resolved(&AtomicMax_Workgroup_UInt16_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicMax_Workgroup_UInt16)->signature = "atomicMax(workgroup *u16,u16,literal MemorySemantics) u16"_c;
    Symbol::Resolved(&AtomicMax_Workgroup_UInt16)->name = "atomicMax(workgroup *u16,u16,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicMax_Workgroup_UInt16)->nameWithVarNames = "atomicMax(ptr : workgroup *u16, compare : u16, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicMax_Workgroup_UInt16)->returnTypeSymbol = &UInt16Type;

    /// atomicMin with Int16, Int16, MemorySemantics
    AtomicMin_Uniform_Int16_ptr.name = "ptr"_c;
    AtomicMin_Uniform_Int16_ptr.type = Type::FullType{ Int16Type.name };
    AtomicMin_Uniform_Int16_ptr.type.strict = true;
    AtomicMin_Uniform_Int16_ptr.type.mut = true;
    AtomicMin_Uniform_Int16_ptr.type.modifiers = AtomicMin_Uniform_Int16_ptr_modifiers;
    AtomicMin_Uniform_Int16_ptr.type.modifierValues = AtomicMin_Uniform_Int16_ptr_modifierValues;
    AtomicMin_Uniform_Int16_compare.name = "compare"_c;
    AtomicMin_Uniform_Int16_compare.type = Type::FullType{ Int16Type.name };
    AtomicMin_Uniform_Int16_semantics.name = "semantics"_c;
    AtomicMin_Uniform_Int16_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicMin_Uniform_Int16_semantics.type.literal = true;
    AtomicMin_Uniform_Int16.documentation = "Compares the value at the pointer with the comparand, and stores the smallest value in the pointer, returns old value"_c;
    AtomicMin_Uniform_Int16.name = AtomicMin_Uniform_Int16_name;
    AtomicMin_Uniform_Int16.backendIndex = 2251;
    AtomicMin_Uniform_Int16.returnType = Type::FullType { Int16Type.name };
    AtomicMin_Uniform_Int16.parameters = AtomicMin_Uniform_Int16_args;
    Symbol::Resolved(&AtomicMin_Uniform_Int16_ptr)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicMin_Uniform_Int16_ptr)->storage = Storage::Uniform;
    Symbol::Resolved(&AtomicMin_Uniform_Int16_compare)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicMin_Uniform_Int16_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicMin_Uniform_Int16)->signature = "atomicMin(uniform *mutable i16,i16,literal MemorySemantics) i16"_c;
    Symbol::Resolved(&AtomicMin_Uniform_Int16)->name = "atomicMin(uniform *mutable i16,i16,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicMin_Uniform_Int16)->nameWithVarNames = "atomicMin(ptr : uniform *mutable i16, compare : i16, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicMin_Uniform_Int16)->returnTypeSymbol = &Int16Type;

    /// atomicMin with Int16, Int16, MemorySemantics
    AtomicMin_Workgroup_Int16_ptr.name = "ptr"_c;
    AtomicMin_Workgroup_Int16_ptr.type = Type::FullType{ Int16Type.name };
    AtomicMin_Workgroup_Int16_ptr.type.strict = true;
    AtomicMin_Workgroup_Int16_ptr.type.modifiers = AtomicMin_Workgroup_Int16_ptr_modifiers;
    AtomicMin_Workgroup_Int16_ptr.type.modifierValues = AtomicMin_Workgroup_Int16_ptr_modifierValues;
    AtomicMin_Workgroup_Int16_compare.name = "compare"_c;
    AtomicMin_Workgroup_Int16_compare.type = Type::FullType{ Int16Type.name };
    AtomicMin_Workgroup_Int16_semantics.name = "semantics"_c;
    AtomicMin_Workgroup_Int16_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicMin_Workgroup_Int16_semantics.type.literal = true;
    AtomicMin_Workgroup_Int16.documentation = "Compares the value at the pointer with the comparand, and stores the smallest value in the pointer, returns old value"_c;
    AtomicMin_Workgroup_Int16.name = AtomicMin_Workgroup_Int16_name;
    AtomicMin_Workgroup_Int16.backendIndex = 2252;
    AtomicMin_Workgroup_Int16.returnType = Type::FullType { Int16Type.name };
    AtomicMin_Workgroup_Int16.parameters = AtomicMin_Workgroup_Int16_args;
    Symbol::Resolved(&AtomicMin_Workgroup_Int16_ptr)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicMin_Workgroup_Int16_ptr)->storage = Storage::Workgroup;
    Symbol::Resolved(&AtomicMin_Workgroup_Int16_compare)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicMin_Workgroup_Int16_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicMin_Workgroup_Int16)->signature = "atomicMin(workgroup *i16,i16,literal MemorySemantics) i16"_c;
    Symbol::Resolved(&AtomicMin_Workgroup_Int16)->name = "atomicMin(workgroup *i16,i16,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicMin_Workgroup_Int16)->nameWithVarNames = "atomicMin(ptr : workgroup *i16, compare : i16, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicMin_Workgroup_Int16)->returnTypeSymbol = &Int16Type;

    /// atomicMax with Int16, Int16, MemorySemantics
    AtomicMax_Uniform_Int16_ptr.name = "ptr"_c;
    AtomicMax_Uniform_Int16_ptr.type = Type::FullType{ Int16Type.name };
    AtomicMax_Uniform_Int16_ptr.type.strict = true;
    AtomicMax_Uniform_Int16_ptr.type.mut = true;
    AtomicMax_Uniform_Int16_ptr.type.modifiers = AtomicMax_Uniform_Int16_ptr_modifiers;
    AtomicMax_Uniform_Int16_ptr.type.modifierValues = AtomicMax_Uniform_Int16_ptr_modifierValues;
    AtomicMax_Uniform_Int16_compare.name = "compare"_c;
    AtomicMax_Uniform_Int16_compare.type = Type::FullType{ Int16Type.name };
    AtomicMax_Uniform_Int16_semantics.name = "semantics"_c;
    AtomicMax_Uniform_Int16_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicMax_Uniform_Int16_semantics.type.literal = true;
    AtomicMax_Uniform_Int16.documentation = "Compares the value at the pointer with the comparand, and stores the largest value in the pointer, returns old value"_c;
    AtomicMax_Uniform_Int16.name = AtomicMax_Uniform_Int16_name;
    AtomicMax_Uniform_Int16.backendIndex = 2253;
    AtomicMax_Uniform_Int16.returnType = Type::FullType { Int16Type.name };
    AtomicMax_Uniform_Int16.parameters = AtomicMax_Uniform_Int16_args;
    Symbol::Resolved(&AtomicMax_Uniform_Int16_ptr)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicMax_Uniform_Int16_ptr)->storage = Storage::Uniform;
    Symbol::Resolved(&AtomicMax_Uniform_Int16_compare)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicMax_Uniform_Int16_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicMax_Uniform_Int16)->signature = "atomicMax(uniform *mutable i16,i16,literal MemorySemantics) i16"_c;
    Symbol::Resolved(&AtomicMax_Uniform_Int16)->name = "atomicMax(uniform *mutable i16,i16,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicMax_Uniform_Int16)->nameWithVarNames = "atomicMax(ptr : uniform *mutable i16, compare : i16, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicMax_Uniform_Int16)->returnTypeSymbol = &Int16Type;

    /// atomicMax with Int16, Int16, MemorySemantics
    AtomicMax_Workgroup_Int16_ptr.name = "ptr"_c;
    AtomicMax_Workgroup_Int16_ptr.type = Type::FullType{ Int16Type.name };
    AtomicMax_Workgroup_Int16_ptr.type.strict = true;
    AtomicMax_Workgroup_Int16_ptr.type.modifiers = AtomicMax_Workgroup_Int16_ptr_modifiers;
    AtomicMax_Workgroup_Int16_ptr.type.modifierValues = AtomicMax_Workgroup_Int16_ptr_modifierValues;
    AtomicMax_Workgroup_Int16_compare.name = "compare"_c;
    AtomicMax_Workgroup_Int16_compare.type = Type::FullType{ Int16Type.name };
    AtomicMax_Workgroup_Int16_semantics.name = "semantics"_c;
    AtomicMax_Workgroup_Int16_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicMax_Workgroup_Int16_semantics.type.literal = true;
    AtomicMax_Workgroup_Int16.documentation = "Compares the value at the pointer with the comparand, and stores the largest value in the pointer, returns old value"_c;
    AtomicMax_Workgroup_Int16.name = AtomicMax_Workgroup_Int16_name;
    AtomicMax_Workgroup_Int16.backendIndex = 2254;
    AtomicMax_Workgroup_Int16.returnType = Type::FullType { Int16Type.name };
    AtomicMax_Workgroup_Int16.parameters = AtomicMax_Workgroup_Int16_args;
    Symbol::Resolved(&AtomicMax_Workgroup_Int16_ptr)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicMax_Workgroup_Int16_ptr)->storage = Storage::Workgroup;
    Symbol::Resolved(&AtomicMax_Workgroup_Int16_compare)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicMax_Workgroup_Int16_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicMax_Workgroup_Int16)->signature = "atomicMax(workgroup *i16,i16,literal MemorySemantics) i16"_c;
    Symbol::Resolved(&AtomicMax_Workgroup_Int16)->name = "atomicMax(workgroup *i16,i16,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicMax_Workgroup_Int16)->nameWithVarNames = "atomicMax(ptr : workgroup *i16, compare : i16, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicMax_Workgroup_Int16)->returnTypeSymbol = &Int16Type;

    /// atomicCompareExchange with UInt32, UInt32, UInt32, MemorySemantics
    AtomicCompareExchange_Uniform_UInt32_ptr.name = "ptr"_c;
    AtomicCompareExchange_Uniform_UInt32_ptr.type = Type::FullType{ UInt32Type.name };
    AtomicCompareExchange_Uniform_UInt32_ptr.type.strict = true;
    AtomicCompareExchange_Uniform_UInt32_ptr.type.mut = true;
    AtomicCompareExchange_Uniform_UInt32_ptr.type.modifiers = AtomicCompareExchange_Uniform_UInt32_ptr_modifiers;
    AtomicCompareExchange_Uniform_UInt32_ptr.type.modifierValues = AtomicCompareExchange_Uniform_UInt32_ptr_modifierValues;
    AtomicCompareExchange_Uniform_UInt32_value.name = "value"_c;
    AtomicCompareExchange_Uniform_UInt32_value.type = Type::FullType{ UInt32Type.name };
    AtomicCompareExchange_Uniform_UInt32_compare.name = "compare"_c;
    AtomicCompareExchange_Uniform_UInt32_compare.type = Type::FullType{ UInt32Type.name };
    AtomicCompareExchange_Uniform_UInt32_semantics.name = "semantics"_c;
    AtomicCompareExchange_Uniform_UInt32_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicCompareExchange_Uniform_UInt32_semantics.type.literal = true;
    AtomicCompareExchange_Uniform_UInt32.documentation = "Compares the value at the pointer location with the comparison, and exchanges it with value if they are identical using the specified memory semantics, always returns the old value"_c;
    AtomicCompareExchange_Uniform_UInt32.name = AtomicCompareExchange_Uniform_UInt32_name;
    AtomicCompareExchange_Uniform_UInt32.backendIndex = 2255;
    AtomicCompareExchange_Uniform_UInt32.returnType = Type::FullType { UInt32Type.name };
    AtomicCompareExchange_Uniform_UInt32.parameters = AtomicCompareExchange_Uniform_UInt32_args;
    Symbol::Resolved(&AtomicCompareExchange_Uniform_UInt32_ptr)->typeSymbol = &UInt32Type;
    Symbol::Resolved(&AtomicCompareExchange_Uniform_UInt32_ptr)->storage = Storage::Uniform;
    Symbol::Resolved(&AtomicCompareExchange_Uniform_UInt32_value)->typeSymbol = &UInt32Type;
    Symbol::Resolved(&AtomicCompareExchange_Uniform_UInt32_compare)->typeSymbol = &UInt32Type;
    Symbol::Resolved(&AtomicCompareExchange_Uniform_UInt32_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicCompareExchange_Uniform_UInt32)->signature = "atomicCompareExchange(uniform *mutable u32,u32,u32,literal MemorySemantics) u32"_c;
    Symbol::Resolved(&AtomicCompareExchange_Uniform_UInt32)->name = "atomicCompareExchange(uniform *mutable u32,u32,u32,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicCompareExchange_Uniform_UInt32)->nameWithVarNames = "atomicCompareExchange(ptr : uniform *mutable u32, value : u32, compare : u32, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicCompareExchange_Uniform_UInt32)->returnTypeSymbol = &UInt32Type;

    /// atomicCompareExchange with UInt32, UInt32, UInt32, MemorySemantics
    AtomicCompareExchange_Workgroup_UInt32_ptr.name = "ptr"_c;
    AtomicCompareExchange_Workgroup_UInt32_ptr.type = Type::FullType{ UInt32Type.name };
    AtomicCompareExchange_Workgroup_UInt32_ptr.type.strict = true;
    AtomicCompareExchange_Workgroup_UInt32_ptr.type.modifiers = AtomicCompareExchange_Workgroup_UInt32_ptr_modifiers;
    AtomicCompareExchange_Workgroup_UInt32_ptr.type.modifierValues = AtomicCompareExchange_Workgroup_UInt32_ptr_modifierValues;
    AtomicCompareExchange_Workgroup_UInt32_value.name = "value"_c;
    AtomicCompareExchange_Workgroup_UInt32_value.type = Type::FullType{ UInt32Type.name };
    AtomicCompareExchange_Workgroup_UInt32_compare.name = "compare"_c;
    AtomicCompareExchange_Workgroup_UInt32_compare.type = Type::FullType{ UInt32Type.name };
    AtomicCompareExchange_Workgroup_UInt32_semantics.name = "semantics"_c;
    AtomicCompareExchange_Workgroup_UInt32_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicCompareExchange_Workgroup_UInt32_semantics.type.literal = true;
    AtomicCompareExchange_Workgroup_UInt32.documentation = "Compares the value at the pointer location with the comparison, and exchanges it with value if they are identical using the specified memory semantics, always returns the old value"_c;
    AtomicCompareExchange_Workgroup_UInt32.name = AtomicCompareExchange_Workgroup_UInt32_name;
    AtomicCompareExchange_Workgroup_UInt32.backendIndex = 2256;
    AtomicCompareExchange_Workgroup_UInt32.returnType = Type::FullType { UInt32Type.name };
    AtomicCompareExchange_Workgroup_UInt32.parameters = AtomicCompareExchange_Workgroup_UInt32_args;
    Symbol::Resolved(&AtomicCompareExchange_Workgroup_UInt32_ptr)->typeSymbol = &UInt32Type;
    Symbol::Resolved(&AtomicCompareExchange_Workgroup_UInt32_ptr)->storage = Storage::Workgroup;
    Symbol::Resolved(&AtomicCompareExchange_Workgroup_UInt32_value)->typeSymbol = &UInt32Type;
    Symbol::Resolved(&AtomicCompareExchange_Workgroup_UInt32_compare)->typeSymbol = &UInt32Type;
    Symbol::Resolved(&AtomicCompareExchange_Workgroup_UInt32_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicCompareExchange_Workgroup_UInt32)->signature = "atomicCompareExchange(workgroup *u32,u32,u32,literal MemorySemantics) u32"_c;
    Symbol::Resolved(&AtomicCompareExchange_Workgroup_UInt32)->name = "atomicCompareExchange(workgroup *u32,u32,u32,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicCompareExchange_Workgroup_UInt32)->nameWithVarNames = "atomicCompareExchange(ptr : workgroup *u32, value : u32, compare : u32, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicCompareExchange_Workgroup_UInt32)->returnTypeSymbol = &UInt32Type;

    /// atomicCompareExchange with Int32, Int32, Int32, MemorySemantics
    AtomicCompareExchange_Uniform_Int32_ptr.name = "ptr"_c;
    AtomicCompareExchange_Uniform_Int32_ptr.type = Type::FullType{ Int32Type.name };
    AtomicCompareExchange_Uniform_Int32_ptr.type.strict = true;
    AtomicCompareExchange_Uniform_Int32_ptr.type.mut = true;
    AtomicCompareExchange_Uniform_Int32_ptr.type.modifiers = AtomicCompareExchange_Uniform_Int32_ptr_modifiers;
    AtomicCompareExchange_Uniform_Int32_ptr.type.modifierValues = AtomicCompareExchange_Uniform_Int32_ptr_modifierValues;
    AtomicCompareExchange_Uniform_Int32_value.name = "value"_c;
    AtomicCompareExchange_Uniform_Int32_value.type = Type::FullType{ Int32Type.name };
    AtomicCompareExchange_Uniform_Int32_compare.name = "compare"_c;
    AtomicCompareExchange_Uniform_Int32_compare.type = Type::FullType{ Int32Type.name };
    AtomicCompareExchange_Uniform_Int32_semantics.name = "semantics"_c;
    AtomicCompareExchange_Uniform_Int32_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicCompareExchange_Uniform_Int32_semantics.type.literal = true;
    AtomicCompareExchange_Uniform_Int32.documentation = "Compares the value at the pointer location with the comparison, and exchanges it with value if they are identical using the specified memory semantics, always returns the old value"_c;
    AtomicCompareExchange_Uniform_Int32.name = AtomicCompareExchange_Uniform_Int32_name;
    AtomicCompareExchange_Uniform_Int32.backendIndex = 2257;
    AtomicCompareExchange_Uniform_Int32.returnType = Type::FullType { Int32Type.name };
    AtomicCompareExchange_Uniform_Int32.parameters = AtomicCompareExchange_Uniform_Int32_args;
    Symbol::Resolved(&AtomicCompareExchange_Uniform_Int32_ptr)->typeSymbol = &Int32Type;
    Symbol::Resolved(&AtomicCompareExchange_Uniform_Int32_ptr)->storage = Storage::Uniform;
    Symbol::Resolved(&AtomicCompareExchange_Uniform_Int32_value)->typeSymbol = &Int32Type;
    Symbol::Resolved(&AtomicCompareExchange_Uniform_Int32_compare)->typeSymbol = &Int32Type;
    Symbol::Resolved(&AtomicCompareExchange_Uniform_Int32_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicCompareExchange_Uniform_Int32)->signature = "atomicCompareExchange(uniform *mutable i32,i32,i32,literal MemorySemantics) i32"_c;
    Symbol::Resolved(&AtomicCompareExchange_Uniform_Int32)->name = "atomicCompareExchange(uniform *mutable i32,i32,i32,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicCompareExchange_Uniform_Int32)->nameWithVarNames = "atomicCompareExchange(ptr : uniform *mutable i32, value : i32, compare : i32, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicCompareExchange_Uniform_Int32)->returnTypeSymbol = &Int32Type;

    /// atomicCompareExchange with Int32, Int32, Int32, MemorySemantics
    AtomicCompareExchange_Workgroup_Int32_ptr.name = "ptr"_c;
    AtomicCompareExchange_Workgroup_Int32_ptr.type = Type::FullType{ Int32Type.name };
    AtomicCompareExchange_Workgroup_Int32_ptr.type.strict = true;
    AtomicCompareExchange_Workgroup_Int32_ptr.type.modifiers = AtomicCompareExchange_Workgroup_Int32_ptr_modifiers;
    AtomicCompareExchange_Workgroup_Int32_ptr.type.modifierValues = AtomicCompareExchange_Workgroup_Int32_ptr_modifierValues;
    AtomicCompareExchange_Workgroup_Int32_value.name = "value"_c;
    AtomicCompareExchange_Workgroup_Int32_value.type = Type::FullType{ Int32Type.name };
    AtomicCompareExchange_Workgroup_Int32_compare.name = "compare"_c;
    AtomicCompareExchange_Workgroup_Int32_compare.type = Type::FullType{ Int32Type.name };
    AtomicCompareExchange_Workgroup_Int32_semantics.name = "semantics"_c;
    AtomicCompareExchange_Workgroup_Int32_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicCompareExchange_Workgroup_Int32_semantics.type.literal = true;
    AtomicCompareExchange_Workgroup_Int32.documentation = "Compares the value at the pointer location with the comparison, and exchanges it with value if they are identical using the specified memory semantics, always returns the old value"_c;
    AtomicCompareExchange_Workgroup_Int32.name = AtomicCompareExchange_Workgroup_Int32_name;
    AtomicCompareExchange_Workgroup_Int32.backendIndex = 2258;
    AtomicCompareExchange_Workgroup_Int32.returnType = Type::FullType { Int32Type.name };
    AtomicCompareExchange_Workgroup_Int32.parameters = AtomicCompareExchange_Workgroup_Int32_args;
    Symbol::Resolved(&AtomicCompareExchange_Workgroup_Int32_ptr)->typeSymbol = &Int32Type;
    Symbol::Resolved(&AtomicCompareExchange_Workgroup_Int32_ptr)->storage = Storage::Workgroup;
    Symbol::Resolved(&AtomicCompareExchange_Workgroup_Int32_value)->typeSymbol = &Int32Type;
    Symbol::Resolved(&AtomicCompareExchange_Workgroup_Int32_compare)->typeSymbol = &Int32Type;
    Symbol::Resolved(&AtomicCompareExchange_Workgroup_Int32_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicCompareExchange_Workgroup_Int32)->signature = "atomicCompareExchange(workgroup *i32,i32,i32,literal MemorySemantics) i32"_c;
    Symbol::Resolved(&AtomicCompareExchange_Workgroup_Int32)->name = "atomicCompareExchange(workgroup *i32,i32,i32,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicCompareExchange_Workgroup_Int32)->nameWithVarNames = "atomicCompareExchange(ptr : workgroup *i32, value : i32, compare : i32, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicCompareExchange_Workgroup_Int32)->returnTypeSymbol = &Int32Type;

    /// atomicCompareExchange with UInt16, UInt16, UInt16, MemorySemantics
    AtomicCompareExchange_Uniform_UInt16_ptr.name = "ptr"_c;
    AtomicCompareExchange_Uniform_UInt16_ptr.type = Type::FullType{ UInt16Type.name };
    AtomicCompareExchange_Uniform_UInt16_ptr.type.strict = true;
    AtomicCompareExchange_Uniform_UInt16_ptr.type.mut = true;
    AtomicCompareExchange_Uniform_UInt16_ptr.type.modifiers = AtomicCompareExchange_Uniform_UInt16_ptr_modifiers;
    AtomicCompareExchange_Uniform_UInt16_ptr.type.modifierValues = AtomicCompareExchange_Uniform_UInt16_ptr_modifierValues;
    AtomicCompareExchange_Uniform_UInt16_value.name = "value"_c;
    AtomicCompareExchange_Uniform_UInt16_value.type = Type::FullType{ UInt16Type.name };
    AtomicCompareExchange_Uniform_UInt16_compare.name = "compare"_c;
    AtomicCompareExchange_Uniform_UInt16_compare.type = Type::FullType{ UInt16Type.name };
    AtomicCompareExchange_Uniform_UInt16_semantics.name = "semantics"_c;
    AtomicCompareExchange_Uniform_UInt16_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicCompareExchange_Uniform_UInt16_semantics.type.literal = true;
    AtomicCompareExchange_Uniform_UInt16.documentation = "Compares the value at the pointer location with the comparison, and exchanges it with value if they are identical using the specified memory semantics, always returns the old value"_c;
    AtomicCompareExchange_Uniform_UInt16.name = AtomicCompareExchange_Uniform_UInt16_name;
    AtomicCompareExchange_Uniform_UInt16.backendIndex = 2259;
    AtomicCompareExchange_Uniform_UInt16.returnType = Type::FullType { UInt16Type.name };
    AtomicCompareExchange_Uniform_UInt16.parameters = AtomicCompareExchange_Uniform_UInt16_args;
    Symbol::Resolved(&AtomicCompareExchange_Uniform_UInt16_ptr)->typeSymbol = &UInt16Type;
    Symbol::Resolved(&AtomicCompareExchange_Uniform_UInt16_ptr)->storage = Storage::Uniform;
    Symbol::Resolved(&AtomicCompareExchange_Uniform_UInt16_value)->typeSymbol = &UInt16Type;
    Symbol::Resolved(&AtomicCompareExchange_Uniform_UInt16_compare)->typeSymbol = &UInt16Type;
    Symbol::Resolved(&AtomicCompareExchange_Uniform_UInt16_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicCompareExchange_Uniform_UInt16)->signature = "atomicCompareExchange(uniform *mutable u16,u16,u16,literal MemorySemantics) u16"_c;
    Symbol::Resolved(&AtomicCompareExchange_Uniform_UInt16)->name = "atomicCompareExchange(uniform *mutable u16,u16,u16,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicCompareExchange_Uniform_UInt16)->nameWithVarNames = "atomicCompareExchange(ptr : uniform *mutable u16, value : u16, compare : u16, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicCompareExchange_Uniform_UInt16)->returnTypeSymbol = &UInt16Type;

    /// atomicCompareExchange with UInt16, UInt16, UInt16, MemorySemantics
    AtomicCompareExchange_Workgroup_UInt16_ptr.name = "ptr"_c;
    AtomicCompareExchange_Workgroup_UInt16_ptr.type = Type::FullType{ UInt16Type.name };
    AtomicCompareExchange_Workgroup_UInt16_ptr.type.strict = true;
    AtomicCompareExchange_Workgroup_UInt16_ptr.type.modifiers = AtomicCompareExchange_Workgroup_UInt16_ptr_modifiers;
    AtomicCompareExchange_Workgroup_UInt16_ptr.type.modifierValues = AtomicCompareExchange_Workgroup_UInt16_ptr_modifierValues;
    AtomicCompareExchange_Workgroup_UInt16_value.name = "value"_c;
    AtomicCompareExchange_Workgroup_UInt16_value.type = Type::FullType{ UInt16Type.name };
    AtomicCompareExchange_Workgroup_UInt16_compare.name = "compare"_c;
    AtomicCompareExchange_Workgroup_UInt16_compare.type = Type::FullType{ UInt16Type.name };
    AtomicCompareExchange_Workgroup_UInt16_semantics.name = "semantics"_c;
    AtomicCompareExchange_Workgroup_UInt16_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicCompareExchange_Workgroup_UInt16_semantics.type.literal = true;
    AtomicCompareExchange_Workgroup_UInt16.documentation = "Compares the value at the pointer location with the comparison, and exchanges it with value if they are identical using the specified memory semantics, always returns the old value"_c;
    AtomicCompareExchange_Workgroup_UInt16.name = AtomicCompareExchange_Workgroup_UInt16_name;
    AtomicCompareExchange_Workgroup_UInt16.backendIndex = 2260;
    AtomicCompareExchange_Workgroup_UInt16.returnType = Type::FullType { UInt16Type.name };
    AtomicCompareExchange_Workgroup_UInt16.parameters = AtomicCompareExchange_Workgroup_UInt16_args;
    Symbol::Resolved(&AtomicCompareExchange_Workgroup_UInt16_ptr)->typeSymbol = &UInt16Type;
    Symbol::Resolved(&AtomicCompareExchange_Workgroup_UInt16_ptr)->storage = Storage::Workgroup;
    Symbol::Resolved(&AtomicCompareExchange_Workgroup_UInt16_value)->typeSymbol = &UInt16Type;
    Symbol::Resolved(&AtomicCompareExchange_Workgroup_UInt16_compare)->typeSymbol = &UInt16Type;
    Symbol::Resolved(&AtomicCompareExchange_Workgroup_UInt16_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicCompareExchange_Workgroup_UInt16)->signature = "atomicCompareExchange(workgroup *u16,u16,u16,literal MemorySemantics) u16"_c;
    Symbol::Resolved(&AtomicCompareExchange_Workgroup_UInt16)->name = "atomicCompareExchange(workgroup *u16,u16,u16,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicCompareExchange_Workgroup_UInt16)->nameWithVarNames = "atomicCompareExchange(ptr : workgroup *u16, value : u16, compare : u16, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicCompareExchange_Workgroup_UInt16)->returnTypeSymbol = &UInt16Type;

    /// atomicCompareExchange with Int16, Int16, Int16, MemorySemantics
    AtomicCompareExchange_Uniform_Int16_ptr.name = "ptr"_c;
    AtomicCompareExchange_Uniform_Int16_ptr.type = Type::FullType{ Int16Type.name };
    AtomicCompareExchange_Uniform_Int16_ptr.type.strict = true;
    AtomicCompareExchange_Uniform_Int16_ptr.type.mut = true;
    AtomicCompareExchange_Uniform_Int16_ptr.type.modifiers = AtomicCompareExchange_Uniform_Int16_ptr_modifiers;
    AtomicCompareExchange_Uniform_Int16_ptr.type.modifierValues = AtomicCompareExchange_Uniform_Int16_ptr_modifierValues;
    AtomicCompareExchange_Uniform_Int16_value.name = "value"_c;
    AtomicCompareExchange_Uniform_Int16_value.type = Type::FullType{ Int16Type.name };
    AtomicCompareExchange_Uniform_Int16_compare.name = "compare"_c;
    AtomicCompareExchange_Uniform_Int16_compare.type = Type::FullType{ Int16Type.name };
    AtomicCompareExchange_Uniform_Int16_semantics.name = "semantics"_c;
    AtomicCompareExchange_Uniform_Int16_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicCompareExchange_Uniform_Int16_semantics.type.literal = true;
    AtomicCompareExchange_Uniform_Int16.documentation = "Compares the value at the pointer location with the comparison, and exchanges it with value if they are identical using the specified memory semantics, always returns the old value"_c;
    AtomicCompareExchange_Uniform_Int16.name = AtomicCompareExchange_Uniform_Int16_name;
    AtomicCompareExchange_Uniform_Int16.backendIndex = 2261;
    AtomicCompareExchange_Uniform_Int16.returnType = Type::FullType { Int16Type.name };
    AtomicCompareExchange_Uniform_Int16.parameters = AtomicCompareExchange_Uniform_Int16_args;
    Symbol::Resolved(&AtomicCompareExchange_Uniform_Int16_ptr)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicCompareExchange_Uniform_Int16_ptr)->storage = Storage::Uniform;
    Symbol::Resolved(&AtomicCompareExchange_Uniform_Int16_value)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicCompareExchange_Uniform_Int16_compare)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicCompareExchange_Uniform_Int16_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicCompareExchange_Uniform_Int16)->signature = "atomicCompareExchange(uniform *mutable i16,i16,i16,literal MemorySemantics) i16"_c;
    Symbol::Resolved(&AtomicCompareExchange_Uniform_Int16)->name = "atomicCompareExchange(uniform *mutable i16,i16,i16,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicCompareExchange_Uniform_Int16)->nameWithVarNames = "atomicCompareExchange(ptr : uniform *mutable i16, value : i16, compare : i16, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicCompareExchange_Uniform_Int16)->returnTypeSymbol = &Int16Type;

    /// atomicCompareExchange with Int16, Int16, Int16, MemorySemantics
    AtomicCompareExchange_Workgroup_Int16_ptr.name = "ptr"_c;
    AtomicCompareExchange_Workgroup_Int16_ptr.type = Type::FullType{ Int16Type.name };
    AtomicCompareExchange_Workgroup_Int16_ptr.type.strict = true;
    AtomicCompareExchange_Workgroup_Int16_ptr.type.modifiers = AtomicCompareExchange_Workgroup_Int16_ptr_modifiers;
    AtomicCompareExchange_Workgroup_Int16_ptr.type.modifierValues = AtomicCompareExchange_Workgroup_Int16_ptr_modifierValues;
    AtomicCompareExchange_Workgroup_Int16_value.name = "value"_c;
    AtomicCompareExchange_Workgroup_Int16_value.type = Type::FullType{ Int16Type.name };
    AtomicCompareExchange_Workgroup_Int16_compare.name = "compare"_c;
    AtomicCompareExchange_Workgroup_Int16_compare.type = Type::FullType{ Int16Type.name };
    AtomicCompareExchange_Workgroup_Int16_semantics.name = "semantics"_c;
    AtomicCompareExchange_Workgroup_Int16_semantics.type = Type::FullType{ MemorySemanticsType.name };
    AtomicCompareExchange_Workgroup_Int16_semantics.type.literal = true;
    AtomicCompareExchange_Workgroup_Int16.documentation = "Compares the value at the pointer location with the comparison, and exchanges it with value if they are identical using the specified memory semantics, always returns the old value"_c;
    AtomicCompareExchange_Workgroup_Int16.name = AtomicCompareExchange_Workgroup_Int16_name;
    AtomicCompareExchange_Workgroup_Int16.backendIndex = 2262;
    AtomicCompareExchange_Workgroup_Int16.returnType = Type::FullType { Int16Type.name };
    AtomicCompareExchange_Workgroup_Int16.parameters = AtomicCompareExchange_Workgroup_Int16_args;
    Symbol::Resolved(&AtomicCompareExchange_Workgroup_Int16_ptr)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicCompareExchange_Workgroup_Int16_ptr)->storage = Storage::Workgroup;
    Symbol::Resolved(&AtomicCompareExchange_Workgroup_Int16_value)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicCompareExchange_Workgroup_Int16_compare)->typeSymbol = &Int16Type;
    Symbol::Resolved(&AtomicCompareExchange_Workgroup_Int16_semantics)->typeSymbol = &MemorySemanticsType;
    Symbol::Resolved(&AtomicCompareExchange_Workgroup_Int16)->signature = "atomicCompareExchange(workgroup *i16,i16,i16,literal MemorySemantics) i16"_c;
    Symbol::Resolved(&AtomicCompareExchange_Workgroup_Int16)->name = "atomicCompareExchange(workgroup *i16,i16,i16,literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicCompareExchange_Workgroup_Int16)->nameWithVarNames = "atomicCompareExchange(ptr : workgroup *i16, value : i16, compare : i16, semantics : literal MemorySemantics)"_c;
    Symbol::Resolved(&AtomicCompareExchange_Workgroup_Int16)->returnTypeSymbol = &Int16Type;

    /// bitInsert with UInt16, UInt16, UInt16, UInt16
    BitInsert_UInt16_base.name = "base"_c;
    BitInsert_UInt16_base.type = Type::FullType{ UInt16Type.name };
    BitInsert_UInt16_value.name = "value"_c;
    BitInsert_UInt16_value.type = Type::FullType{ UInt16Type.name };
    BitInsert_UInt16_offset.name = "offset"_c;
    BitInsert_UInt16_offset.type = Type::FullType{ UInt16Type.name };
    BitInsert_UInt16_count.name = "count"_c;
    BitInsert_UInt16_count.type = Type::FullType{ UInt16Type.name };
    BitInsert_UInt16.documentation = "Insert bit into bitmask"_c;
    BitInsert_UInt16.name = BitInsert_UInt16_name;
    BitInsert_UInt16.backendIndex = 2263;
    BitInsert_UInt16.returnType = Type::FullType { UInt16Type.name };
    BitInsert_UInt16.parameters = BitInsert_UInt16_args;
    Symbol::Resolved(&BitInsert_UInt16_base)->typeSymbol = &UInt16Type;
    Symbol::Resolved(&BitInsert_UInt16_value)->typeSymbol = &UInt16Type;
    Symbol::Resolved(&BitInsert_UInt16_offset)->typeSymbol = &UInt16Type;
    Symbol::Resolved(&BitInsert_UInt16_count)->typeSymbol = &UInt16Type;
    Symbol::Resolved(&BitInsert_UInt16)->signature = "bitInsert(u16,u16,u16,u16) u16"_c;
    Symbol::Resolved(&BitInsert_UInt16)->name = "bitInsert(u16,u16,u16,u16)"_c;
    Symbol::Resolved(&BitInsert_UInt16)->nameWithVarNames = "bitInsert(base : u16, value : u16, offset : u16, count : u16)"_c;
    Symbol::Resolved(&BitInsert_UInt16)->returnTypeSymbol = &UInt16Type;

    /// bitInsert with UInt32, UInt32, UInt32, UInt32
    BitInsert_UInt32_base.name = "base"_c;
    BitInsert_UInt32_base.type = Type::FullType{ UInt32Type.name };
    BitInsert_UInt32_value.name = "value"_c;
    BitInsert_UInt32_value.type = Type::FullType{ UInt32Type.name };
    BitInsert_UInt32_offset.name = "offset"_c;
    BitInsert_UInt32_offset.type = Type::FullType{ UInt32Type.name };
    BitInsert_UInt32_count.name = "count"_c;
    BitInsert_UInt32_count.type = Type::FullType{ UInt32Type.name };
    BitInsert_UInt32.documentation = "Insert bit into bitmask"_c;
    BitInsert_UInt32.name = BitInsert_UInt32_name;
    BitInsert_UInt32.backendIndex = 2264;
    BitInsert_UInt32.returnType = Type::FullType { UInt32Type.name };
    BitInsert_UInt32.parameters = BitInsert_UInt32_args;
    Symbol::Resolved(&BitInsert_UInt32_base)->typeSymbol = &UInt32Type;
    Symbol::Resolved(&BitInsert_UInt32_value)->typeSymbol = &UInt32Type;
    Symbol::Resolved(&BitInsert_UInt32_offset)->typeSymbol = &UInt32Type;
    Symbol::Resolved(&BitInsert_UInt32_count)->typeSymbol = &UInt32Type;
    Symbol::Resolved(&BitInsert_UInt32)->signature = "bitInsert(u32,u32,u32,u32) u32"_c;
    Symbol::Resolved(&BitInsert_UInt32)->name = "bitInsert(u32,u32,u32,u32)"_c;
    Symbol::Resolved(&BitInsert_UInt32)->nameWithVarNames = "bitInsert(base : u32, value : u32, offset : u32, count : u32)"_c;
    Symbol::Resolved(&BitInsert_UInt32)->returnTypeSymbol = &UInt32Type;

    /// bitExtract with UInt32, UInt32, UInt32
    BitExtract_UInt32_base.name = "base"_c;
    BitExtract_UInt32_base.type = Type::FullType{ UInt32Type.name };
    BitExtract_UInt32_offset.name = "offset"_c;
    BitExtract_UInt32_offset.type = Type::FullType{ UInt32Type.name };
    BitExtract_UInt32_count.name = "count"_c;
    BitExtract_UInt32_count.type = Type::FullType{ UInt32Type.name };
    BitExtract_UInt32.documentation = "Extract a specific bit from a bitmask"_c;
    BitExtract_UInt32.name = BitExtract_UInt32_name;
    BitExtract_UInt32.backendIndex = 2265;
    BitExtract_UInt32.returnType = Type::FullType { UInt32Type.name };
    BitExtract_UInt32.parameters = BitExtract_UInt32_args;
    Symbol::Resolved(&BitExtract_UInt32_base)->typeSymbol = &UInt32Type;
    Symbol::Resolved(&BitExtract_UInt32_offset)->typeSymbol = &UInt32Type;
    Symbol::Resolved(&BitExtract_UInt32_count)->typeSymbol = &UInt32Type;
    Symbol::Resolved(&BitExtract_UInt32)->signature = "bitExtract(u32,u32,u32) u32"_c;
    Symbol::Resolved(&BitExtract_UInt32)->name = "bitExtract(u32,u32,u32)"_c;
    Symbol::Resolved(&BitExtract_UInt32)->nameWithVarNames = "bitExtract(base : u32, offset : u32, count : u32)"_c;
    Symbol::Resolved(&BitExtract_UInt32)->returnTypeSymbol = &UInt32Type;

    /// bitExtract with Int32, Int32, Int32
    BitExtract_Int32_base.name = "base"_c;
    BitExtract_Int32_base.type = Type::FullType{ Int32Type.name };
    BitExtract_Int32_offset.name = "offset"_c;
    BitExtract_Int32_offset.type = Type::FullType{ Int32Type.name };
    BitExtract_Int32_count.name = "count"_c;
    BitExtract_Int32_count.type = Type::FullType{ Int32Type.name };
    BitExtract_Int32.documentation = "Extract a specific bit from a bitmask"_c;
    BitExtract_Int32.name = BitExtract_Int32_name;
    BitExtract_Int32.backendIndex = 2266;
    BitExtract_Int32.returnType = Type::FullType { Int32Type.name };
    BitExtract_Int32.parameters = BitExtract_Int32_args;
    Symbol::Resolved(&BitExtract_Int32_base)->typeSymbol = &Int32Type;
    Symbol::Resolved(&BitExtract_Int32_offset)->typeSymbol = &Int32Type;
    Symbol::Resolved(&BitExtract_Int32_count)->typeSymbol = &Int32Type;
    Symbol::Resolved(&BitExtract_Int32)->signature = "bitExtract(i32,i32,i32) i32"_c;
    Symbol::Resolved(&BitExtract_Int32)->name = "bitExtract(i32,i32,i32)"_c;
    Symbol::Resolved(&BitExtract_Int32)->nameWithVarNames = "bitExtract(base : i32, offset : i32, count : i32)"_c;
    Symbol::Resolved(&BitExtract_Int32)->returnTypeSymbol = &Int32Type;

    /// bitExtract with UInt16, UInt16, UInt16
    BitExtract_UInt16_base.name = "base"_c;
    BitExtract_UInt16_base.type = Type::FullType{ UInt16Type.name };
    BitExtract_UInt16_offset.name = "offset"_c;
    BitExtract_UInt16_offset.type = Type::FullType{ UInt16Type.name };
    BitExtract_UInt16_count.name = "count"_c;
    BitExtract_UInt16_count.type = Type::FullType{ UInt16Type.name };
    BitExtract_UInt16.documentation = "Extract a specific bit from a bitmask"_c;
    BitExtract_UInt16.name = BitExtract_UInt16_name;
    BitExtract_UInt16.backendIndex = 2267;
    BitExtract_UInt16.returnType = Type::FullType { UInt16Type.name };
    BitExtract_UInt16.parameters = BitExtract_UInt16_args;
    Symbol::Resolved(&BitExtract_UInt16_base)->typeSymbol = &UInt16Type;
    Symbol::Resolved(&BitExtract_UInt16_offset)->typeSymbol = &UInt16Type;
    Symbol::Resolved(&BitExtract_UInt16_count)->typeSymbol = &UInt16Type;
    Symbol::Resolved(&BitExtract_UInt16)->signature = "bitExtract(u16,u16,u16) u16"_c;
    Symbol::Resolved(&BitExtract_UInt16)->name = "bitExtract(u16,u16,u16)"_c;
    Symbol::Resolved(&BitExtract_UInt16)->nameWithVarNames = "bitExtract(base : u16, offset : u16, count : u16)"_c;
    Symbol::Resolved(&BitExtract_UInt16)->returnTypeSymbol = &UInt16Type;

    /// bitExtract with Int16, Int16, Int16
    BitExtract_Int16_base.name = "base"_c;
    BitExtract_Int16_base.type = Type::FullType{ Int16Type.name };
    BitExtract_Int16_offset.name = "offset"_c;
    BitExtract_Int16_offset.type = Type::FullType{ Int16Type.name };
    BitExtract_Int16_count.name = "count"_c;
    BitExtract_Int16_count.type = Type::FullType{ Int16Type.name };
    BitExtract_Int16.documentation = "Extract a specific bit from a bitmask"_c;
    BitExtract_Int16.name = BitExtract_Int16_name;
    BitExtract_Int16.backendIndex = 2268;
    BitExtract_Int16.returnType = Type::FullType { Int16Type.name };
    BitExtract_Int16.parameters = BitExtract_Int16_args;
    Symbol::Resolved(&BitExtract_Int16_base)->typeSymbol = &Int16Type;
    Symbol::Resolved(&BitExtract_Int16_offset)->typeSymbol = &Int16Type;
    Symbol::Resolved(&BitExtract_Int16_count)->typeSymbol = &Int16Type;
    Symbol::Resolved(&BitExtract_Int16)->signature = "bitExtract(i16,i16,i16) i16"_c;
    Symbol::Resolved(&BitExtract_Int16)->name = "bitExtract(i16,i16,i16)"_c;
    Symbol::Resolved(&BitExtract_Int16)->nameWithVarNames = "bitExtract(base : i16, offset : i16, count : i16)"_c;
    Symbol::Resolved(&BitExtract_Int16)->returnTypeSymbol = &Int16Type;

    /// bitReverse with UInt32
    BitReverse_UInt32_base.name = "base"_c;
    BitReverse_UInt32_base.type = Type::FullType{ UInt32Type.name };
    BitReverse_UInt32.documentation = "Reverses the bits in a bitmask"_c;
    BitReverse_UInt32.name = BitReverse_UInt32_name;
    BitReverse_UInt32.backendIndex = 2269;
    BitReverse_UInt32.returnType = Type::FullType { UInt32Type.name };
    BitReverse_UInt32.parameters = BitReverse_UInt32_args;
    Symbol::Resolved(&BitReverse_UInt32_base)->typeSymbol = &UInt32Type;
    Symbol::Resolved(&BitReverse_UInt32)->signature = "bitReverse(u32) u32"_c;
    Symbol::Resolved(&BitReverse_UInt32)->name = "bitReverse(u32)"_c;
    Symbol::Resolved(&BitReverse_UInt32)->nameWithVarNames = "bitReverse(base : u32)"_c;
    Symbol::Resolved(&BitReverse_UInt32)->returnTypeSymbol = &UInt32Type;

    /// bitReverse with Int32
    BitReverse_Int32_base.name = "base"_c;
    BitReverse_Int32_base.type = Type::FullType{ Int32Type.name };
    BitReverse_Int32.documentation = "Reverses the bits in a bitmask"_c;
    BitReverse_Int32.name = BitReverse_Int32_name;
    BitReverse_Int32.backendIndex = 2270;
    BitReverse_Int32.returnType = Type::FullType { Int32Type.name };
    BitReverse_Int32.parameters = BitReverse_Int32_args;
    Symbol::Resolved(&BitReverse_Int32_base)->typeSymbol = &Int32Type;
    Symbol::Resolved(&BitReverse_Int32)->signature = "bitReverse(i32) i32"_c;
    Symbol::Resolved(&BitReverse_Int32)->name = "bitReverse(i32)"_c;
    Symbol::Resolved(&BitReverse_Int32)->nameWithVarNames = "bitReverse(base : i32)"_c;
    Symbol::Resolved(&BitReverse_Int32)->returnTypeSymbol = &Int32Type;

    /// bitReverse with UInt16
    BitReverse_UInt16_base.name = "base"_c;
    BitReverse_UInt16_base.type = Type::FullType{ UInt16Type.name };
    BitReverse_UInt16.documentation = "Reverses the bits in a bitmask"_c;
    BitReverse_UInt16.name = BitReverse_UInt16_name;
    BitReverse_UInt16.backendIndex = 2271;
    BitReverse_UInt16.returnType = Type::FullType { UInt16Type.name };
    BitReverse_UInt16.parameters = BitReverse_UInt16_args;
    Symbol::Resolved(&BitReverse_UInt16_base)->typeSymbol = &UInt16Type;
    Symbol::Resolved(&BitReverse_UInt16)->signature = "bitReverse(u16) u16"_c;
    Symbol::Resolved(&BitReverse_UInt16)->name = "bitReverse(u16)"_c;
    Symbol::Resolved(&BitReverse_UInt16)->nameWithVarNames = "bitReverse(base : u16)"_c;
    Symbol::Resolved(&BitReverse_UInt16)->returnTypeSymbol = &UInt16Type;

    /// bitReverse with Int16
    BitReverse_Int16_base.name = "base"_c;
    BitReverse_Int16_base.type = Type::FullType{ Int16Type.name };
    BitReverse_Int16.documentation = "Reverses the bits in a bitmask"_c;
    BitReverse_Int16.name = BitReverse_Int16_name;
    BitReverse_Int16.backendIndex = 2272;
    BitReverse_Int16.returnType = Type::FullType { Int16Type.name };
    BitReverse_Int16.parameters = BitReverse_Int16_args;
    Symbol::Resolved(&BitReverse_Int16_base)->typeSymbol = &Int16Type;
    Symbol::Resolved(&BitReverse_Int16)->signature = "bitReverse(i16) i16"_c;
    Symbol::Resolved(&BitReverse_Int16)->name = "bitReverse(i16)"_c;
    Symbol::Resolved(&BitReverse_Int16)->nameWithVarNames = "bitReverse(base : i16)"_c;
    Symbol::Resolved(&BitReverse_Int16)->returnTypeSymbol = &Int16Type;

    /// bitCount with UInt32
    BitCount_UInt32_base.name = "base"_c;
    BitCount_UInt32_base.type = Type::FullType{ UInt32Type.name };
    BitCount_UInt32.documentation = "Counts the number of bits set to 1 in a bitmask"_c;
    BitCount_UInt32.name = BitCount_UInt32_name;
    BitCount_UInt32.backendIndex = 2273;
    BitCount_UInt32.returnType = Type::FullType { UInt32Type.name };
    BitCount_UInt32.parameters = BitCount_UInt32_args;
    Symbol::Resolved(&BitCount_UInt32_base)->typeSymbol = &UInt32Type;
    Symbol::Resolved(&BitCount_UInt32)->signature = "bitCount(u32) u32"_c;
    Symbol::Resolved(&BitCount_UInt32)->name = "bitCount(u32)"_c;
    Symbol::Resolved(&BitCount_UInt32)->nameWithVarNames = "bitCount(base : u32)"_c;
    Symbol::Resolved(&BitCount_UInt32)->returnTypeSymbol = &UInt32Type;

    /// bitCount with Int32
    BitCount_Int32_base.name = "base"_c;
    BitCount_Int32_base.type = Type::FullType{ Int32Type.name };
    BitCount_Int32.documentation = "Counts the number of bits set to 1 in a bitmask"_c;
    BitCount_Int32.name = BitCount_Int32_name;
    BitCount_Int32.backendIndex = 2274;
    BitCount_Int32.returnType = Type::FullType { Int32Type.name };
    BitCount_Int32.parameters = BitCount_Int32_args;
    Symbol::Resolved(&BitCount_Int32_base)->typeSymbol = &Int32Type;
    Symbol::Resolved(&BitCount_Int32)->signature = "bitCount(i32) i32"_c;
    Symbol::Resolved(&BitCount_Int32)->name = "bitCount(i32)"_c;
    Symbol::Resolved(&BitCount_Int32)->nameWithVarNames = "bitCount(base : i32)"_c;
    Symbol::Resolved(&BitCount_Int32)->returnTypeSymbol = &Int32Type;

    /// bitCount with UInt16
    BitCount_UInt16_base.name = "base"_c;
    BitCount_UInt16_base.type = Type::FullType{ UInt16Type.name };
    BitCount_UInt16.documentation = "Counts the number of bits set to 1 in a bitmask"_c;
    BitCount_UInt16.name = BitCount_UInt16_name;
    BitCount_UInt16.backendIndex = 2275;
    BitCount_UInt16.returnType = Type::FullType { UInt16Type.name };
    BitCount_UInt16.parameters = BitCount_UInt16_args;
    Symbol::Resolved(&BitCount_UInt16_base)->typeSymbol = &UInt16Type;
    Symbol::Resolved(&BitCount_UInt16)->signature = "bitCount(u16) u16"_c;
    Symbol::Resolved(&BitCount_UInt16)->name = "bitCount(u16)"_c;
    Symbol::Resolved(&BitCount_UInt16)->nameWithVarNames = "bitCount(base : u16)"_c;
    Symbol::Resolved(&BitCount_UInt16)->returnTypeSymbol = &UInt16Type;

    /// bitCount with Int16
    BitCount_Int16_base.name = "base"_c;
    BitCount_Int16_base.type = Type::FullType{ Int16Type.name };
    BitCount_Int16.documentation = "Counts the number of bits set to 1 in a bitmask"_c;
    BitCount_Int16.name = BitCount_Int16_name;
    BitCount_Int16.backendIndex = 2276;
    BitCount_Int16.returnType = Type::FullType { Int16Type.name };
    BitCount_Int16.parameters = BitCount_Int16_args;
    Symbol::Resolved(&BitCount_Int16_base)->typeSymbol = &Int16Type;
    Symbol::Resolved(&BitCount_Int16)->signature = "bitCount(i16) i16"_c;
    Symbol::Resolved(&BitCount_Int16)->name = "bitCount(i16)"_c;
    Symbol::Resolved(&BitCount_Int16)->nameWithVarNames = "bitCount(base : i16)"_c;
    Symbol::Resolved(&BitCount_Int16)->returnTypeSymbol = &Int16Type;

    /// executionBarrier
    ExecutionBarrier.documentation = "Execution barrier to ensure all threads have reached this point before proceeding"_c;
    ExecutionBarrier.name = ExecutionBarrier_name;
    ExecutionBarrier.backendIndex = 2277;
    ExecutionBarrier.returnType = Type::FullType { VoidType.name };
    Symbol::Resolved(&ExecutionBarrier)->signature = "executionBarrier() void"_c;
    Symbol::Resolved(&ExecutionBarrier)->name = "executionBarrier()"_c;
    Symbol::Resolved(&ExecutionBarrier)->nameWithVarNames = "executionBarrier()"_c;
    Symbol::Resolved(&ExecutionBarrier)->returnTypeSymbol = &VoidType;

    /// executionBarrierSubgroup
    ExecutionBarrierSubgroup.documentation = "Execution barrier to ensure all threads in the subgroup have reached this point before proceeding"_c;
    ExecutionBarrierSubgroup.name = ExecutionBarrierSubgroup_name;
    ExecutionBarrierSubgroup.backendIndex = 2278;
    ExecutionBarrierSubgroup.returnType = Type::FullType { VoidType.name };
    Symbol::Resolved(&ExecutionBarrierSubgroup)->signature = "executionBarrierSubgroup() void"_c;
    Symbol::Resolved(&ExecutionBarrierSubgroup)->name = "executionBarrierSubgroup()"_c;
    Symbol::Resolved(&ExecutionBarrierSubgroup)->nameWithVarNames = "executionBarrierSubgroup()"_c;
    Symbol::Resolved(&ExecutionBarrierSubgroup)->returnTypeSymbol = &VoidType;

    /// executionBarrierWorkgroup
    ExecutionBarrierWorkgroup.documentation = "Execution barrier to ensure all threads in the workgroup have reached this point before proceeding"_c;
    ExecutionBarrierWorkgroup.name = ExecutionBarrierWorkgroup_name;
    ExecutionBarrierWorkgroup.backendIndex = 2279;
    ExecutionBarrierWorkgroup.returnType = Type::FullType { VoidType.name };
    Symbol::Resolved(&ExecutionBarrierWorkgroup)->signature = "executionBarrierWorkgroup() void"_c;
    Symbol::Resolved(&ExecutionBarrierWorkgroup)->name = "executionBarrierWorkgroup()"_c;
    Symbol::Resolved(&ExecutionBarrierWorkgroup)->nameWithVarNames = "executionBarrierWorkgroup()"_c;
    Symbol::Resolved(&ExecutionBarrierWorkgroup)->returnTypeSymbol = &VoidType;

    /// memoryBarrier
    MemoryBarrier.documentation = "Memory barrier to ensure memory operations are completed before proceeding"_c;
    MemoryBarrier.name = MemoryBarrier_name;
    MemoryBarrier.backendIndex = 2280;
    MemoryBarrier.returnType = Type::FullType { VoidType.name };
    Symbol::Resolved(&MemoryBarrier)->signature = "memoryBarrier() void"_c;
    Symbol::Resolved(&MemoryBarrier)->name = "memoryBarrier()"_c;
    Symbol::Resolved(&MemoryBarrier)->nameWithVarNames = "memoryBarrier()"_c;
    Symbol::Resolved(&MemoryBarrier)->returnTypeSymbol = &VoidType;

    /// memoryBarrierBuffer
    MemoryBarrierBuffer.documentation = "Memory barrier to ensure buffer memory operations are completed before proceeding"_c;
    MemoryBarrierBuffer.name = MemoryBarrierBuffer_name;
    MemoryBarrierBuffer.backendIndex = 2281;
    MemoryBarrierBuffer.returnType = Type::FullType { VoidType.name };
    Symbol::Resolved(&MemoryBarrierBuffer)->signature = "memoryBarrierBuffer() void"_c;
    Symbol::Resolved(&MemoryBarrierBuffer)->name = "memoryBarrierBuffer()"_c;
    Symbol::Resolved(&MemoryBarrierBuffer)->nameWithVarNames = "memoryBarrierBuffer()"_c;
    Symbol::Resolved(&MemoryBarrierBuffer)->returnTypeSymbol = &VoidType;

    /// memoryBarrierTexture
    MemoryBarrierTexture.documentation = "Memory barrier to ensure texture memory operations are completed before proceeding"_c;
    MemoryBarrierTexture.name = MemoryBarrierTexture_name;
    MemoryBarrierTexture.backendIndex = 2282;
    MemoryBarrierTexture.returnType = Type::FullType { VoidType.name };
    Symbol::Resolved(&MemoryBarrierTexture)->signature = "memoryBarrierTexture() void"_c;
    Symbol::Resolved(&MemoryBarrierTexture)->name = "memoryBarrierTexture()"_c;
    Symbol::Resolved(&MemoryBarrierTexture)->nameWithVarNames = "memoryBarrierTexture()"_c;
    Symbol::Resolved(&MemoryBarrierTexture)->returnTypeSymbol = &VoidType;

    /// memoryBarrierAtomic
    MemoryBarrierAtomic.documentation = "Memory barrier to ensure atomic memory operations are completed before proceeding"_c;
    MemoryBarrierAtomic.name = MemoryBarrierAtomic_name;
    MemoryBarrierAtomic.backendIndex = 2283;
    MemoryBarrierAtomic.returnType = Type::FullType { VoidType.name };
    Symbol::Resolved(&MemoryBarrierAtomic)->signature = "memoryBarrierAtomic() void"_c;
    Symbol::Resolved(&MemoryBarrierAtomic)->name = "memoryBarrierAtomic()"_c;
    Symbol::Resolved(&MemoryBarrierAtomic)->nameWithVarNames = "memoryBarrierAtomic()"_c;
    Symbol::Resolved(&MemoryBarrierAtomic)->returnTypeSymbol = &VoidType;

    /// memoryBarrierSubgroup
    MemoryBarrierSubgroup.documentation = "Memory barrier to ensure subgroup memory operations are completed before proceeding"_c;
    MemoryBarrierSubgroup.name = MemoryBarrierSubgroup_name;
    MemoryBarrierSubgroup.backendIndex = 2284;
    MemoryBarrierSubgroup.returnType = Type::FullType { VoidType.name };
    Symbol::Resolved(&MemoryBarrierSubgroup)->signature = "memoryBarrierSubgroup() void"_c;
    Symbol::Resolved(&MemoryBarrierSubgroup)->name = "memoryBarrierSubgroup()"_c;
    Symbol::Resolved(&MemoryBarrierSubgroup)->nameWithVarNames = "memoryBarrierSubgroup()"_c;
    Symbol::Resolved(&MemoryBarrierSubgroup)->returnTypeSymbol = &VoidType;

    /// memoryBarrierWorkgroup
    MemoryBarrierWorkgroup.documentation = "Memory barrier to ensure workgroup memory operations are completed before proceeding"_c;
    MemoryBarrierWorkgroup.name = MemoryBarrierWorkgroup_name;
    MemoryBarrierWorkgroup.backendIndex = 2285;
    MemoryBarrierWorkgroup.returnType = Type::FullType { VoidType.name };
    Symbol::Resolved(&MemoryBarrierWorkgroup)->signature = "memoryBarrierWorkgroup() void"_c;
    Symbol::Resolved(&MemoryBarrierWorkgroup)->name = "memoryBarrierWorkgroup()"_c;
    Symbol::Resolved(&MemoryBarrierWorkgroup)->nameWithVarNames = "memoryBarrierWorkgroup()"_c;
    Symbol::Resolved(&MemoryBarrierWorkgroup)->returnTypeSymbol = &VoidType;

    /// textureGetSize with Texture1D
    TextureGetSize_Texture1D_texture.name = "texture"_c;
    TextureGetSize_Texture1D_texture.type = Type::FullType{ Texture1DType.name };
    TextureGetSize_Texture1D_texture.type.strict = true;
    TextureGetSize_Texture1D_texture.type.mut = true;
    TextureGetSize_Texture1D_texture.type.modifiers = TextureGetSize_Texture1D_texture_modifiers;
    TextureGetSize_Texture1D_texture.type.modifierValues = TextureGetSize_Texture1D_texture_modifierValues;
    TextureGetSize_Texture1D.documentation = "Get the size of a texture"_c;
    TextureGetSize_Texture1D.name = TextureGetSize_Texture1D_name;
    TextureGetSize_Texture1D.backendIndex = 2286;
    TextureGetSize_Texture1D.returnType = Type::FullType { UInt32Type.name };
    TextureGetSize_Texture1D.parameters = TextureGetSize_Texture1D_args;
    Symbol::Resolved(&TextureGetSize_Texture1D_texture)->typeSymbol = &Texture1DType;
    Symbol::Resolved(&TextureGetSize_Texture1D_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureGetSize_Texture1D)->signature = "textureGetSize(uniform *mutable texture1D) u32"_c;
    Symbol::Resolved(&TextureGetSize_Texture1D)->name = "textureGetSize(uniform *mutable texture1D)"_c;
    Symbol::Resolved(&TextureGetSize_Texture1D)->nameWithVarNames = "textureGetSize(texture : uniform *mutable texture1D)"_c;
    Symbol::Resolved(&TextureGetSize_Texture1D)->returnTypeSymbol = &UInt32Type;

    /// textureGetSize with Texture2D
    TextureGetSize_Texture2D_texture.name = "texture"_c;
    TextureGetSize_Texture2D_texture.type = Type::FullType{ Texture2DType.name };
    TextureGetSize_Texture2D_texture.type.strict = true;
    TextureGetSize_Texture2D_texture.type.mut = true;
    TextureGetSize_Texture2D_texture.type.modifiers = TextureGetSize_Texture2D_texture_modifiers;
    TextureGetSize_Texture2D_texture.type.modifierValues = TextureGetSize_Texture2D_texture_modifierValues;
    TextureGetSize_Texture2D.documentation = "Get the size of a texture"_c;
    TextureGetSize_Texture2D.name = TextureGetSize_Texture2D_name;
    TextureGetSize_Texture2D.backendIndex = 2287;
    TextureGetSize_Texture2D.returnType = Type::FullType { UInt32x2Type.name };
    TextureGetSize_Texture2D.parameters = TextureGetSize_Texture2D_args;
    Symbol::Resolved(&TextureGetSize_Texture2D_texture)->typeSymbol = &Texture2DType;
    Symbol::Resolved(&TextureGetSize_Texture2D_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureGetSize_Texture2D)->signature = "textureGetSize(uniform *mutable texture2D) u32x2"_c;
    Symbol::Resolved(&TextureGetSize_Texture2D)->name = "textureGetSize(uniform *mutable texture2D)"_c;
    Symbol::Resolved(&TextureGetSize_Texture2D)->nameWithVarNames = "textureGetSize(texture : uniform *mutable texture2D)"_c;
    Symbol::Resolved(&TextureGetSize_Texture2D)->returnTypeSymbol = &UInt32x2Type;

    /// textureGetSize with Texture3D
    TextureGetSize_Texture3D_texture.name = "texture"_c;
    TextureGetSize_Texture3D_texture.type = Type::FullType{ Texture3DType.name };
    TextureGetSize_Texture3D_texture.type.strict = true;
    TextureGetSize_Texture3D_texture.type.mut = true;
    TextureGetSize_Texture3D_texture.type.modifiers = TextureGetSize_Texture3D_texture_modifiers;
    TextureGetSize_Texture3D_texture.type.modifierValues = TextureGetSize_Texture3D_texture_modifierValues;
    TextureGetSize_Texture3D.documentation = "Get the size of a texture"_c;
    TextureGetSize_Texture3D.name = TextureGetSize_Texture3D_name;
    TextureGetSize_Texture3D.backendIndex = 2288;
    TextureGetSize_Texture3D.returnType = Type::FullType { UInt32x3Type.name };
    TextureGetSize_Texture3D.parameters = TextureGetSize_Texture3D_args;
    Symbol::Resolved(&TextureGetSize_Texture3D_texture)->typeSymbol = &Texture3DType;
    Symbol::Resolved(&TextureGetSize_Texture3D_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureGetSize_Texture3D)->signature = "textureGetSize(uniform *mutable texture3D) u32x3"_c;
    Symbol::Resolved(&TextureGetSize_Texture3D)->name = "textureGetSize(uniform *mutable texture3D)"_c;
    Symbol::Resolved(&TextureGetSize_Texture3D)->nameWithVarNames = "textureGetSize(texture : uniform *mutable texture3D)"_c;
    Symbol::Resolved(&TextureGetSize_Texture3D)->returnTypeSymbol = &UInt32x3Type;

    /// textureGetSize with TextureCube
    TextureGetSize_TextureCube_texture.name = "texture"_c;
    TextureGetSize_TextureCube_texture.type = Type::FullType{ TextureCubeType.name };
    TextureGetSize_TextureCube_texture.type.strict = true;
    TextureGetSize_TextureCube_texture.type.mut = true;
    TextureGetSize_TextureCube_texture.type.modifiers = TextureGetSize_TextureCube_texture_modifiers;
    TextureGetSize_TextureCube_texture.type.modifierValues = TextureGetSize_TextureCube_texture_modifierValues;
    TextureGetSize_TextureCube.documentation = "Get the size of a texture"_c;
    TextureGetSize_TextureCube.name = TextureGetSize_TextureCube_name;
    TextureGetSize_TextureCube.backendIndex = 2289;
    TextureGetSize_TextureCube.returnType = Type::FullType { UInt32x3Type.name };
    TextureGetSize_TextureCube.parameters = TextureGetSize_TextureCube_args;
    Symbol::Resolved(&TextureGetSize_TextureCube_texture)->typeSymbol = &TextureCubeType;
    Symbol::Resolved(&TextureGetSize_TextureCube_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureGetSize_TextureCube)->signature = "textureGetSize(uniform *mutable textureCube) u32x3"_c;
    Symbol::Resolved(&TextureGetSize_TextureCube)->name = "textureGetSize(uniform *mutable textureCube)"_c;
    Symbol::Resolved(&TextureGetSize_TextureCube)->nameWithVarNames = "textureGetSize(texture : uniform *mutable textureCube)"_c;
    Symbol::Resolved(&TextureGetSize_TextureCube)->returnTypeSymbol = &UInt32x3Type;

    /// textureGetSize with Texture1DArray
    TextureGetSize_Texture1DArray_texture.name = "texture"_c;
    TextureGetSize_Texture1DArray_texture.type = Type::FullType{ Texture1DArrayType.name };
    TextureGetSize_Texture1DArray_texture.type.strict = true;
    TextureGetSize_Texture1DArray_texture.type.mut = true;
    TextureGetSize_Texture1DArray_texture.type.modifiers = TextureGetSize_Texture1DArray_texture_modifiers;
    TextureGetSize_Texture1DArray_texture.type.modifierValues = TextureGetSize_Texture1DArray_texture_modifierValues;
    TextureGetSize_Texture1DArray.documentation = "Get the size of a texture"_c;
    TextureGetSize_Texture1DArray.name = TextureGetSize_Texture1DArray_name;
    TextureGetSize_Texture1DArray.backendIndex = 2290;
    TextureGetSize_Texture1DArray.returnType = Type::FullType { UInt32x2Type.name };
    TextureGetSize_Texture1DArray.parameters = TextureGetSize_Texture1DArray_args;
    Symbol::Resolved(&TextureGetSize_Texture1DArray_texture)->typeSymbol = &Texture1DArrayType;
    Symbol::Resolved(&TextureGetSize_Texture1DArray_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureGetSize_Texture1DArray)->signature = "textureGetSize(uniform *mutable texture1DArray) u32x2"_c;
    Symbol::Resolved(&TextureGetSize_Texture1DArray)->name = "textureGetSize(uniform *mutable texture1DArray)"_c;
    Symbol::Resolved(&TextureGetSize_Texture1DArray)->nameWithVarNames = "textureGetSize(texture : uniform *mutable texture1DArray)"_c;
    Symbol::Resolved(&TextureGetSize_Texture1DArray)->returnTypeSymbol = &UInt32x2Type;

    /// textureGetSize with Texture2DArray
    TextureGetSize_Texture2DArray_texture.name = "texture"_c;
    TextureGetSize_Texture2DArray_texture.type = Type::FullType{ Texture2DArrayType.name };
    TextureGetSize_Texture2DArray_texture.type.strict = true;
    TextureGetSize_Texture2DArray_texture.type.mut = true;
    TextureGetSize_Texture2DArray_texture.type.modifiers = TextureGetSize_Texture2DArray_texture_modifiers;
    TextureGetSize_Texture2DArray_texture.type.modifierValues = TextureGetSize_Texture2DArray_texture_modifierValues;
    TextureGetSize_Texture2DArray.documentation = "Get the size of a texture"_c;
    TextureGetSize_Texture2DArray.name = TextureGetSize_Texture2DArray_name;
    TextureGetSize_Texture2DArray.backendIndex = 2291;
    TextureGetSize_Texture2DArray.returnType = Type::FullType { UInt32x3Type.name };
    TextureGetSize_Texture2DArray.parameters = TextureGetSize_Texture2DArray_args;
    Symbol::Resolved(&TextureGetSize_Texture2DArray_texture)->typeSymbol = &Texture2DArrayType;
    Symbol::Resolved(&TextureGetSize_Texture2DArray_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureGetSize_Texture2DArray)->signature = "textureGetSize(uniform *mutable texture2DArray) u32x3"_c;
    Symbol::Resolved(&TextureGetSize_Texture2DArray)->name = "textureGetSize(uniform *mutable texture2DArray)"_c;
    Symbol::Resolved(&TextureGetSize_Texture2DArray)->nameWithVarNames = "textureGetSize(texture : uniform *mutable texture2DArray)"_c;
    Symbol::Resolved(&TextureGetSize_Texture2DArray)->returnTypeSymbol = &UInt32x3Type;

    /// textureGetSize with TextureCubeArray
    TextureGetSize_TextureCubeArray_texture.name = "texture"_c;
    TextureGetSize_TextureCubeArray_texture.type = Type::FullType{ TextureCubeArrayType.name };
    TextureGetSize_TextureCubeArray_texture.type.strict = true;
    TextureGetSize_TextureCubeArray_texture.type.mut = true;
    TextureGetSize_TextureCubeArray_texture.type.modifiers = TextureGetSize_TextureCubeArray_texture_modifiers;
    TextureGetSize_TextureCubeArray_texture.type.modifierValues = TextureGetSize_TextureCubeArray_texture_modifierValues;
    TextureGetSize_TextureCubeArray.documentation = "Get the size of a texture"_c;
    TextureGetSize_TextureCubeArray.name = TextureGetSize_TextureCubeArray_name;
    TextureGetSize_TextureCubeArray.backendIndex = 2292;
    TextureGetSize_TextureCubeArray.returnType = Type::FullType { UInt32x4Type.name };
    TextureGetSize_TextureCubeArray.parameters = TextureGetSize_TextureCubeArray_args;
    Symbol::Resolved(&TextureGetSize_TextureCubeArray_texture)->typeSymbol = &TextureCubeArrayType;
    Symbol::Resolved(&TextureGetSize_TextureCubeArray_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureGetSize_TextureCubeArray)->signature = "textureGetSize(uniform *mutable textureCubeArray) u32x4"_c;
    Symbol::Resolved(&TextureGetSize_TextureCubeArray)->name = "textureGetSize(uniform *mutable textureCubeArray)"_c;
    Symbol::Resolved(&TextureGetSize_TextureCubeArray)->nameWithVarNames = "textureGetSize(texture : uniform *mutable textureCubeArray)"_c;
    Symbol::Resolved(&TextureGetSize_TextureCubeArray)->returnTypeSymbol = &UInt32x4Type;

    /// textureGetSizeMip with Texture1D, UInt32
    TextureGetSizeMip_Texture1D_texture.name = "texture"_c;
    TextureGetSizeMip_Texture1D_texture.type = Type::FullType{ Texture1DType.name };
    TextureGetSizeMip_Texture1D_texture.type.strict = true;
    TextureGetSizeMip_Texture1D_texture.type.modifiers = TextureGetSizeMip_Texture1D_texture_modifiers;
    TextureGetSizeMip_Texture1D_texture.type.modifierValues = TextureGetSizeMip_Texture1D_texture_modifierValues;
    TextureGetSizeMip_Texture1D_mip.name = "mip"_c;
    TextureGetSizeMip_Texture1D_mip.type = Type::FullType{ UInt32Type.name };
    TextureGetSizeMip_Texture1D.documentation = "Get the size of a texture at a specific mip level"_c;
    TextureGetSizeMip_Texture1D.name = TextureGetSizeMip_Texture1D_name;
    TextureGetSizeMip_Texture1D.backendIndex = 2293;
    TextureGetSizeMip_Texture1D.returnType = Type::FullType { UInt32Type.name };
    TextureGetSizeMip_Texture1D.parameters = TextureGetSizeMip_Texture1D_args;
    Symbol::Resolved(&TextureGetSizeMip_Texture1D_texture)->typeSymbol = &Texture1DType;
    Symbol::Resolved(&TextureGetSizeMip_Texture1D_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureGetSizeMip_Texture1D_mip)->typeSymbol = &UInt32Type;
    Symbol::Resolved(&TextureGetSizeMip_Texture1D)->signature = "textureGetSizeMip(uniform *texture1D,u32) u32"_c;
    Symbol::Resolved(&TextureGetSizeMip_Texture1D)->name = "textureGetSizeMip(uniform *texture1D,u32)"_c;
    Symbol::Resolved(&TextureGetSizeMip_Texture1D)->nameWithVarNames = "textureGetSizeMip(texture : uniform *texture1D, mip : u32)"_c;
    Symbol::Resolved(&TextureGetSizeMip_Texture1D)->returnTypeSymbol = &UInt32Type;

    /// textureGetSizeMip with Texture2D, UInt32
    TextureGetSizeMip_Texture2D_texture.name = "texture"_c;
    TextureGetSizeMip_Texture2D_texture.type = Type::FullType{ Texture2DType.name };
    TextureGetSizeMip_Texture2D_texture.type.strict = true;
    TextureGetSizeMip_Texture2D_texture.type.modifiers = TextureGetSizeMip_Texture2D_texture_modifiers;
    TextureGetSizeMip_Texture2D_texture.type.modifierValues = TextureGetSizeMip_Texture2D_texture_modifierValues;
    TextureGetSizeMip_Texture2D_mip.name = "mip"_c;
    TextureGetSizeMip_Texture2D_mip.type = Type::FullType{ UInt32Type.name };
    TextureGetSizeMip_Texture2D.documentation = "Get the size of a texture at a specific mip level"_c;
    TextureGetSizeMip_Texture2D.name = TextureGetSizeMip_Texture2D_name;
    TextureGetSizeMip_Texture2D.backendIndex = 2294;
    TextureGetSizeMip_Texture2D.returnType = Type::FullType { UInt32x2Type.name };
    TextureGetSizeMip_Texture2D.parameters = TextureGetSizeMip_Texture2D_args;
    Symbol::Resolved(&TextureGetSizeMip_Texture2D_texture)->typeSymbol = &Texture2DType;
    Symbol::Resolved(&TextureGetSizeMip_Texture2D_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureGetSizeMip_Texture2D_mip)->typeSymbol = &UInt32Type;
    Symbol::Resolved(&TextureGetSizeMip_Texture2D)->signature = "textureGetSizeMip(uniform *texture2D,u32) u32x2"_c;
    Symbol::Resolved(&TextureGetSizeMip_Texture2D)->name = "textureGetSizeMip(uniform *texture2D,u32)"_c;
    Symbol::Resolved(&TextureGetSizeMip_Texture2D)->nameWithVarNames = "textureGetSizeMip(texture : uniform *texture2D, mip : u32)"_c;
    Symbol::Resolved(&TextureGetSizeMip_Texture2D)->returnTypeSymbol = &UInt32x2Type;

    /// textureGetSizeMip with Texture3D, UInt32
    TextureGetSizeMip_Texture3D_texture.name = "texture"_c;
    TextureGetSizeMip_Texture3D_texture.type = Type::FullType{ Texture3DType.name };
    TextureGetSizeMip_Texture3D_texture.type.strict = true;
    TextureGetSizeMip_Texture3D_texture.type.modifiers = TextureGetSizeMip_Texture3D_texture_modifiers;
    TextureGetSizeMip_Texture3D_texture.type.modifierValues = TextureGetSizeMip_Texture3D_texture_modifierValues;
    TextureGetSizeMip_Texture3D_mip.name = "mip"_c;
    TextureGetSizeMip_Texture3D_mip.type = Type::FullType{ UInt32Type.name };
    TextureGetSizeMip_Texture3D.documentation = "Get the size of a texture at a specific mip level"_c;
    TextureGetSizeMip_Texture3D.name = TextureGetSizeMip_Texture3D_name;
    TextureGetSizeMip_Texture3D.backendIndex = 2295;
    TextureGetSizeMip_Texture3D.returnType = Type::FullType { UInt32x3Type.name };
    TextureGetSizeMip_Texture3D.parameters = TextureGetSizeMip_Texture3D_args;
    Symbol::Resolved(&TextureGetSizeMip_Texture3D_texture)->typeSymbol = &Texture3DType;
    Symbol::Resolved(&TextureGetSizeMip_Texture3D_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureGetSizeMip_Texture3D_mip)->typeSymbol = &UInt32Type;
    Symbol::Resolved(&TextureGetSizeMip_Texture3D)->signature = "textureGetSizeMip(uniform *texture3D,u32) u32x3"_c;
    Symbol::Resolved(&TextureGetSizeMip_Texture3D)->name = "textureGetSizeMip(uniform *texture3D,u32)"_c;
    Symbol::Resolved(&TextureGetSizeMip_Texture3D)->nameWithVarNames = "textureGetSizeMip(texture : uniform *texture3D, mip : u32)"_c;
    Symbol::Resolved(&TextureGetSizeMip_Texture3D)->returnTypeSymbol = &UInt32x3Type;

    /// textureGetSizeMip with TextureCube, UInt32
    TextureGetSizeMip_TextureCube_texture.name = "texture"_c;
    TextureGetSizeMip_TextureCube_texture.type = Type::FullType{ TextureCubeType.name };
    TextureGetSizeMip_TextureCube_texture.type.strict = true;
    TextureGetSizeMip_TextureCube_texture.type.modifiers = TextureGetSizeMip_TextureCube_texture_modifiers;
    TextureGetSizeMip_TextureCube_texture.type.modifierValues = TextureGetSizeMip_TextureCube_texture_modifierValues;
    TextureGetSizeMip_TextureCube_mip.name = "mip"_c;
    TextureGetSizeMip_TextureCube_mip.type = Type::FullType{ UInt32Type.name };
    TextureGetSizeMip_TextureCube.documentation = "Get the size of a texture at a specific mip level"_c;
    TextureGetSizeMip_TextureCube.name = TextureGetSizeMip_TextureCube_name;
    TextureGetSizeMip_TextureCube.backendIndex = 2296;
    TextureGetSizeMip_TextureCube.returnType = Type::FullType { UInt32x3Type.name };
    TextureGetSizeMip_TextureCube.parameters = TextureGetSizeMip_TextureCube_args;
    Symbol::Resolved(&TextureGetSizeMip_TextureCube_texture)->typeSymbol = &TextureCubeType;
    Symbol::Resolved(&TextureGetSizeMip_TextureCube_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureGetSizeMip_TextureCube_mip)->typeSymbol = &UInt32Type;
    Symbol::Resolved(&TextureGetSizeMip_TextureCube)->signature = "textureGetSizeMip(uniform *textureCube,u32) u32x3"_c;
    Symbol::Resolved(&TextureGetSizeMip_TextureCube)->name = "textureGetSizeMip(uniform *textureCube,u32)"_c;
    Symbol::Resolved(&TextureGetSizeMip_TextureCube)->nameWithVarNames = "textureGetSizeMip(texture : uniform *textureCube, mip : u32)"_c;
    Symbol::Resolved(&TextureGetSizeMip_TextureCube)->returnTypeSymbol = &UInt32x3Type;

    /// textureGetSizeMip with Texture1DArray, UInt32
    TextureGetSizeMip_Texture1DArray_texture.name = "texture"_c;
    TextureGetSizeMip_Texture1DArray_texture.type = Type::FullType{ Texture1DArrayType.name };
    TextureGetSizeMip_Texture1DArray_texture.type.strict = true;
    TextureGetSizeMip_Texture1DArray_texture.type.modifiers = TextureGetSizeMip_Texture1DArray_texture_modifiers;
    TextureGetSizeMip_Texture1DArray_texture.type.modifierValues = TextureGetSizeMip_Texture1DArray_texture_modifierValues;
    TextureGetSizeMip_Texture1DArray_mip.name = "mip"_c;
    TextureGetSizeMip_Texture1DArray_mip.type = Type::FullType{ UInt32Type.name };
    TextureGetSizeMip_Texture1DArray.documentation = "Get the size of a texture at a specific mip level"_c;
    TextureGetSizeMip_Texture1DArray.name = TextureGetSizeMip_Texture1DArray_name;
    TextureGetSizeMip_Texture1DArray.backendIndex = 2297;
    TextureGetSizeMip_Texture1DArray.returnType = Type::FullType { UInt32x2Type.name };
    TextureGetSizeMip_Texture1DArray.parameters = TextureGetSizeMip_Texture1DArray_args;
    Symbol::Resolved(&TextureGetSizeMip_Texture1DArray_texture)->typeSymbol = &Texture1DArrayType;
    Symbol::Resolved(&TextureGetSizeMip_Texture1DArray_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureGetSizeMip_Texture1DArray_mip)->typeSymbol = &UInt32Type;
    Symbol::Resolved(&TextureGetSizeMip_Texture1DArray)->signature = "textureGetSizeMip(uniform *texture1DArray,u32) u32x2"_c;
    Symbol::Resolved(&TextureGetSizeMip_Texture1DArray)->name = "textureGetSizeMip(uniform *texture1DArray,u32)"_c;
    Symbol::Resolved(&TextureGetSizeMip_Texture1DArray)->nameWithVarNames = "textureGetSizeMip(texture : uniform *texture1DArray, mip : u32)"_c;
    Symbol::Resolved(&TextureGetSizeMip_Texture1DArray)->returnTypeSymbol = &UInt32x2Type;

    /// textureGetSizeMip with Texture2DArray, UInt32
    TextureGetSizeMip_Texture2DArray_texture.name = "texture"_c;
    TextureGetSizeMip_Texture2DArray_texture.type = Type::FullType{ Texture2DArrayType.name };
    TextureGetSizeMip_Texture2DArray_texture.type.strict = true;
    TextureGetSizeMip_Texture2DArray_texture.type.modifiers = TextureGetSizeMip_Texture2DArray_texture_modifiers;
    TextureGetSizeMip_Texture2DArray_texture.type.modifierValues = TextureGetSizeMip_Texture2DArray_texture_modifierValues;
    TextureGetSizeMip_Texture2DArray_mip.name = "mip"_c;
    TextureGetSizeMip_Texture2DArray_mip.type = Type::FullType{ UInt32Type.name };
    TextureGetSizeMip_Texture2DArray.documentation = "Get the size of a texture at a specific mip level"_c;
    TextureGetSizeMip_Texture2DArray.name = TextureGetSizeMip_Texture2DArray_name;
    TextureGetSizeMip_Texture2DArray.backendIndex = 2298;
    TextureGetSizeMip_Texture2DArray.returnType = Type::FullType { UInt32x3Type.name };
    TextureGetSizeMip_Texture2DArray.parameters = TextureGetSizeMip_Texture2DArray_args;
    Symbol::Resolved(&TextureGetSizeMip_Texture2DArray_texture)->typeSymbol = &Texture2DArrayType;
    Symbol::Resolved(&TextureGetSizeMip_Texture2DArray_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureGetSizeMip_Texture2DArray_mip)->typeSymbol = &UInt32Type;
    Symbol::Resolved(&TextureGetSizeMip_Texture2DArray)->signature = "textureGetSizeMip(uniform *texture2DArray,u32) u32x3"_c;
    Symbol::Resolved(&TextureGetSizeMip_Texture2DArray)->name = "textureGetSizeMip(uniform *texture2DArray,u32)"_c;
    Symbol::Resolved(&TextureGetSizeMip_Texture2DArray)->nameWithVarNames = "textureGetSizeMip(texture : uniform *texture2DArray, mip : u32)"_c;
    Symbol::Resolved(&TextureGetSizeMip_Texture2DArray)->returnTypeSymbol = &UInt32x3Type;

    /// textureGetSizeMip with TextureCubeArray, UInt32
    TextureGetSizeMip_TextureCubeArray_texture.name = "texture"_c;
    TextureGetSizeMip_TextureCubeArray_texture.type = Type::FullType{ TextureCubeArrayType.name };
    TextureGetSizeMip_TextureCubeArray_texture.type.strict = true;
    TextureGetSizeMip_TextureCubeArray_texture.type.modifiers = TextureGetSizeMip_TextureCubeArray_texture_modifiers;
    TextureGetSizeMip_TextureCubeArray_texture.type.modifierValues = TextureGetSizeMip_TextureCubeArray_texture_modifierValues;
    TextureGetSizeMip_TextureCubeArray_mip.name = "mip"_c;
    TextureGetSizeMip_TextureCubeArray_mip.type = Type::FullType{ UInt32Type.name };
    TextureGetSizeMip_TextureCubeArray.documentation = "Get the size of a texture at a specific mip level"_c;
    TextureGetSizeMip_TextureCubeArray.name = TextureGetSizeMip_TextureCubeArray_name;
    TextureGetSizeMip_TextureCubeArray.backendIndex = 2299;
    TextureGetSizeMip_TextureCubeArray.returnType = Type::FullType { UInt32x4Type.name };
    TextureGetSizeMip_TextureCubeArray.parameters = TextureGetSizeMip_TextureCubeArray_args;
    Symbol::Resolved(&TextureGetSizeMip_TextureCubeArray_texture)->typeSymbol = &TextureCubeArrayType;
    Symbol::Resolved(&TextureGetSizeMip_TextureCubeArray_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureGetSizeMip_TextureCubeArray_mip)->typeSymbol = &UInt32Type;
    Symbol::Resolved(&TextureGetSizeMip_TextureCubeArray)->signature = "textureGetSizeMip(uniform *textureCubeArray,u32) u32x4"_c;
    Symbol::Resolved(&TextureGetSizeMip_TextureCubeArray)->name = "textureGetSizeMip(uniform *textureCubeArray,u32)"_c;
    Symbol::Resolved(&TextureGetSizeMip_TextureCubeArray)->nameWithVarNames = "textureGetSizeMip(texture : uniform *textureCubeArray, mip : u32)"_c;
    Symbol::Resolved(&TextureGetSizeMip_TextureCubeArray)->returnTypeSymbol = &UInt32x4Type;

    /// textureGetMips with Texture1D
    TextureGetMips_Texture1D_texture.name = "texture"_c;
    TextureGetMips_Texture1D_texture.type = Type::FullType{ Texture1DType.name };
    TextureGetMips_Texture1D_texture.type.modifiers = TextureGetMips_Texture1D_texture_modifiers;
    TextureGetMips_Texture1D_texture.type.modifierValues = TextureGetMips_Texture1D_texture_modifierValues;
    TextureGetMips_Texture1D.documentation = "Get the number of mips in a texture"_c;
    TextureGetMips_Texture1D.name = TextureGetMips_Texture1D_name;
    TextureGetMips_Texture1D.backendIndex = 2300;
    TextureGetMips_Texture1D.returnType = Type::FullType { Texture1DType.name };
    TextureGetMips_Texture1D.parameters = TextureGetMips_Texture1D_args;
    Symbol::Resolved(&TextureGetMips_Texture1D_texture)->typeSymbol = &Texture1DType;
    Symbol::Resolved(&TextureGetMips_Texture1D_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureGetMips_Texture1D)->signature = "textureGetMips(uniform *texture1D) texture1D"_c;
    Symbol::Resolved(&TextureGetMips_Texture1D)->name = "textureGetMips(uniform *texture1D)"_c;
    Symbol::Resolved(&TextureGetMips_Texture1D)->nameWithVarNames = "textureGetMips(texture : uniform *texture1D)"_c;
    Symbol::Resolved(&TextureGetMips_Texture1D)->returnTypeSymbol = &Texture1DType;

    /// textureGetMips with Texture2D
    TextureGetMips_Texture2D_texture.name = "texture"_c;
    TextureGetMips_Texture2D_texture.type = Type::FullType{ Texture2DType.name };
    TextureGetMips_Texture2D_texture.type.modifiers = TextureGetMips_Texture2D_texture_modifiers;
    TextureGetMips_Texture2D_texture.type.modifierValues = TextureGetMips_Texture2D_texture_modifierValues;
    TextureGetMips_Texture2D.documentation = "Get the number of mips in a texture"_c;
    TextureGetMips_Texture2D.name = TextureGetMips_Texture2D_name;
    TextureGetMips_Texture2D.backendIndex = 2301;
    TextureGetMips_Texture2D.returnType = Type::FullType { Texture2DType.name };
    TextureGetMips_Texture2D.parameters = TextureGetMips_Texture2D_args;
    Symbol::Resolved(&TextureGetMips_Texture2D_texture)->typeSymbol = &Texture2DType;
    Symbol::Resolved(&TextureGetMips_Texture2D_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureGetMips_Texture2D)->signature = "textureGetMips(uniform *texture2D) texture2D"_c;
    Symbol::Resolved(&TextureGetMips_Texture2D)->name = "textureGetMips(uniform *texture2D)"_c;
    Symbol::Resolved(&TextureGetMips_Texture2D)->nameWithVarNames = "textureGetMips(texture : uniform *texture2D)"_c;
    Symbol::Resolved(&TextureGetMips_Texture2D)->returnTypeSymbol = &Texture2DType;

    /// textureGetMips with Texture3D
    TextureGetMips_Texture3D_texture.name = "texture"_c;
    TextureGetMips_Texture3D_texture.type = Type::FullType{ Texture3DType.name };
    TextureGetMips_Texture3D_texture.type.modifiers = TextureGetMips_Texture3D_texture_modifiers;
    TextureGetMips_Texture3D_texture.type.modifierValues = TextureGetMips_Texture3D_texture_modifierValues;
    TextureGetMips_Texture3D.documentation = "Get the number of mips in a texture"_c;
    TextureGetMips_Texture3D.name = TextureGetMips_Texture3D_name;
    TextureGetMips_Texture3D.backendIndex = 2302;
    TextureGetMips_Texture3D.returnType = Type::FullType { Texture3DType.name };
    TextureGetMips_Texture3D.parameters = TextureGetMips_Texture3D_args;
    Symbol::Resolved(&TextureGetMips_Texture3D_texture)->typeSymbol = &Texture3DType;
    Symbol::Resolved(&TextureGetMips_Texture3D_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureGetMips_Texture3D)->signature = "textureGetMips(uniform *texture3D) texture3D"_c;
    Symbol::Resolved(&TextureGetMips_Texture3D)->name = "textureGetMips(uniform *texture3D)"_c;
    Symbol::Resolved(&TextureGetMips_Texture3D)->nameWithVarNames = "textureGetMips(texture : uniform *texture3D)"_c;
    Symbol::Resolved(&TextureGetMips_Texture3D)->returnTypeSymbol = &Texture3DType;

    /// textureGetMips with TextureCube
    TextureGetMips_TextureCube_texture.name = "texture"_c;
    TextureGetMips_TextureCube_texture.type = Type::FullType{ TextureCubeType.name };
    TextureGetMips_TextureCube_texture.type.modifiers = TextureGetMips_TextureCube_texture_modifiers;
    TextureGetMips_TextureCube_texture.type.modifierValues = TextureGetMips_TextureCube_texture_modifierValues;
    TextureGetMips_TextureCube.documentation = "Get the number of mips in a texture"_c;
    TextureGetMips_TextureCube.name = TextureGetMips_TextureCube_name;
    TextureGetMips_TextureCube.backendIndex = 2303;
    TextureGetMips_TextureCube.returnType = Type::FullType { TextureCubeType.name };
    TextureGetMips_TextureCube.parameters = TextureGetMips_TextureCube_args;
    Symbol::Resolved(&TextureGetMips_TextureCube_texture)->typeSymbol = &TextureCubeType;
    Symbol::Resolved(&TextureGetMips_TextureCube_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureGetMips_TextureCube)->signature = "textureGetMips(uniform *textureCube) textureCube"_c;
    Symbol::Resolved(&TextureGetMips_TextureCube)->name = "textureGetMips(uniform *textureCube)"_c;
    Symbol::Resolved(&TextureGetMips_TextureCube)->nameWithVarNames = "textureGetMips(texture : uniform *textureCube)"_c;
    Symbol::Resolved(&TextureGetMips_TextureCube)->returnTypeSymbol = &TextureCubeType;

    /// textureGetMips with Texture1DArray
    TextureGetMips_Texture1DArray_texture.name = "texture"_c;
    TextureGetMips_Texture1DArray_texture.type = Type::FullType{ Texture1DArrayType.name };
    TextureGetMips_Texture1DArray_texture.type.modifiers = TextureGetMips_Texture1DArray_texture_modifiers;
    TextureGetMips_Texture1DArray_texture.type.modifierValues = TextureGetMips_Texture1DArray_texture_modifierValues;
    TextureGetMips_Texture1DArray.documentation = "Get the number of mips in a texture"_c;
    TextureGetMips_Texture1DArray.name = TextureGetMips_Texture1DArray_name;
    TextureGetMips_Texture1DArray.backendIndex = 2304;
    TextureGetMips_Texture1DArray.returnType = Type::FullType { Texture1DArrayType.name };
    TextureGetMips_Texture1DArray.parameters = TextureGetMips_Texture1DArray_args;
    Symbol::Resolved(&TextureGetMips_Texture1DArray_texture)->typeSymbol = &Texture1DArrayType;
    Symbol::Resolved(&TextureGetMips_Texture1DArray_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureGetMips_Texture1DArray)->signature = "textureGetMips(uniform *texture1DArray) texture1DArray"_c;
    Symbol::Resolved(&TextureGetMips_Texture1DArray)->name = "textureGetMips(uniform *texture1DArray)"_c;
    Symbol::Resolved(&TextureGetMips_Texture1DArray)->nameWithVarNames = "textureGetMips(texture : uniform *texture1DArray)"_c;
    Symbol::Resolved(&TextureGetMips_Texture1DArray)->returnTypeSymbol = &Texture1DArrayType;

    /// textureGetMips with Texture2DArray
    TextureGetMips_Texture2DArray_texture.name = "texture"_c;
    TextureGetMips_Texture2DArray_texture.type = Type::FullType{ Texture2DArrayType.name };
    TextureGetMips_Texture2DArray_texture.type.modifiers = TextureGetMips_Texture2DArray_texture_modifiers;
    TextureGetMips_Texture2DArray_texture.type.modifierValues = TextureGetMips_Texture2DArray_texture_modifierValues;
    TextureGetMips_Texture2DArray.documentation = "Get the number of mips in a texture"_c;
    TextureGetMips_Texture2DArray.name = TextureGetMips_Texture2DArray_name;
    TextureGetMips_Texture2DArray.backendIndex = 2305;
    TextureGetMips_Texture2DArray.returnType = Type::FullType { Texture2DArrayType.name };
    TextureGetMips_Texture2DArray.parameters = TextureGetMips_Texture2DArray_args;
    Symbol::Resolved(&TextureGetMips_Texture2DArray_texture)->typeSymbol = &Texture2DArrayType;
    Symbol::Resolved(&TextureGetMips_Texture2DArray_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureGetMips_Texture2DArray)->signature = "textureGetMips(uniform *texture2DArray) texture2DArray"_c;
    Symbol::Resolved(&TextureGetMips_Texture2DArray)->name = "textureGetMips(uniform *texture2DArray)"_c;
    Symbol::Resolved(&TextureGetMips_Texture2DArray)->nameWithVarNames = "textureGetMips(texture : uniform *texture2DArray)"_c;
    Symbol::Resolved(&TextureGetMips_Texture2DArray)->returnTypeSymbol = &Texture2DArrayType;

    /// textureGetMips with TextureCubeArray
    TextureGetMips_TextureCubeArray_texture.name = "texture"_c;
    TextureGetMips_TextureCubeArray_texture.type = Type::FullType{ TextureCubeArrayType.name };
    TextureGetMips_TextureCubeArray_texture.type.modifiers = TextureGetMips_TextureCubeArray_texture_modifiers;
    TextureGetMips_TextureCubeArray_texture.type.modifierValues = TextureGetMips_TextureCubeArray_texture_modifierValues;
    TextureGetMips_TextureCubeArray.documentation = "Get the number of mips in a texture"_c;
    TextureGetMips_TextureCubeArray.name = TextureGetMips_TextureCubeArray_name;
    TextureGetMips_TextureCubeArray.backendIndex = 2306;
    TextureGetMips_TextureCubeArray.returnType = Type::FullType { TextureCubeArrayType.name };
    TextureGetMips_TextureCubeArray.parameters = TextureGetMips_TextureCubeArray_args;
    Symbol::Resolved(&TextureGetMips_TextureCubeArray_texture)->typeSymbol = &TextureCubeArrayType;
    Symbol::Resolved(&TextureGetMips_TextureCubeArray_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureGetMips_TextureCubeArray)->signature = "textureGetMips(uniform *textureCubeArray) textureCubeArray"_c;
    Symbol::Resolved(&TextureGetMips_TextureCubeArray)->name = "textureGetMips(uniform *textureCubeArray)"_c;
    Symbol::Resolved(&TextureGetMips_TextureCubeArray)->nameWithVarNames = "textureGetMips(texture : uniform *textureCubeArray)"_c;
    Symbol::Resolved(&TextureGetMips_TextureCubeArray)->returnTypeSymbol = &TextureCubeArrayType;

    /// textureGetSamples with Texture2DMS
    TextureGetSamples_Texture2DMS_texture.name = "texture"_c;
    TextureGetSamples_Texture2DMS_texture.type = Type::FullType{ Texture2DMSType.name };
    TextureGetSamples_Texture2DMS_texture.type.modifiers = TextureGetSamples_Texture2DMS_texture_modifiers;
    TextureGetSamples_Texture2DMS_texture.type.modifierValues = TextureGetSamples_Texture2DMS_texture_modifierValues;
    TextureGetSamples_Texture2DMS.documentation = "Get the number of samples in a multisampled texture"_c;
    TextureGetSamples_Texture2DMS.name = TextureGetSamples_Texture2DMS_name;
    TextureGetSamples_Texture2DMS.backendIndex = 2307;
    TextureGetSamples_Texture2DMS.returnType = Type::FullType { Texture2DMSType.name };
    TextureGetSamples_Texture2DMS.parameters = TextureGetSamples_Texture2DMS_args;
    Symbol::Resolved(&TextureGetSamples_Texture2DMS_texture)->typeSymbol = &Texture2DMSType;
    Symbol::Resolved(&TextureGetSamples_Texture2DMS_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureGetSamples_Texture2DMS)->signature = "textureGetSamples(uniform *texture2DMS) texture2DMS"_c;
    Symbol::Resolved(&TextureGetSamples_Texture2DMS)->name = "textureGetSamples(uniform *texture2DMS)"_c;
    Symbol::Resolved(&TextureGetSamples_Texture2DMS)->nameWithVarNames = "textureGetSamples(texture : uniform *texture2DMS)"_c;
    Symbol::Resolved(&TextureGetSamples_Texture2DMS)->returnTypeSymbol = &Texture2DMSType;

    /// textureGetSamples with Texture2DMSArray
    TextureGetSamples_Texture2DMSArray_texture.name = "texture"_c;
    TextureGetSamples_Texture2DMSArray_texture.type = Type::FullType{ Texture2DMSArrayType.name };
    TextureGetSamples_Texture2DMSArray_texture.type.modifiers = TextureGetSamples_Texture2DMSArray_texture_modifiers;
    TextureGetSamples_Texture2DMSArray_texture.type.modifierValues = TextureGetSamples_Texture2DMSArray_texture_modifierValues;
    TextureGetSamples_Texture2DMSArray.documentation = "Get the number of samples in a multisampled texture"_c;
    TextureGetSamples_Texture2DMSArray.name = TextureGetSamples_Texture2DMSArray_name;
    TextureGetSamples_Texture2DMSArray.backendIndex = 2308;
    TextureGetSamples_Texture2DMSArray.returnType = Type::FullType { Texture2DMSArrayType.name };
    TextureGetSamples_Texture2DMSArray.parameters = TextureGetSamples_Texture2DMSArray_args;
    Symbol::Resolved(&TextureGetSamples_Texture2DMSArray_texture)->typeSymbol = &Texture2DMSArrayType;
    Symbol::Resolved(&TextureGetSamples_Texture2DMSArray_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureGetSamples_Texture2DMSArray)->signature = "textureGetSamples(uniform *texture2DMSArray) texture2DMSArray"_c;
    Symbol::Resolved(&TextureGetSamples_Texture2DMSArray)->name = "textureGetSamples(uniform *texture2DMSArray)"_c;
    Symbol::Resolved(&TextureGetSamples_Texture2DMSArray)->nameWithVarNames = "textureGetSamples(texture : uniform *texture2DMSArray)"_c;
    Symbol::Resolved(&TextureGetSamples_Texture2DMSArray)->returnTypeSymbol = &Texture2DMSArrayType;

    /// textureGetSampledMip with Texture1D, Sampler, Float32
    TextureGetSampledMip_Texture1D_texture.name = "texture"_c;
    TextureGetSampledMip_Texture1D_texture.type = Type::FullType{ Texture1DType.name };
    TextureGetSampledMip_Texture1D_texture.type.modifiers = TextureGetSampledMip_Texture1D_texture_modifiers;
    TextureGetSampledMip_Texture1D_texture.type.modifierValues = TextureGetSampledMip_Texture1D_texture_modifierValues;
    TextureGetSampledMip_Texture1D_sampler.name = "sampler"_c;
    TextureGetSampledMip_Texture1D_sampler.type = Type::FullType{ SamplerType.name };
    TextureGetSampledMip_Texture1D_sampler.type.modifiers = TextureGetSampledMip_Texture1D_sampler_modifiers;
    TextureGetSampledMip_Texture1D_sampler.type.modifierValues = TextureGetSampledMip_Texture1D_sampler_modifierValues;
    TextureGetSampledMip_Texture1D_coordinate.name = "coordinate"_c;
    TextureGetSampledMip_Texture1D_coordinate.type = Type::FullType{ Float32Type.name };
    TextureGetSampledMip_Texture1D.documentation = "Get the mip level of a texture at a specific coordinate. The return value is a vector where the first value is the mip level to sample, and the second is the offset relative to the base mip for which the sample would occur"_c;
    TextureGetSampledMip_Texture1D.name = TextureGetSampledMip_Texture1D_name;
    TextureGetSampledMip_Texture1D.backendIndex = 2309;
    TextureGetSampledMip_Texture1D.returnType = Type::FullType { Float32x2Type.name };
    TextureGetSampledMip_Texture1D.parameters = TextureGetSampledMip_Texture1D_args;
    Symbol::Resolved(&TextureGetSampledMip_Texture1D_texture)->typeSymbol = &Texture1DType;
    Symbol::Resolved(&TextureGetSampledMip_Texture1D_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureGetSampledMip_Texture1D_sampler)->typeSymbol = &SamplerType;
    Symbol::Resolved(&TextureGetSampledMip_Texture1D_sampler)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureGetSampledMip_Texture1D_coordinate)->typeSymbol = &Float32Type;
    Symbol::Resolved(&TextureGetSampledMip_Texture1D)->signature = "textureGetSampledMip(uniform *texture1D,uniform *sampler,f32) f32x2"_c;
    Symbol::Resolved(&TextureGetSampledMip_Texture1D)->name = "textureGetSampledMip(uniform *texture1D,uniform *sampler,f32)"_c;
    Symbol::Resolved(&TextureGetSampledMip_Texture1D)->nameWithVarNames = "textureGetSampledMip(texture : uniform *texture1D, sampler : uniform *sampler, coordinate : f32)"_c;
    Symbol::Resolved(&TextureGetSampledMip_Texture1D)->returnTypeSymbol = &Float32x2Type;

    /// textureGetSampledMip with SampledTexture1D, Float32
    SampledTextureGetSampledMip_Texture1D_texture.name = "texture"_c;
    SampledTextureGetSampledMip_Texture1D_texture.type = Type::FullType{ SampledTexture1DType.name };
    SampledTextureGetSampledMip_Texture1D_texture.type.modifiers = SampledTextureGetSampledMip_Texture1D_texture_modifiers;
    SampledTextureGetSampledMip_Texture1D_texture.type.modifierValues = SampledTextureGetSampledMip_Texture1D_texture_modifierValues;
    SampledTextureGetSampledMip_Texture1D_coordinate.name = "coordinate"_c;
    SampledTextureGetSampledMip_Texture1D_coordinate.type = Type::FullType{ Float32Type.name };
    SampledTextureGetSampledMip_Texture1D.documentation = "Get the mip level of a texture at a specific coordinate. The return value is a vector where the first value is the mip level to sample, and the second is the offset relative to the base mip for which the sample would occur"_c;
    SampledTextureGetSampledMip_Texture1D.name = SampledTextureGetSampledMip_Texture1D_name;
    SampledTextureGetSampledMip_Texture1D.backendIndex = 2310;
    SampledTextureGetSampledMip_Texture1D.returnType = Type::FullType { Float32x2Type.name };
    SampledTextureGetSampledMip_Texture1D.parameters = SampledTextureGetSampledMip_Texture1D_args;
    Symbol::Resolved(&SampledTextureGetSampledMip_Texture1D_texture)->typeSymbol = &SampledTexture1DType;
    Symbol::Resolved(&SampledTextureGetSampledMip_Texture1D_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&SampledTextureGetSampledMip_Texture1D_coordinate)->typeSymbol = &Float32Type;
    Symbol::Resolved(&SampledTextureGetSampledMip_Texture1D)->signature = "textureGetSampledMip(uniform *textureSampled1D,f32) f32x2"_c;
    Symbol::Resolved(&SampledTextureGetSampledMip_Texture1D)->name = "textureGetSampledMip(uniform *textureSampled1D,f32)"_c;
    Symbol::Resolved(&SampledTextureGetSampledMip_Texture1D)->nameWithVarNames = "textureGetSampledMip(texture : uniform *textureSampled1D, coordinate : f32)"_c;
    Symbol::Resolved(&SampledTextureGetSampledMip_Texture1D)->returnTypeSymbol = &Float32x2Type;

    /// textureGetSampledMip with Texture2D, Sampler, Float32x2
    TextureGetSampledMip_Texture2D_texture.name = "texture"_c;
    TextureGetSampledMip_Texture2D_texture.type = Type::FullType{ Texture2DType.name };
    TextureGetSampledMip_Texture2D_texture.type.modifiers = TextureGetSampledMip_Texture2D_texture_modifiers;
    TextureGetSampledMip_Texture2D_texture.type.modifierValues = TextureGetSampledMip_Texture2D_texture_modifierValues;
    TextureGetSampledMip_Texture2D_sampler.name = "sampler"_c;
    TextureGetSampledMip_Texture2D_sampler.type = Type::FullType{ SamplerType.name };
    TextureGetSampledMip_Texture2D_sampler.type.modifiers = TextureGetSampledMip_Texture2D_sampler_modifiers;
    TextureGetSampledMip_Texture2D_sampler.type.modifierValues = TextureGetSampledMip_Texture2D_sampler_modifierValues;
    TextureGetSampledMip_Texture2D_coordinate.name = "coordinate"_c;
    TextureGetSampledMip_Texture2D_coordinate.type = Type::FullType{ Float32x2Type.name };
    TextureGetSampledMip_Texture2D.documentation = "Get the mip level of a texture at a specific coordinate. The return value is a vector where the first value is the mip level to sample, and the second is the offset relative to the base mip for which the sample would occur"_c;
    TextureGetSampledMip_Texture2D.name = TextureGetSampledMip_Texture2D_name;
    TextureGetSampledMip_Texture2D.backendIndex = 2311;
    TextureGetSampledMip_Texture2D.returnType = Type::FullType { Float32x2Type.name };
    TextureGetSampledMip_Texture2D.parameters = TextureGetSampledMip_Texture2D_args;
    Symbol::Resolved(&TextureGetSampledMip_Texture2D_texture)->typeSymbol = &Texture2DType;
    Symbol::Resolved(&TextureGetSampledMip_Texture2D_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureGetSampledMip_Texture2D_sampler)->typeSymbol = &SamplerType;
    Symbol::Resolved(&TextureGetSampledMip_Texture2D_sampler)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureGetSampledMip_Texture2D_coordinate)->typeSymbol = &Float32x2Type;
    Symbol::Resolved(&TextureGetSampledMip_Texture2D)->signature = "textureGetSampledMip(uniform *texture2D,uniform *sampler,f32x2) f32x2"_c;
    Symbol::Resolved(&TextureGetSampledMip_Texture2D)->name = "textureGetSampledMip(uniform *texture2D,uniform *sampler,f32x2)"_c;
    Symbol::Resolved(&TextureGetSampledMip_Texture2D)->nameWithVarNames = "textureGetSampledMip(texture : uniform *texture2D, sampler : uniform *sampler, coordinate : f32x2)"_c;
    Symbol::Resolved(&TextureGetSampledMip_Texture2D)->returnTypeSymbol = &Float32x2Type;

    /// textureGetSampledMip with SampledTexture2D, Float32x2
    SampledTextureGetSampledMip_Texture2D_texture.name = "texture"_c;
    SampledTextureGetSampledMip_Texture2D_texture.type = Type::FullType{ SampledTexture2DType.name };
    SampledTextureGetSampledMip_Texture2D_texture.type.modifiers = SampledTextureGetSampledMip_Texture2D_texture_modifiers;
    SampledTextureGetSampledMip_Texture2D_texture.type.modifierValues = SampledTextureGetSampledMip_Texture2D_texture_modifierValues;
    SampledTextureGetSampledMip_Texture2D_coordinate.name = "coordinate"_c;
    SampledTextureGetSampledMip_Texture2D_coordinate.type = Type::FullType{ Float32x2Type.name };
    SampledTextureGetSampledMip_Texture2D.documentation = "Get the mip level of a texture at a specific coordinate. The return value is a vector where the first value is the mip level to sample, and the second is the offset relative to the base mip for which the sample would occur"_c;
    SampledTextureGetSampledMip_Texture2D.name = SampledTextureGetSampledMip_Texture2D_name;
    SampledTextureGetSampledMip_Texture2D.backendIndex = 2312;
    SampledTextureGetSampledMip_Texture2D.returnType = Type::FullType { Float32x2Type.name };
    SampledTextureGetSampledMip_Texture2D.parameters = SampledTextureGetSampledMip_Texture2D_args;
    Symbol::Resolved(&SampledTextureGetSampledMip_Texture2D_texture)->typeSymbol = &SampledTexture2DType;
    Symbol::Resolved(&SampledTextureGetSampledMip_Texture2D_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&SampledTextureGetSampledMip_Texture2D_coordinate)->typeSymbol = &Float32x2Type;
    Symbol::Resolved(&SampledTextureGetSampledMip_Texture2D)->signature = "textureGetSampledMip(uniform *textureSampled2D,f32x2) f32x2"_c;
    Symbol::Resolved(&SampledTextureGetSampledMip_Texture2D)->name = "textureGetSampledMip(uniform *textureSampled2D,f32x2)"_c;
    Symbol::Resolved(&SampledTextureGetSampledMip_Texture2D)->nameWithVarNames = "textureGetSampledMip(texture : uniform *textureSampled2D, coordinate : f32x2)"_c;
    Symbol::Resolved(&SampledTextureGetSampledMip_Texture2D)->returnTypeSymbol = &Float32x2Type;

    /// textureGetSampledMip with Texture3D, Sampler, Float32x3
    TextureGetSampledMip_Texture3D_texture.name = "texture"_c;
    TextureGetSampledMip_Texture3D_texture.type = Type::FullType{ Texture3DType.name };
    TextureGetSampledMip_Texture3D_texture.type.modifiers = TextureGetSampledMip_Texture3D_texture_modifiers;
    TextureGetSampledMip_Texture3D_texture.type.modifierValues = TextureGetSampledMip_Texture3D_texture_modifierValues;
    TextureGetSampledMip_Texture3D_sampler.name = "sampler"_c;
    TextureGetSampledMip_Texture3D_sampler.type = Type::FullType{ SamplerType.name };
    TextureGetSampledMip_Texture3D_sampler.type.modifiers = TextureGetSampledMip_Texture3D_sampler_modifiers;
    TextureGetSampledMip_Texture3D_sampler.type.modifierValues = TextureGetSampledMip_Texture3D_sampler_modifierValues;
    TextureGetSampledMip_Texture3D_coordinate.name = "coordinate"_c;
    TextureGetSampledMip_Texture3D_coordinate.type = Type::FullType{ Float32x3Type.name };
    TextureGetSampledMip_Texture3D.documentation = "Get the mip level of a texture at a specific coordinate. The return value is a vector where the first value is the mip level to sample, and the second is the offset relative to the base mip for which the sample would occur"_c;
    TextureGetSampledMip_Texture3D.name = TextureGetSampledMip_Texture3D_name;
    TextureGetSampledMip_Texture3D.backendIndex = 2313;
    TextureGetSampledMip_Texture3D.returnType = Type::FullType { Float32x2Type.name };
    TextureGetSampledMip_Texture3D.parameters = TextureGetSampledMip_Texture3D_args;
    Symbol::Resolved(&TextureGetSampledMip_Texture3D_texture)->typeSymbol = &Texture3DType;
    Symbol::Resolved(&TextureGetSampledMip_Texture3D_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureGetSampledMip_Texture3D_sampler)->typeSymbol = &SamplerType;
    Symbol::Resolved(&TextureGetSampledMip_Texture3D_sampler)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureGetSampledMip_Texture3D_coordinate)->typeSymbol = &Float32x3Type;
    Symbol::Resolved(&TextureGetSampledMip_Texture3D)->signature = "textureGetSampledMip(uniform *texture3D,uniform *sampler,f32x3) f32x2"_c;
    Symbol::Resolved(&TextureGetSampledMip_Texture3D)->name = "textureGetSampledMip(uniform *texture3D,uniform *sampler,f32x3)"_c;
    Symbol::Resolved(&TextureGetSampledMip_Texture3D)->nameWithVarNames = "textureGetSampledMip(texture : uniform *texture3D, sampler : uniform *sampler, coordinate : f32x3)"_c;
    Symbol::Resolved(&TextureGetSampledMip_Texture3D)->returnTypeSymbol = &Float32x2Type;

    /// textureGetSampledMip with SampledTexture3D, Float32x3
    SampledTextureGetSampledMip_Texture3D_texture.name = "texture"_c;
    SampledTextureGetSampledMip_Texture3D_texture.type = Type::FullType{ SampledTexture3DType.name };
    SampledTextureGetSampledMip_Texture3D_texture.type.modifiers = SampledTextureGetSampledMip_Texture3D_texture_modifiers;
    SampledTextureGetSampledMip_Texture3D_texture.type.modifierValues = SampledTextureGetSampledMip_Texture3D_texture_modifierValues;
    SampledTextureGetSampledMip_Texture3D_coordinate.name = "coordinate"_c;
    SampledTextureGetSampledMip_Texture3D_coordinate.type = Type::FullType{ Float32x3Type.name };
    SampledTextureGetSampledMip_Texture3D.documentation = "Get the mip level of a texture at a specific coordinate. The return value is a vector where the first value is the mip level to sample, and the second is the offset relative to the base mip for which the sample would occur"_c;
    SampledTextureGetSampledMip_Texture3D.name = SampledTextureGetSampledMip_Texture3D_name;
    SampledTextureGetSampledMip_Texture3D.backendIndex = 2314;
    SampledTextureGetSampledMip_Texture3D.returnType = Type::FullType { Float32x2Type.name };
    SampledTextureGetSampledMip_Texture3D.parameters = SampledTextureGetSampledMip_Texture3D_args;
    Symbol::Resolved(&SampledTextureGetSampledMip_Texture3D_texture)->typeSymbol = &SampledTexture3DType;
    Symbol::Resolved(&SampledTextureGetSampledMip_Texture3D_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&SampledTextureGetSampledMip_Texture3D_coordinate)->typeSymbol = &Float32x3Type;
    Symbol::Resolved(&SampledTextureGetSampledMip_Texture3D)->signature = "textureGetSampledMip(uniform *textureSampled3D,f32x3) f32x2"_c;
    Symbol::Resolved(&SampledTextureGetSampledMip_Texture3D)->name = "textureGetSampledMip(uniform *textureSampled3D,f32x3)"_c;
    Symbol::Resolved(&SampledTextureGetSampledMip_Texture3D)->nameWithVarNames = "textureGetSampledMip(texture : uniform *textureSampled3D, coordinate : f32x3)"_c;
    Symbol::Resolved(&SampledTextureGetSampledMip_Texture3D)->returnTypeSymbol = &Float32x2Type;

    /// textureGetSampledMip with TextureCube, Sampler, Float32x3
    TextureGetSampledMip_TextureCube_texture.name = "texture"_c;
    TextureGetSampledMip_TextureCube_texture.type = Type::FullType{ TextureCubeType.name };
    TextureGetSampledMip_TextureCube_texture.type.modifiers = TextureGetSampledMip_TextureCube_texture_modifiers;
    TextureGetSampledMip_TextureCube_texture.type.modifierValues = TextureGetSampledMip_TextureCube_texture_modifierValues;
    TextureGetSampledMip_TextureCube_sampler.name = "sampler"_c;
    TextureGetSampledMip_TextureCube_sampler.type = Type::FullType{ SamplerType.name };
    TextureGetSampledMip_TextureCube_sampler.type.modifiers = TextureGetSampledMip_TextureCube_sampler_modifiers;
    TextureGetSampledMip_TextureCube_sampler.type.modifierValues = TextureGetSampledMip_TextureCube_sampler_modifierValues;
    TextureGetSampledMip_TextureCube_coordinate.name = "coordinate"_c;
    TextureGetSampledMip_TextureCube_coordinate.type = Type::FullType{ Float32x3Type.name };
    TextureGetSampledMip_TextureCube.documentation = "Get the mip level of a texture at a specific coordinate. The return value is a vector where the first value is the mip level to sample, and the second is the offset relative to the base mip for which the sample would occur"_c;
    TextureGetSampledMip_TextureCube.name = TextureGetSampledMip_TextureCube_name;
    TextureGetSampledMip_TextureCube.backendIndex = 2315;
    TextureGetSampledMip_TextureCube.returnType = Type::FullType { Float32x2Type.name };
    TextureGetSampledMip_TextureCube.parameters = TextureGetSampledMip_TextureCube_args;
    Symbol::Resolved(&TextureGetSampledMip_TextureCube_texture)->typeSymbol = &TextureCubeType;
    Symbol::Resolved(&TextureGetSampledMip_TextureCube_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureGetSampledMip_TextureCube_sampler)->typeSymbol = &SamplerType;
    Symbol::Resolved(&TextureGetSampledMip_TextureCube_sampler)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureGetSampledMip_TextureCube_coordinate)->typeSymbol = &Float32x3Type;
    Symbol::Resolved(&TextureGetSampledMip_TextureCube)->signature = "textureGetSampledMip(uniform *textureCube,uniform *sampler,f32x3) f32x2"_c;
    Symbol::Resolved(&TextureGetSampledMip_TextureCube)->name = "textureGetSampledMip(uniform *textureCube,uniform *sampler,f32x3)"_c;
    Symbol::Resolved(&TextureGetSampledMip_TextureCube)->nameWithVarNames = "textureGetSampledMip(texture : uniform *textureCube, sampler : uniform *sampler, coordinate : f32x3)"_c;
    Symbol::Resolved(&TextureGetSampledMip_TextureCube)->returnTypeSymbol = &Float32x2Type;

    /// textureGetSampledMip with SampledTextureCube, Float32x3
    SampledTextureGetSampledMip_TextureCube_texture.name = "texture"_c;
    SampledTextureGetSampledMip_TextureCube_texture.type = Type::FullType{ SampledTextureCubeType.name };
    SampledTextureGetSampledMip_TextureCube_texture.type.modifiers = SampledTextureGetSampledMip_TextureCube_texture_modifiers;
    SampledTextureGetSampledMip_TextureCube_texture.type.modifierValues = SampledTextureGetSampledMip_TextureCube_texture_modifierValues;
    SampledTextureGetSampledMip_TextureCube_coordinate.name = "coordinate"_c;
    SampledTextureGetSampledMip_TextureCube_coordinate.type = Type::FullType{ Float32x3Type.name };
    SampledTextureGetSampledMip_TextureCube.documentation = "Get the mip level of a texture at a specific coordinate. The return value is a vector where the first value is the mip level to sample, and the second is the offset relative to the base mip for which the sample would occur"_c;
    SampledTextureGetSampledMip_TextureCube.name = SampledTextureGetSampledMip_TextureCube_name;
    SampledTextureGetSampledMip_TextureCube.backendIndex = 2316;
    SampledTextureGetSampledMip_TextureCube.returnType = Type::FullType { Float32x2Type.name };
    SampledTextureGetSampledMip_TextureCube.parameters = SampledTextureGetSampledMip_TextureCube_args;
    Symbol::Resolved(&SampledTextureGetSampledMip_TextureCube_texture)->typeSymbol = &SampledTextureCubeType;
    Symbol::Resolved(&SampledTextureGetSampledMip_TextureCube_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&SampledTextureGetSampledMip_TextureCube_coordinate)->typeSymbol = &Float32x3Type;
    Symbol::Resolved(&SampledTextureGetSampledMip_TextureCube)->signature = "textureGetSampledMip(uniform *textureSampledCube,f32x3) f32x2"_c;
    Symbol::Resolved(&SampledTextureGetSampledMip_TextureCube)->name = "textureGetSampledMip(uniform *textureSampledCube,f32x3)"_c;
    Symbol::Resolved(&SampledTextureGetSampledMip_TextureCube)->nameWithVarNames = "textureGetSampledMip(texture : uniform *textureSampledCube, coordinate : f32x3)"_c;
    Symbol::Resolved(&SampledTextureGetSampledMip_TextureCube)->returnTypeSymbol = &Float32x2Type;

    /// textureGetSampledMip with Texture1DArray, Sampler, Float32x2
    TextureGetSampledMip_Texture1DArray_texture.name = "texture"_c;
    TextureGetSampledMip_Texture1DArray_texture.type = Type::FullType{ Texture1DArrayType.name };
    TextureGetSampledMip_Texture1DArray_texture.type.modifiers = TextureGetSampledMip_Texture1DArray_texture_modifiers;
    TextureGetSampledMip_Texture1DArray_texture.type.modifierValues = TextureGetSampledMip_Texture1DArray_texture_modifierValues;
    TextureGetSampledMip_Texture1DArray_sampler.name = "sampler"_c;
    TextureGetSampledMip_Texture1DArray_sampler.type = Type::FullType{ SamplerType.name };
    TextureGetSampledMip_Texture1DArray_sampler.type.modifiers = TextureGetSampledMip_Texture1DArray_sampler_modifiers;
    TextureGetSampledMip_Texture1DArray_sampler.type.modifierValues = TextureGetSampledMip_Texture1DArray_sampler_modifierValues;
    TextureGetSampledMip_Texture1DArray_coordinate.name = "coordinate"_c;
    TextureGetSampledMip_Texture1DArray_coordinate.type = Type::FullType{ Float32x2Type.name };
    TextureGetSampledMip_Texture1DArray.documentation = "Get the mip level of a texture at a specific coordinate. The return value is a vector where the first value is the mip level to sample, and the second is the offset relative to the base mip for which the sample would occur"_c;
    TextureGetSampledMip_Texture1DArray.name = TextureGetSampledMip_Texture1DArray_name;
    TextureGetSampledMip_Texture1DArray.backendIndex = 2317;
    TextureGetSampledMip_Texture1DArray.returnType = Type::FullType { Float32x2Type.name };
    TextureGetSampledMip_Texture1DArray.parameters = TextureGetSampledMip_Texture1DArray_args;
    Symbol::Resolved(&TextureGetSampledMip_Texture1DArray_texture)->typeSymbol = &Texture1DArrayType;
    Symbol::Resolved(&TextureGetSampledMip_Texture1DArray_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureGetSampledMip_Texture1DArray_sampler)->typeSymbol = &SamplerType;
    Symbol::Resolved(&TextureGetSampledMip_Texture1DArray_sampler)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureGetSampledMip_Texture1DArray_coordinate)->typeSymbol = &Float32x2Type;
    Symbol::Resolved(&TextureGetSampledMip_Texture1DArray)->signature = "textureGetSampledMip(uniform *texture1DArray,uniform *sampler,f32x2) f32x2"_c;
    Symbol::Resolved(&TextureGetSampledMip_Texture1DArray)->name = "textureGetSampledMip(uniform *texture1DArray,uniform *sampler,f32x2)"_c;
    Symbol::Resolved(&TextureGetSampledMip_Texture1DArray)->nameWithVarNames = "textureGetSampledMip(texture : uniform *texture1DArray, sampler : uniform *sampler, coordinate : f32x2)"_c;
    Symbol::Resolved(&TextureGetSampledMip_Texture1DArray)->returnTypeSymbol = &Float32x2Type;

    /// textureGetSampledMip with SampledTexture1DArray, Float32x2
    SampledTextureGetSampledMip_Texture1DArray_texture.name = "texture"_c;
    SampledTextureGetSampledMip_Texture1DArray_texture.type = Type::FullType{ SampledTexture1DArrayType.name };
    SampledTextureGetSampledMip_Texture1DArray_texture.type.modifiers = SampledTextureGetSampledMip_Texture1DArray_texture_modifiers;
    SampledTextureGetSampledMip_Texture1DArray_texture.type.modifierValues = SampledTextureGetSampledMip_Texture1DArray_texture_modifierValues;
    SampledTextureGetSampledMip_Texture1DArray_coordinate.name = "coordinate"_c;
    SampledTextureGetSampledMip_Texture1DArray_coordinate.type = Type::FullType{ Float32x2Type.name };
    SampledTextureGetSampledMip_Texture1DArray.documentation = "Get the mip level of a texture at a specific coordinate. The return value is a vector where the first value is the mip level to sample, and the second is the offset relative to the base mip for which the sample would occur"_c;
    SampledTextureGetSampledMip_Texture1DArray.name = SampledTextureGetSampledMip_Texture1DArray_name;
    SampledTextureGetSampledMip_Texture1DArray.backendIndex = 2318;
    SampledTextureGetSampledMip_Texture1DArray.returnType = Type::FullType { Float32x2Type.name };
    SampledTextureGetSampledMip_Texture1DArray.parameters = SampledTextureGetSampledMip_Texture1DArray_args;
    Symbol::Resolved(&SampledTextureGetSampledMip_Texture1DArray_texture)->typeSymbol = &SampledTexture1DArrayType;
    Symbol::Resolved(&SampledTextureGetSampledMip_Texture1DArray_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&SampledTextureGetSampledMip_Texture1DArray_coordinate)->typeSymbol = &Float32x2Type;
    Symbol::Resolved(&SampledTextureGetSampledMip_Texture1DArray)->signature = "textureGetSampledMip(uniform *textureSampled1DArray,f32x2) f32x2"_c;
    Symbol::Resolved(&SampledTextureGetSampledMip_Texture1DArray)->name = "textureGetSampledMip(uniform *textureSampled1DArray,f32x2)"_c;
    Symbol::Resolved(&SampledTextureGetSampledMip_Texture1DArray)->nameWithVarNames = "textureGetSampledMip(texture : uniform *textureSampled1DArray, coordinate : f32x2)"_c;
    Symbol::Resolved(&SampledTextureGetSampledMip_Texture1DArray)->returnTypeSymbol = &Float32x2Type;

    /// textureGetSampledMip with Texture2DArray, Sampler, Float32x3
    TextureGetSampledMip_Texture2DArray_texture.name = "texture"_c;
    TextureGetSampledMip_Texture2DArray_texture.type = Type::FullType{ Texture2DArrayType.name };
    TextureGetSampledMip_Texture2DArray_texture.type.modifiers = TextureGetSampledMip_Texture2DArray_texture_modifiers;
    TextureGetSampledMip_Texture2DArray_texture.type.modifierValues = TextureGetSampledMip_Texture2DArray_texture_modifierValues;
    TextureGetSampledMip_Texture2DArray_sampler.name = "sampler"_c;
    TextureGetSampledMip_Texture2DArray_sampler.type = Type::FullType{ SamplerType.name };
    TextureGetSampledMip_Texture2DArray_sampler.type.modifiers = TextureGetSampledMip_Texture2DArray_sampler_modifiers;
    TextureGetSampledMip_Texture2DArray_sampler.type.modifierValues = TextureGetSampledMip_Texture2DArray_sampler_modifierValues;
    TextureGetSampledMip_Texture2DArray_coordinate.name = "coordinate"_c;
    TextureGetSampledMip_Texture2DArray_coordinate.type = Type::FullType{ Float32x3Type.name };
    TextureGetSampledMip_Texture2DArray.documentation = "Get the mip level of a texture at a specific coordinate. The return value is a vector where the first value is the mip level to sample, and the second is the offset relative to the base mip for which the sample would occur"_c;
    TextureGetSampledMip_Texture2DArray.name = TextureGetSampledMip_Texture2DArray_name;
    TextureGetSampledMip_Texture2DArray.backendIndex = 2319;
    TextureGetSampledMip_Texture2DArray.returnType = Type::FullType { Float32x2Type.name };
    TextureGetSampledMip_Texture2DArray.parameters = TextureGetSampledMip_Texture2DArray_args;
    Symbol::Resolved(&TextureGetSampledMip_Texture2DArray_texture)->typeSymbol = &Texture2DArrayType;
    Symbol::Resolved(&TextureGetSampledMip_Texture2DArray_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureGetSampledMip_Texture2DArray_sampler)->typeSymbol = &SamplerType;
    Symbol::Resolved(&TextureGetSampledMip_Texture2DArray_sampler)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureGetSampledMip_Texture2DArray_coordinate)->typeSymbol = &Float32x3Type;
    Symbol::Resolved(&TextureGetSampledMip_Texture2DArray)->signature = "textureGetSampledMip(uniform *texture2DArray,uniform *sampler,f32x3) f32x2"_c;
    Symbol::Resolved(&TextureGetSampledMip_Texture2DArray)->name = "textureGetSampledMip(uniform *texture2DArray,uniform *sampler,f32x3)"_c;
    Symbol::Resolved(&TextureGetSampledMip_Texture2DArray)->nameWithVarNames = "textureGetSampledMip(texture : uniform *texture2DArray, sampler : uniform *sampler, coordinate : f32x3)"_c;
    Symbol::Resolved(&TextureGetSampledMip_Texture2DArray)->returnTypeSymbol = &Float32x2Type;

    /// textureGetSampledMip with SampledTexture2DArray, Float32x3
    SampledTextureGetSampledMip_Texture2DArray_texture.name = "texture"_c;
    SampledTextureGetSampledMip_Texture2DArray_texture.type = Type::FullType{ SampledTexture2DArrayType.name };
    SampledTextureGetSampledMip_Texture2DArray_texture.type.modifiers = SampledTextureGetSampledMip_Texture2DArray_texture_modifiers;
    SampledTextureGetSampledMip_Texture2DArray_texture.type.modifierValues = SampledTextureGetSampledMip_Texture2DArray_texture_modifierValues;
    SampledTextureGetSampledMip_Texture2DArray_coordinate.name = "coordinate"_c;
    SampledTextureGetSampledMip_Texture2DArray_coordinate.type = Type::FullType{ Float32x3Type.name };
    SampledTextureGetSampledMip_Texture2DArray.documentation = "Get the mip level of a texture at a specific coordinate. The return value is a vector where the first value is the mip level to sample, and the second is the offset relative to the base mip for which the sample would occur"_c;
    SampledTextureGetSampledMip_Texture2DArray.name = SampledTextureGetSampledMip_Texture2DArray_name;
    SampledTextureGetSampledMip_Texture2DArray.backendIndex = 2320;
    SampledTextureGetSampledMip_Texture2DArray.returnType = Type::FullType { Float32x2Type.name };
    SampledTextureGetSampledMip_Texture2DArray.parameters = SampledTextureGetSampledMip_Texture2DArray_args;
    Symbol::Resolved(&SampledTextureGetSampledMip_Texture2DArray_texture)->typeSymbol = &SampledTexture2DArrayType;
    Symbol::Resolved(&SampledTextureGetSampledMip_Texture2DArray_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&SampledTextureGetSampledMip_Texture2DArray_coordinate)->typeSymbol = &Float32x3Type;
    Symbol::Resolved(&SampledTextureGetSampledMip_Texture2DArray)->signature = "textureGetSampledMip(uniform *textureSampled2DArray,f32x3) f32x2"_c;
    Symbol::Resolved(&SampledTextureGetSampledMip_Texture2DArray)->name = "textureGetSampledMip(uniform *textureSampled2DArray,f32x3)"_c;
    Symbol::Resolved(&SampledTextureGetSampledMip_Texture2DArray)->nameWithVarNames = "textureGetSampledMip(texture : uniform *textureSampled2DArray, coordinate : f32x3)"_c;
    Symbol::Resolved(&SampledTextureGetSampledMip_Texture2DArray)->returnTypeSymbol = &Float32x2Type;

    /// textureGetSampledMip with TextureCubeArray, Sampler, Float32x4
    TextureGetSampledMip_TextureCubeArray_texture.name = "texture"_c;
    TextureGetSampledMip_TextureCubeArray_texture.type = Type::FullType{ TextureCubeArrayType.name };
    TextureGetSampledMip_TextureCubeArray_texture.type.modifiers = TextureGetSampledMip_TextureCubeArray_texture_modifiers;
    TextureGetSampledMip_TextureCubeArray_texture.type.modifierValues = TextureGetSampledMip_TextureCubeArray_texture_modifierValues;
    TextureGetSampledMip_TextureCubeArray_sampler.name = "sampler"_c;
    TextureGetSampledMip_TextureCubeArray_sampler.type = Type::FullType{ SamplerType.name };
    TextureGetSampledMip_TextureCubeArray_sampler.type.modifiers = TextureGetSampledMip_TextureCubeArray_sampler_modifiers;
    TextureGetSampledMip_TextureCubeArray_sampler.type.modifierValues = TextureGetSampledMip_TextureCubeArray_sampler_modifierValues;
    TextureGetSampledMip_TextureCubeArray_coordinate.name = "coordinate"_c;
    TextureGetSampledMip_TextureCubeArray_coordinate.type = Type::FullType{ Float32x4Type.name };
    TextureGetSampledMip_TextureCubeArray.documentation = "Get the mip level of a texture at a specific coordinate. The return value is a vector where the first value is the mip level to sample, and the second is the offset relative to the base mip for which the sample would occur"_c;
    TextureGetSampledMip_TextureCubeArray.name = TextureGetSampledMip_TextureCubeArray_name;
    TextureGetSampledMip_TextureCubeArray.backendIndex = 2321;
    TextureGetSampledMip_TextureCubeArray.returnType = Type::FullType { Float32x2Type.name };
    TextureGetSampledMip_TextureCubeArray.parameters = TextureGetSampledMip_TextureCubeArray_args;
    Symbol::Resolved(&TextureGetSampledMip_TextureCubeArray_texture)->typeSymbol = &TextureCubeArrayType;
    Symbol::Resolved(&TextureGetSampledMip_TextureCubeArray_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureGetSampledMip_TextureCubeArray_sampler)->typeSymbol = &SamplerType;
    Symbol::Resolved(&TextureGetSampledMip_TextureCubeArray_sampler)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureGetSampledMip_TextureCubeArray_coordinate)->typeSymbol = &Float32x4Type;
    Symbol::Resolved(&TextureGetSampledMip_TextureCubeArray)->signature = "textureGetSampledMip(uniform *textureCubeArray,uniform *sampler,f32x4) f32x2"_c;
    Symbol::Resolved(&TextureGetSampledMip_TextureCubeArray)->name = "textureGetSampledMip(uniform *textureCubeArray,uniform *sampler,f32x4)"_c;
    Symbol::Resolved(&TextureGetSampledMip_TextureCubeArray)->nameWithVarNames = "textureGetSampledMip(texture : uniform *textureCubeArray, sampler : uniform *sampler, coordinate : f32x4)"_c;
    Symbol::Resolved(&TextureGetSampledMip_TextureCubeArray)->returnTypeSymbol = &Float32x2Type;

    /// textureGetSampledMip with SampledTextureCubeArray, Float32x4
    SampledTextureGetSampledMip_TextureCubeArray_texture.name = "texture"_c;
    SampledTextureGetSampledMip_TextureCubeArray_texture.type = Type::FullType{ SampledTextureCubeArrayType.name };
    SampledTextureGetSampledMip_TextureCubeArray_texture.type.modifiers = SampledTextureGetSampledMip_TextureCubeArray_texture_modifiers;
    SampledTextureGetSampledMip_TextureCubeArray_texture.type.modifierValues = SampledTextureGetSampledMip_TextureCubeArray_texture_modifierValues;
    SampledTextureGetSampledMip_TextureCubeArray_coordinate.name = "coordinate"_c;
    SampledTextureGetSampledMip_TextureCubeArray_coordinate.type = Type::FullType{ Float32x4Type.name };
    SampledTextureGetSampledMip_TextureCubeArray.documentation = "Get the mip level of a texture at a specific coordinate. The return value is a vector where the first value is the mip level to sample, and the second is the offset relative to the base mip for which the sample would occur"_c;
    SampledTextureGetSampledMip_TextureCubeArray.name = SampledTextureGetSampledMip_TextureCubeArray_name;
    SampledTextureGetSampledMip_TextureCubeArray.backendIndex = 2322;
    SampledTextureGetSampledMip_TextureCubeArray.returnType = Type::FullType { Float32x2Type.name };
    SampledTextureGetSampledMip_TextureCubeArray.parameters = SampledTextureGetSampledMip_TextureCubeArray_args;
    Symbol::Resolved(&SampledTextureGetSampledMip_TextureCubeArray_texture)->typeSymbol = &SampledTextureCubeArrayType;
    Symbol::Resolved(&SampledTextureGetSampledMip_TextureCubeArray_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&SampledTextureGetSampledMip_TextureCubeArray_coordinate)->typeSymbol = &Float32x4Type;
    Symbol::Resolved(&SampledTextureGetSampledMip_TextureCubeArray)->signature = "textureGetSampledMip(uniform *textureSampledCubeArray,f32x4) f32x2"_c;
    Symbol::Resolved(&SampledTextureGetSampledMip_TextureCubeArray)->name = "textureGetSampledMip(uniform *textureSampledCubeArray,f32x4)"_c;
    Symbol::Resolved(&SampledTextureGetSampledMip_TextureCubeArray)->nameWithVarNames = "textureGetSampledMip(texture : uniform *textureSampledCubeArray, coordinate : f32x4)"_c;
    Symbol::Resolved(&SampledTextureGetSampledMip_TextureCubeArray)->returnTypeSymbol = &Float32x2Type;

    /// textureLoad with Texture1D, Int32
    TextureLoad_Texture1D_texture.name = "texture"_c;
    TextureLoad_Texture1D_texture.type = Type::FullType{ Texture1DType.name };
    TextureLoad_Texture1D_texture.type.strict = true;
    TextureLoad_Texture1D_texture.type.mut = true;
    TextureLoad_Texture1D_texture.type.modifiers = TextureLoad_Texture1D_texture_modifiers;
    TextureLoad_Texture1D_texture.type.modifierValues = TextureLoad_Texture1D_texture_modifierValues;
    TextureLoad_Texture1D_coordinate.name = "coordinate"_c;
    TextureLoad_Texture1D_coordinate.type = Type::FullType{ Int32Type.name };
    TextureLoad_Texture1D.documentation = "Load a single texel without using a sampler value at an absolute non-normalized coordinate"_c;
    TextureLoad_Texture1D.name = TextureLoad_Texture1D_name;
    TextureLoad_Texture1D.backendIndex = 2323;
    TextureLoad_Texture1D.returnType = Type::FullType { Float32x4Type.name };
    TextureLoad_Texture1D.parameters = TextureLoad_Texture1D_args;
    Symbol::Resolved(&TextureLoad_Texture1D_texture)->typeSymbol = &Texture1DType;
    Symbol::Resolved(&TextureLoad_Texture1D_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureLoad_Texture1D_coordinate)->typeSymbol = &Int32Type;
    Symbol::Resolved(&TextureLoad_Texture1D)->signature = "textureLoad(uniform *mutable texture1D,i32) f32x4"_c;
    Symbol::Resolved(&TextureLoad_Texture1D)->name = "textureLoad(uniform *mutable texture1D,i32)"_c;
    Symbol::Resolved(&TextureLoad_Texture1D)->nameWithVarNames = "textureLoad(texture : uniform *mutable texture1D, coordinate : i32)"_c;
    Symbol::Resolved(&TextureLoad_Texture1D)->returnTypeSymbol = &Float32x4Type;

    /// textureLoadMip with Texture1D, Int32, Int32
    TextureLoadMip_Texture1D_texture.name = "texture"_c;
    TextureLoadMip_Texture1D_texture.type = Type::FullType{ Texture1DType.name };
    TextureLoadMip_Texture1D_texture.type.strict = true;
    TextureLoadMip_Texture1D_texture.type.mut = true;
    TextureLoadMip_Texture1D_texture.type.modifiers = TextureLoadMip_Texture1D_texture_modifiers;
    TextureLoadMip_Texture1D_texture.type.modifierValues = TextureLoadMip_Texture1D_texture_modifierValues;
    TextureLoadMip_Texture1D_coordinate.name = "coordinate"_c;
    TextureLoadMip_Texture1D_coordinate.type = Type::FullType{ Int32Type.name };
    TextureLoadMip_Texture1D_mip.name = "mip"_c;
    TextureLoadMip_Texture1D_mip.type = Type::FullType{ Int32Type.name };
    TextureLoadMip_Texture1D.documentation = "Load a single texel without using a sampler value at an absolute non-normalized coordinate at a specific mip level"_c;
    TextureLoadMip_Texture1D.name = TextureLoadMip_Texture1D_name;
    TextureLoadMip_Texture1D.backendIndex = 2324;
    TextureLoadMip_Texture1D.returnType = Type::FullType { Float32x4Type.name };
    TextureLoadMip_Texture1D.parameters = TextureLoadMip_Texture1D_args;
    Symbol::Resolved(&TextureLoadMip_Texture1D_texture)->typeSymbol = &Texture1DType;
    Symbol::Resolved(&TextureLoadMip_Texture1D_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureLoadMip_Texture1D_coordinate)->typeSymbol = &Int32Type;
    Symbol::Resolved(&TextureLoadMip_Texture1D_mip)->typeSymbol = &Int32Type;
    Symbol::Resolved(&TextureLoadMip_Texture1D)->signature = "textureLoadMip(uniform *mutable texture1D,i32,i32) f32x4"_c;
    Symbol::Resolved(&TextureLoadMip_Texture1D)->name = "textureLoadMip(uniform *mutable texture1D,i32,i32)"_c;
    Symbol::Resolved(&TextureLoadMip_Texture1D)->nameWithVarNames = "textureLoadMip(texture : uniform *mutable texture1D, coordinate : i32, mip : i32)"_c;
    Symbol::Resolved(&TextureLoadMip_Texture1D)->returnTypeSymbol = &Float32x4Type;

    /// textureStore with Texture1D, Int32, Float32x4
    TextureStore_Texture1D_texture.name = "texture"_c;
    TextureStore_Texture1D_texture.type = Type::FullType{ Texture1DType.name };
    TextureStore_Texture1D_texture.type.strict = true;
    TextureStore_Texture1D_texture.type.mut = true;
    TextureStore_Texture1D_texture.type.modifiers = TextureStore_Texture1D_texture_modifiers;
    TextureStore_Texture1D_texture.type.modifierValues = TextureStore_Texture1D_texture_modifierValues;
    TextureStore_Texture1D_coordinate.name = "coordinate"_c;
    TextureStore_Texture1D_coordinate.type = Type::FullType{ Int32Type.name };
    TextureStore_Texture1D_value.name = "value"_c;
    TextureStore_Texture1D_value.type = Type::FullType{ Float32x4Type.name };
    TextureStore_Texture1D.documentation = "Store a single texel without using a sampler value at an absolute non-normalized coordinate"_c;
    TextureStore_Texture1D.name = TextureStore_Texture1D_name;
    TextureStore_Texture1D.backendIndex = 2325;
    TextureStore_Texture1D.returnType = Type::FullType { VoidType.name };
    TextureStore_Texture1D.parameters = TextureStore_Texture1D_args;
    Symbol::Resolved(&TextureStore_Texture1D_texture)->typeSymbol = &Texture1DType;
    Symbol::Resolved(&TextureStore_Texture1D_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureStore_Texture1D_coordinate)->typeSymbol = &Int32Type;
    Symbol::Resolved(&TextureStore_Texture1D_value)->typeSymbol = &Float32x4Type;
    Symbol::Resolved(&TextureStore_Texture1D)->signature = "textureStore(uniform *mutable texture1D,i32,f32x4) void"_c;
    Symbol::Resolved(&TextureStore_Texture1D)->name = "textureStore(uniform *mutable texture1D,i32,f32x4)"_c;
    Symbol::Resolved(&TextureStore_Texture1D)->nameWithVarNames = "textureStore(texture : uniform *mutable texture1D, coordinate : i32, value : f32x4)"_c;
    Symbol::Resolved(&TextureStore_Texture1D)->returnTypeSymbol = &VoidType;

    /// textureStoreMip with Texture1D, Int32, Int32, Float32x4
    TextureStoreMip_Texture1D_texture.name = "texture"_c;
    TextureStoreMip_Texture1D_texture.type = Type::FullType{ Texture1DType.name };
    TextureStoreMip_Texture1D_texture.type.strict = true;
    TextureStoreMip_Texture1D_texture.type.mut = true;
    TextureStoreMip_Texture1D_texture.type.modifiers = TextureStoreMip_Texture1D_texture_modifiers;
    TextureStoreMip_Texture1D_texture.type.modifierValues = TextureStoreMip_Texture1D_texture_modifierValues;
    TextureStoreMip_Texture1D_coordinate.name = "coordinate"_c;
    TextureStoreMip_Texture1D_coordinate.type = Type::FullType{ Int32Type.name };
    TextureStoreMip_Texture1D_mip.name = "mip"_c;
    TextureStoreMip_Texture1D_mip.type = Type::FullType{ Int32Type.name };
    TextureStoreMip_Texture1D_value.name = "value"_c;
    TextureStoreMip_Texture1D_value.type = Type::FullType{ Float32x4Type.name };
    TextureStoreMip_Texture1D.documentation = "Store a single texel without using a sampler value at an absolute non-normalized coordinate at a specific mip level"_c;
    TextureStoreMip_Texture1D.name = TextureStoreMip_Texture1D_name;
    TextureStoreMip_Texture1D.backendIndex = 2326;
    TextureStoreMip_Texture1D.returnType = Type::FullType { VoidType.name };
    TextureStoreMip_Texture1D.parameters = TextureStoreMip_Texture1D_args;
    Symbol::Resolved(&TextureStoreMip_Texture1D_texture)->typeSymbol = &Texture1DType;
    Symbol::Resolved(&TextureStoreMip_Texture1D_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureStoreMip_Texture1D_coordinate)->typeSymbol = &Int32Type;
    Symbol::Resolved(&TextureStoreMip_Texture1D_mip)->typeSymbol = &Int32Type;
    Symbol::Resolved(&TextureStoreMip_Texture1D_value)->typeSymbol = &Float32x4Type;
    Symbol::Resolved(&TextureStoreMip_Texture1D)->signature = "textureStoreMip(uniform *mutable texture1D,i32,i32,f32x4) void"_c;
    Symbol::Resolved(&TextureStoreMip_Texture1D)->name = "textureStoreMip(uniform *mutable texture1D,i32,i32,f32x4)"_c;
    Symbol::Resolved(&TextureStoreMip_Texture1D)->nameWithVarNames = "textureStoreMip(texture : uniform *mutable texture1D, coordinate : i32, mip : i32, value : f32x4)"_c;
    Symbol::Resolved(&TextureStoreMip_Texture1D)->returnTypeSymbol = &VoidType;

    /// textureLoad with Texture2D, Int32x2
    TextureLoad_Texture2D_texture.name = "texture"_c;
    TextureLoad_Texture2D_texture.type = Type::FullType{ Texture2DType.name };
    TextureLoad_Texture2D_texture.type.strict = true;
    TextureLoad_Texture2D_texture.type.mut = true;
    TextureLoad_Texture2D_texture.type.modifiers = TextureLoad_Texture2D_texture_modifiers;
    TextureLoad_Texture2D_texture.type.modifierValues = TextureLoad_Texture2D_texture_modifierValues;
    TextureLoad_Texture2D_coordinate.name = "coordinate"_c;
    TextureLoad_Texture2D_coordinate.type = Type::FullType{ Int32x2Type.name };
    TextureLoad_Texture2D.documentation = "Load a single texel without using a sampler value at an absolute non-normalized coordinate"_c;
    TextureLoad_Texture2D.name = TextureLoad_Texture2D_name;
    TextureLoad_Texture2D.backendIndex = 2327;
    TextureLoad_Texture2D.returnType = Type::FullType { Float32x4Type.name };
    TextureLoad_Texture2D.parameters = TextureLoad_Texture2D_args;
    Symbol::Resolved(&TextureLoad_Texture2D_texture)->typeSymbol = &Texture2DType;
    Symbol::Resolved(&TextureLoad_Texture2D_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureLoad_Texture2D_coordinate)->typeSymbol = &Int32x2Type;
    Symbol::Resolved(&TextureLoad_Texture2D)->signature = "textureLoad(uniform *mutable texture2D,i32x2) f32x4"_c;
    Symbol::Resolved(&TextureLoad_Texture2D)->name = "textureLoad(uniform *mutable texture2D,i32x2)"_c;
    Symbol::Resolved(&TextureLoad_Texture2D)->nameWithVarNames = "textureLoad(texture : uniform *mutable texture2D, coordinate : i32x2)"_c;
    Symbol::Resolved(&TextureLoad_Texture2D)->returnTypeSymbol = &Float32x4Type;

    /// textureLoadMip with Texture2D, Int32x2, Int32
    TextureLoadMip_Texture2D_texture.name = "texture"_c;
    TextureLoadMip_Texture2D_texture.type = Type::FullType{ Texture2DType.name };
    TextureLoadMip_Texture2D_texture.type.strict = true;
    TextureLoadMip_Texture2D_texture.type.mut = true;
    TextureLoadMip_Texture2D_texture.type.modifiers = TextureLoadMip_Texture2D_texture_modifiers;
    TextureLoadMip_Texture2D_texture.type.modifierValues = TextureLoadMip_Texture2D_texture_modifierValues;
    TextureLoadMip_Texture2D_coordinate.name = "coordinate"_c;
    TextureLoadMip_Texture2D_coordinate.type = Type::FullType{ Int32x2Type.name };
    TextureLoadMip_Texture2D_mip.name = "mip"_c;
    TextureLoadMip_Texture2D_mip.type = Type::FullType{ Int32Type.name };
    TextureLoadMip_Texture2D.documentation = "Load a single texel without using a sampler value at an absolute non-normalized coordinate at a specific mip level"_c;
    TextureLoadMip_Texture2D.name = TextureLoadMip_Texture2D_name;
    TextureLoadMip_Texture2D.backendIndex = 2328;
    TextureLoadMip_Texture2D.returnType = Type::FullType { Float32x4Type.name };
    TextureLoadMip_Texture2D.parameters = TextureLoadMip_Texture2D_args;
    Symbol::Resolved(&TextureLoadMip_Texture2D_texture)->typeSymbol = &Texture2DType;
    Symbol::Resolved(&TextureLoadMip_Texture2D_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureLoadMip_Texture2D_coordinate)->typeSymbol = &Int32x2Type;
    Symbol::Resolved(&TextureLoadMip_Texture2D_mip)->typeSymbol = &Int32Type;
    Symbol::Resolved(&TextureLoadMip_Texture2D)->signature = "textureLoadMip(uniform *mutable texture2D,i32x2,i32) f32x4"_c;
    Symbol::Resolved(&TextureLoadMip_Texture2D)->name = "textureLoadMip(uniform *mutable texture2D,i32x2,i32)"_c;
    Symbol::Resolved(&TextureLoadMip_Texture2D)->nameWithVarNames = "textureLoadMip(texture : uniform *mutable texture2D, coordinate : i32x2, mip : i32)"_c;
    Symbol::Resolved(&TextureLoadMip_Texture2D)->returnTypeSymbol = &Float32x4Type;

    /// textureStore with Texture2D, Int32x2, Float32x4
    TextureStore_Texture2D_texture.name = "texture"_c;
    TextureStore_Texture2D_texture.type = Type::FullType{ Texture2DType.name };
    TextureStore_Texture2D_texture.type.strict = true;
    TextureStore_Texture2D_texture.type.mut = true;
    TextureStore_Texture2D_texture.type.modifiers = TextureStore_Texture2D_texture_modifiers;
    TextureStore_Texture2D_texture.type.modifierValues = TextureStore_Texture2D_texture_modifierValues;
    TextureStore_Texture2D_coordinate.name = "coordinate"_c;
    TextureStore_Texture2D_coordinate.type = Type::FullType{ Int32x2Type.name };
    TextureStore_Texture2D_value.name = "value"_c;
    TextureStore_Texture2D_value.type = Type::FullType{ Float32x4Type.name };
    TextureStore_Texture2D.documentation = "Store a single texel without using a sampler value at an absolute non-normalized coordinate"_c;
    TextureStore_Texture2D.name = TextureStore_Texture2D_name;
    TextureStore_Texture2D.backendIndex = 2329;
    TextureStore_Texture2D.returnType = Type::FullType { VoidType.name };
    TextureStore_Texture2D.parameters = TextureStore_Texture2D_args;
    Symbol::Resolved(&TextureStore_Texture2D_texture)->typeSymbol = &Texture2DType;
    Symbol::Resolved(&TextureStore_Texture2D_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureStore_Texture2D_coordinate)->typeSymbol = &Int32x2Type;
    Symbol::Resolved(&TextureStore_Texture2D_value)->typeSymbol = &Float32x4Type;
    Symbol::Resolved(&TextureStore_Texture2D)->signature = "textureStore(uniform *mutable texture2D,i32x2,f32x4) void"_c;
    Symbol::Resolved(&TextureStore_Texture2D)->name = "textureStore(uniform *mutable texture2D,i32x2,f32x4)"_c;
    Symbol::Resolved(&TextureStore_Texture2D)->nameWithVarNames = "textureStore(texture : uniform *mutable texture2D, coordinate : i32x2, value : f32x4)"_c;
    Symbol::Resolved(&TextureStore_Texture2D)->returnTypeSymbol = &VoidType;

    /// textureStoreMip with Texture2D, Int32x2, Int32, Float32x4
    TextureStoreMip_Texture2D_texture.name = "texture"_c;
    TextureStoreMip_Texture2D_texture.type = Type::FullType{ Texture2DType.name };
    TextureStoreMip_Texture2D_texture.type.strict = true;
    TextureStoreMip_Texture2D_texture.type.mut = true;
    TextureStoreMip_Texture2D_texture.type.modifiers = TextureStoreMip_Texture2D_texture_modifiers;
    TextureStoreMip_Texture2D_texture.type.modifierValues = TextureStoreMip_Texture2D_texture_modifierValues;
    TextureStoreMip_Texture2D_coordinate.name = "coordinate"_c;
    TextureStoreMip_Texture2D_coordinate.type = Type::FullType{ Int32x2Type.name };
    TextureStoreMip_Texture2D_mip.name = "mip"_c;
    TextureStoreMip_Texture2D_mip.type = Type::FullType{ Int32Type.name };
    TextureStoreMip_Texture2D_value.name = "value"_c;
    TextureStoreMip_Texture2D_value.type = Type::FullType{ Float32x4Type.name };
    TextureStoreMip_Texture2D.documentation = "Store a single texel without using a sampler value at an absolute non-normalized coordinate at a specific mip level"_c;
    TextureStoreMip_Texture2D.name = TextureStoreMip_Texture2D_name;
    TextureStoreMip_Texture2D.backendIndex = 2330;
    TextureStoreMip_Texture2D.returnType = Type::FullType { VoidType.name };
    TextureStoreMip_Texture2D.parameters = TextureStoreMip_Texture2D_args;
    Symbol::Resolved(&TextureStoreMip_Texture2D_texture)->typeSymbol = &Texture2DType;
    Symbol::Resolved(&TextureStoreMip_Texture2D_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureStoreMip_Texture2D_coordinate)->typeSymbol = &Int32x2Type;
    Symbol::Resolved(&TextureStoreMip_Texture2D_mip)->typeSymbol = &Int32Type;
    Symbol::Resolved(&TextureStoreMip_Texture2D_value)->typeSymbol = &Float32x4Type;
    Symbol::Resolved(&TextureStoreMip_Texture2D)->signature = "textureStoreMip(uniform *mutable texture2D,i32x2,i32,f32x4) void"_c;
    Symbol::Resolved(&TextureStoreMip_Texture2D)->name = "textureStoreMip(uniform *mutable texture2D,i32x2,i32,f32x4)"_c;
    Symbol::Resolved(&TextureStoreMip_Texture2D)->nameWithVarNames = "textureStoreMip(texture : uniform *mutable texture2D, coordinate : i32x2, mip : i32, value : f32x4)"_c;
    Symbol::Resolved(&TextureStoreMip_Texture2D)->returnTypeSymbol = &VoidType;

    /// textureLoad with Texture3D, Int32x3
    TextureLoad_Texture3D_texture.name = "texture"_c;
    TextureLoad_Texture3D_texture.type = Type::FullType{ Texture3DType.name };
    TextureLoad_Texture3D_texture.type.strict = true;
    TextureLoad_Texture3D_texture.type.mut = true;
    TextureLoad_Texture3D_texture.type.modifiers = TextureLoad_Texture3D_texture_modifiers;
    TextureLoad_Texture3D_texture.type.modifierValues = TextureLoad_Texture3D_texture_modifierValues;
    TextureLoad_Texture3D_coordinate.name = "coordinate"_c;
    TextureLoad_Texture3D_coordinate.type = Type::FullType{ Int32x3Type.name };
    TextureLoad_Texture3D.documentation = "Load a single texel without using a sampler value at an absolute non-normalized coordinate"_c;
    TextureLoad_Texture3D.name = TextureLoad_Texture3D_name;
    TextureLoad_Texture3D.backendIndex = 2331;
    TextureLoad_Texture3D.returnType = Type::FullType { Float32x4Type.name };
    TextureLoad_Texture3D.parameters = TextureLoad_Texture3D_args;
    Symbol::Resolved(&TextureLoad_Texture3D_texture)->typeSymbol = &Texture3DType;
    Symbol::Resolved(&TextureLoad_Texture3D_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureLoad_Texture3D_coordinate)->typeSymbol = &Int32x3Type;
    Symbol::Resolved(&TextureLoad_Texture3D)->signature = "textureLoad(uniform *mutable texture3D,i32x3) f32x4"_c;
    Symbol::Resolved(&TextureLoad_Texture3D)->name = "textureLoad(uniform *mutable texture3D,i32x3)"_c;
    Symbol::Resolved(&TextureLoad_Texture3D)->nameWithVarNames = "textureLoad(texture : uniform *mutable texture3D, coordinate : i32x3)"_c;
    Symbol::Resolved(&TextureLoad_Texture3D)->returnTypeSymbol = &Float32x4Type;

    /// textureLoadMip with Texture3D, Int32x3, Int32
    TextureLoadMip_Texture3D_texture.name = "texture"_c;
    TextureLoadMip_Texture3D_texture.type = Type::FullType{ Texture3DType.name };
    TextureLoadMip_Texture3D_texture.type.strict = true;
    TextureLoadMip_Texture3D_texture.type.mut = true;
    TextureLoadMip_Texture3D_texture.type.modifiers = TextureLoadMip_Texture3D_texture_modifiers;
    TextureLoadMip_Texture3D_texture.type.modifierValues = TextureLoadMip_Texture3D_texture_modifierValues;
    TextureLoadMip_Texture3D_coordinate.name = "coordinate"_c;
    TextureLoadMip_Texture3D_coordinate.type = Type::FullType{ Int32x3Type.name };
    TextureLoadMip_Texture3D_mip.name = "mip"_c;
    TextureLoadMip_Texture3D_mip.type = Type::FullType{ Int32Type.name };
    TextureLoadMip_Texture3D.documentation = "Load a single texel without using a sampler value at an absolute non-normalized coordinate at a specific mip level"_c;
    TextureLoadMip_Texture3D.name = TextureLoadMip_Texture3D_name;
    TextureLoadMip_Texture3D.backendIndex = 2332;
    TextureLoadMip_Texture3D.returnType = Type::FullType { Float32x4Type.name };
    TextureLoadMip_Texture3D.parameters = TextureLoadMip_Texture3D_args;
    Symbol::Resolved(&TextureLoadMip_Texture3D_texture)->typeSymbol = &Texture3DType;
    Symbol::Resolved(&TextureLoadMip_Texture3D_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureLoadMip_Texture3D_coordinate)->typeSymbol = &Int32x3Type;
    Symbol::Resolved(&TextureLoadMip_Texture3D_mip)->typeSymbol = &Int32Type;
    Symbol::Resolved(&TextureLoadMip_Texture3D)->signature = "textureLoadMip(uniform *mutable texture3D,i32x3,i32) f32x4"_c;
    Symbol::Resolved(&TextureLoadMip_Texture3D)->name = "textureLoadMip(uniform *mutable texture3D,i32x3,i32)"_c;
    Symbol::Resolved(&TextureLoadMip_Texture3D)->nameWithVarNames = "textureLoadMip(texture : uniform *mutable texture3D, coordinate : i32x3, mip : i32)"_c;
    Symbol::Resolved(&TextureLoadMip_Texture3D)->returnTypeSymbol = &Float32x4Type;

    /// textureStore with Texture3D, Int32x3, Float32x4
    TextureStore_Texture3D_texture.name = "texture"_c;
    TextureStore_Texture3D_texture.type = Type::FullType{ Texture3DType.name };
    TextureStore_Texture3D_texture.type.strict = true;
    TextureStore_Texture3D_texture.type.mut = true;
    TextureStore_Texture3D_texture.type.modifiers = TextureStore_Texture3D_texture_modifiers;
    TextureStore_Texture3D_texture.type.modifierValues = TextureStore_Texture3D_texture_modifierValues;
    TextureStore_Texture3D_coordinate.name = "coordinate"_c;
    TextureStore_Texture3D_coordinate.type = Type::FullType{ Int32x3Type.name };
    TextureStore_Texture3D_value.name = "value"_c;
    TextureStore_Texture3D_value.type = Type::FullType{ Float32x4Type.name };
    TextureStore_Texture3D.documentation = "Store a single texel without using a sampler value at an absolute non-normalized coordinate"_c;
    TextureStore_Texture3D.name = TextureStore_Texture3D_name;
    TextureStore_Texture3D.backendIndex = 2333;
    TextureStore_Texture3D.returnType = Type::FullType { VoidType.name };
    TextureStore_Texture3D.parameters = TextureStore_Texture3D_args;
    Symbol::Resolved(&TextureStore_Texture3D_texture)->typeSymbol = &Texture3DType;
    Symbol::Resolved(&TextureStore_Texture3D_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureStore_Texture3D_coordinate)->typeSymbol = &Int32x3Type;
    Symbol::Resolved(&TextureStore_Texture3D_value)->typeSymbol = &Float32x4Type;
    Symbol::Resolved(&TextureStore_Texture3D)->signature = "textureStore(uniform *mutable texture3D,i32x3,f32x4) void"_c;
    Symbol::Resolved(&TextureStore_Texture3D)->name = "textureStore(uniform *mutable texture3D,i32x3,f32x4)"_c;
    Symbol::Resolved(&TextureStore_Texture3D)->nameWithVarNames = "textureStore(texture : uniform *mutable texture3D, coordinate : i32x3, value : f32x4)"_c;
    Symbol::Resolved(&TextureStore_Texture3D)->returnTypeSymbol = &VoidType;

    /// textureStoreMip with Texture3D, Int32x3, Int32, Float32x4
    TextureStoreMip_Texture3D_texture.name = "texture"_c;
    TextureStoreMip_Texture3D_texture.type = Type::FullType{ Texture3DType.name };
    TextureStoreMip_Texture3D_texture.type.strict = true;
    TextureStoreMip_Texture3D_texture.type.mut = true;
    TextureStoreMip_Texture3D_texture.type.modifiers = TextureStoreMip_Texture3D_texture_modifiers;
    TextureStoreMip_Texture3D_texture.type.modifierValues = TextureStoreMip_Texture3D_texture_modifierValues;
    TextureStoreMip_Texture3D_coordinate.name = "coordinate"_c;
    TextureStoreMip_Texture3D_coordinate.type = Type::FullType{ Int32x3Type.name };
    TextureStoreMip_Texture3D_mip.name = "mip"_c;
    TextureStoreMip_Texture3D_mip.type = Type::FullType{ Int32Type.name };
    TextureStoreMip_Texture3D_value.name = "value"_c;
    TextureStoreMip_Texture3D_value.type = Type::FullType{ Float32x4Type.name };
    TextureStoreMip_Texture3D.documentation = "Store a single texel without using a sampler value at an absolute non-normalized coordinate at a specific mip level"_c;
    TextureStoreMip_Texture3D.name = TextureStoreMip_Texture3D_name;
    TextureStoreMip_Texture3D.backendIndex = 2334;
    TextureStoreMip_Texture3D.returnType = Type::FullType { VoidType.name };
    TextureStoreMip_Texture3D.parameters = TextureStoreMip_Texture3D_args;
    Symbol::Resolved(&TextureStoreMip_Texture3D_texture)->typeSymbol = &Texture3DType;
    Symbol::Resolved(&TextureStoreMip_Texture3D_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureStoreMip_Texture3D_coordinate)->typeSymbol = &Int32x3Type;
    Symbol::Resolved(&TextureStoreMip_Texture3D_mip)->typeSymbol = &Int32Type;
    Symbol::Resolved(&TextureStoreMip_Texture3D_value)->typeSymbol = &Float32x4Type;
    Symbol::Resolved(&TextureStoreMip_Texture3D)->signature = "textureStoreMip(uniform *mutable texture3D,i32x3,i32,f32x4) void"_c;
    Symbol::Resolved(&TextureStoreMip_Texture3D)->name = "textureStoreMip(uniform *mutable texture3D,i32x3,i32,f32x4)"_c;
    Symbol::Resolved(&TextureStoreMip_Texture3D)->nameWithVarNames = "textureStoreMip(texture : uniform *mutable texture3D, coordinate : i32x3, mip : i32, value : f32x4)"_c;
    Symbol::Resolved(&TextureStoreMip_Texture3D)->returnTypeSymbol = &VoidType;

    /// textureLoad with TextureCube, Int32x3
    TextureLoad_TextureCube_texture.name = "texture"_c;
    TextureLoad_TextureCube_texture.type = Type::FullType{ TextureCubeType.name };
    TextureLoad_TextureCube_texture.type.strict = true;
    TextureLoad_TextureCube_texture.type.mut = true;
    TextureLoad_TextureCube_texture.type.modifiers = TextureLoad_TextureCube_texture_modifiers;
    TextureLoad_TextureCube_texture.type.modifierValues = TextureLoad_TextureCube_texture_modifierValues;
    TextureLoad_TextureCube_coordinate.name = "coordinate"_c;
    TextureLoad_TextureCube_coordinate.type = Type::FullType{ Int32x3Type.name };
    TextureLoad_TextureCube.documentation = "Load a single texel without using a sampler value at an absolute non-normalized coordinate"_c;
    TextureLoad_TextureCube.name = TextureLoad_TextureCube_name;
    TextureLoad_TextureCube.backendIndex = 2335;
    TextureLoad_TextureCube.returnType = Type::FullType { Float32x4Type.name };
    TextureLoad_TextureCube.parameters = TextureLoad_TextureCube_args;
    Symbol::Resolved(&TextureLoad_TextureCube_texture)->typeSymbol = &TextureCubeType;
    Symbol::Resolved(&TextureLoad_TextureCube_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureLoad_TextureCube_coordinate)->typeSymbol = &Int32x3Type;
    Symbol::Resolved(&TextureLoad_TextureCube)->signature = "textureLoad(uniform *mutable textureCube,i32x3) f32x4"_c;
    Symbol::Resolved(&TextureLoad_TextureCube)->name = "textureLoad(uniform *mutable textureCube,i32x3)"_c;
    Symbol::Resolved(&TextureLoad_TextureCube)->nameWithVarNames = "textureLoad(texture : uniform *mutable textureCube, coordinate : i32x3)"_c;
    Symbol::Resolved(&TextureLoad_TextureCube)->returnTypeSymbol = &Float32x4Type;

    /// textureLoadMip with TextureCube, Int32x3, Int32
    TextureLoadMip_TextureCube_texture.name = "texture"_c;
    TextureLoadMip_TextureCube_texture.type = Type::FullType{ TextureCubeType.name };
    TextureLoadMip_TextureCube_texture.type.strict = true;
    TextureLoadMip_TextureCube_texture.type.mut = true;
    TextureLoadMip_TextureCube_texture.type.modifiers = TextureLoadMip_TextureCube_texture_modifiers;
    TextureLoadMip_TextureCube_texture.type.modifierValues = TextureLoadMip_TextureCube_texture_modifierValues;
    TextureLoadMip_TextureCube_coordinate.name = "coordinate"_c;
    TextureLoadMip_TextureCube_coordinate.type = Type::FullType{ Int32x3Type.name };
    TextureLoadMip_TextureCube_mip.name = "mip"_c;
    TextureLoadMip_TextureCube_mip.type = Type::FullType{ Int32Type.name };
    TextureLoadMip_TextureCube.documentation = "Load a single texel without using a sampler value at an absolute non-normalized coordinate at a specific mip level"_c;
    TextureLoadMip_TextureCube.name = TextureLoadMip_TextureCube_name;
    TextureLoadMip_TextureCube.backendIndex = 2336;
    TextureLoadMip_TextureCube.returnType = Type::FullType { Float32x4Type.name };
    TextureLoadMip_TextureCube.parameters = TextureLoadMip_TextureCube_args;
    Symbol::Resolved(&TextureLoadMip_TextureCube_texture)->typeSymbol = &TextureCubeType;
    Symbol::Resolved(&TextureLoadMip_TextureCube_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureLoadMip_TextureCube_coordinate)->typeSymbol = &Int32x3Type;
    Symbol::Resolved(&TextureLoadMip_TextureCube_mip)->typeSymbol = &Int32Type;
    Symbol::Resolved(&TextureLoadMip_TextureCube)->signature = "textureLoadMip(uniform *mutable textureCube,i32x3,i32) f32x4"_c;
    Symbol::Resolved(&TextureLoadMip_TextureCube)->name = "textureLoadMip(uniform *mutable textureCube,i32x3,i32)"_c;
    Symbol::Resolved(&TextureLoadMip_TextureCube)->nameWithVarNames = "textureLoadMip(texture : uniform *mutable textureCube, coordinate : i32x3, mip : i32)"_c;
    Symbol::Resolved(&TextureLoadMip_TextureCube)->returnTypeSymbol = &Float32x4Type;

    /// textureStore with TextureCube, Int32x3, Float32x4
    TextureStore_TextureCube_texture.name = "texture"_c;
    TextureStore_TextureCube_texture.type = Type::FullType{ TextureCubeType.name };
    TextureStore_TextureCube_texture.type.strict = true;
    TextureStore_TextureCube_texture.type.mut = true;
    TextureStore_TextureCube_texture.type.modifiers = TextureStore_TextureCube_texture_modifiers;
    TextureStore_TextureCube_texture.type.modifierValues = TextureStore_TextureCube_texture_modifierValues;
    TextureStore_TextureCube_coordinate.name = "coordinate"_c;
    TextureStore_TextureCube_coordinate.type = Type::FullType{ Int32x3Type.name };
    TextureStore_TextureCube_value.name = "value"_c;
    TextureStore_TextureCube_value.type = Type::FullType{ Float32x4Type.name };
    TextureStore_TextureCube.documentation = "Store a single texel without using a sampler value at an absolute non-normalized coordinate"_c;
    TextureStore_TextureCube.name = TextureStore_TextureCube_name;
    TextureStore_TextureCube.backendIndex = 2337;
    TextureStore_TextureCube.returnType = Type::FullType { VoidType.name };
    TextureStore_TextureCube.parameters = TextureStore_TextureCube_args;
    Symbol::Resolved(&TextureStore_TextureCube_texture)->typeSymbol = &TextureCubeType;
    Symbol::Resolved(&TextureStore_TextureCube_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureStore_TextureCube_coordinate)->typeSymbol = &Int32x3Type;
    Symbol::Resolved(&TextureStore_TextureCube_value)->typeSymbol = &Float32x4Type;
    Symbol::Resolved(&TextureStore_TextureCube)->signature = "textureStore(uniform *mutable textureCube,i32x3,f32x4) void"_c;
    Symbol::Resolved(&TextureStore_TextureCube)->name = "textureStore(uniform *mutable textureCube,i32x3,f32x4)"_c;
    Symbol::Resolved(&TextureStore_TextureCube)->nameWithVarNames = "textureStore(texture : uniform *mutable textureCube, coordinate : i32x3, value : f32x4)"_c;
    Symbol::Resolved(&TextureStore_TextureCube)->returnTypeSymbol = &VoidType;

    /// textureStoreMip with TextureCube, Int32x3, Int32, Float32x4
    TextureStoreMip_TextureCube_texture.name = "texture"_c;
    TextureStoreMip_TextureCube_texture.type = Type::FullType{ TextureCubeType.name };
    TextureStoreMip_TextureCube_texture.type.strict = true;
    TextureStoreMip_TextureCube_texture.type.mut = true;
    TextureStoreMip_TextureCube_texture.type.modifiers = TextureStoreMip_TextureCube_texture_modifiers;
    TextureStoreMip_TextureCube_texture.type.modifierValues = TextureStoreMip_TextureCube_texture_modifierValues;
    TextureStoreMip_TextureCube_coordinate.name = "coordinate"_c;
    TextureStoreMip_TextureCube_coordinate.type = Type::FullType{ Int32x3Type.name };
    TextureStoreMip_TextureCube_mip.name = "mip"_c;
    TextureStoreMip_TextureCube_mip.type = Type::FullType{ Int32Type.name };
    TextureStoreMip_TextureCube_value.name = "value"_c;
    TextureStoreMip_TextureCube_value.type = Type::FullType{ Float32x4Type.name };
    TextureStoreMip_TextureCube.documentation = "Store a single texel without using a sampler value at an absolute non-normalized coordinate at a specific mip level"_c;
    TextureStoreMip_TextureCube.name = TextureStoreMip_TextureCube_name;
    TextureStoreMip_TextureCube.backendIndex = 2338;
    TextureStoreMip_TextureCube.returnType = Type::FullType { VoidType.name };
    TextureStoreMip_TextureCube.parameters = TextureStoreMip_TextureCube_args;
    Symbol::Resolved(&TextureStoreMip_TextureCube_texture)->typeSymbol = &TextureCubeType;
    Symbol::Resolved(&TextureStoreMip_TextureCube_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureStoreMip_TextureCube_coordinate)->typeSymbol = &Int32x3Type;
    Symbol::Resolved(&TextureStoreMip_TextureCube_mip)->typeSymbol = &Int32Type;
    Symbol::Resolved(&TextureStoreMip_TextureCube_value)->typeSymbol = &Float32x4Type;
    Symbol::Resolved(&TextureStoreMip_TextureCube)->signature = "textureStoreMip(uniform *mutable textureCube,i32x3,i32,f32x4) void"_c;
    Symbol::Resolved(&TextureStoreMip_TextureCube)->name = "textureStoreMip(uniform *mutable textureCube,i32x3,i32,f32x4)"_c;
    Symbol::Resolved(&TextureStoreMip_TextureCube)->nameWithVarNames = "textureStoreMip(texture : uniform *mutable textureCube, coordinate : i32x3, mip : i32, value : f32x4)"_c;
    Symbol::Resolved(&TextureStoreMip_TextureCube)->returnTypeSymbol = &VoidType;

    /// textureLoad with Texture1DArray, Int32x2
    TextureLoad_Texture1DArray_texture.name = "texture"_c;
    TextureLoad_Texture1DArray_texture.type = Type::FullType{ Texture1DArrayType.name };
    TextureLoad_Texture1DArray_texture.type.strict = true;
    TextureLoad_Texture1DArray_texture.type.mut = true;
    TextureLoad_Texture1DArray_texture.type.modifiers = TextureLoad_Texture1DArray_texture_modifiers;
    TextureLoad_Texture1DArray_texture.type.modifierValues = TextureLoad_Texture1DArray_texture_modifierValues;
    TextureLoad_Texture1DArray_coordinate.name = "coordinate"_c;
    TextureLoad_Texture1DArray_coordinate.type = Type::FullType{ Int32x2Type.name };
    TextureLoad_Texture1DArray.documentation = "Load a single texel without using a sampler value at an absolute non-normalized coordinate"_c;
    TextureLoad_Texture1DArray.name = TextureLoad_Texture1DArray_name;
    TextureLoad_Texture1DArray.backendIndex = 2339;
    TextureLoad_Texture1DArray.returnType = Type::FullType { Float32x4Type.name };
    TextureLoad_Texture1DArray.parameters = TextureLoad_Texture1DArray_args;
    Symbol::Resolved(&TextureLoad_Texture1DArray_texture)->typeSymbol = &Texture1DArrayType;
    Symbol::Resolved(&TextureLoad_Texture1DArray_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureLoad_Texture1DArray_coordinate)->typeSymbol = &Int32x2Type;
    Symbol::Resolved(&TextureLoad_Texture1DArray)->signature = "textureLoad(uniform *mutable texture1DArray,i32x2) f32x4"_c;
    Symbol::Resolved(&TextureLoad_Texture1DArray)->name = "textureLoad(uniform *mutable texture1DArray,i32x2)"_c;
    Symbol::Resolved(&TextureLoad_Texture1DArray)->nameWithVarNames = "textureLoad(texture : uniform *mutable texture1DArray, coordinate : i32x2)"_c;
    Symbol::Resolved(&TextureLoad_Texture1DArray)->returnTypeSymbol = &Float32x4Type;

    /// textureLoadMip with Texture1DArray, Int32x2, Int32
    TextureLoadMip_Texture1DArray_texture.name = "texture"_c;
    TextureLoadMip_Texture1DArray_texture.type = Type::FullType{ Texture1DArrayType.name };
    TextureLoadMip_Texture1DArray_texture.type.strict = true;
    TextureLoadMip_Texture1DArray_texture.type.mut = true;
    TextureLoadMip_Texture1DArray_texture.type.modifiers = TextureLoadMip_Texture1DArray_texture_modifiers;
    TextureLoadMip_Texture1DArray_texture.type.modifierValues = TextureLoadMip_Texture1DArray_texture_modifierValues;
    TextureLoadMip_Texture1DArray_coordinate.name = "coordinate"_c;
    TextureLoadMip_Texture1DArray_coordinate.type = Type::FullType{ Int32x2Type.name };
    TextureLoadMip_Texture1DArray_mip.name = "mip"_c;
    TextureLoadMip_Texture1DArray_mip.type = Type::FullType{ Int32Type.name };
    TextureLoadMip_Texture1DArray.documentation = "Load a single texel without using a sampler value at an absolute non-normalized coordinate at a specific mip level"_c;
    TextureLoadMip_Texture1DArray.name = TextureLoadMip_Texture1DArray_name;
    TextureLoadMip_Texture1DArray.backendIndex = 2340;
    TextureLoadMip_Texture1DArray.returnType = Type::FullType { Float32x4Type.name };
    TextureLoadMip_Texture1DArray.parameters = TextureLoadMip_Texture1DArray_args;
    Symbol::Resolved(&TextureLoadMip_Texture1DArray_texture)->typeSymbol = &Texture1DArrayType;
    Symbol::Resolved(&TextureLoadMip_Texture1DArray_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureLoadMip_Texture1DArray_coordinate)->typeSymbol = &Int32x2Type;
    Symbol::Resolved(&TextureLoadMip_Texture1DArray_mip)->typeSymbol = &Int32Type;
    Symbol::Resolved(&TextureLoadMip_Texture1DArray)->signature = "textureLoadMip(uniform *mutable texture1DArray,i32x2,i32) f32x4"_c;
    Symbol::Resolved(&TextureLoadMip_Texture1DArray)->name = "textureLoadMip(uniform *mutable texture1DArray,i32x2,i32)"_c;
    Symbol::Resolved(&TextureLoadMip_Texture1DArray)->nameWithVarNames = "textureLoadMip(texture : uniform *mutable texture1DArray, coordinate : i32x2, mip : i32)"_c;
    Symbol::Resolved(&TextureLoadMip_Texture1DArray)->returnTypeSymbol = &Float32x4Type;

    /// textureStore with Texture1DArray, Int32x2, Float32x4
    TextureStore_Texture1DArray_texture.name = "texture"_c;
    TextureStore_Texture1DArray_texture.type = Type::FullType{ Texture1DArrayType.name };
    TextureStore_Texture1DArray_texture.type.strict = true;
    TextureStore_Texture1DArray_texture.type.mut = true;
    TextureStore_Texture1DArray_texture.type.modifiers = TextureStore_Texture1DArray_texture_modifiers;
    TextureStore_Texture1DArray_texture.type.modifierValues = TextureStore_Texture1DArray_texture_modifierValues;
    TextureStore_Texture1DArray_coordinate.name = "coordinate"_c;
    TextureStore_Texture1DArray_coordinate.type = Type::FullType{ Int32x2Type.name };
    TextureStore_Texture1DArray_value.name = "value"_c;
    TextureStore_Texture1DArray_value.type = Type::FullType{ Float32x4Type.name };
    TextureStore_Texture1DArray.documentation = "Store a single texel without using a sampler value at an absolute non-normalized coordinate"_c;
    TextureStore_Texture1DArray.name = TextureStore_Texture1DArray_name;
    TextureStore_Texture1DArray.backendIndex = 2341;
    TextureStore_Texture1DArray.returnType = Type::FullType { VoidType.name };
    TextureStore_Texture1DArray.parameters = TextureStore_Texture1DArray_args;
    Symbol::Resolved(&TextureStore_Texture1DArray_texture)->typeSymbol = &Texture1DArrayType;
    Symbol::Resolved(&TextureStore_Texture1DArray_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureStore_Texture1DArray_coordinate)->typeSymbol = &Int32x2Type;
    Symbol::Resolved(&TextureStore_Texture1DArray_value)->typeSymbol = &Float32x4Type;
    Symbol::Resolved(&TextureStore_Texture1DArray)->signature = "textureStore(uniform *mutable texture1DArray,i32x2,f32x4) void"_c;
    Symbol::Resolved(&TextureStore_Texture1DArray)->name = "textureStore(uniform *mutable texture1DArray,i32x2,f32x4)"_c;
    Symbol::Resolved(&TextureStore_Texture1DArray)->nameWithVarNames = "textureStore(texture : uniform *mutable texture1DArray, coordinate : i32x2, value : f32x4)"_c;
    Symbol::Resolved(&TextureStore_Texture1DArray)->returnTypeSymbol = &VoidType;

    /// textureStoreMip with Texture1DArray, Int32x2, Int32, Float32x4
    TextureStoreMip_Texture1DArray_texture.name = "texture"_c;
    TextureStoreMip_Texture1DArray_texture.type = Type::FullType{ Texture1DArrayType.name };
    TextureStoreMip_Texture1DArray_texture.type.strict = true;
    TextureStoreMip_Texture1DArray_texture.type.mut = true;
    TextureStoreMip_Texture1DArray_texture.type.modifiers = TextureStoreMip_Texture1DArray_texture_modifiers;
    TextureStoreMip_Texture1DArray_texture.type.modifierValues = TextureStoreMip_Texture1DArray_texture_modifierValues;
    TextureStoreMip_Texture1DArray_coordinate.name = "coordinate"_c;
    TextureStoreMip_Texture1DArray_coordinate.type = Type::FullType{ Int32x2Type.name };
    TextureStoreMip_Texture1DArray_mip.name = "mip"_c;
    TextureStoreMip_Texture1DArray_mip.type = Type::FullType{ Int32Type.name };
    TextureStoreMip_Texture1DArray_value.name = "value"_c;
    TextureStoreMip_Texture1DArray_value.type = Type::FullType{ Float32x4Type.name };
    TextureStoreMip_Texture1DArray.documentation = "Store a single texel without using a sampler value at an absolute non-normalized coordinate at a specific mip level"_c;
    TextureStoreMip_Texture1DArray.name = TextureStoreMip_Texture1DArray_name;
    TextureStoreMip_Texture1DArray.backendIndex = 2342;
    TextureStoreMip_Texture1DArray.returnType = Type::FullType { VoidType.name };
    TextureStoreMip_Texture1DArray.parameters = TextureStoreMip_Texture1DArray_args;
    Symbol::Resolved(&TextureStoreMip_Texture1DArray_texture)->typeSymbol = &Texture1DArrayType;
    Symbol::Resolved(&TextureStoreMip_Texture1DArray_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureStoreMip_Texture1DArray_coordinate)->typeSymbol = &Int32x2Type;
    Symbol::Resolved(&TextureStoreMip_Texture1DArray_mip)->typeSymbol = &Int32Type;
    Symbol::Resolved(&TextureStoreMip_Texture1DArray_value)->typeSymbol = &Float32x4Type;
    Symbol::Resolved(&TextureStoreMip_Texture1DArray)->signature = "textureStoreMip(uniform *mutable texture1DArray,i32x2,i32,f32x4) void"_c;
    Symbol::Resolved(&TextureStoreMip_Texture1DArray)->name = "textureStoreMip(uniform *mutable texture1DArray,i32x2,i32,f32x4)"_c;
    Symbol::Resolved(&TextureStoreMip_Texture1DArray)->nameWithVarNames = "textureStoreMip(texture : uniform *mutable texture1DArray, coordinate : i32x2, mip : i32, value : f32x4)"_c;
    Symbol::Resolved(&TextureStoreMip_Texture1DArray)->returnTypeSymbol = &VoidType;

    /// textureLoad with Texture2DArray, Int32x3
    TextureLoad_Texture2DArray_texture.name = "texture"_c;
    TextureLoad_Texture2DArray_texture.type = Type::FullType{ Texture2DArrayType.name };
    TextureLoad_Texture2DArray_texture.type.strict = true;
    TextureLoad_Texture2DArray_texture.type.mut = true;
    TextureLoad_Texture2DArray_texture.type.modifiers = TextureLoad_Texture2DArray_texture_modifiers;
    TextureLoad_Texture2DArray_texture.type.modifierValues = TextureLoad_Texture2DArray_texture_modifierValues;
    TextureLoad_Texture2DArray_coordinate.name = "coordinate"_c;
    TextureLoad_Texture2DArray_coordinate.type = Type::FullType{ Int32x3Type.name };
    TextureLoad_Texture2DArray.documentation = "Load a single texel without using a sampler value at an absolute non-normalized coordinate"_c;
    TextureLoad_Texture2DArray.name = TextureLoad_Texture2DArray_name;
    TextureLoad_Texture2DArray.backendIndex = 2343;
    TextureLoad_Texture2DArray.returnType = Type::FullType { Float32x4Type.name };
    TextureLoad_Texture2DArray.parameters = TextureLoad_Texture2DArray_args;
    Symbol::Resolved(&TextureLoad_Texture2DArray_texture)->typeSymbol = &Texture2DArrayType;
    Symbol::Resolved(&TextureLoad_Texture2DArray_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureLoad_Texture2DArray_coordinate)->typeSymbol = &Int32x3Type;
    Symbol::Resolved(&TextureLoad_Texture2DArray)->signature = "textureLoad(uniform *mutable texture2DArray,i32x3) f32x4"_c;
    Symbol::Resolved(&TextureLoad_Texture2DArray)->name = "textureLoad(uniform *mutable texture2DArray,i32x3)"_c;
    Symbol::Resolved(&TextureLoad_Texture2DArray)->nameWithVarNames = "textureLoad(texture : uniform *mutable texture2DArray, coordinate : i32x3)"_c;
    Symbol::Resolved(&TextureLoad_Texture2DArray)->returnTypeSymbol = &Float32x4Type;

    /// textureLoadMip with Texture2DArray, Int32x3, Int32
    TextureLoadMip_Texture2DArray_texture.name = "texture"_c;
    TextureLoadMip_Texture2DArray_texture.type = Type::FullType{ Texture2DArrayType.name };
    TextureLoadMip_Texture2DArray_texture.type.strict = true;
    TextureLoadMip_Texture2DArray_texture.type.mut = true;
    TextureLoadMip_Texture2DArray_texture.type.modifiers = TextureLoadMip_Texture2DArray_texture_modifiers;
    TextureLoadMip_Texture2DArray_texture.type.modifierValues = TextureLoadMip_Texture2DArray_texture_modifierValues;
    TextureLoadMip_Texture2DArray_coordinate.name = "coordinate"_c;
    TextureLoadMip_Texture2DArray_coordinate.type = Type::FullType{ Int32x3Type.name };
    TextureLoadMip_Texture2DArray_mip.name = "mip"_c;
    TextureLoadMip_Texture2DArray_mip.type = Type::FullType{ Int32Type.name };
    TextureLoadMip_Texture2DArray.documentation = "Load a single texel without using a sampler value at an absolute non-normalized coordinate at a specific mip level"_c;
    TextureLoadMip_Texture2DArray.name = TextureLoadMip_Texture2DArray_name;
    TextureLoadMip_Texture2DArray.backendIndex = 2344;
    TextureLoadMip_Texture2DArray.returnType = Type::FullType { Float32x4Type.name };
    TextureLoadMip_Texture2DArray.parameters = TextureLoadMip_Texture2DArray_args;
    Symbol::Resolved(&TextureLoadMip_Texture2DArray_texture)->typeSymbol = &Texture2DArrayType;
    Symbol::Resolved(&TextureLoadMip_Texture2DArray_texture)->storage = Storage::Uniform;
    Symbol::Resolved(&TextureLoadMip_Texture2DArray_coordinate)->typeSymbol = &Int32x3Type;
    Symbol::Resolved(&TextureLoadMip_Texture2DArray_mip)->typeSymbol = &Int32Type;
    Symbol::Resolved(&TextureLoadMip_Texture2DArray)->signature = "textureLoadMip(uniform *mutable texture2DArray,i32x3,i32) f32x4"_c;
    Symbol::Resolved(&TextureLoadMip_Texture2DArray)->name = "textureLoadMip(uniform *mutable texture2DArray,i32x3,i32)"_c;
    Symbol::Resolved(&TextureLoadMip_Texture2DArray)->nameWithVarNames = "textureLoadMip(texture : uniform *mutable texture2DArray, coordinate : i32x3, mip : i32)"_c;
    Symbol::Resolved(&TextureLoadMip_Texture2DArray)->returnTypeSymbol = &Float32x4Type;

}
} // namespace GPULang
