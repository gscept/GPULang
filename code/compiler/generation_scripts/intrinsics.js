[
    {
        "name": "f32",
        "documentation": "Convert from u32 to f32",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "f32(u32) f32",
            "f32(i32) f32",
            "f32(b8) f32",
            "f32(f16) f32",
            "f32(u16) f32",
            "f32(i16) f32",
            "f32(f32) f32"
        ]
    },
    {
        "name": "u32",
        "documentation": "Convert from f32 to u32",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "u32(f32) u32",
            "u32(i32) u32",
            "u32(b8) u32",
            "u32(f16) u32",
            "u32(u16) u32",
            "u32(i16) u32",
            "u32(u32) u32"
        ]
    },
    {
        "name": "i32",
        "documentation": "Convert from f32 to i32",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "i32(f32) i32",
            "i32(u32) i32",
            "i32(b8) i32",
            "i32(f16) i32",
            "i32(u16) i32",
            "i32(i16) i32",
            "i32(i32) i32"
        ]
    },
    {
        "name": "b8",
        "documentation": "Convert from u32 to b8",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "b8(u32) b8",
            "b8(i32) b8",
            "b8(u16) b8",
            "b8(i16) b8",
            "b8(b8) b8"
        ]
    },
    {
        "name": "f16",
        "documentation": "Convert from f32 to f16",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "f16(f32) f16",
            "f16(u32) f16",
            "f16(i32) f16",
            "f16(b8) f16",
            "f16(u16) f16",
            "f16(i16) f16",
            "f16(f16) f16"
        ]
    },
    {
        "name": "u16",
        "documentation": "Convert from f32 to u16",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "u16(f32) u16",
            "u16(u32) u16",
            "u16(i32) u16",
            "u16(b8) u16",
            "u16(f16) u16",
            "u16(i16) u16",
            "u16(u16) u16"
        ]
    },
    {
        "name": "i16",
        "documentation": "Convert from f32 to i16",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "i16(f32) i16",
            "i16(u32) i16",
            "i16(i32) i16",
            "i16(b8) i16",
            "i16(f16) i16",
            "i16(u16) i16",
            "i16(i16) i16"
        ]
    },
    {
        "name": "f32x2",
        "documentation": "Convert from f32x2 to f32x2",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "f32x2(f32x2) f32x2",
            "f32x2(f32) f32x2",
            "f32x2(u32x2) f32x2",
            "f32x2(u32) f32x2",
            "f32x2(i32x2) f32x2",
            "f32x2(i32) f32x2",
            "f32x2(b8x2) f32x2",
            "f32x2(b8) f32x2",
            "f32x2(f16x2) f32x2",
            "f32x2(f16) f32x2",
            "f32x2(u16x2) f32x2",
            "f32x2(u16) f32x2",
            "f32x2(i16x2) f32x2",
            "f32x2(i16) f32x2",
            "f32x2(f32, f32) f32x2"
        ]
    },
    {
        "name": "u32x2",
        "documentation": "Convert from f32x2 to u32x2",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "u32x2(f32x2) u32x2",
            "u32x2(f32) u32x2",
            "u32x2(u32x2) u32x2",
            "u32x2(u32) u32x2",
            "u32x2(i32x2) u32x2",
            "u32x2(i32) u32x2",
            "u32x2(b8x2) u32x2",
            "u32x2(b8) u32x2",
            "u32x2(f16x2) u32x2",
            "u32x2(f16) u32x2",
            "u32x2(u16x2) u32x2",
            "u32x2(u16) u32x2",
            "u32x2(i16x2) u32x2",
            "u32x2(i16) u32x2",
            "u32x2(u32, u32) u32x2"
        ]
    },
    {
        "name": "i32x2",
        "documentation": "Convert from f32x2 to i32x2",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "i32x2(f32x2) i32x2",
            "i32x2(f32) i32x2",
            "i32x2(u32x2) i32x2",
            "i32x2(u32) i32x2",
            "i32x2(i32x2) i32x2",
            "i32x2(i32) i32x2",
            "i32x2(b8x2) i32x2",
            "i32x2(b8) i32x2",
            "i32x2(f16x2) i32x2",
            "i32x2(f16) i32x2",
            "i32x2(u16x2) i32x2",
            "i32x2(u16) i32x2",
            "i32x2(i16x2) i32x2",
            "i32x2(i16) i32x2",
            "i32x2(i32, i32) i32x2"
        ]
    },
    {
        "name": "b8x2",
        "documentation": "Convert from u32x2 to b8x2",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "b8x2(u32x2) b8x2",
            "b8x2(u32) b8x2",
            "b8x2(i32x2) b8x2",
            "b8x2(i32) b8x2",
            "b8x2(b8x2) b8x2",
            "b8x2(b8) b8x2",
            "b8x2(u16x2) b8x2",
            "b8x2(u16) b8x2",
            "b8x2(i16x2) b8x2",
            "b8x2(i16) b8x2",
            "b8x2(b8, b8) b8x2"
        ]
    },
    {
        "name": "f16x2",
        "documentation": "Convert from f32x2 to f16x2",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "f16x2(f32x2) f16x2",
            "f16x2(f32) f16x2",
            "f16x2(u32x2) f16x2",
            "f16x2(u32) f16x2",
            "f16x2(i32x2) f16x2",
            "f16x2(i32) f16x2",
            "f16x2(b8x2) f16x2",
            "f16x2(b8) f16x2",
            "f16x2(f16x2) f16x2",
            "f16x2(f16) f16x2",
            "f16x2(u16x2) f16x2",
            "f16x2(u16) f16x2",
            "f16x2(i16x2) f16x2",
            "f16x2(i16) f16x2",
            "f16x2(f16, f16) f16x2"
        ]
    },
    {
        "name": "u16x2",
        "documentation": "Convert from f32x2 to u16x2",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "u16x2(f32x2) u16x2",
            "u16x2(f32) u16x2",
            "u16x2(u32x2) u16x2",
            "u16x2(u32) u16x2",
            "u16x2(i32x2) u16x2",
            "u16x2(i32) u16x2",
            "u16x2(b8x2) u16x2",
            "u16x2(b8) u16x2",
            "u16x2(f16x2) u16x2",
            "u16x2(f16) u16x2",
            "u16x2(u16x2) u16x2",
            "u16x2(u16) u16x2",
            "u16x2(i16x2) u16x2",
            "u16x2(i16) u16x2",
            "u16x2(u16, u16) u16x2"
        ]
    },
    {
        "name": "i16x2",
        "documentation": "Convert from f32x2 to i16x2",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "i16x2(f32x2) i16x2",
            "i16x2(f32) i16x2",
            "i16x2(u32x2) i16x2",
            "i16x2(u32) i16x2",
            "i16x2(i32x2) i16x2",
            "i16x2(i32) i16x2",
            "i16x2(b8x2) i16x2",
            "i16x2(b8) i16x2",
            "i16x2(f16x2) i16x2",
            "i16x2(f16) i16x2",
            "i16x2(u16x2) i16x2",
            "i16x2(u16) i16x2",
            "i16x2(i16x2) i16x2",
            "i16x2(i16) i16x2",
            "i16x2(i16, i16) i16x2"
        ]
    },
    {
        "name": "f32x3",
        "documentation": "Convert from f32x3 to f32x3",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "f32x3(f32x3) f32x3",
            "f32x3(f32) f32x3",
            "f32x3(u32x3) f32x3",
            "f32x3(u32) f32x3",
            "f32x3(i32x3) f32x3",
            "f32x3(i32) f32x3",
            "f32x3(b8x3) f32x3",
            "f32x3(b8) f32x3",
            "f32x3(f16x3) f32x3",
            "f32x3(f16) f32x3",
            "f32x3(u16x3) f32x3",
            "f32x3(u16) f32x3",
            "f32x3(i16x3) f32x3",
            "f32x3(i16) f32x3",
            "f32x3(f32, f32, f32) f32x3",
            "f32x3(f32x2, f32) f32x3",
            "f32x3(f32, f32x2) f32x3"
        ]
    },
    {
        "name": "u32x3",
        "documentation": "Convert from f32x3 to u32x3",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "u32x3(f32x3) u32x3",
            "u32x3(f32) u32x3",
            "u32x3(u32x3) u32x3",
            "u32x3(u32) u32x3",
            "u32x3(i32x3) u32x3",
            "u32x3(i32) u32x3",
            "u32x3(b8x3) u32x3",
            "u32x3(b8) u32x3",
            "u32x3(f16x3) u32x3",
            "u32x3(f16) u32x3",
            "u32x3(u16x3) u32x3",
            "u32x3(u16) u32x3",
            "u32x3(i16x3) u32x3",
            "u32x3(i16) u32x3",
            "u32x3(u32, u32, u32) u32x3",
            "u32x3(u32x2, u32) u32x3",
            "u32x3(u32, u32x2) u32x3"
        ]
    },
    {
        "name": "i32x3",
        "documentation": "Convert from f32x3 to i32x3",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "i32x3(f32x3) i32x3",
            "i32x3(f32) i32x3",
            "i32x3(u32x3) i32x3",
            "i32x3(u32) i32x3",
            "i32x3(i32x3) i32x3",
            "i32x3(i32) i32x3",
            "i32x3(b8x3) i32x3",
            "i32x3(b8) i32x3",
            "i32x3(f16x3) i32x3",
            "i32x3(f16) i32x3",
            "i32x3(u16x3) i32x3",
            "i32x3(u16) i32x3",
            "i32x3(i16x3) i32x3",
            "i32x3(i16) i32x3",
            "i32x3(i32, i32, i32) i32x3",
            "i32x3(i32x2, i32) i32x3",
            "i32x3(i32, i32x2) i32x3"
        ]
    },
    {
        "name": "b8x3",
        "documentation": "Convert from u32x3 to b8x3",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "b8x3(u32x3) b8x3",
            "b8x3(u32) b8x3",
            "b8x3(i32x3) b8x3",
            "b8x3(i32) b8x3",
            "b8x3(b8x3) b8x3",
            "b8x3(b8) b8x3",
            "b8x3(u16x3) b8x3",
            "b8x3(u16) b8x3",
            "b8x3(i16x3) b8x3",
            "b8x3(i16) b8x3",
            "b8x3(b8, b8, b8) b8x3",
            "b8x3(b8x2, b8) b8x3",
            "b8x3(b8, b8x2) b8x3"
        ]
    },
    {
        "name": "f16x3",
        "documentation": "Convert from f32x3 to f16x3",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "f16x3(f32x3) f16x3",
            "f16x3(f32) f16x3",
            "f16x3(u32x3) f16x3",
            "f16x3(u32) f16x3",
            "f16x3(i32x3) f16x3",
            "f16x3(i32) f16x3",
            "f16x3(b8x3) f16x3",
            "f16x3(b8) f16x3",
            "f16x3(f16x3) f16x3",
            "f16x3(f16) f16x3",
            "f16x3(u16x3) f16x3",
            "f16x3(u16) f16x3",
            "f16x3(i16x3) f16x3",
            "f16x3(i16) f16x3",
            "f16x3(f16, f16, f16) f16x3",
            "f16x3(f16x2, f16) f16x3",
            "f16x3(f16, f16x2) f16x3"
        ]
    },
    {
        "name": "u16x3",
        "documentation": "Convert from f32x3 to u16x3",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "u16x3(f32x3) u16x3",
            "u16x3(f32) u16x3",
            "u16x3(u32x3) u16x3",
            "u16x3(u32) u16x3",
            "u16x3(i32x3) u16x3",
            "u16x3(i32) u16x3",
            "u16x3(b8x3) u16x3",
            "u16x3(b8) u16x3",
            "u16x3(f16x3) u16x3",
            "u16x3(f16) u16x3",
            "u16x3(u16x3) u16x3",
            "u16x3(u16) u16x3",
            "u16x3(i16x3) u16x3",
            "u16x3(i16) u16x3",
            "u16x3(u16, u16, u16) u16x3",
            "u16x3(u16x2, u16) u16x3",
            "u16x3(u16, u16x2) u16x3"
        ]
    },
    {
        "name": "i16x3",
        "documentation": "Convert from f32x3 to i16x3",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "i16x3(f32x3) i16x3",
            "i16x3(f32) i16x3",
            "i16x3(u32x3) i16x3",
            "i16x3(u32) i16x3",
            "i16x3(i32x3) i16x3",
            "i16x3(i32) i16x3",
            "i16x3(b8x3) i16x3",
            "i16x3(b8) i16x3",
            "i16x3(f16x3) i16x3",
            "i16x3(f16) i16x3",
            "i16x3(u16x3) i16x3",
            "i16x3(u16) i16x3",
            "i16x3(i16x3) i16x3",
            "i16x3(i16) i16x3",
            "i16x3(i16, i16, i16) i16x3",
            "i16x3(i16x2, i16) i16x3",
            "i16x3(i16, i16x2) i16x3"
        ]
    },
    {
        "name": "f32x4",
        "documentation": "Convert from f32x4 to f32x4",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "f32x4(f32x4) f32x4",
            "f32x4(f32) f32x4",
            "f32x4(u32x4) f32x4",
            "f32x4(u32) f32x4",
            "f32x4(i32x4) f32x4",
            "f32x4(i32) f32x4",
            "f32x4(b8x4) f32x4",
            "f32x4(b8) f32x4",
            "f32x4(f16x4) f32x4",
            "f32x4(f16) f32x4",
            "f32x4(u16x4) f32x4",
            "f32x4(u16) f32x4",
            "f32x4(i16x4) f32x4",
            "f32x4(i16) f32x4",
            "f32x4(f32, f32, f32, f32) f32x4",
            "f32x4(f32x2, f32, f32) f32x4",
            "f32x4(f32, f32x2, f32) f32x4",
            "f32x4(f32, f32, f32x2) f32x4",
            "f32x4(f32x2, f32x2) f32x4",
            "f32x4(f32x3, f32) f32x4",
            "f32x4(f32, f32x3) f32x4"
        ]
    },
    {
        "name": "u32x4",
        "documentation": "Convert from f32x4 to u32x4",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "u32x4(f32x4) u32x4",
            "u32x4(f32) u32x4",
            "u32x4(u32x4) u32x4",
            "u32x4(u32) u32x4",
            "u32x4(i32x4) u32x4",
            "u32x4(i32) u32x4",
            "u32x4(b8x4) u32x4",
            "u32x4(b8) u32x4",
            "u32x4(f16x4) u32x4",
            "u32x4(f16) u32x4",
            "u32x4(u16x4) u32x4",
            "u32x4(u16) u32x4",
            "u32x4(i16x4) u32x4",
            "u32x4(i16) u32x4",
            "u32x4(u32, u32, u32, u32) u32x4",
            "u32x4(u32x2, u32, u32) u32x4",
            "u32x4(u32, u32x2, u32) u32x4",
            "u32x4(u32, u32, u32x2) u32x4",
            "u32x4(u32x2, u32x2) u32x4",
            "u32x4(u32x3, u32) u32x4",
            "u32x4(u32, u32x3) u32x4"
        ]
    },
    {
        "name": "i32x4",
        "documentation": "Convert from f32x4 to i32x4",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "i32x4(f32x4) i32x4",
            "i32x4(f32) i32x4",
            "i32x4(u32x4) i32x4",
            "i32x4(u32) i32x4",
            "i32x4(i32x4) i32x4",
            "i32x4(i32) i32x4",
            "i32x4(b8x4) i32x4",
            "i32x4(b8) i32x4",
            "i32x4(f16x4) i32x4",
            "i32x4(f16) i32x4",
            "i32x4(u16x4) i32x4",
            "i32x4(u16) i32x4",
            "i32x4(i16x4) i32x4",
            "i32x4(i16) i32x4",
            "i32x4(i32, i32, i32, i32) i32x4",
            "i32x4(i32x2, i32, i32) i32x4",
            "i32x4(i32, i32x2, i32) i32x4",
            "i32x4(i32, i32, i32x2) i32x4",
            "i32x4(i32x2, i32x2) i32x4",
            "i32x4(i32x3, i32) i32x4",
            "i32x4(i32, i32x3) i32x4"
        ]
    },
    {
        "name": "b8x4",
        "documentation": "Convert from u32x4 to b8x4",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "b8x4(u32x4) b8x4",
            "b8x4(u32) b8x4",
            "b8x4(i32x4) b8x4",
            "b8x4(i32) b8x4",
            "b8x4(b8x4) b8x4",
            "b8x4(b8) b8x4",
            "b8x4(u16x4) b8x4",
            "b8x4(u16) b8x4",
            "b8x4(i16x4) b8x4",
            "b8x4(i16) b8x4",
            "b8x4(b8, b8, b8, b8) b8x4",
            "b8x4(b8x2, b8, b8) b8x4",
            "b8x4(b8, b8x2, b8) b8x4",
            "b8x4(b8, b8, b8x2) b8x4",
            "b8x4(b8x2, b8x2) b8x4",
            "b8x4(b8x3, b8) b8x4",
            "b8x4(b8, b8x3) b8x4"
        ]
    },
    {
        "name": "f16x4",
        "documentation": "Convert from f32x4 to f16x4",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "f16x4(f32x4) f16x4",
            "f16x4(f32) f16x4",
            "f16x4(u32x4) f16x4",
            "f16x4(u32) f16x4",
            "f16x4(i32x4) f16x4",
            "f16x4(i32) f16x4",
            "f16x4(b8x4) f16x4",
            "f16x4(b8) f16x4",
            "f16x4(f16x4) f16x4",
            "f16x4(f16) f16x4",
            "f16x4(u16x4) f16x4",
            "f16x4(u16) f16x4",
            "f16x4(i16x4) f16x4",
            "f16x4(i16) f16x4",
            "f16x4(f16, f16, f16, f16) f16x4",
            "f16x4(f16x2, f16, f16) f16x4",
            "f16x4(f16, f16x2, f16) f16x4",
            "f16x4(f16, f16, f16x2) f16x4",
            "f16x4(f16x2, f16x2) f16x4",
            "f16x4(f16x3, f16) f16x4",
            "f16x4(f16, f16x3) f16x4"
        ]
    },
    {
        "name": "u16x4",
        "documentation": "Convert from f32x4 to u16x4",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "u16x4(f32x4) u16x4",
            "u16x4(f32) u16x4",
            "u16x4(u32x4) u16x4",
            "u16x4(u32) u16x4",
            "u16x4(i32x4) u16x4",
            "u16x4(i32) u16x4",
            "u16x4(b8x4) u16x4",
            "u16x4(b8) u16x4",
            "u16x4(f16x4) u16x4",
            "u16x4(f16) u16x4",
            "u16x4(u16x4) u16x4",
            "u16x4(u16) u16x4",
            "u16x4(i16x4) u16x4",
            "u16x4(i16) u16x4",
            "u16x4(u16, u16, u16, u16) u16x4",
            "u16x4(u16x2, u16, u16) u16x4",
            "u16x4(u16, u16x2, u16) u16x4",
            "u16x4(u16, u16, u16x2) u16x4",
            "u16x4(u16x2, u16x2) u16x4",
            "u16x4(u16x3, u16) u16x4",
            "u16x4(u16, u16x3) u16x4"
        ]
    },
    {
        "name": "i16x4",
        "documentation": "Convert from f32x4 to i16x4",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "i16x4(f32x4) i16x4",
            "i16x4(f32) i16x4",
            "i16x4(u32x4) i16x4",
            "i16x4(u32) i16x4",
            "i16x4(i32x4) i16x4",
            "i16x4(i32) i16x4",
            "i16x4(b8x4) i16x4",
            "i16x4(b8) i16x4",
            "i16x4(f16x4) i16x4",
            "i16x4(f16) i16x4",
            "i16x4(u16x4) i16x4",
            "i16x4(u16) i16x4",
            "i16x4(i16x4) i16x4",
            "i16x4(i16) i16x4",
            "i16x4(i16, i16, i16, i16) i16x4",
            "i16x4(i16x2, i16, i16) i16x4",
            "i16x4(i16, i16x2, i16) i16x4",
            "i16x4(i16, i16, i16x2) i16x4",
            "i16x4(i16x2, i16x2) i16x4",
            "i16x4(i16x3, i16) i16x4",
            "i16x4(i16, i16x3) i16x4"
        ]
    },
    {
        "name": "f32x2x2",
        "documentation": null,
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "f32x2x2(f32x2, f32x2) f32x2x2",
            "f32x2x2() f32x2x2",
            "f32x2x2(f32, f32, f32, f32) f32x2x2"
        ]
    },
    {
        "name": "f32x2x3",
        "documentation": null,
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "f32x2x3(f32x3, f32x3) f32x2x3",
            "f32x2x3() f32x2x3",
            "f32x2x3(f32, f32, f32, f32, f32, f32) f32x2x3"
        ]
    },
    {
        "name": "f32x2x4",
        "documentation": null,
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "f32x2x4(f32x4, f32x4) f32x2x4",
            "f32x2x4() f32x2x4",
            "f32x2x4(f32, f32, f32, f32, f32, f32, f32, f32) f32x2x4"
        ]
    },
    {
        "name": "f32x3x2",
        "documentation": null,
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "f32x3x2(f32x2, f32x2, f32x2) f32x3x2",
            "f32x3x2() f32x3x2",
            "f32x3x2(f32, f32, f32, f32, f32, f32) f32x3x2"
        ]
    },
    {
        "name": "f32x3x3",
        "documentation": null,
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "f32x3x3(f32x3, f32x3, f32x3) f32x3x3",
            "f32x3x3() f32x3x3",
            "f32x3x3(f32, f32, f32, f32, f32, f32, f32, f32, f32) f32x3x3"
        ]
    },
    {
        "name": "f32x3x4",
        "documentation": null,
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "f32x3x4(f32x4, f32x4, f32x4) f32x3x4",
            "f32x3x4() f32x3x4",
            "f32x3x4(f32, f32, f32, f32, f32, f32, f32, f32, f32, f32, f32, f32) f32x3x4"
        ]
    },
    {
        "name": "f32x4x2",
        "documentation": null,
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "f32x4x2(f32x2, f32x2, f32x2, f32x2) f32x4x2",
            "f32x4x2() f32x4x2",
            "f32x4x2(f32, f32, f32, f32, f32, f32, f32, f32) f32x4x2"
        ]
    },
    {
        "name": "f32x4x3",
        "documentation": null,
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "f32x4x3(f32x3, f32x3, f32x3, f32x3) f32x4x3",
            "f32x4x3() f32x4x3",
            "f32x4x3(f32, f32, f32, f32, f32, f32, f32, f32, f32, f32, f32, f32) f32x4x3"
        ]
    },
    {
        "name": "f32x4x4",
        "documentation": null,
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "f32x4x4(f32x4, f32x4, f32x4, f32x4) f32x4x4",
            "f32x4x4() f32x4x4",
            "f32x4x4(f32, f32, f32, f32, f32, f32, f32, f32, f32, f32, f32, f32, f32, f32, f32, f32) f32x4x4"
        ]
    },
    {
        "name": "f16x2x2",
        "documentation": null,
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "f16x2x2(f16x2, f16x2) f16x2x2",
            "f16x2x2() f16x2x2",
            "f16x2x2(f16, f16, f16, f16) f16x2x2"
        ]
    },
    {
        "name": "f16x2x3",
        "documentation": null,
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "f16x2x3(f16x3, f16x3) f16x2x3",
            "f16x2x3() f16x2x3",
            "f16x2x3(f16, f16, f16, f16, f16, f16) f16x2x3"
        ]
    },
    {
        "name": "f16x2x4",
        "documentation": null,
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "f16x2x4(f16x4, f16x4) f16x2x4",
            "f16x2x4() f16x2x4",
            "f16x2x4(f16, f16, f16, f16, f16, f16, f16, f16) f16x2x4"
        ]
    },
    {
        "name": "f16x3x2",
        "documentation": null,
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "f16x3x2(f16x2, f16x2, f16x2) f16x3x2",
            "f16x3x2() f16x3x2",
            "f16x3x2(f16, f16, f16, f16, f16, f16) f16x3x2"
        ]
    },
    {
        "name": "f16x3x3",
        "documentation": null,
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "f16x3x3(f16x3, f16x3, f16x3) f16x3x3",
            "f16x3x3() f16x3x3",
            "f16x3x3(f16, f16, f16, f16, f16, f16, f16, f16, f16) f16x3x3"
        ]
    },
    {
        "name": "f16x3x4",
        "documentation": null,
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "f16x3x4(f16x4, f16x4, f16x4) f16x3x4",
            "f16x3x4() f16x3x4",
            "f16x3x4(f16, f16, f16, f16, f16, f16, f16, f16, f16, f16, f16, f16) f16x3x4"
        ]
    },
    {
        "name": "f16x4x2",
        "documentation": null,
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "f16x4x2(f16x2, f16x2, f16x2, f16x2) f16x4x2",
            "f16x4x2() f16x4x2",
            "f16x4x2(f16, f16, f16, f16, f16, f16, f16, f16) f16x4x2"
        ]
    },
    {
        "name": "f16x4x3",
        "documentation": null,
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "f16x4x3(f16x3, f16x3, f16x3, f16x3) f16x4x3",
            "f16x4x3() f16x4x3",
            "f16x4x3(f16, f16, f16, f16, f16, f16, f16, f16, f16, f16, f16, f16) f16x4x3"
        ]
    },
    {
        "name": "f16x4x4",
        "documentation": null,
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "f16x4x4(f16x4, f16x4, f16x4, f16x4) f16x4x4",
            "f16x4x4() f16x4x4",
            "f16x4x4(f16, f16, f16, f16, f16, f16, f16, f16, f16, f16, f16, f16, f16, f16, f16, f16) f16x4x4"
        ]
    },
    {
        "name": "acos",
        "documentation": "Returns the arc cosine of a value.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "acos(f32) f32",
            "acos(f32x2) f32x2",
            "acos(f32x3) f32x3",
            "acos(f32x4) f32x4",
            "acos(f16) f16",
            "acos(f16x2) f16x2",
            "acos(f16x3) f16x3",
            "acos(f16x4) f16x4"
        ]
    },
    {
        "name": "acosh",
        "documentation": "Returns the hyperbolic arc cosine of a value.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "acosh(f32) f32",
            "acosh(f32x2) f32x2",
            "acosh(f32x3) f32x3",
            "acosh(f32x4) f32x4",
            "acosh(f16) f16",
            "acosh(f16x2) f16x2",
            "acosh(f16x3) f16x3",
            "acosh(f16x4) f16x4"
        ]
    },
    {
        "name": "asin",
        "documentation": "Returns the arc sine of a value.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "asin(f32) f32",
            "asin(f32x2) f32x2",
            "asin(f32x3) f32x3",
            "asin(f32x4) f32x4",
            "asin(f16) f16",
            "asin(f16x2) f16x2",
            "asin(f16x3) f16x3",
            "asin(f16x4) f16x4"
        ]
    },
    {
        "name": "asinh",
        "documentation": "Returns the hyperbolic arc sine of a value.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "asinh(f32) f32",
            "asinh(f32x2) f32x2",
            "asinh(f32x3) f32x3",
            "asinh(f32x4) f32x4",
            "asinh(f16) f16",
            "asinh(f16x2) f16x2",
            "asinh(f16x3) f16x3",
            "asinh(f16x4) f16x4"
        ]
    },
    {
        "name": "atan",
        "documentation": "Returns the arc tangent of a value.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "atan(f32) f32",
            "atan(f32x2) f32x2",
            "atan(f32x3) f32x3",
            "atan(f32x4) f32x4",
            "atan(f16) f16",
            "atan(f16x2) f16x2",
            "atan(f16x3) f16x3",
            "atan(f16x4) f16x4"
        ]
    },
    {
        "name": "atanh",
        "documentation": "Returns the hyperbolic arc tangent of a value.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "atanh(f32) f32",
            "atanh(f32x2) f32x2",
            "atanh(f32x3) f32x3",
            "atanh(f32x4) f32x4",
            "atanh(f16) f16",
            "atanh(f16x2) f16x2",
            "atanh(f16x3) f16x3",
            "atanh(f16x4) f16x4"
        ]
    },
    {
        "name": "cos",
        "documentation": "Returns the cosine of a value.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "cos(f32) f32",
            "cos(f32x2) f32x2",
            "cos(f32x3) f32x3",
            "cos(f32x4) f32x4",
            "cos(f16) f16",
            "cos(f16x2) f16x2",
            "cos(f16x3) f16x3",
            "cos(f16x4) f16x4"
        ]
    },
    {
        "name": "cosh",
        "documentation": "Returns the hyperbolic cosine of a value.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "cosh(f32) f32",
            "cosh(f32x2) f32x2",
            "cosh(f32x3) f32x3",
            "cosh(f32x4) f32x4",
            "cosh(f16) f16",
            "cosh(f16x2) f16x2",
            "cosh(f16x3) f16x3",
            "cosh(f16x4) f16x4"
        ]
    },
    {
        "name": "exp",
        "documentation": "Returns the exponential of a value.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "exp(f32) f32",
            "exp(f32x2) f32x2",
            "exp(f32x3) f32x3",
            "exp(f32x4) f32x4",
            "exp(f16) f16",
            "exp(f16x2) f16x2",
            "exp(f16x3) f16x3",
            "exp(f16x4) f16x4"
        ]
    },
    {
        "name": "exp2",
        "documentation": "Returns the base 2 exponential of a value.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "exp2(f32) f32",
            "exp2(f32x2) f32x2",
            "exp2(f32x3) f32x3",
            "exp2(f32x4) f32x4",
            "exp2(f16) f16",
            "exp2(f16x2) f16x2",
            "exp2(f16x3) f16x3",
            "exp2(f16x4) f16x4"
        ]
    },
    {
        "name": "invSqrt",
        "documentation": "Returns the inverse square root of a value.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "invSqrt(f32) f32",
            "invSqrt(f32x2) f32x2",
            "invSqrt(f32x3) f32x3",
            "invSqrt(f32x4) f32x4",
            "invSqrt(f16) f16",
            "invSqrt(f16x2) f16x2",
            "invSqrt(f16x3) f16x3",
            "invSqrt(f16x4) f16x4"
        ]
    },
    {
        "name": "log",
        "documentation": "Returns the natural logarithm of a value.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "log(f32) f32",
            "log(f32x2) f32x2",
            "log(f32x3) f32x3",
            "log(f32x4) f32x4",
            "log(f16) f16",
            "log(f16x2) f16x2",
            "log(f16x3) f16x3",
            "log(f16x4) f16x4"
        ]
    },
    {
        "name": "log2",
        "documentation": "Returns the base 2 logarithm of a value.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "log2(f32) f32",
            "log2(f32x2) f32x2",
            "log2(f32x3) f32x3",
            "log2(f32x4) f32x4",
            "log2(f16) f16",
            "log2(f16x2) f16x2",
            "log2(f16x3) f16x3",
            "log2(f16x4) f16x4"
        ]
    },
    {
        "name": "sin",
        "documentation": "Returns the sine of a value.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "sin(f32) f32",
            "sin(f32x2) f32x2",
            "sin(f32x3) f32x3",
            "sin(f32x4) f32x4",
            "sin(f16) f16",
            "sin(f16x2) f16x2",
            "sin(f16x3) f16x3",
            "sin(f16x4) f16x4"
        ]
    },
    {
        "name": "sinh",
        "documentation": "Returns the hyperbolic sine of a value.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "sinh(f32) f32",
            "sinh(f32x2) f32x2",
            "sinh(f32x3) f32x3",
            "sinh(f32x4) f32x4",
            "sinh(f16) f16",
            "sinh(f16x2) f16x2",
            "sinh(f16x3) f16x3",
            "sinh(f16x4) f16x4"
        ]
    },
    {
        "name": "sqrt",
        "documentation": "Returns the square root of a value.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "sqrt(f32) f32",
            "sqrt(f32x2) f32x2",
            "sqrt(f32x3) f32x3",
            "sqrt(f32x4) f32x4",
            "sqrt(f16) f16",
            "sqrt(f16x2) f16x2",
            "sqrt(f16x3) f16x3",
            "sqrt(f16x4) f16x4"
        ]
    },
    {
        "name": "tan",
        "documentation": "Returns the tangent of a value.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "tan(f32) f32",
            "tan(f32x2) f32x2",
            "tan(f32x3) f32x3",
            "tan(f32x4) f32x4",
            "tan(f16) f16",
            "tan(f16x2) f16x2",
            "tan(f16x3) f16x3",
            "tan(f16x4) f16x4"
        ]
    },
    {
        "name": "tanh",
        "documentation": "Returns the hyperbolic tangent of a value.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "tanh(f32) f32",
            "tanh(f32x2) f32x2",
            "tanh(f32x3) f32x3",
            "tanh(f32x4) f32x4",
            "tanh(f16) f16",
            "tanh(f16x2) f16x2",
            "tanh(f16x3) f16x3",
            "tanh(f16x4) f16x4",
            "tanh(f32, f32) f32",
            "tanh(f32x2, f32x2) f32x2",
            "tanh(f32x3, f32x3) f32x3",
            "tanh(f32x4, f32x4) f32x4",
            "tanh(f16, f16) f16",
            "tanh(f16x2, f16x2) f16x2",
            "tanh(f16x3, f16x3) f16x3",
            "tanh(f16x4, f16x4) f16x4"
        ]
    },
    {
        "name": "pow",
        "documentation": "Returns the result of raising a value to the power of an exponent.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "pow(f32, f32) f32",
            "pow(f32x2, f32x2) f32x2",
            "pow(f32x3, f32x3) f32x3",
            "pow(f32x4, f32x4) f32x4",
            "pow(f16, f16) f16",
            "pow(f16x2, f16x2) f16x2",
            "pow(f16x3, f16x3) f16x3",
            "pow(f16x4, f16x4) f16x4"
        ]
    },
    {
        "name": "mad",
        "documentation": "Returns the result of multiplying a value by a multiplier and adding an addend.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "mad(f32, f32, f32) f32",
            "mad(f32x2, f32x2, f32x2) f32x2",
            "mad(f32x3, f32x3, f32x3) f32x3",
            "mad(f32x4, f32x4, f32x4) f32x4",
            "mad(f16, f16, f16) f16",
            "mad(f16x2, f16x2, f16x2) f16x2",
            "mad(f16x3, f16x3, f16x3) f16x3",
            "mad(f16x4, f16x4, f16x4) f16x4",
            "mad(i32, i32, i32) i32",
            "mad(i32x2, i32x2, i32x2) i32x2",
            "mad(i32x3, i32x3, i32x3) i32x3",
            "mad(i32x4, i32x4, i32x4) i32x4",
            "mad(i16, i16, i16) i16",
            "mad(i16x2, i16x2, i16x2) i16x2",
            "mad(i16x3, i16x3, i16x3) i16x3",
            "mad(i16x4, i16x4, i16x4) i16x4",
            "mad(u32, u32, u32) u32",
            "mad(u32x2, u32x2, u32x2) u32x2",
            "mad(u32x3, u32x3, u32x3) u32x3",
            "mad(u32x4, u32x4, u32x4) u32x4",
            "mad(u16, u16, u16) u16",
            "mad(u16x2, u16x2, u16x2) u16x2",
            "mad(u16x3, u16x3, u16x3) u16x3",
            "mad(u16x4, u16x4, u16x4) u16x4"
        ]
    },
    {
        "name": "dot",
        "documentation": "Returns the dot product of two vectors.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "dot(f32x2, f32x2) f32",
            "dot(f32x3, f32x3) f32",
            "dot(f32x4, f32x4) f32",
            "dot(f16x2, f16x2) f16",
            "dot(f16x3, f16x3) f16",
            "dot(f16x4, f16x4) f16"
        ]
    },
    {
        "name": "reflect",
        "documentation": "Returns the reflection of a vector through a surface using an incident vector and normal.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "reflect(f32x2, f32x2) f32x2",
            "reflect(f32x3, f32x3) f32x3",
            "reflect(f32x4, f32x4) f32x4",
            "reflect(f16x2, f16x2) f16x2",
            "reflect(f16x3, f16x3) f16x3",
            "reflect(f16x4, f16x4) f16x4"
        ]
    },
    {
        "name": "refract",
        "documentation": "Returns the refraction of a vector through a surface using an incident vector, normal and an index of refraction.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "refract(f32x2, f32x2, f32x2) f32x2",
            "refract(f32x3, f32x3, f32x3) f32x3",
            "refract(f32x4, f32x4, f32x4) f32x4",
            "refract(f16x2, f16x2, f16x2) f16x2",
            "refract(f16x3, f16x3, f16x3) f16x3",
            "refract(f16x4, f16x4, f16x4) f16x4"
        ]
    },
    {
        "name": "cross",
        "documentation": "Returns the cross product of two vectors.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "cross(f32x3, f32x3) f32x3",
            "cross(f16x3, f16x3) f16x3"
        ]
    },
    {
        "name": "length",
        "documentation": "Returns the length of the vector.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "length(f32x2) f32x2",
            "length(f32x3) f32x3",
            "length(f32x4) f32x4",
            "length(f16x2) f16x2",
            "length(f16x3) f16x3",
            "length(f16x4) f16x4"
        ]
    },
    {
        "name": "normalize",
        "documentation": "Returns the normalized vector.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "normalize(f32x2) f32x2",
            "normalize(f32x3) f32x3",
            "normalize(f32x4) f32x4",
            "normalize(f16x2) f16x2",
            "normalize(f16x3) f16x3",
            "normalize(f16x4) f16x4"
        ]
    },
    {
        "name": "distance",
        "documentation": "Returns the distance between two points.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "distance(f32x2, f32x2) f32x2",
            "distance(f32x3, f32x3) f32x3",
            "distance(f32x4, f32x4) f32x4",
            "distance(f16x2, f16x2) f16x2",
            "distance(f16x3, f16x3) f16x3",
            "distance(f16x4, f16x4) f16x4"
        ]
    },
    {
        "name": "min",
        "documentation": "Returns the minimum of x and y.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "min(f32, f32) f32",
            "min(f32x2, f32x2) f32x2",
            "min(f32x3, f32x3) f32x3",
            "min(f32x4, f32x4) f32x4",
            "min(f16, f16) f16",
            "min(f16x2, f16x2) f16x2",
            "min(f16x3, f16x3) f16x3",
            "min(f16x4, f16x4) f16x4",
            "min(i32, i32) i32",
            "min(i32x2, i32x2) i32x2",
            "min(i32x3, i32x3) i32x3",
            "min(i32x4, i32x4) i32x4",
            "min(i16, i16) i16",
            "min(i16x2, i16x2) i16x2",
            "min(i16x3, i16x3) i16x3",
            "min(i16x4, i16x4) i16x4",
            "min(u32, u32) u32",
            "min(u32x2, u32x2) u32x2",
            "min(u32x3, u32x3) u32x3",
            "min(u32x4, u32x4) u32x4",
            "min(u16, u16) u16",
            "min(u16x2, u16x2) u16x2",
            "min(u16x3, u16x3) u16x3",
            "min(u16x4, u16x4) u16x4"
        ]
    },
    {
        "name": "max",
        "documentation": "Returns the maximum of x and y.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "max(f32, f32) f32",
            "max(f32x2, f32x2) f32x2",
            "max(f32x3, f32x3) f32x3",
            "max(f32x4, f32x4) f32x4",
            "max(f16, f16) f16",
            "max(f16x2, f16x2) f16x2",
            "max(f16x3, f16x3) f16x3",
            "max(f16x4, f16x4) f16x4",
            "max(i32, i32) i32",
            "max(i32x2, i32x2) i32x2",
            "max(i32x3, i32x3) i32x3",
            "max(i32x4, i32x4) i32x4",
            "max(i16, i16) i16",
            "max(i16x2, i16x2) i16x2",
            "max(i16x3, i16x3) i16x3",
            "max(i16x4, i16x4) i16x4",
            "max(u32, u32) u32",
            "max(u32x2, u32x2) u32x2",
            "max(u32x3, u32x3) u32x3",
            "max(u32x4, u32x4) u32x4",
            "max(u16, u16) u16",
            "max(u16x2, u16x2) u16x2",
            "max(u16x3, u16x3) u16x3",
            "max(u16x4, u16x4) u16x4"
        ]
    },
    {
        "name": "clamp",
        "documentation": "Returns the value clamped between min and max.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "clamp(f32, f32, f32) f32",
            "clamp(f32x2, f32x2, f32x2) f32x2",
            "clamp(f32x3, f32x3, f32x3) f32x3",
            "clamp(f32x4, f32x4, f32x4) f32x4",
            "clamp(f16, f16, f16) f16",
            "clamp(f16x2, f16x2, f16x2) f16x2",
            "clamp(f16x3, f16x3, f16x3) f16x3",
            "clamp(f16x4, f16x4, f16x4) f16x4",
            "clamp(i32, i32, i32) i32",
            "clamp(i32x2, i32x2, i32x2) i32x2",
            "clamp(i32x3, i32x3, i32x3) i32x3",
            "clamp(i32x4, i32x4, i32x4) i32x4",
            "clamp(i16, i16, i16) i16",
            "clamp(i16x2, i16x2, i16x2) i16x2",
            "clamp(i16x3, i16x3, i16x3) i16x3",
            "clamp(i16x4, i16x4, i16x4) i16x4",
            "clamp(u32, u32, u32) u32",
            "clamp(u32x2, u32x2, u32x2) u32x2",
            "clamp(u32x3, u32x3, u32x3) u32x3",
            "clamp(u32x4, u32x4, u32x4) u32x4",
            "clamp(u16, u16, u16) u16",
            "clamp(u16x2, u16x2, u16x2) u16x2",
            "clamp(u16x3, u16x3, u16x3) u16x3",
            "clamp(u16x4, u16x4, u16x4) u16x4"
        ]
    },
    {
        "name": "lerp",
        "documentation": "Returns the linear interpolation between a and b by t.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "lerp(f32x2, f32x2, f32x2) f32x2",
            "lerp(f32x3, f32x3, f32x3) f32x3",
            "lerp(f32x4, f32x4, f32x4) f32x4",
            "lerp(f16x2, f16x2, f16x2) f16x2",
            "lerp(f16x3, f16x3, f16x3) f16x3",
            "lerp(f16x4, f16x4, f16x4) f16x4"
        ]
    },
    {
        "name": "step",
        "documentation": "Returns 0.0 if x < edge, otherwise returns 1.0.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "step(f32, f32) f32",
            "step(f32x2, f32x2) f32x2",
            "step(f32x3, f32x3) f32x3",
            "step(f32x4, f32x4) f32x4",
            "step(f16, f16) f16",
            "step(f16x2, f16x2) f16x2",
            "step(f16x3, f16x3) f16x3",
            "step(f16x4, f16x4) f16x4"
        ]
    },
    {
        "name": "smoothstep",
        "documentation": "Returns the smoothstep interpolation of the input.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "smoothstep(f32, f32, f32) f32",
            "smoothstep(f32x2, f32x2, f32x2) f32x2",
            "smoothstep(f32x3, f32x3, f32x3) f32x3",
            "smoothstep(f32x4, f32x4, f32x4) f32x4",
            "smoothstep(f16, f16, f16) f16",
            "smoothstep(f16x2, f16x2, f16x2) f16x2",
            "smoothstep(f16x3, f16x3, f16x3) f16x3",
            "smoothstep(f16x4, f16x4, f16x4) f16x4"
        ]
    },
    {
        "name": "ceil",
        "documentation": "Returns the smallest integer value that is greater than or equal to the input.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "ceil(f32) f32",
            "ceil(f32x2) f32x2",
            "ceil(f32x3) f32x3",
            "ceil(f32x4) f32x4",
            "ceil(f16) f16",
            "ceil(f16x2) f16x2",
            "ceil(f16x3) f16x3",
            "ceil(f16x4) f16x4"
        ]
    },
    {
        "name": "floor",
        "documentation": "Returns the largest integer value that is less than or equal to the input.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "floor(f32) f32",
            "floor(f32x2) f32x2",
            "floor(f32x3) f32x3",
            "floor(f32x4) f32x4",
            "floor(f16) f16",
            "floor(f16x2) f16x2",
            "floor(f16x3) f16x3",
            "floor(f16x4) f16x4"
        ]
    },
    {
        "name": "fract",
        "documentation": "Returns the fractional part of the input.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "fract(f32) f32",
            "fract(f32x2) f32x2",
            "fract(f32x3) f32x3",
            "fract(f32x4) f32x4",
            "fract(f16) f16",
            "fract(f16x2) f16x2",
            "fract(f16x3) f16x3",
            "fract(f16x4) f16x4"
        ]
    },
    {
        "name": "saturate",
        "documentation": "Returns the input clamped to the range [0, 1].",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "saturate(f32) f32",
            "saturate(f32x2) f32x2",
            "saturate(f32x3) f32x3",
            "saturate(f32x4) f32x4",
            "saturate(f16) f16",
            "saturate(f16x2) f16x2",
            "saturate(f16x3) f16x3",
            "saturate(f16x4) f16x4"
        ]
    },
    {
        "name": "trunc",
        "documentation": "Returns the integer part of the input, removing any fractional part.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "trunc(f32) f32",
            "trunc(f32x2) f32x2",
            "trunc(f32x3) f32x3",
            "trunc(f32x4) f32x4",
            "trunc(f16) f16",
            "trunc(f16x2) f16x2",
            "trunc(f16x3) f16x3",
            "trunc(f16x4) f16x4"
        ]
    },
    {
        "name": "ddx",
        "documentation": "Returns the derivative of the input with respect to the screen x coordinate.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "ddx(f32) f32",
            "ddx(f32x2) f32x2",
            "ddx(f32x3) f32x3",
            "ddx(f32x4) f32x4",
            "ddx(f16) f16",
            "ddx(f16x2) f16x2",
            "ddx(f16x3) f16x3",
            "ddx(f16x4) f16x4"
        ]
    },
    {
        "name": "ddy",
        "documentation": "Returns the derivative of the input with respect to the screen y coordinate.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "ddy(f32) f32",
            "ddy(f32x2) f32x2",
            "ddy(f32x3) f32x3",
            "ddy(f32x4) f32x4",
            "ddy(f16) f16",
            "ddy(f16x2) f16x2",
            "ddy(f16x3) f16x3",
            "ddy(f16x4) f16x4"
        ]
    },
    {
        "name": "fwidth",
        "documentation": "Returns the width of the input, which is the maximum of the absolute values of the derivatives in the screen x and y coordinates.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "fwidth(f32) f32",
            "fwidth(f32x2) f32x2",
            "fwidth(f32x3) f32x3",
            "fwidth(f32x4) f32x4",
            "fwidth(f16) f16",
            "fwidth(f16x2) f16x2",
            "fwidth(f16x3) f16x3",
            "fwidth(f16x4) f16x4"
        ]
    },
    {
        "name": "sign",
        "documentation": "Returns the sign of the value.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "sign(i32) i32",
            "sign(i32x2) i32x2",
            "sign(i32x3) i32x3",
            "sign(i32x4) i32x4",
            "sign(i16) i16",
            "sign(i16x2) i16x2",
            "sign(i16x3) i16x3",
            "sign(i16x4) i16x4",
            "sign(f32) f32",
            "sign(f32x2) f32x2",
            "sign(f32x3) f32x3",
            "sign(f32x4) f32x4",
            "sign(f16) f16",
            "sign(f16x2) f16x2",
            "sign(f16x3) f16x3",
            "sign(f16x4) f16x4"
        ]
    },
    {
        "name": "abs",
        "documentation": "Returns the absolute value of the input.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "abs(i32) i32",
            "abs(i32x2) i32x2",
            "abs(i32x3) i32x3",
            "abs(i32x4) i32x4",
            "abs(i16) i16",
            "abs(i16x2) i16x2",
            "abs(i16x3) i16x3",
            "abs(i16x4) i16x4",
            "abs(f32) f32",
            "abs(f32x2) f32x2",
            "abs(f32x3) f32x3",
            "abs(f32x4) f32x4",
            "abs(f16) f16",
            "abs(f16x2) f16x2",
            "abs(f16x3) f16x3",
            "abs(f16x4) f16x4"
        ]
    },
    {
        "name": "castToF16",
        "documentation": "Casts value of UInt16 to type Float16 without conversion.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "castToF16(u16) f16",
            "castToF16(i16) f16"
        ]
    },
    {
        "name": "castToU16",
        "documentation": "Casts value of Float16 to type UInt16 without conversion.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "castToU16(f16) u16",
            "castToU16(i16) u16"
        ]
    },
    {
        "name": "castToI16",
        "documentation": "Casts value of Float16 to type Int16 without conversion.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "castToI16(f16) i16",
            "castToI16(u16) i16"
        ]
    },
    {
        "name": "castToF32",
        "documentation": "Casts value of UInt32 to type Float32 without conversion.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "castToF32(u32) f32",
            "castToF32(i32) f32"
        ]
    },
    {
        "name": "castToU32",
        "documentation": "Casts value of Float32 to type UInt32 without conversion.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "castToU32(f32) u32",
            "castToU32(i32) u32"
        ]
    },
    {
        "name": "castToI32",
        "documentation": "Casts value of Float32 to type Int32 without conversion.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "castToI32(f32) i32",
            "castToI32(u32) i32"
        ]
    },
    {
        "name": "any",
        "documentation": "Returns true if any component of the vector is non-zero.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "any(b8) b8",
            "any(b8x2) b8x2",
            "any(b8x3) b8x3",
            "any(b8x4) b8x4"
        ]
    },
    {
        "name": "all",
        "documentation": "Returns true if all components of the vector are non-zero.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "all(b8) b8",
            "all(b8x2) b8x2",
            "all(b8x3) b8x3",
            "all(b8x4) b8x4"
        ]
    },
    {
        "name": "transpose",
        "documentation": "Returns the transposed matrix.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "transpose(f32x2x2) f32x2x2",
            "transpose(f16x2x2) f16x2x2",
            "transpose(f32x2x3) f32x2x3",
            "transpose(f16x2x3) f16x2x3",
            "transpose(f32x2x4) f32x2x4",
            "transpose(f16x2x4) f16x2x4",
            "transpose(f32x3x2) f32x3x2",
            "transpose(f16x3x2) f16x3x2",
            "transpose(f32x3x3) f32x3x3",
            "transpose(f16x3x3) f16x3x3",
            "transpose(f32x3x4) f32x3x4",
            "transpose(f16x3x4) f16x3x4",
            "transpose(f32x4x2) f32x4x2",
            "transpose(f16x4x2) f16x4x2",
            "transpose(f32x4x3) f32x4x3",
            "transpose(f16x4x3) f16x4x3",
            "transpose(f32x4x4) f32x4x4",
            "transpose(f16x4x4) f16x4x4"
        ]
    },
    {
        "name": "inverse",
        "documentation": "Returns the inverse of the matrix.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "inverse(f32x2x2) f32x2x2",
            "inverse(f16x2x2) f16x2x2",
            "inverse(f32x2x3) f32x2x3",
            "inverse(f16x2x3) f16x2x3",
            "inverse(f32x2x4) f32x2x4",
            "inverse(f16x2x4) f16x2x4",
            "inverse(f32x3x2) f32x3x2",
            "inverse(f16x3x2) f16x3x2",
            "inverse(f32x3x3) f32x3x3",
            "inverse(f16x3x3) f16x3x3",
            "inverse(f32x3x4) f32x3x4",
            "inverse(f16x3x4) f16x3x4",
            "inverse(f32x4x2) f32x4x2",
            "inverse(f16x4x2) f16x4x2",
            "inverse(f32x4x3) f32x4x3",
            "inverse(f16x4x3) f16x4x3",
            "inverse(f32x4x4) f32x4x4",
            "inverse(f16x4x4) f16x4x4"
        ]
    },
    {
        "name": "vertexGetOutputLayer",
        "documentation": null,
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "vertexGetOutputLayer() u32"
        ]
    },
    {
        "name": "vertexGetOutputViewport",
        "documentation": null,
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "vertexGetOutputViewport() u32"
        ]
    },
    {
        "name": "vertexGetIndex",
        "documentation": null,
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "vertexGetIndex() u32"
        ]
    },
    {
        "name": "vertexGetInstanceIndex",
        "documentation": null,
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "vertexGetInstanceIndex() u32"
        ]
    },
    {
        "name": "vertexGetBaseIndex",
        "documentation": null,
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "vertexGetBaseIndex() u32"
        ]
    },
    {
        "name": "vertexGetBaseInstanceIndex",
        "documentation": null,
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "vertexGetBaseInstanceIndex() u32"
        ]
    },
    {
        "name": "vertexGetDrawIndex",
        "documentation": null,
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "vertexGetDrawIndex() u32"
        ]
    },
    {
        "name": "vertexSetOutputLayer",
        "documentation": "Sets the output layer for the current vertex.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "vertexSetOutputLayer(u16) void",
            "vertexSetOutputLayer(u32) void"
        ]
    },
    {
        "name": "vertexSetOutputViewport",
        "documentation": "Sets the output viewport for the current vertex.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "vertexSetOutputViewport(u16) void",
            "vertexSetOutputViewport(u32) void"
        ]
    },
    {
        "name": "vertexExportCoordinates",
        "documentation": "Exports the value as the vertex position to the rasterizer. This function must be called at least once in a vertex shader. This is the same as the `SV_POSITION` in HLSL or `gl_Position` in GLSL.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "vertexExportCoordinates(f32x4) void",
            "vertexExportCoordinates(f16x4) void"
        ]
    },
    {
        "name": "geometryExportVertex",
        "documentation": null,
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "geometryExportVertex() void"
        ]
    },
    {
        "name": "geometryExportPrimitive",
        "documentation": null,
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "geometryExportPrimitive() void"
        ]
    },
    {
        "name": "pixelGetCoordinates",
        "documentation": "Returns the post transformation coordinates of the current pixel. xy is the pixel position in non-normalized coordinates, z is the depth in the range [0, 1] or [-1, 1] based on the graphics API.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "pixelGetCoordinates() f32x4",
            "pixelGetCoordinates() f16x4"
        ]
    },
    {
        "name": "pixelGetDepth",
        "documentation": "Returns the depth value for the current pixel",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "pixelGetDepth() f32"
        ]
    },
    {
        "name": "pixelSetDepth",
        "documentation": "Sets the depth value for the current pixel",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "pixelSetDepth(f32) void"
        ]
    },
    {
        "name": "pixelExportColor",
        "documentation": "Exports a color value to the framebuffer output at index. This is the same as writing to `SV_TARGET<index>` in HLSL or to a GLSL `layout(location = <index>)` out variable.",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "pixelExportColor(f32, literal i32) void",
            "pixelExportColor(f32, literal u32) void",
            "pixelExportColor(f32, literal i16) void",
            "pixelExportColor(f32, literal u16) void",
            "pixelExportColor(f32x2, literal i32) void",
            "pixelExportColor(f32x2, literal u32) void",
            "pixelExportColor(f32x2, literal i16) void",
            "pixelExportColor(f32x2, literal u16) void",
            "pixelExportColor(f32x3, literal i32) void",
            "pixelExportColor(f32x3, literal u32) void",
            "pixelExportColor(f32x3, literal i16) void",
            "pixelExportColor(f32x3, literal u16) void",
            "pixelExportColor(f32x4, literal i32) void",
            "pixelExportColor(f32x4, literal u32) void",
            "pixelExportColor(f32x4, literal i16) void",
            "pixelExportColor(f32x4, literal u16) void",
            "pixelExportColor(f16, literal i32) void",
            "pixelExportColor(f16, literal u32) void",
            "pixelExportColor(f16, literal i16) void",
            "pixelExportColor(f16, literal u16) void",
            "pixelExportColor(f16x2, literal i32) void",
            "pixelExportColor(f16x2, literal u32) void",
            "pixelExportColor(f16x2, literal i16) void",
            "pixelExportColor(f16x2, literal u16) void",
            "pixelExportColor(f16x3, literal i32) void",
            "pixelExportColor(f16x3, literal u32) void",
            "pixelExportColor(f16x3, literal i16) void",
            "pixelExportColor(f16x3, literal u16) void",
            "pixelExportColor(f16x4, literal i32) void",
            "pixelExportColor(f16x4, literal u32) void",
            "pixelExportColor(f16x4, literal i16) void",
            "pixelExportColor(f16x4, literal u16) void",
            "pixelExportColor(i32, literal i32) void",
            "pixelExportColor(i32, literal u32) void",
            "pixelExportColor(i32, literal i16) void",
            "pixelExportColor(i32, literal u16) void",
            "pixelExportColor(i32x2, literal i32) void",
            "pixelExportColor(i32x2, literal u32) void",
            "pixelExportColor(i32x2, literal i16) void",
            "pixelExportColor(i32x2, literal u16) void",
            "pixelExportColor(i32x3, literal i32) void",
            "pixelExportColor(i32x3, literal u32) void",
            "pixelExportColor(i32x3, literal i16) void",
            "pixelExportColor(i32x3, literal u16) void",
            "pixelExportColor(i32x4, literal i32) void",
            "pixelExportColor(i32x4, literal u32) void",
            "pixelExportColor(i32x4, literal i16) void",
            "pixelExportColor(i32x4, literal u16) void",
            "pixelExportColor(i16, literal i32) void",
            "pixelExportColor(i16, literal u32) void",
            "pixelExportColor(i16, literal i16) void",
            "pixelExportColor(i16, literal u16) void",
            "pixelExportColor(i16x2, literal i32) void",
            "pixelExportColor(i16x2, literal u32) void",
            "pixelExportColor(i16x2, literal i16) void",
            "pixelExportColor(i16x2, literal u16) void",
            "pixelExportColor(i16x3, literal i32) void",
            "pixelExportColor(i16x3, literal u32) void",
            "pixelExportColor(i16x3, literal i16) void",
            "pixelExportColor(i16x3, literal u16) void",
            "pixelExportColor(i16x4, literal i32) void",
            "pixelExportColor(i16x4, literal u32) void",
            "pixelExportColor(i16x4, literal i16) void",
            "pixelExportColor(i16x4, literal u16) void",
            "pixelExportColor(u32, literal i32) void",
            "pixelExportColor(u32, literal u32) void",
            "pixelExportColor(u32, literal i16) void",
            "pixelExportColor(u32, literal u16) void",
            "pixelExportColor(u32x2, literal i32) void",
            "pixelExportColor(u32x2, literal u32) void",
            "pixelExportColor(u32x2, literal i16) void",
            "pixelExportColor(u32x2, literal u16) void",
            "pixelExportColor(u32x3, literal i32) void",
            "pixelExportColor(u32x3, literal u32) void",
            "pixelExportColor(u32x3, literal i16) void",
            "pixelExportColor(u32x3, literal u16) void",
            "pixelExportColor(u32x4, literal i32) void",
            "pixelExportColor(u32x4, literal u32) void",
            "pixelExportColor(u32x4, literal i16) void",
            "pixelExportColor(u32x4, literal u16) void",
            "pixelExportColor(u16, literal i32) void",
            "pixelExportColor(u16, literal u32) void",
            "pixelExportColor(u16, literal i16) void",
            "pixelExportColor(u16, literal u16) void",
            "pixelExportColor(u16x2, literal i32) void",
            "pixelExportColor(u16x2, literal u32) void",
            "pixelExportColor(u16x2, literal i16) void",
            "pixelExportColor(u16x2, literal u16) void",
            "pixelExportColor(u16x3, literal i32) void",
            "pixelExportColor(u16x3, literal u32) void",
            "pixelExportColor(u16x3, literal i16) void",
            "pixelExportColor(u16x3, literal u16) void",
            "pixelExportColor(u16x4, literal i32) void",
            "pixelExportColor(u16x4, literal u32) void",
            "pixelExportColor(u16x4, literal i16) void",
            "pixelExportColor(u16x4, literal u16) void"
        ]
    },
    {
        "name": "computeGetLocalThreadIndices",
        "documentation": "Returns the local thread indices within the workgroup",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "computeGetLocalThreadIndices() u32x3"
        ]
    },
    {
        "name": "computeGetGlobalThreadIndices",
        "documentation": "Returns the global thread indices in the dispatch",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "computeGetGlobalThreadIndices() u32x3"
        ]
    },
    {
        "name": "computeGetWorkgroupIndices",
        "documentation": "Returns the workgroup indices in the dispatch",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "computeGetWorkgroupIndices() u32x3"
        ]
    },
    {
        "name": "computeGetWorkGroupDimensions",
        "documentation": "Returns the dimensions of the workgroup in the dispatch",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "computeGetWorkGroupDimensions() u32x3"
        ]
    },
    {
        "name": "computeGetIndexInWorkgroup",
        "documentation": "Returns flattened index of the current thread in the workgroup using (x * workgroupSize.y + y) * workgroupSize.x + z",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "computeGetIndexInWorkgroup() u32"
        ]
    },
    {
        "name": "subgroupGetId",
        "documentation": "Returns the subgroup ID of the current thread",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "subgroupGetId() u32x3"
        ]
    },
    {
        "name": "subgroupGetSize",
        "documentation": "Returns the size of the subgroup",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "subgroupGetSize() u32x3"
        ]
    },
    {
        "name": "subgroupGetNum",
        "documentation": "Returns the number of subgroups in the workgroup",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "subgroupGetNum() u32x3"
        ]
    },
    {
        "name": "subgroupGetThreadMask",
        "documentation": "Returns a 128 bit subgroup mask where the current thread is active",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "subgroupGetThreadMask() u32x4"
        ]
    },
    {
        "name": "subgroupGetThreadAndLowerMask",
        "documentation": "Returns a 128 bit subgroup mask where the current thread and all lower threads are active",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "subgroupGetThreadAndLowerMask() u32x4"
        ]
    },
    {
        "name": "subgroupGetLowerMask",
        "documentation": "Returns a 128 bit subgroup mask where all lower threads are active",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "subgroupGetLowerMask() u32x4"
        ]
    },
    {
        "name": "subgroupGetThreadAndGreaterMask",
        "documentation": "Returns a 128 bit subgroup mask where the current thread and all greater threads are active",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "subgroupGetThreadAndGreaterMask() u32x4"
        ]
    },
    {
        "name": "subgroupGetGreaterMask",
        "documentation": "Returns a 128 bit subgroup mask where all greater threads are active",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "subgroupGetGreaterMask() u32x4"
        ]
    },
    {
        "name": "subgroupGetFirstActiveThread",
        "documentation": null,
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "subgroupGetFirstActiveThread() u32"
        ]
    },
    {
        "name": "subgroupBroadcastFirstActiveThread",
        "documentation": "Returns the value of the provided argument for the first active thread in the subgroup",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "subgroupBroadcastFirstActiveThread(f32) f32",
            "subgroupBroadcastFirstActiveThread(f32x2) f32x2",
            "subgroupBroadcastFirstActiveThread(f32x3) f32x3",
            "subgroupBroadcastFirstActiveThread(f32x4) f32x4",
            "subgroupBroadcastFirstActiveThread(f16) f16",
            "subgroupBroadcastFirstActiveThread(f16x2) f16x2",
            "subgroupBroadcastFirstActiveThread(f16x3) f16x3",
            "subgroupBroadcastFirstActiveThread(f16x4) f16x4",
            "subgroupBroadcastFirstActiveThread(i32) i32",
            "subgroupBroadcastFirstActiveThread(i32x2) i32x2",
            "subgroupBroadcastFirstActiveThread(i32x3) i32x3",
            "subgroupBroadcastFirstActiveThread(i32x4) i32x4",
            "subgroupBroadcastFirstActiveThread(i16) i16",
            "subgroupBroadcastFirstActiveThread(i16x2) i16x2",
            "subgroupBroadcastFirstActiveThread(i16x3) i16x3",
            "subgroupBroadcastFirstActiveThread(i16x4) i16x4",
            "subgroupBroadcastFirstActiveThread(u32) u32",
            "subgroupBroadcastFirstActiveThread(u32x2) u32x2",
            "subgroupBroadcastFirstActiveThread(u32x3) u32x3",
            "subgroupBroadcastFirstActiveThread(u32x4) u32x4",
            "subgroupBroadcastFirstActiveThread(u16) u16",
            "subgroupBroadcastFirstActiveThread(u16x2) u16x2",
            "subgroupBroadcastFirstActiveThread(u16x3) u16x3",
            "subgroupBroadcastFirstActiveThread(u16x4) u16x4"
        ]
    },
    {
        "name": "subgroupBallot",
        "documentation": "Constructs a 128 bit subgroup thread mask to the value of the predicate argument for each active thread",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "subgroupBallot(b8) u32x4"
        ]
    },
    {
        "name": "subgroupInverseBallot",
        "documentation": "Constructs a 128 bit subgroup thread mask to the inverse of the value of the predicate argument for each active thread",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "subgroupInverseBallot(b8) u32x4"
        ]
    },
    {
        "name": "subgroupBallotBitCount",
        "documentation": "Returns the number of bits set to 1 in a 128 bit subgroup thread mask",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "subgroupBallotBitCount(u32x4) u32"
        ]
    },
    {
        "name": "subgroupBallotFirstOne",
        "documentation": "Returns the first one (ctz) in a 128 bit subgroup thread mask",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "subgroupBallotFirstOne(u32x4) u32"
        ]
    },
    {
        "name": "subgroupBallotLastOne",
        "documentation": "Returns the last one (clz) in a 128 bit subgroup thread mask",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "subgroupBallotLastOne(u32x4) u32"
        ]
    },
    {
        "name": "subgroupBallotBit",
        "documentation": "Extracts a specific bit from a 128 bit subgroup thread mask",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "subgroupBallotBit(u32x4, literal u32) u32"
        ]
    },
    {
        "name": "subgroupSwapDiagonal",
        "documentation": "Swaps the value at the current thread with the value at the diagonal thread in the subgroup",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "subgroupSwapDiagonal(f32) f32",
            "subgroupSwapDiagonal(f32x2) f32x2",
            "subgroupSwapDiagonal(f32x3) f32x3",
            "subgroupSwapDiagonal(f32x4) f32x4",
            "subgroupSwapDiagonal(f16) f16",
            "subgroupSwapDiagonal(f16x2) f16x2",
            "subgroupSwapDiagonal(f16x3) f16x3",
            "subgroupSwapDiagonal(f16x4) f16x4",
            "subgroupSwapDiagonal(i32) i32",
            "subgroupSwapDiagonal(i32x2) i32x2",
            "subgroupSwapDiagonal(i32x3) i32x3",
            "subgroupSwapDiagonal(i32x4) i32x4",
            "subgroupSwapDiagonal(i16) i16",
            "subgroupSwapDiagonal(i16x2) i16x2",
            "subgroupSwapDiagonal(i16x3) i16x3",
            "subgroupSwapDiagonal(i16x4) i16x4",
            "subgroupSwapDiagonal(u32) u32",
            "subgroupSwapDiagonal(u32x2) u32x2",
            "subgroupSwapDiagonal(u32x3) u32x3",
            "subgroupSwapDiagonal(u32x4) u32x4",
            "subgroupSwapDiagonal(u16) u16",
            "subgroupSwapDiagonal(u16x2) u16x2",
            "subgroupSwapDiagonal(u16x3) u16x3",
            "subgroupSwapDiagonal(u16x4) u16x4"
        ]
    },
    {
        "name": "subgroupSwapVertical",
        "documentation": "Swaps the value at the current thread with the value at the vertical thread in the subgroup",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "subgroupSwapVertical(f32) f32",
            "subgroupSwapVertical(f32x2) f32x2",
            "subgroupSwapVertical(f32x3) f32x3",
            "subgroupSwapVertical(f32x4) f32x4",
            "subgroupSwapVertical(f16) f16",
            "subgroupSwapVertical(f16x2) f16x2",
            "subgroupSwapVertical(f16x3) f16x3",
            "subgroupSwapVertical(f16x4) f16x4",
            "subgroupSwapVertical(i32) i32",
            "subgroupSwapVertical(i32x2) i32x2",
            "subgroupSwapVertical(i32x3) i32x3",
            "subgroupSwapVertical(i32x4) i32x4",
            "subgroupSwapVertical(i16) i16",
            "subgroupSwapVertical(i16x2) i16x2",
            "subgroupSwapVertical(i16x3) i16x3",
            "subgroupSwapVertical(i16x4) i16x4",
            "subgroupSwapVertical(u32) u32",
            "subgroupSwapVertical(u32x2) u32x2",
            "subgroupSwapVertical(u32x3) u32x3",
            "subgroupSwapVertical(u32x4) u32x4",
            "subgroupSwapVertical(u16) u16",
            "subgroupSwapVertical(u16x2) u16x2",
            "subgroupSwapVertical(u16x3) u16x3",
            "subgroupSwapVertical(u16x4) u16x4"
        ]
    },
    {
        "name": "subgroupSwapHorizontal",
        "documentation": "Swaps the value at the current thread with the value at the horizontal thread in the subgroup",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "subgroupSwapHorizontal(f32) f32",
            "subgroupSwapHorizontal(f32x2) f32x2",
            "subgroupSwapHorizontal(f32x3) f32x3",
            "subgroupSwapHorizontal(f32x4) f32x4",
            "subgroupSwapHorizontal(f16) f16",
            "subgroupSwapHorizontal(f16x2) f16x2",
            "subgroupSwapHorizontal(f16x3) f16x3",
            "subgroupSwapHorizontal(f16x4) f16x4",
            "subgroupSwapHorizontal(i32) i32",
            "subgroupSwapHorizontal(i32x2) i32x2",
            "subgroupSwapHorizontal(i32x3) i32x3",
            "subgroupSwapHorizontal(i32x4) i32x4",
            "subgroupSwapHorizontal(i16) i16",
            "subgroupSwapHorizontal(i16x2) i16x2",
            "subgroupSwapHorizontal(i16x3) i16x3",
            "subgroupSwapHorizontal(i16x4) i16x4",
            "subgroupSwapHorizontal(u32) u32",
            "subgroupSwapHorizontal(u32x2) u32x2",
            "subgroupSwapHorizontal(u32x3) u32x3",
            "subgroupSwapHorizontal(u32x4) u32x4",
            "subgroupSwapHorizontal(u16) u16",
            "subgroupSwapHorizontal(u16x2) u16x2",
            "subgroupSwapHorizontal(u16x3) u16x3",
            "subgroupSwapHorizontal(u16x4) u16x4"
        ]
    },
    {
        "name": "atomicLoad",
        "documentation": "Loads the value at the pointer location with the specified memory semantics",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "atomicLoad(*u32, literal MemorySemantics) u32",
            "atomicLoad(*i32, literal MemorySemantics) i32",
            "atomicLoad(*u16, literal MemorySemantics) u16",
            "atomicLoad(*i16, literal MemorySemantics) i16"
        ]
    },
    {
        "name": "atomicIncrement",
        "documentation": "Increments the value at the pointer location with the specified memory semantics, returns the old value",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "atomicIncrement(*u32, literal MemorySemantics) u32",
            "atomicIncrement(*i32, literal MemorySemantics) i32",
            "atomicIncrement(*u16, literal MemorySemantics) u16",
            "atomicIncrement(*i16, literal MemorySemantics) i16"
        ]
    },
    {
        "name": "atomicDecrement",
        "documentation": "Decrements the value at the pointer location with the specified memory semantics, returns the old value",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "atomicDecrement(*u32, literal MemorySemantics) u32",
            "atomicDecrement(*i32, literal MemorySemantics) i32",
            "atomicDecrement(*u16, literal MemorySemantics) u16",
            "atomicDecrement(*i16, literal MemorySemantics) i16"
        ]
    },
    {
        "name": "atomicStore",
        "documentation": "Stores the value at the pointer location with the specified memory semantics, returns the old value",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "atomicStore(*u32, u32, literal MemorySemantics) u32",
            "atomicStore(*i32, i32, literal MemorySemantics) i32",
            "atomicStore(*u16, u16, literal MemorySemantics) u16",
            "atomicStore(*i16, i16, literal MemorySemantics) i16"
        ]
    },
    {
        "name": "atomicExchange",
        "documentation": "Exchanges the value at the pointer location with the specified value and memory semantics, returns the old value",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "atomicExchange(*u32, u32, literal MemorySemantics) u32",
            "atomicExchange(*i32, i32, literal MemorySemantics) i32",
            "atomicExchange(*u16, u16, literal MemorySemantics) u16",
            "atomicExchange(*i16, i16, literal MemorySemantics) i16"
        ]
    },
    {
        "name": "atomicAdd",
        "documentation": "Adds the value to the pointer location with the specified memory semantics, returns the old value",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "atomicAdd(*u32, u32, literal MemorySemantics) u32",
            "atomicAdd(*i32, i32, literal MemorySemantics) i32",
            "atomicAdd(*u16, u16, literal MemorySemantics) u16",
            "atomicAdd(*i16, i16, literal MemorySemantics) i16"
        ]
    },
    {
        "name": "atomicSubtract",
        "documentation": "Subtracts the value from the pointer location with the specified memory semantics, returns the old value",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "atomicSubtract(*u32, u32, literal MemorySemantics) u32",
            "atomicSubtract(*i32, i32, literal MemorySemantics) i32",
            "atomicSubtract(*u16, u16, literal MemorySemantics) u16",
            "atomicSubtract(*i16, i16, literal MemorySemantics) i16"
        ]
    },
    {
        "name": "atomicAnd",
        "documentation": "Performs a bitwise AND operation with the value at the pointer location with the specified memory semantics, returns the old value",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "atomicAnd(*u32, u32, literal MemorySemantics) u32",
            "atomicAnd(*i32, i32, literal MemorySemantics) i32",
            "atomicAnd(*u16, u16, literal MemorySemantics) u16",
            "atomicAnd(*i16, i16, literal MemorySemantics) i16"
        ]
    },
    {
        "name": "atomicOr",
        "documentation": "Performs a bitwise OR operation with the value at the pointer location with the specified memory semantics, returns the old value",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "atomicOr(*u32, u32, literal MemorySemantics) u32",
            "atomicOr(*i32, i32, literal MemorySemantics) i32",
            "atomicOr(*u16, u16, literal MemorySemantics) u16",
            "atomicOr(*i16, i16, literal MemorySemantics) i16"
        ]
    },
    {
        "name": "atomicXor",
        "documentation": "Performs a bitwise XOR operation with the value at the pointer location with the specified memory semantics, returns the old value",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "atomicXor(*u32, u32, literal MemorySemantics) u32",
            "atomicXor(*i32, i32, literal MemorySemantics) i32",
            "atomicXor(*u16, u16, literal MemorySemantics) u16",
            "atomicXor(*i16, i16, literal MemorySemantics) i16"
        ]
    },
    {
        "name": "atomicCompareExchange",
        "documentation": "Compares the value at the pointer location with the comparison, and exchanges it with value if they are identical using the specified memory semantics, always returns the old value",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "atomicCompareExchange(*i16, i16, i16, literal MemorySemantics) i16",
            "atomicCompareExchange(*i16, i16, i16, literal MemorySemantics) i16",
            "atomicCompareExchange(*i16, i16, i16, literal MemorySemantics) i16",
            "atomicCompareExchange(*i16, i16, i16, literal MemorySemantics) i16"
        ]
    },
    {
        "name": "bitInsert",
        "documentation": "Insert bit into bitmask",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "bitInsert(u16, u16, u16, u16) u16",
            "bitInsert(u32, u32, u32, u32) u32"
        ]
    },
    {
        "name": "bitExtract",
        "documentation": "Extract a specific bit from a bitmask",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "bitExtract(u32, u32, u32) u32",
            "bitExtract(i32, i32, i32) i32",
            "bitExtract(u16, u16, u16) u16",
            "bitExtract(i16, i16, i16) i16"
        ]
    },
    {
        "name": "bitReverse",
        "documentation": "Reverses the bits in a bitmask",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "bitReverse(u32) u32",
            "bitReverse(i32) i32",
            "bitReverse(u16) u16",
            "bitReverse(i16) i16"
        ]
    },
    {
        "name": "bitCount",
        "documentation": "Counts the number of bits set to 1 in a bitmask",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "bitCount(u32) u32",
            "bitCount(i32) i32",
            "bitCount(u16) u16",
            "bitCount(i16) i16"
        ]
    },
    {
        "name": "executionBarrier",
        "documentation": "Execution barrier to ensure all threads have reached this point before proceeding",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "executionBarrier() i16"
        ]
    },
    {
        "name": "executionBarrierSubgroup",
        "documentation": "Execution barrier to ensure all threads in the subgroup have reached this point before proceeding",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "executionBarrierSubgroup() i16"
        ]
    },
    {
        "name": "executionBarrierWorkgroup",
        "documentation": "Execution barrier to ensure all threads in the workgroup have reached this point before proceeding",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "executionBarrierWorkgroup() i16"
        ]
    },
    {
        "name": "memoryBarrier",
        "documentation": "Memory barrier to ensure memory operations are completed before proceeding",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "memoryBarrier() i16"
        ]
    },
    {
        "name": "memoryBarrierBuffer",
        "documentation": "Memory barrier to ensure buffer memory operations are completed before proceeding",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "memoryBarrierBuffer() i16"
        ]
    },
    {
        "name": "memoryBarrierTexture",
        "documentation": "Memory barrier to ensure texture memory operations are completed before proceeding",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "memoryBarrierTexture() i16"
        ]
    },
    {
        "name": "memoryBarrierAtomic",
        "documentation": "Memory barrier to ensure atomic memory operations are completed before proceeding",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "memoryBarrierAtomic() i16"
        ]
    },
    {
        "name": "memoryBarrierSubgroup",
        "documentation": "Memory barrier to ensure subgroup memory operations are completed before proceeding",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "memoryBarrierSubgroup() i16"
        ]
    },
    {
        "name": "memoryBarrierWorkgroup",
        "documentation": "Memory barrier to ensure workgroup memory operations are completed before proceeding",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "memoryBarrierWorkgroup() i16"
        ]
    },
    {
        "name": "textureGetSize",
        "documentation": "Get the size of a texture",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureGetSize(uniform *texture1D) u32",
            "textureGetSize(uniform *texture2D) u32x2",
            "textureGetSize(uniform *texture3D) u32x3",
            "textureGetSize(uniform *textureCube) u32x3",
            "textureGetSize(uniform *texture1DArray) u32x2",
            "textureGetSize(uniform *texture2DArray) u32x3",
            "textureGetSize(uniform *textureCubeArray) u32x4"
        ]
    },
    {
        "name": "textureGetSizeMip",
        "documentation": "Get the size of a texture at a specific mip level",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureGetSizeMip(uniform *texture1D, u32) u32",
            "textureGetSizeMip(uniform *texture2D, u32) u32x2",
            "textureGetSizeMip(uniform *texture3D, u32) u32x3",
            "textureGetSizeMip(uniform *textureCube, u32) u32x3",
            "textureGetSizeMip(uniform *texture1DArray, u32) u32x2",
            "textureGetSizeMip(uniform *texture2DArray, u32) u32x3",
            "textureGetSizeMip(uniform *textureCubeArray, u32) u32x4"
        ]
    },
    {
        "name": "textureGetMips",
        "documentation": "Get the number of mips in a texture",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureGetMips(uniform *texture1D) texture1D",
            "textureGetMips(uniform *texture2D) texture2D",
            "textureGetMips(uniform *texture3D) texture3D",
            "textureGetMips(uniform *textureCube) textureCube",
            "textureGetMips(uniform *texture1DArray) texture1DArray",
            "textureGetMips(uniform *texture2DArray) texture2DArray",
            "textureGetMips(uniform *textureCubeArray) textureCubeArray"
        ]
    },
    {
        "name": "textureGetSamples",
        "documentation": "Get the number of samples in a multisampled texture",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureGetSamples(uniform *texture2DMS) texture2DMS",
            "textureGetSamples(uniform *texture2DMSArray) texture2DMSArray"
        ]
    },
    {
        "name": "textureGetSampledMip",
        "documentation": "Get the mip level of a texture at a specific coordinate. The return value is a vector where the first value is the mip level to sample, and the second is the offset relative to the base mip for which the sample would occur",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureGetSampledMip(uniform *texture1D, uniform *sampler, f32) f32x2",
            "textureGetSampledMip(uniform *sampled texture1D, f32) f32x2",
            "textureGetSampledMip(uniform *texture2D, uniform *sampler, f32x2) f32x2",
            "textureGetSampledMip(uniform *sampled texture2D, f32x2) f32x2",
            "textureGetSampledMip(uniform *texture3D, uniform *sampler, f32x3) f32x2",
            "textureGetSampledMip(uniform *sampled texture3D, f32x3) f32x2",
            "textureGetSampledMip(uniform *textureCube, uniform *sampler, f32x3) f32x2",
            "textureGetSampledMip(uniform *sampled textureCube, f32x3) f32x2",
            "textureGetSampledMip(uniform *texture1DArray, uniform *sampler, f32x2) f32x2",
            "textureGetSampledMip(uniform *sampled texture1DArray, f32x2) f32x2",
            "textureGetSampledMip(uniform *texture2DArray, uniform *sampler, f32x3) f32x2",
            "textureGetSampledMip(uniform *sampled texture2DArray, f32x3) f32x2",
            "textureGetSampledMip(uniform *textureCubeArray, uniform *sampler, f32x4) f32x2",
            "textureGetSampledMip(uniform *sampled textureCubeArray, f32x4) f32x2"
        ]
    },
    {
        "name": "textureLoad",
        "documentation": "Load a single texel without using a sampler value at an absolute non-normalized coordinate",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureLoad(uniform *mutable texture1D, i32) f32x4",
            "textureLoad(uniform *mutable texture2D, i32x2) f32x4",
            "textureLoad(uniform *mutable texture3D, i32x3) f32x4",
            "textureLoad(uniform *mutable textureCube, i32x3) f32x4",
            "textureLoad(uniform *mutable texture1DArray, i32x2) f32x4",
            "textureLoad(uniform *mutable texture2DArray, i32x3) f32x4",
            "textureLoad(uniform *mutable textureCubeArray, i32x4) f32x4",
            "textureLoad(uniform *mutable texture2DMS, i32x2) f32x4",
            "textureLoad(uniform *mutable texture2DMSArray, i32x3) f32x4"
        ]
    },
    {
        "name": "textureLoadMip",
        "documentation": "Load a single texel without using a sampler value at an absolute non-normalized coordinate at a specific mip level",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureLoadMip(uniform *mutable texture1D, i32, i32) f32x4",
            "textureLoadMip(uniform *mutable texture2D, i32x2, i32) f32x4",
            "textureLoadMip(uniform *mutable texture3D, i32x3, i32) f32x4",
            "textureLoadMip(uniform *mutable textureCube, i32x3, i32) f32x4",
            "textureLoadMip(uniform *mutable texture1DArray, i32x2, i32) f32x4",
            "textureLoadMip(uniform *mutable texture2DArray, i32x3, i32) f32x4",
            "textureLoadMip(uniform *mutable textureCubeArray, i32x4, i32) f32x4",
            "textureLoadMip(uniform *mutable texture2DMS, i32x2, i32) f32x4",
            "textureLoadMip(uniform *mutable texture2DMSArray, i32x3, i32) f32x4"
        ]
    },
    {
        "name": "textureStore",
        "documentation": "Store a single texel without using a sampler value at an absolute non-normalized coordinate",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureStore(uniform *mutable texture1D, i32, f32x4) void",
            "textureStore(uniform *mutable texture2D, i32x2, f32x4) void",
            "textureStore(uniform *mutable texture3D, i32x3, f32x4) void",
            "textureStore(uniform *mutable textureCube, i32x3, f32x4) void",
            "textureStore(uniform *mutable texture1DArray, i32x2, f32x4) void",
            "textureStore(uniform *mutable texture2DArray, i32x3, f32x4) void",
            "textureStore(uniform *mutable textureCubeArray, i32x4, f32x4) void",
            "textureStore(uniform *mutable texture2DMS, i32x2, f32x4) void",
            "textureStore(uniform *mutable texture2DMSArray, i32x3, f32x4) void"
        ]
    },
    {
        "name": "textureStoreMip",
        "documentation": "Store a single texel without using a sampler value at an absolute non-normalized coordinate at a specific mip level",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureStoreMip(uniform *mutable texture1D, i32, i32, f32x4) void",
            "textureStoreMip(uniform *mutable texture2D, i32x2, i32, f32x4) void",
            "textureStoreMip(uniform *mutable texture3D, i32x3, i32, f32x4) void",
            "textureStoreMip(uniform *mutable textureCube, i32x3, i32, f32x4) void",
            "textureStoreMip(uniform *mutable texture1DArray, i32x2, i32, f32x4) void",
            "textureStoreMip(uniform *mutable texture2DArray, i32x3, i32, f32x4) void",
            "textureStoreMip(uniform *mutable textureCubeArray, i32x4, i32, f32x4) void",
            "textureStoreMip(uniform *mutable texture2DMS, i32x2, i32, f32x4) void",
            "textureStoreMip(uniform *mutable texture2DMSArray, i32x3, i32, f32x4) void"
        ]
    },
    {
        "name": "textureFetch",
        "documentation": "Fetch a single texel without using a sampler value at a coordinate",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureFetch(uniform *texture1D, i32, u32) f32x4",
            "textureFetch(uniform *texture2D, i32x2, u32) f32x4",
            "textureFetch(uniform *texture3D, i32x3, u32) f32x4",
            "textureFetch(uniform *texture1DArray, i32x2, u32) f32x4",
            "textureFetch(uniform *texture2DArray, i32x3, u32) f32x4",
            "textureFetch(uniform *texture2DMS, i32x2, u32) f32x4",
            "textureFetch(uniform *texture2DMSArray, i32x3, u32) f32x4"
        ]
    },
    {
        "name": "textureFetchSample",
        "documentation": "Fetch a single texel without using a sampler value at a coordinate at a specific sample index",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureFetchSample(uniform *texture1D, i32, u32, u32) f32x4",
            "textureFetchSample(uniform *texture2D, i32x2, u32, u32) f32x4",
            "textureFetchSample(uniform *texture3D, i32x3, u32, u32) f32x4",
            "textureFetchSample(uniform *texture1DArray, i32x2, u32, u32) f32x4",
            "textureFetchSample(uniform *texture2DArray, i32x3, u32, u32) f32x4",
            "textureFetchSample(uniform *texture2DMS, i32x2, u32, u32) f32x4",
            "textureFetchSample(uniform *texture2DMSArray, i32x3, u32, u32) f32x4"
        ]
    },
    {
        "name": "textureGather",
        "documentation": "Gather 4 values of a quad at a coordinate where the component is the channel to read",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureGather(uniform *texture2D, uniform *sampler, i32x2, i32) f32x4",
            "textureGather(uniform *sampled texture2D, i32x2, i32) f32x4",
            "textureGather(uniform *textureCube, uniform *sampler, i32x3, i32) f32x4",
            "textureGather(uniform *sampled textureCube, i32x3, i32) f32x4",
            "textureGather(uniform *texture2DArray, uniform *sampler, i32x3, i32) f32x4",
            "textureGather(uniform *sampled texture2DArray, i32x3, i32) f32x4",
            "textureGather(uniform *textureCubeArray, uniform *sampler, i32x4, i32) f32x4",
            "textureGather(uniform *sampled textureCubeArray, i32x4, i32) f32x4"
        ]
    },
    {
        "name": "textureGatherOffset",
        "documentation": "Gather 4 values of a quad at a coordinate where the component is the channel to read with an offset applied to the coordinate",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureGatherOffset(uniform *texture2D, uniform *sampler, i32x2, i32, u32) f32x4",
            "textureGatherOffset(uniform *sampled texture2D, i32x2, i32, u32) f32x4",
            "textureGatherOffset(uniform *textureCube, uniform *sampler, i32x3, i32, u32) f32x4",
            "textureGatherOffset(uniform *sampled textureCube, i32x3, i32, u32) f32x4",
            "textureGatherOffset(uniform *texture2DArray, uniform *sampler, i32x3, i32, u32) f32x4",
            "textureGatherOffset(uniform *sampled texture2DArray, i32x3, i32, u32) f32x4",
            "textureGatherOffset(uniform *textureCubeArray, uniform *sampler, i32x4, i32, u32) f32x4",
            "textureGatherOffset(uniform *sampled textureCubeArray, i32x4, i32, u32) f32x4"
        ]
    },
    {
        "name": "texturePixelCacheLoad",
        "documentation": "Load a pixel value from a previous thread",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "texturePixelCacheLoad(uniform *pixelCache) pixelCache",
            "texturePixelCacheLoad(uniform *pixelCacheMS, u32) pixelCacheMS"
        ]
    },
    {
        "name": "textureSample",
        "documentation": "Sample a texture at coordinate",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureSample(uniform *texture1D, uniform *sampler, f32) f32x4",
            "textureSample(uniform *sampled texture1D, f32) f32x4",
            "textureSample(uniform *texture2D, uniform *sampler, f32x2) f32x4",
            "textureSample(uniform *sampled texture2D, f32x2) f32x4",
            "textureSample(uniform *texture3D, uniform *sampler, f32x3) f32x4",
            "textureSample(uniform *sampled texture3D, f32x3) f32x4",
            "textureSample(uniform *textureCube, uniform *sampler, f32x3) f32x4",
            "textureSample(uniform *sampled textureCube, f32x3) f32x4",
            "textureSample(uniform *texture1DArray, uniform *sampler, f32x2) f32x4",
            "textureSample(uniform *sampled texture1DArray, f32x2) f32x4",
            "textureSample(uniform *texture2DArray, uniform *sampler, f32x3) f32x4",
            "textureSample(uniform *sampled texture2DArray, f32x3) f32x4",
            "textureSample(uniform *textureCubeArray, uniform *sampler, f32x4) f32x4",
            "textureSample(uniform *sampled textureCubeArray, f32x4) f32x4"
        ]
    },
    {
        "name": "textureSampleOffset",
        "documentation": "Sample a texture at coordinate with an offset applied to the coordinate",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureSampleOffset(uniform *texture1D, uniform *sampler, f32, f32) f32x4",
            "textureSampleOffset(uniform *sampled texture1D, f32, f32) f32x4",
            "textureSampleOffset(uniform *texture2D, uniform *sampler, f32x2, f32x2) f32x4",
            "textureSampleOffset(uniform *sampled texture2D, f32x2, f32x2) f32x4",
            "textureSampleOffset(uniform *texture3D, uniform *sampler, f32x3, f32x3) f32x4",
            "textureSampleOffset(uniform *sampled texture3D, f32x3, f32x3) f32x4",
            "textureSampleOffset(uniform *texture1DArray, uniform *sampler, f32x2, f32x2) f32x4",
            "textureSampleOffset(uniform *sampled texture1DArray, f32x2, f32x2) f32x4",
            "textureSampleOffset(uniform *texture2DArray, uniform *sampler, f32x3, f32x3) f32x4",
            "textureSampleOffset(uniform *sampled texture2DArray, f32x3, f32x3) f32x4"
        ]
    },
    {
        "name": "textureSampleProj",
        "documentation": "Sample a texture at coordinate with projection",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureSampleProj(uniform *texture1D, uniform *sampler, f32, f32) f32x4",
            "textureSampleProj(uniform *sampled texture1D, f32, f32) f32x4",
            "textureSampleProj(uniform *texture2D, uniform *sampler, f32x2, f32) f32x4",
            "textureSampleProj(uniform *sampled texture2D, f32x2, f32) f32x4",
            "textureSampleProj(uniform *texture3D, uniform *sampler, f32x3, f32) f32x4",
            "textureSampleProj(uniform *sampled texture3D, f32x3, f32) f32x4"
        ]
    },
    {
        "name": "textureSampleProjOffset",
        "documentation": "Sample a texture at coordinate with projection with an offset applied to the coordinate",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureSampleProjOffset(uniform *texture1D, uniform *sampler, f32, f32, f32) f32x4",
            "textureSampleProjOffset(uniform *sampled texture1D, f32, f32, f32) f32x4",
            "textureSampleProjOffset(uniform *texture2D, uniform *sampler, f32x2, f32, f32x2) f32x4",
            "textureSampleProjOffset(uniform *sampled texture2D, f32x2, f32, f32x2) f32x4",
            "textureSampleProjOffset(uniform *texture3D, uniform *sampler, f32x3, f32, f32x3) f32x4",
            "textureSampleProjOffset(uniform *sampled texture3D, f32x3, f32, f32x3) f32x4"
        ]
    },
    {
        "name": "textureSampleCompare",
        "documentation": "Sample a texture at coordinate with depth comparison",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureSampleCompare(uniform *texture1D, uniform *sampler, f32, f32) f32",
            "textureSampleCompare(uniform *sampled texture1D, f32, f32) f32",
            "textureSampleCompare(uniform *texture2D, uniform *sampler, f32x2, f32) f32",
            "textureSampleCompare(uniform *sampled texture2D, f32x2, f32) f32",
            "textureSampleCompare(uniform *texture3D, uniform *sampler, f32x3, f32) f32",
            "textureSampleCompare(uniform *sampled texture3D, f32x3, f32) f32",
            "textureSampleCompare(uniform *texture1DArray, uniform *sampler, f32x2, f32) f32",
            "textureSampleCompare(uniform *sampled texture1DArray, f32x2, f32) f32",
            "textureSampleCompare(uniform *texture2DArray, uniform *sampler, f32x3, f32) f32",
            "textureSampleCompare(uniform *sampled texture2DArray, f32x3, f32) f32"
        ]
    },
    {
        "name": "textureSampleCompareOffset",
        "documentation": "Sample a texture at coordinate with depth comparison with an offset applied to the coordinate",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureSampleCompareOffset(uniform *texture1D, uniform *sampler, f32, f32, f32) f32",
            "textureSampleCompareOffset(uniform *sampled texture1D, f32, f32, f32) f32",
            "textureSampleCompareOffset(uniform *texture2D, uniform *sampler, f32x2, f32, f32x2) f32",
            "textureSampleCompareOffset(uniform *sampled texture2D, f32x2, f32, f32x2) f32",
            "textureSampleCompareOffset(uniform *texture3D, uniform *sampler, f32x3, f32, f32x3) f32",
            "textureSampleCompareOffset(uniform *sampled texture3D, f32x3, f32, f32x3) f32",
            "textureSampleCompareOffset(uniform *texture1DArray, uniform *sampler, f32x2, f32, f32x2) f32",
            "textureSampleCompareOffset(uniform *sampled texture1DArray, f32x2, f32, f32x2) f32",
            "textureSampleCompareOffset(uniform *texture2DArray, uniform *sampler, f32x3, f32, f32x3) f32",
            "textureSampleCompareOffset(uniform *sampled texture2DArray, f32x3, f32, f32x3) f32"
        ]
    },
    {
        "name": "textureSampleProjCompare",
        "documentation": "Sample a texture at coordinate with projection with depth comparison",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureSampleProjCompare(uniform *texture1D, uniform *sampler, f32, f32, f32) f32",
            "textureSampleProjCompare(uniform *sampled texture1D, f32, f32, f32) f32",
            "textureSampleProjCompare(uniform *texture2D, uniform *sampler, f32x2, f32, f32) f32",
            "textureSampleProjCompare(uniform *sampled texture2D, f32x2, f32, f32) f32",
            "textureSampleProjCompare(uniform *texture3D, uniform *sampler, f32x3, f32, f32) f32",
            "textureSampleProjCompare(uniform *sampled texture3D, f32x3, f32, f32) f32"
        ]
    },
    {
        "name": "textureSampleProjCompareOffset",
        "documentation": "Sample a texture at coordinate with projection with depth comparison with an offset applied to the coordinate",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureSampleProjCompareOffset(uniform *texture1D, uniform *sampler, f32, f32, f32, f32) f32",
            "textureSampleProjCompareOffset(uniform *sampled texture1D, f32, f32, f32, f32) f32",
            "textureSampleProjCompareOffset(uniform *texture2D, uniform *sampler, f32x2, f32, f32, f32x2) f32",
            "textureSampleProjCompareOffset(uniform *sampled texture2D, f32x2, f32, f32, f32x2) f32",
            "textureSampleProjCompareOffset(uniform *texture3D, uniform *sampler, f32x3, f32, f32, f32x3) f32",
            "textureSampleProjCompareOffset(uniform *sampled texture3D, f32x3, f32, f32, f32x3) f32"
        ]
    },
    {
        "name": "textureSampleLod",
        "documentation": "Sample a texture at coordinate with explicit level of detail",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureSampleLod(uniform *texture1D, uniform *sampler, f32, f32) f32x4",
            "textureSampleLod(uniform *sampled texture1D, f32, f32) f32x4",
            "textureSampleLod(uniform *texture2D, uniform *sampler, f32x2, f32) f32x4",
            "textureSampleLod(uniform *sampled texture2D, f32x2, f32) f32x4",
            "textureSampleLod(uniform *texture3D, uniform *sampler, f32x3, f32) f32x4",
            "textureSampleLod(uniform *sampled texture3D, f32x3, f32) f32x4",
            "textureSampleLod(uniform *textureCube, uniform *sampler, f32x3, f32) f32x4",
            "textureSampleLod(uniform *sampled textureCube, f32x3, f32) f32x4",
            "textureSampleLod(uniform *texture1DArray, uniform *sampler, f32x2, f32) f32x4",
            "textureSampleLod(uniform *sampled texture1DArray, f32x2, f32) f32x4",
            "textureSampleLod(uniform *texture2DArray, uniform *sampler, f32x3, f32) f32x4",
            "textureSampleLod(uniform *sampled texture2DArray, f32x3, f32) f32x4",
            "textureSampleLod(uniform *textureCubeArray, uniform *sampler, f32x4, f32) f32x4",
            "textureSampleLod(uniform *sampled textureCubeArray, f32x4, f32) f32x4"
        ]
    },
    {
        "name": "textureSampleLodOffset",
        "documentation": "Sample a texture at coordinate with explicit level of detail with an offset applied to the coordinate",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureSampleLodOffset(uniform *texture1D, uniform *sampler, f32, f32, f32) f32x4",
            "textureSampleLodOffset(uniform *sampled texture1D, f32, f32, f32) f32x4",
            "textureSampleLodOffset(uniform *texture2D, uniform *sampler, f32x2, f32, f32x2) f32x4",
            "textureSampleLodOffset(uniform *sampled texture2D, f32x2, f32, f32x2) f32x4",
            "textureSampleLodOffset(uniform *texture3D, uniform *sampler, f32x3, f32, f32x3) f32x4",
            "textureSampleLodOffset(uniform *sampled texture3D, f32x3, f32, f32x3) f32x4",
            "textureSampleLodOffset(uniform *texture1DArray, uniform *sampler, f32x2, f32, f32x2) f32x4",
            "textureSampleLodOffset(uniform *sampled texture1DArray, f32x2, f32, f32x2) f32x4",
            "textureSampleLodOffset(uniform *texture2DArray, uniform *sampler, f32x3, f32, f32x3) f32x4",
            "textureSampleLodOffset(uniform *sampled texture2DArray, f32x3, f32, f32x3) f32x4"
        ]
    },
    {
        "name": "textureSampleLodProj",
        "documentation": "Sample a texture at coordinate with explicit level of detail with projection",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureSampleLodProj(uniform *texture1D, uniform *sampler, f32, f32, f32) f32x4",
            "textureSampleLodProj(uniform *sampled texture1D, f32, f32, f32) f32x4",
            "textureSampleLodProj(uniform *texture2D, uniform *sampler, f32x2, f32, f32) f32x4",
            "textureSampleLodProj(uniform *sampled texture2D, f32x2, f32, f32) f32x4",
            "textureSampleLodProj(uniform *texture3D, uniform *sampler, f32x3, f32, f32) f32x4",
            "textureSampleLodProj(uniform *sampled texture3D, f32x3, f32, f32) f32x4"
        ]
    },
    {
        "name": "textureSampleLodProjOffset",
        "documentation": "Sample a texture at coordinate with explicit level of detail with projection with an offset applied to the coordinate",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureSampleLodProjOffset(uniform *texture1D, uniform *sampler, f32, f32, f32, f32) f32x4",
            "textureSampleLodProjOffset(uniform *sampled texture1D, f32, f32, f32, f32) f32x4",
            "textureSampleLodProjOffset(uniform *texture2D, uniform *sampler, f32x2, f32, f32, f32x2) f32x4",
            "textureSampleLodProjOffset(uniform *sampled texture2D, f32x2, f32, f32, f32x2) f32x4",
            "textureSampleLodProjOffset(uniform *texture3D, uniform *sampler, f32x3, f32, f32, f32x3) f32x4",
            "textureSampleLodProjOffset(uniform *sampled texture3D, f32x3, f32, f32, f32x3) f32x4"
        ]
    },
    {
        "name": "textureSampleLodCompare",
        "documentation": "Sample a texture at coordinate with explicit level of detail with depth comparison",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureSampleLodCompare(uniform *texture1D, uniform *sampler, f32, f32, f32) f32",
            "textureSampleLodCompare(uniform *sampled texture1D, f32, f32, f32) f32",
            "textureSampleLodCompare(uniform *texture2D, uniform *sampler, f32x2, f32, f32) f32",
            "textureSampleLodCompare(uniform *sampled texture2D, f32x2, f32, f32) f32",
            "textureSampleLodCompare(uniform *texture3D, uniform *sampler, f32x3, f32, f32) f32",
            "textureSampleLodCompare(uniform *sampled texture3D, f32x3, f32, f32) f32",
            "textureSampleLodCompare(uniform *texture1DArray, uniform *sampler, f32x2, f32, f32) f32",
            "textureSampleLodCompare(uniform *sampled texture1DArray, f32x2, f32, f32) f32",
            "textureSampleLodCompare(uniform *texture2DArray, uniform *sampler, f32x3, f32, f32) f32",
            "textureSampleLodCompare(uniform *sampled texture2DArray, f32x3, f32, f32) f32"
        ]
    },
    {
        "name": "textureSampleLodCompareOffset",
        "documentation": "Sample a texture at coordinate with explicit level of detail with depth comparison with an offset applied to the coordinate",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureSampleLodCompareOffset(uniform *texture1D, uniform *sampler, f32, f32, f32, f32) f32",
            "textureSampleLodCompareOffset(uniform *sampled texture1D, f32, f32, f32, f32) f32",
            "textureSampleLodCompareOffset(uniform *texture2D, uniform *sampler, f32x2, f32, f32, f32x2) f32",
            "textureSampleLodCompareOffset(uniform *sampled texture2D, f32x2, f32, f32, f32x2) f32",
            "textureSampleLodCompareOffset(uniform *texture3D, uniform *sampler, f32x3, f32, f32, f32x3) f32",
            "textureSampleLodCompareOffset(uniform *sampled texture3D, f32x3, f32, f32, f32x3) f32",
            "textureSampleLodCompareOffset(uniform *texture1DArray, uniform *sampler, f32x2, f32, f32, f32x2) f32",
            "textureSampleLodCompareOffset(uniform *sampled texture1DArray, f32x2, f32, f32, f32x2) f32",
            "textureSampleLodCompareOffset(uniform *texture2DArray, uniform *sampler, f32x3, f32, f32, f32x3) f32",
            "textureSampleLodCompareOffset(uniform *sampled texture2DArray, f32x3, f32, f32, f32x3) f32"
        ]
    },
    {
        "name": "textureSampleLodProjCompare",
        "documentation": "Sample a texture at coordinate with explicit level of detail with projection with depth comparison",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureSampleLodProjCompare(uniform *texture1D, uniform *sampler, f32, f32, f32, f32) f32",
            "textureSampleLodProjCompare(uniform *sampled texture1D, f32, f32, f32, f32) f32",
            "textureSampleLodProjCompare(uniform *texture2D, uniform *sampler, f32x2, f32, f32, f32) f32",
            "textureSampleLodProjCompare(uniform *sampled texture2D, f32x2, f32, f32, f32) f32",
            "textureSampleLodProjCompare(uniform *texture3D, uniform *sampler, f32x3, f32, f32, f32) f32",
            "textureSampleLodProjCompare(uniform *sampled texture3D, f32x3, f32, f32, f32) f32"
        ]
    },
    {
        "name": "textureSampleLodProjCompareOffset",
        "documentation": "Sample a texture at coordinate with explicit level of detail with projection with depth comparison with an offset applied to the coordinate",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureSampleLodProjCompareOffset(uniform *texture1D, uniform *sampler, f32, f32, f32, f32, f32) f32",
            "textureSampleLodProjCompareOffset(uniform *sampled texture1D, f32, f32, f32, f32, f32) f32",
            "textureSampleLodProjCompareOffset(uniform *texture2D, uniform *sampler, f32x2, f32, f32, f32, f32x2) f32",
            "textureSampleLodProjCompareOffset(uniform *sampled texture2D, f32x2, f32, f32, f32, f32x2) f32",
            "textureSampleLodProjCompareOffset(uniform *texture3D, uniform *sampler, f32x3, f32, f32, f32, f32x3) f32",
            "textureSampleLodProjCompareOffset(uniform *sampled texture3D, f32x3, f32, f32, f32, f32x3) f32"
        ]
    },
    {
        "name": "textureSampleGrad",
        "documentation": "Sample a texture at coordinate with explicit gradient",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureSampleGrad(uniform *texture1D, uniform *sampler, f32, f32, f32) f32x4",
            "textureSampleGrad(uniform *sampled texture1D, f32, f32, f32) f32x4",
            "textureSampleGrad(uniform *texture2D, uniform *sampler, f32x2, f32x2, f32x2) f32x4",
            "textureSampleGrad(uniform *sampled texture2D, f32x2, f32x2, f32x2) f32x4",
            "textureSampleGrad(uniform *texture3D, uniform *sampler, f32x3, f32x3, f32x3) f32x4",
            "textureSampleGrad(uniform *sampled texture3D, f32x3, f32x3, f32x3) f32x4",
            "textureSampleGrad(uniform *textureCube, uniform *sampler, f32x3, f32x3, f32x3) f32x4",
            "textureSampleGrad(uniform *sampled textureCube, f32x3, f32x3, f32x3) f32x4",
            "textureSampleGrad(uniform *texture1DArray, uniform *sampler, f32x2, f32x2, f32x2) f32x4",
            "textureSampleGrad(uniform *sampled texture1DArray, f32x2, f32x2, f32x2) f32x4",
            "textureSampleGrad(uniform *texture2DArray, uniform *sampler, f32x3, f32x3, f32x3) f32x4",
            "textureSampleGrad(uniform *sampled texture2DArray, f32x3, f32x3, f32x3) f32x4",
            "textureSampleGrad(uniform *textureCubeArray, uniform *sampler, f32x4, f32x4, f32x4) f32x4",
            "textureSampleGrad(uniform *sampled textureCubeArray, f32x4, f32x4, f32x4) f32x4"
        ]
    },
    {
        "name": "textureSampleGradOffset",
        "documentation": "Sample a texture at coordinate with explicit gradient with an offset applied to the coordinate",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureSampleGradOffset(uniform *texture1D, uniform *sampler, f32, f32, f32, f32) f32x4",
            "textureSampleGradOffset(uniform *sampled texture1D, f32, f32, f32, f32) f32x4",
            "textureSampleGradOffset(uniform *texture2D, uniform *sampler, f32x2, f32x2, f32x2, f32x2) f32x4",
            "textureSampleGradOffset(uniform *sampled texture2D, f32x2, f32x2, f32x2, f32x2) f32x4",
            "textureSampleGradOffset(uniform *texture3D, uniform *sampler, f32x3, f32x3, f32x3, f32x3) f32x4",
            "textureSampleGradOffset(uniform *sampled texture3D, f32x3, f32x3, f32x3, f32x3) f32x4",
            "textureSampleGradOffset(uniform *texture1DArray, uniform *sampler, f32x2, f32x2, f32x2, f32x2) f32x4",
            "textureSampleGradOffset(uniform *sampled texture1DArray, f32x2, f32x2, f32x2, f32x2) f32x4",
            "textureSampleGradOffset(uniform *texture2DArray, uniform *sampler, f32x3, f32x3, f32x3, f32x3) f32x4",
            "textureSampleGradOffset(uniform *sampled texture2DArray, f32x3, f32x3, f32x3, f32x3) f32x4"
        ]
    },
    {
        "name": "textureSampleGradProj",
        "documentation": "Sample a texture at coordinate with explicit gradient with projection",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureSampleGradProj(uniform *texture1D, uniform *sampler, f32, f32, f32, f32) f32x4",
            "textureSampleGradProj(uniform *sampled texture1D, f32, f32, f32, f32) f32x4",
            "textureSampleGradProj(uniform *texture2D, uniform *sampler, f32x2, f32x2, f32x2, f32) f32x4",
            "textureSampleGradProj(uniform *sampled texture2D, f32x2, f32x2, f32x2, f32) f32x4",
            "textureSampleGradProj(uniform *texture3D, uniform *sampler, f32x3, f32x3, f32x3, f32) f32x4",
            "textureSampleGradProj(uniform *sampled texture3D, f32x3, f32x3, f32x3, f32) f32x4"
        ]
    },
    {
        "name": "textureSampleGradProjOffset",
        "documentation": "Sample a texture at coordinate with explicit gradient with projection with an offset applied to the coordinate",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureSampleGradProjOffset(uniform *texture1D, uniform *sampler, f32, f32, f32, f32, f32) f32x4",
            "textureSampleGradProjOffset(uniform *sampled texture1D, f32, f32, f32, f32, f32) f32x4",
            "textureSampleGradProjOffset(uniform *texture2D, uniform *sampler, f32x2, f32x2, f32x2, f32, f32x2) f32x4",
            "textureSampleGradProjOffset(uniform *sampled texture2D, f32x2, f32x2, f32x2, f32, f32x2) f32x4",
            "textureSampleGradProjOffset(uniform *texture3D, uniform *sampler, f32x3, f32x3, f32x3, f32, f32x3) f32x4",
            "textureSampleGradProjOffset(uniform *sampled texture3D, f32x3, f32x3, f32x3, f32, f32x3) f32x4"
        ]
    },
    {
        "name": "textureSampleGradCompare",
        "documentation": "Sample a texture at coordinate with explicit gradient with depth comparison",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureSampleGradCompare(uniform *texture1D, uniform *sampler, f32, f32, f32, f32) f32",
            "textureSampleGradCompare(uniform *sampled texture1D, f32, f32, f32, f32) f32",
            "textureSampleGradCompare(uniform *texture2D, uniform *sampler, f32x2, f32x2, f32x2, f32) f32",
            "textureSampleGradCompare(uniform *sampled texture2D, f32x2, f32x2, f32x2, f32) f32",
            "textureSampleGradCompare(uniform *texture3D, uniform *sampler, f32x3, f32x3, f32x3, f32) f32",
            "textureSampleGradCompare(uniform *sampled texture3D, f32x3, f32x3, f32x3, f32) f32",
            "textureSampleGradCompare(uniform *texture1DArray, uniform *sampler, f32x2, f32x2, f32x2, f32) f32",
            "textureSampleGradCompare(uniform *sampled texture1DArray, f32x2, f32x2, f32x2, f32) f32",
            "textureSampleGradCompare(uniform *texture2DArray, uniform *sampler, f32x3, f32x3, f32x3, f32) f32",
            "textureSampleGradCompare(uniform *sampled texture2DArray, f32x3, f32x3, f32x3, f32) f32"
        ]
    },
    {
        "name": "textureSampleGradCompareOffset",
        "documentation": "Sample a texture at coordinate with explicit gradient with depth comparison with an offset applied to the coordinate",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureSampleGradCompareOffset(uniform *texture1D, uniform *sampler, f32, f32, f32, f32, f32) f32",
            "textureSampleGradCompareOffset(uniform *sampled texture1D, f32, f32, f32, f32, f32) f32",
            "textureSampleGradCompareOffset(uniform *texture2D, uniform *sampler, f32x2, f32x2, f32x2, f32, f32x2) f32",
            "textureSampleGradCompareOffset(uniform *sampled texture2D, f32x2, f32x2, f32x2, f32, f32x2) f32",
            "textureSampleGradCompareOffset(uniform *texture3D, uniform *sampler, f32x3, f32x3, f32x3, f32, f32x3) f32",
            "textureSampleGradCompareOffset(uniform *sampled texture3D, f32x3, f32x3, f32x3, f32, f32x3) f32",
            "textureSampleGradCompareOffset(uniform *texture1DArray, uniform *sampler, f32x2, f32x2, f32x2, f32, f32x2) f32",
            "textureSampleGradCompareOffset(uniform *sampled texture1DArray, f32x2, f32x2, f32x2, f32, f32x2) f32",
            "textureSampleGradCompareOffset(uniform *texture2DArray, uniform *sampler, f32x3, f32x3, f32x3, f32, f32x3) f32",
            "textureSampleGradCompareOffset(uniform *sampled texture2DArray, f32x3, f32x3, f32x3, f32, f32x3) f32"
        ]
    },
    {
        "name": "textureSampleGradProjCompare",
        "documentation": "Sample a texture at coordinate with explicit gradient with projection with depth comparison",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureSampleGradProjCompare(uniform *texture1D, uniform *sampler, f32, f32, f32, f32, f32) f32",
            "textureSampleGradProjCompare(uniform *sampled texture1D, f32, f32, f32, f32, f32) f32",
            "textureSampleGradProjCompare(uniform *texture2D, uniform *sampler, f32x2, f32x2, f32x2, f32, f32) f32",
            "textureSampleGradProjCompare(uniform *sampled texture2D, f32x2, f32x2, f32x2, f32, f32) f32",
            "textureSampleGradProjCompare(uniform *texture3D, uniform *sampler, f32x3, f32x3, f32x3, f32, f32) f32",
            "textureSampleGradProjCompare(uniform *sampled texture3D, f32x3, f32x3, f32x3, f32, f32) f32"
        ]
    },
    {
        "name": "textureSampleGradProjCompareOffset",
        "documentation": "Sample a texture at coordinate with explicit gradient with projection with depth comparison with an offset applied to the coordinate",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureSampleGradProjCompareOffset(uniform *texture1D, uniform *sampler, f32, f32, f32, f32, f32, f32) f32",
            "textureSampleGradProjCompareOffset(uniform *sampled texture1D, f32, f32, f32, f32, f32, f32) f32",
            "textureSampleGradProjCompareOffset(uniform *texture2D, uniform *sampler, f32x2, f32x2, f32x2, f32, f32, f32x2) f32",
            "textureSampleGradProjCompareOffset(uniform *sampled texture2D, f32x2, f32x2, f32x2, f32, f32, f32x2) f32",
            "textureSampleGradProjCompareOffset(uniform *texture3D, uniform *sampler, f32x3, f32x3, f32x3, f32, f32, f32x3) f32",
            "textureSampleGradProjCompareOffset(uniform *sampled texture3D, f32x3, f32x3, f32x3, f32, f32, f32x3) f32"
        ]
    },
    {
        "name": "textureSampleBias",
        "documentation": "Sample a texture at coordinate with a mip bias",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureSampleBias(uniform *texture1D, uniform *sampler, f32, f32) f32x4",
            "textureSampleBias(uniform *sampled texture1D, f32, f32) f32x4",
            "textureSampleBias(uniform *texture2D, uniform *sampler, f32x2, f32) f32x4",
            "textureSampleBias(uniform *sampled texture2D, f32x2, f32) f32x4",
            "textureSampleBias(uniform *texture3D, uniform *sampler, f32x3, f32) f32x4",
            "textureSampleBias(uniform *sampled texture3D, f32x3, f32) f32x4",
            "textureSampleBias(uniform *textureCube, uniform *sampler, f32x3, f32) f32x4",
            "textureSampleBias(uniform *sampled textureCube, f32x3, f32) f32x4",
            "textureSampleBias(uniform *texture1DArray, uniform *sampler, f32x2, f32) f32x4",
            "textureSampleBias(uniform *sampled texture1DArray, f32x2, f32) f32x4",
            "textureSampleBias(uniform *texture2DArray, uniform *sampler, f32x3, f32) f32x4",
            "textureSampleBias(uniform *sampled texture2DArray, f32x3, f32) f32x4",
            "textureSampleBias(uniform *textureCubeArray, uniform *sampler, f32x4, f32) f32x4",
            "textureSampleBias(uniform *sampled textureCubeArray, f32x4, f32) f32x4"
        ]
    },
    {
        "name": "textureSampleBiasOffset",
        "documentation": "Sample a texture at coordinate with a mip bias with an offset applied to the coordinate",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureSampleBiasOffset(uniform *texture1D, uniform *sampler, f32, f32, f32) f32x4",
            "textureSampleBiasOffset(uniform *sampled texture1D, f32, f32, f32) f32x4",
            "textureSampleBiasOffset(uniform *texture2D, uniform *sampler, f32x2, f32, f32x2) f32x4",
            "textureSampleBiasOffset(uniform *sampled texture2D, f32x2, f32, f32x2) f32x4",
            "textureSampleBiasOffset(uniform *texture3D, uniform *sampler, f32x3, f32, f32x3) f32x4",
            "textureSampleBiasOffset(uniform *sampled texture3D, f32x3, f32, f32x3) f32x4",
            "textureSampleBiasOffset(uniform *texture1DArray, uniform *sampler, f32x2, f32, f32x2) f32x4",
            "textureSampleBiasOffset(uniform *sampled texture1DArray, f32x2, f32, f32x2) f32x4",
            "textureSampleBiasOffset(uniform *texture2DArray, uniform *sampler, f32x3, f32, f32x3) f32x4",
            "textureSampleBiasOffset(uniform *sampled texture2DArray, f32x3, f32, f32x3) f32x4"
        ]
    },
    {
        "name": "textureSampleBiasProj",
        "documentation": "Sample a texture at coordinate with a mip bias with projection",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureSampleBiasProj(uniform *texture1D, uniform *sampler, f32, f32, f32) f32x4",
            "textureSampleBiasProj(uniform *sampled texture1D, f32, f32, f32) f32x4",
            "textureSampleBiasProj(uniform *texture2D, uniform *sampler, f32x2, f32, f32) f32x4",
            "textureSampleBiasProj(uniform *sampled texture2D, f32x2, f32, f32) f32x4",
            "textureSampleBiasProj(uniform *texture3D, uniform *sampler, f32x3, f32, f32) f32x4",
            "textureSampleBiasProj(uniform *sampled texture3D, f32x3, f32, f32) f32x4"
        ]
    },
    {
        "name": "textureSampleBiasProjOffset",
        "documentation": "Sample a texture at coordinate with a mip bias with projection with an offset applied to the coordinate",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureSampleBiasProjOffset(uniform *texture1D, uniform *sampler, f32, f32, f32, f32) f32x4",
            "textureSampleBiasProjOffset(uniform *sampled texture1D, f32, f32, f32, f32) f32x4",
            "textureSampleBiasProjOffset(uniform *texture2D, uniform *sampler, f32x2, f32, f32, f32x2) f32x4",
            "textureSampleBiasProjOffset(uniform *sampled texture2D, f32x2, f32, f32, f32x2) f32x4",
            "textureSampleBiasProjOffset(uniform *texture3D, uniform *sampler, f32x3, f32, f32, f32x3) f32x4",
            "textureSampleBiasProjOffset(uniform *sampled texture3D, f32x3, f32, f32, f32x3) f32x4"
        ]
    },
    {
        "name": "textureSampleBiasCompare",
        "documentation": "Sample a texture at coordinate with a mip bias with depth comparison",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureSampleBiasCompare(uniform *texture1D, uniform *sampler, f32, f32, f32) f32",
            "textureSampleBiasCompare(uniform *sampled texture1D, f32, f32, f32) f32",
            "textureSampleBiasCompare(uniform *texture2D, uniform *sampler, f32x2, f32, f32) f32",
            "textureSampleBiasCompare(uniform *sampled texture2D, f32x2, f32, f32) f32",
            "textureSampleBiasCompare(uniform *texture3D, uniform *sampler, f32x3, f32, f32) f32",
            "textureSampleBiasCompare(uniform *sampled texture3D, f32x3, f32, f32) f32",
            "textureSampleBiasCompare(uniform *texture1DArray, uniform *sampler, f32x2, f32, f32) f32",
            "textureSampleBiasCompare(uniform *sampled texture1DArray, f32x2, f32, f32) f32",
            "textureSampleBiasCompare(uniform *texture2DArray, uniform *sampler, f32x3, f32, f32) f32",
            "textureSampleBiasCompare(uniform *sampled texture2DArray, f32x3, f32, f32) f32"
        ]
    },
    {
        "name": "textureSampleBiasCompareOffset",
        "documentation": "Sample a texture at coordinate with a mip bias with depth comparison with an offset applied to the coordinate",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureSampleBiasCompareOffset(uniform *texture1D, uniform *sampler, f32, f32, f32, f32) f32",
            "textureSampleBiasCompareOffset(uniform *sampled texture1D, f32, f32, f32, f32) f32",
            "textureSampleBiasCompareOffset(uniform *texture2D, uniform *sampler, f32x2, f32, f32, f32x2) f32",
            "textureSampleBiasCompareOffset(uniform *sampled texture2D, f32x2, f32, f32, f32x2) f32",
            "textureSampleBiasCompareOffset(uniform *texture3D, uniform *sampler, f32x3, f32, f32, f32x3) f32",
            "textureSampleBiasCompareOffset(uniform *sampled texture3D, f32x3, f32, f32, f32x3) f32",
            "textureSampleBiasCompareOffset(uniform *texture1DArray, uniform *sampler, f32x2, f32, f32, f32x2) f32",
            "textureSampleBiasCompareOffset(uniform *sampled texture1DArray, f32x2, f32, f32, f32x2) f32",
            "textureSampleBiasCompareOffset(uniform *texture2DArray, uniform *sampler, f32x3, f32, f32, f32x3) f32",
            "textureSampleBiasCompareOffset(uniform *sampled texture2DArray, f32x3, f32, f32, f32x3) f32"
        ]
    },
    {
        "name": "textureSampleBiasProjCompare",
        "documentation": "Sample a texture at coordinate with a mip bias with projection with depth comparison",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureSampleBiasProjCompare(uniform *texture1D, uniform *sampler, f32, f32, f32, f32) f32",
            "textureSampleBiasProjCompare(uniform *sampled texture1D, f32, f32, f32, f32) f32",
            "textureSampleBiasProjCompare(uniform *texture2D, uniform *sampler, f32x2, f32, f32, f32) f32",
            "textureSampleBiasProjCompare(uniform *sampled texture2D, f32x2, f32, f32, f32) f32",
            "textureSampleBiasProjCompare(uniform *texture3D, uniform *sampler, f32x3, f32, f32, f32) f32",
            "textureSampleBiasProjCompare(uniform *sampled texture3D, f32x3, f32, f32, f32) f32"
        ]
    },
    {
        "name": "textureSampleBiasProjCompareOffset",
        "documentation": "Sample a texture at coordinate with a mip bias with projection with depth comparison with an offset applied to the coordinate",
        "target_support": [
            1,
            1,
            1,
            1
        ],
        "overloads": [
            "textureSampleBiasProjCompareOffset(uniform *texture1D, uniform *sampler, f32, f32, f32, f32, f32) f32",
            "textureSampleBiasProjCompareOffset(uniform *sampled texture1D, f32, f32, f32, f32, f32) f32",
            "textureSampleBiasProjCompareOffset(uniform *texture2D, uniform *sampler, f32x2, f32, f32, f32, f32x2) f32",
            "textureSampleBiasProjCompareOffset(uniform *sampled texture2D, f32x2, f32, f32, f32, f32x2) f32",
            "textureSampleBiasProjCompareOffset(uniform *texture3D, uniform *sampler, f32x3, f32, f32, f32, f32x3) f32",
            "textureSampleBiasProjCompareOffset(uniform *sampled texture3D, f32x3, f32, f32, f32, f32x3) f32"
        ]
    }
]