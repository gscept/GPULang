
import os
from math import trunc

os.makedirs('../generated', exist_ok=True)
os.makedirs('../generated/spirv', exist_ok=True)
open_file = open('../generated/swizzle.h', 'w')
open_file.write("//-------------------------------------------------\n")
open_file.write("// *** Generated by type_gen.py. ***\n")
open_file.write("//         DO NOT MODIFY!!!\n")
open_file.write("//-------------------------------------------------\n\n")

def generate_swizzle_four():
    components = ['x', 'y', 'z', 'w']
    open_file.write("#define SWIZZLE4()\\\n")
    for x in components:
        open_file.write(f"X(" + x + ")\\\n")
        for y in components:
            open_file.write(f"X(" + x + y + ")\\\n")
            for z in components:
                open_file.write(f"X(" + x + y + z + ")\\\n")
                for w in components:
                    open_file.write(f"X(" + x + y + z + w + ")\\\n")
    components = ['r', 'g', 'b', 'a']
    for x in components:
        open_file.write(f"X(" + x + ")\\\n")
        for y in components:
            open_file.write(f"X(" + x + y + ")\\\n")
            for z in components:
                open_file.write(f"X(" + x + y + z + ")\\\n")
                for w in components:
                    open_file.write(f"X(" + x + y + z + w + ")\\\n")
    open_file.write("\n")

def generate_swizzle_three():
    components = ['x', 'y', 'z']

    open_file.write("#define SWIZZLE3()\\\n")
    for x in components:
        open_file.write(f"X(" + x + ")\\\n")
        for y in components:
            open_file.write(f"X(" + x + y + ")\\\n")
            for z in components:
                open_file.write(f"X(" + x + y + z + ")\\\n")
    components = ['r', 'g', 'b']
    for x in components:
        open_file.write(f"X(" + x + ")\\\n")
        for y in components:
            open_file.write(f"X(" + x + y + ")\\\n")
            for z in components:
                open_file.write(f"X(" + x + y + z + ")\\\n")
    open_file.write("\n")

def generate_swizzle_two():
    components = ['x', 'y']
    open_file.write("#define SWIZZLE2()\\\n")
    for x in components:
        open_file.write(f"X(" + x + ")\\\n")
        for y in components:
            open_file.write(f"X(" + x + y + ")\\\n")
    components = ['r', 'g']
    for x in components:
        open_file.write(f"X(" + x + ")\\\n")
        for y in components:
            open_file.write(f"X(" + x + y + ")\\\n")
    open_file.write("\n")

def generate_types():
    types = ["Float32", "UInt32", "Int32", "Bool8", "Float16", "UInt16", "Int16"]
    base_types = ["Float", "UInt", "Int", "Bool", "Float", "UInt", "Int"]

    bit_widths = [32, 32, 32, 8, 16, 16, 16]
    data_types = ["f32", "u32", "i32", "b8", "f16", "u16", "i16"]

    bit_operator_names = ['or', 'and', 'xor', 'lsh', 'rsh']
    bit_operators = ['|', '&', '^', '<<', '>>']

    scalar_operator_names = ['add', 'sub', 'mul', 'div', 'mod']
    scalar_operators = ['+', '-', '*', '/', '%']

    comparison_operator_names = ['lt', 'lte', 'gt', 'gte', 'eq', 'neq']
    comparison_operators = ['<', '<=', '>', '>=', '==', '!=']

    bool_operator_names = ['oror', 'andand', 'eq', 'neq']
    bool_operators = ['||', '&&', '==', '!=']

    assignment_operator_names = ['addasg', 'subasg', 'mulasg', 'divasg']
    assignment_operators = ['+=', '-=', '*=', '/=']

    bit_assignment_operator_names = ['orasg', 'andasg', 'xorasg', 'lshasg', 'rhsasg']
    bit_assignment_operators = ['|=', '&=', '^=', '<<=', '>>=']

    scale_operator_names = ['scale', 'scale', 'scale', 'scale', 'scale', 'scale']
    scale_operators = ['*', '*', '*', '*', '*', '*']
    scale_operator_types = ['Float32', 'Float16', 'UInt32', 'UInt16', 'Int32', 'Int16']
    scale_operator_data_types = ['f32', 'f16', 'u32', 'u16', 'i32', 'i16']

    index_operator_names = ['index_Int32', 'index_UInt32', 'index_Int16', 'index_UInt16']
    index_operators = ['[]', '[]', '[]', '[]']
    index_types = ['Int32', 'UInt32', 'Int16', 'UInt16']
    index_data_types = ['i32', 'u32', 'i16', 'u16']

    vector_matrix_operator_names = ['mul']
    vector_matrix_operators = ['*']

    header_file = open("../generated/types.h", 'w')
    source_file = open("../generated/types.cc", 'w')

    ### Type conversion enum and SPIRV conversion methods ###
    spirv_intrinsics = open("../generated/types_spirv.h", 'w')

    conversion_table_enum = "enum TypeConversionTable\n"
    conversion_table_enum += '{\n'

    class TypeConverter:
        def __init__(self, enu, target, source_data_type, spirv_conversion_function, spirv_conversion_prep, spirv_conversion_arguments):
            self.enum = enu
            self.target = target
            self.source_data_type = source_data_type    
            self.spirv_conversion_function = spirv_conversion_function
            self.spirv_conversion_prep = spirv_conversion_prep
            self.spirv_conversion_arguments = spirv_conversion_arguments

    type_conversions = []
    for type1, width1, data_type1 in zip(types, bit_widths, data_types):
        for type2, width2, data_type2 in zip(types, bit_widths, data_types):
            if type1 != type2:
                conversion_table_enum += '    {}To{},\n'.format(type1, type2)
                spirv_conversion_function = ''
                spirv_conversion_prep = ''

                if type1.startswith('Bool'):
                    if type2.startswith('Int') or type2.startswith('UInt'):
                        spirv_conversion_prep = '            SPIRVResult trueValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::{}(1), vectorSize);\n'.format(type2)
                        spirv_conversion_prep += '            SPIRVResult falseValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::{}(0), vectorSize);\n'.format(type2)
                        type_conversions.append(TypeConverter('{}To{}'.format(type1, type2), type2, data_type1, 'OpSelect', spirv_conversion_prep, 'trueValue, falseValue'))
                else:    
                    if not type2.startswith('Bool'):
                        spirv_conversion_prep = ''
                        if type1.startswith('Float'):                    
                            if width1 != width2:
                                spirv_conversion_function = 'OpFConvert'
                            if type2.startswith('UInt'):
                                spirv_conversion_function = 'OpConvertFToU'
                            elif type2.startswith('Int'):
                                spirv_conversion_function = 'OpConvertFToS'
                        elif type1.startswith('UInt'):
                            if width1 != width2:
                                spirv_conversion_function = 'OpUConvert'
                            if type2.startswith('Int'):
                                spirv_conversion_function = 'OpBitcast'
                            elif type2.startswith('Float'):
                                spirv_conversion_function = 'OpConvertUToF'
                        elif type1.startswith('Int'):
                            if width1 != width2:
                                spirv_conversion_function = 'OpSConvert'
                            if type2.startswith('UInt'):
                                spirv_conversion_function = 'OpBitcast'
                            elif type2.startswith('Float'):
                                spirv_conversion_function = 'OpConvertSToF'
                        type_conversions.append(TypeConverter('{}To{}'.format(type1, type2), type2, data_type1, spirv_conversion_function, spirv_conversion_prep, ''))
                    else:
                        if type1.startswith('UInt') or type1.startswith('Int'):
                            spirv_conversion_prep = '            value = LoadValueSPIRV(c, g, value);\n'
                            spirv_conversion_prep += '            SPIRVResult falseValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::{}(0), vectorSize);\n'.format(type1)   
                            type_conversions.append(TypeConverter('{}To{}'.format(type1, type2), type2, data_type1, 'OpINotEqual', spirv_conversion_prep, 'value, falseValue'))


    conversion_table_enum = conversion_table_enum[0:-2]
    conversion_table_enum += '\n};\n\n'

    spirv_type_construction = ''

    spirv_intrinsics.write("#pragma once\n")
    spirv_intrinsics.write("//-------------------------------------------------\n")
    spirv_intrinsics.write("// *** Generated by type_gen.py. ***\n")
    spirv_intrinsics.write("//       DO NOT MODIFY!!!\n")
    spirv_intrinsics.write("//-------------------------------------------------\n")
    spirv_intrinsics.write('#include "compiler.h"\n')
    spirv_intrinsics.write('#include "generators/spirvgenerator.h"\n')
    spirv_intrinsics.write('#include "containers.h"\n')
    spirv_intrinsics.write('#include "types.h"\n')
    spirv_intrinsics.write('namespace GPULang\n')
    spirv_intrinsics.write('{\n')
    spirv_intrinsics.write('struct SPIRVGenerator;\n')
    spirv_intrinsics.write('struct Compiler;\n')
    spirv_intrinsics.write('struct SPIRVResult;\n')
    spirv_intrinsics.write('SPIRVResult GenerateConversionSPIRV(const Compiler* compiler, SPIRVGenerator* generator, ConversionTable conversion, uint32_t vectorSize, SPIRVResult inArg);\n')
    spirv_intrinsics.write('SPIRVResult GenerateSplatCompositeSPIRV(const Compiler* compiler, SPIRVGenerator* generator, uint32_t returnType, uint32_t num, SPIRVResult arg);\n')
    spirv_intrinsics.write("static auto CreateSampledImageSPIRV = [](const Compiler* c, SPIRVGenerator* g, SPIRVResult img, SPIRVResult samp) -> SPIRVResult\n")
    spirv_intrinsics.write("{\n")
    spirv_intrinsics.write("        assert(img.parentTypes.size() > 0);\n")
    spirv_intrinsics.write("        SPIRVResult image = LoadValueSPIRV(c, g, img, true);\n")
    spirv_intrinsics.write("        SPIRVResult sampler = LoadValueSPIRV(c, g, samp, true);\n")
    spirv_intrinsics.write("        uint32_t typeSymbol = AddType(g, TStr::Compact(\"sampledImage_\", img.parentTypes[0]), OpTypeSampledImage, SPVArg{img.parentTypes[0]});\n")
    spirv_intrinsics.write("        uint32_t sampledImage = g->writer->MappedInstruction(OpSampledImage, SPVWriter::Section::LocalFunction, typeSymbol, image, sampler);\n")
    spirv_intrinsics.write("        return SPIRVResult(sampledImage, typeSymbol, true);\n")
    spirv_intrinsics.write("};\n\n")
    spirv_intrinsics.write('constexpr ConverterTable = StaticMap{ std::array{\n')
    spirv_type_construction = ''
    for converter in type_conversions:
        spirv_type_construction += '    {{ TypeConversionTable::{}, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {{\n'.format(converter.enum)
        spirv_type_construction += '        if (value.isLiteral)\n'
        spirv_type_construction += '        {\n'
        spirv_type_construction += '            assert(vectorSize == 1);\n'
        spirv_type_construction += '            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::{}(value.literalValue.{}));\n'.format(converter.target, converter.source_data_type)
        spirv_type_construction += '        }\n'
        spirv_type_construction += '        else\n'
        spirv_type_construction += '        {\n'
        spirv_type_construction += '            uint32_t type;\n'
        spirv_type_construction += '            if (vectorSize > 1)\n'
        spirv_type_construction += '                type = GeneratePODTypeSPIRV(c, g, TypeCode::{}, vectorSize);\n'.format(converter.target)
        spirv_type_construction += '            else\n'
        spirv_type_construction += '                type = GeneratePODTypeSPIRV(c, g, TypeCode::{});\n'.format(converter.target)
        if not converter.spirv_conversion_arguments:
            spirv_type_construction += '            value = LoadValueSPIRV(c, g, value);\n'
            spirv_type_construction += '            uint32_t res = value.name;\n'
        if converter.spirv_conversion_prep:
            spirv_type_construction += converter.spirv_conversion_prep
        if not converter.spirv_conversion_arguments:
            spirv_type_construction += '            res = g->writer->MappedInstruction({}, SPVWriter::Section::LocalFunction, type, SPVArg{{res}});\n'.format(converter.spirv_conversion_function)
        else:
            spirv_type_construction += '            res = g->writer->MappedInstruction({}, SPVWriter::Section::LocalFunction, type, {});\n'.format(converter.spirv_conversion_function, converter.spirv_conversion_arguments)
        spirv_type_construction += '            return SPIRVResult(res, type, true);\n'
        spirv_type_construction += '        }\n'
        spirv_type_construction += '    } },\n'
    spirv_intrinsics.write(spirv_type_construction[0:-2])
    spirv_intrinsics.write('\n}};\n\n')
    spirv_intrinsics.write('StaticMap default_intrinsics = std::array{\n')
    

    ### Built-in data types (Float, Int, UInt, Bool and their vector/matrix variants)
    header_file.write("#pragma once\n")
    header_file.write("//-------------------------------------------------\n")
    header_file.write("// *** Generated by type_gen.py. ***\n")
    header_file.write("//       DO NOT MODIFY!!!\n")
    header_file.write("//-------------------------------------------------\n")
    header_file.write('#include "ast/types/type.h"\n')
    header_file.write('#include "ast/variable.h"\n')
    header_file.write('#include "ast/function.h"\n')
    header_file.write('#include "ast/enumeration.h"\n')
    header_file.write('#include "ast/expressions/intexpression.h"\n')
    header_file.write('#include "ast/expressions/enumexpression.h"\n')
    header_file.write('namespace GPULang\n')
    header_file.write('{\n')
    header_file.write(conversion_table_enum)

    source_file.write("//-------------------------------------------------\n")
    source_file.write("// *** Generated by type_gen.py. ***\n")
    source_file.write("//       DO NOT MODIFY!!!\n")
    source_file.write("//-------------------------------------------------\n")
    source_file.write('#include "types.h"\n')
    source_file.write('namespace GPULang\n')
    source_file.write('{\n')

    spirv_type_construction = ''
    spirv_code = ''

    def spirv_intrinsic(fun, arg):
        return 'std::pair{{ &{} , [](const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args) -> SPIRVResult\n{{\n{}}}}},\n'.format(fun, arg)

    for size in range(1, 5):
        for type, data_type, base_type, bits in zip(types, data_types, base_types, bit_widths):
            if size == 1:
                data_type_name = data_type
                type_name = type
            else:
                type_name = '{}x{}'.format(type, size)
                data_type_name = '{}x{}'.format(data_type, size)

            class_decl = ""
            class_decl += 'struct {} : public Type\n'.format(type_name)
            class_decl += '{\n'
            class_decl += '    {}();\n'.format(type_name)
            class_decl += '};\n'
            class_decl += 'extern {} {}Type;\n\n'.format(type_name, type_name)
            
            
            header_file.write(class_decl)

            declaration_string = ""
            #declaration_string = '#define DECL_{}_ctors\\\n'.format(type_name)
            definition_string = '#define DEF_{}_ctors\\\n'.format(type_name)
            setup_string = ""
            list_string = ""
            for type2, data_type2, bits2 in zip(types, data_types, bit_widths):
                if type2 == 'Bool8' and type != 'Bool8':
                    continue

                if size == 1 and type2 == type:
                    continue

                if type == 'Bool8' and not (type2.startswith('Int') or type2.startswith('UInt')):
                    continue

                if size == 1:
                    data_type_name2 = data_type2
                    type_name2 = type2
                else:
                    type_name2 = '{}x{}'.format(type2, size)
                    data_type_name2 = '{}x{}'.format(data_type2, size)

                fun_name = '{}_convert_{}'.format(type_name, type_name2)
                arg_name = '{}_convert_{}_arg0'.format(type_name, type_name2)
                declaration_string += 'extern Variable {};\n'.format(arg_name)
                definition_string += 'Variable {};\\\n'.format(arg_name)
                declaration_string += 'extern Function {};\n'.format(fun_name)
                definition_string += 'Function {};\\\n'.format(fun_name)
                setup_string += '    // Conversion from {}\n'.format(type_name2)
                setup_string += '    {}.name = "_arg0"_c;\n'.format(arg_name)
                setup_string += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(arg_name, type_name2)
                setup_string += '    {}.name = "{}"_c;\n'.format(fun_name, data_type_name)
                setup_string += '    {}.returnType = Type::FullType {{ {}Type.name }};\n'.format(fun_name, type_name)
                setup_string += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(arg_name, type_name2)
                setup_string += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(fun_name, type_name)
                list_string += '        std::pair{{ "{}"_c, &{} }},\n'.format(data_type_name, fun_name)
                list_string += '        std::pair{{ "{}({})"_c, &{} }},\n'.format(data_type_name, data_type_name2, fun_name)
                spirv_type_construction += spirv_intrinsic(fun_name, '    return GenerateConversionSPIRV(c, g, TypeConversionTable::{}To{}, {}, args[0]);\n'.format(type, type2, size))
                if size > 1:
                    fun_name = '{}_splat_{}'.format(type_name, type2)
                    arg_name = '{}_splat_{}_arg0'.format(type_name, type2)
                    declaration_string += 'extern Variable {};\n'.format(arg_name)
                    definition_string += 'Variable {};\\\n'.format(arg_name)
                    declaration_string += 'extern Function {};\n'.format(fun_name)
                    definition_string += 'Function {};\\\n'.format(fun_name)
                    setup_string += '    // Splat with {}\n'.format(type2)
                    setup_string += '    {}.name = "_arg0"_c;\n'.format(arg_name)
                    setup_string += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(arg_name, type2)
                    setup_string += '    {}.name = "{}"_c;\n'.format(fun_name, data_type_name)
                    setup_string += '    {}.returnType = Type::FullType {{ {}Type.name }};\n'.format(fun_name, type_name)
                    setup_string += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(arg_name, type2)
                    setup_string += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(fun_name, type_name)
                    list_string += '        std::pair{{ "{}"_c, &{} }},\n'.format(data_type_name, fun_name)
                    list_string += '        std::pair{{ "{}({})"_c, &{} }},\n'.format(data_type_name, data_type2, fun_name)
                    spirv_function = '    SPIRVResult val = args[0];\n'
                    if type != type2:
                        spirv_function += '    val = GenerateConversionSPIRV(c, g, TypeConversionTable::{}To{}, 1, val);\n'.format(type2, type)
                    spirv_function += '    return GenerateSplatCompositeSPIRV(c, g, returnType, {}, val);\n'.format(size)
                    spirv_type_construction += spirv_intrinsic(fun_name, spirv_function)


            four_component_combinations = [[1, 1, 1, 1], [2, 1, 1], [1, 2, 1], [1, 1, 2], [3, 1], [1,3]]
            three_component_combiations = [[1,1,1], [2, 1], [1, 2]]
            two_component_combinations = [[1, 1]]
            if size == 1:
                combinations = [[1]]
            elif size == 2:
                combinations = two_component_combinations
            elif size == 3:
                combinations = three_component_combiations
            elif size == 4:
                combinations = four_component_combinations
            for ctor_idx, comb in enumerate(combinations):
                fun_name = '{}_ctor{}'.format(type_name, ctor_idx)                

                dec_var = ''
                def_var = ''
                list_entry_key = ""
                list_entry_value = ""
                arg_list = ""
                setup_args = ""
                args = []
                arg_types = []
                spirv_function =  "        SPIRVResult loadedArg = LoadValueSPIRV(c, g, args[0]);\n"
                spirv_function += "        if (returnType == loadedArg.typeName) {\n"
                spirv_function += "            return loadedArg;\n"
                spirv_function += "        }\n"
                if type != type2:
                    spirv_function += '    loadedArg = GenerateConversionSPIRV(c, g, TypeConversionTable::{}To{}, {}, loadedArg);\n'.format(type, type2, size)
                spirv_function += '    return loadedArg;\n'

                for arg_idx, s in enumerate(comb):
                    arg_name = '{}_ctor{}_arg{}'.format(type_name, ctor_idx, arg_idx)
                    args.append(arg_name)
                    if list_entry_key != "":
                        list_entry_key += ","
                    if s == 1:
                        arg_type_name = '{}'.format(type)
                        fun_name += '_{}'.format(type)
                        list_entry_value += '_{}'.format(type)
                        list_entry_key += '{}'.format(data_type)
                        dec_var += 'extern Variable {};\n'.format(arg_name)
                        def_var += 'Variable {};\n'.format(arg_name)
                        arg_list += '{}, '.format(arg_type_name)
                        
                    else:
                        fun_name += '_{}x{}'.format(type, s)
                        list_entry_key += '{}x{}'.format(data_type, s)
                        list_entry_value += '_{}x{}'.format(type, s)
                        dec_var += 'extern Variable {};\n'.format(arg_name)
                        def_var += 'Variable {};\n'.format(arg_name)
                        arg_type_name = '{}x{}'.format(type, s)
                        arg_list += '{}, '.format(arg_type_name)
                    arg_types.append(arg_type_name)
                    setup_args += '    {}.name = "_arg{}"_c;\n'.format(arg_name, arg_idx)
                    setup_args += '    {}.type = Type::FullType {{ {}Type.name }};\n'.format(arg_name, arg_type_name)
                
                setup_string += '    // Construct with {}\n'.format(arg_list[0:-2])
                setup_string += setup_args
                setup_string += '    {}.name = "{}"_c;\n'.format(fun_name, ctor_idx, data_type_name)
                setup_string += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(fun_name, type_name)
                for arg, arg_type in zip(args, arg_types):
                    setup_string += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(arg, arg_type)
                setup_string += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(fun_name, type_name)
                
                list_string += '        std::pair{{ "{}"_c, &{}_ctor{}{}}},\n'.format(data_type_name, type_name, ctor_idx, list_entry_value)
                list_string += '        std::pair{{ "{}({})"_c, &{}_ctor{}{}}},\n'.format(data_type_name, list_entry_key, type_name, ctor_idx, list_entry_value)
                spirv_function = '    return GenerateCompositeSPIRV(c, g, returnType, {{{}}});\n'.format(', '.join(['args[{}]'.format(idx) for idx, arg in enumerate(args)]))
                spirv_type_construction += spirv_intrinsic(fun_name, spirv_function)

                declaration_string += '{}'.format(dec_var)
                declaration_string += 'extern Function {};\n'.format(fun_name)
                definition_string += '{}'.format(def_var)
                definition_string += 'Function {};\\\n'.format(fun_name)
                
            spirv_intrinsics.write(spirv_type_construction)
            header_file.write(declaration_string[0:-1] + '\n')
            header_file.write("\n")
            header_file.write(definition_string[0:-2] + '\n')
            header_file.write("\n")
            header_file.write("\n")
        
            definition_string = "#define DEF_{}_operators\\\n".format(type_name)

            for name, op, idx_type, idx_data_type in zip(index_operator_names, index_operators, index_types, index_data_types):
                fun_name = '{}_operator_{}'.format(type_name, name)
                arg_name = '{}_operator_{}_arg0'.format(type_name, name)
                declaration_string += 'extern Variable {};\n'.format(arg_name)
                declaration_string += 'extern Function {};\n'.format(fun_name)
                definition_string += 'Variable {};\\\n'.format(arg_name)
                definition_string += 'Function {};\\\n'.format(fun_name)
                setup_string += '    // operator{}({})\n'.format(op, idx_data_type)
                setup_string += '    {}.name = "_arg0"_c;\n'.format(arg_name, name)
                setup_string += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(arg_name, idx_type)
                setup_string += '    {}.name = "operator{}"_c;\n'.format(fun_name, op)
                setup_string += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(fun_name, type)
                setup_string += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(arg_name, idx_type)
                setup_string += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(fun_name, type)
                list_string += '        std::pair{{ "operator{}({})"_c, &{}}},\n'.format(op, idx_data_type, fun_name)

                spirv_function =  '    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, {}.returnType, &{}Type, args[0].scope);\n'.format(fun_name, type)
                spirv_function += '    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);\n'
                spirv_function += '    SPIRVResult ret = args[0];\n'
                spirv_function += '    ret.AddAccessChainLink({loadedIndex});\n'
                spirv_function += '    ret.typeName = returnTypePtr.typeName;\n'
                spirv_function += '    ret.parentTypes = returnTypePtr.parentTypes;\n'
                spirv_function += '    ret.scope = args[0].scope;\n'
                spirv_function += '    ret.isValue = false;\n'
                spirv_function += '    return ret;\n'
                spirv_code += spirv_intrinsic(fun_name, spirv_function)

            if type == 'Bool8':
                for name, op in zip(bool_operator_names, bool_operators):
                    fun_name = '{}_operator_{}_{}'.format(type_name, name, type_name)
                    arg_name = '{}_operator_{}_{}_arg0'.format(type_name, name, type_name)
                    setup_string += '    // operator{}({})\n'.format(op, data_type_name)
                    setup_string += '    {}.name = "_arg0"_c;\n'.format(arg_name, name)
                    setup_string += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(arg_name, type_name)
                    setup_string += '    {}.name = "operator{}"_c;\n'.format(fun_name, op)
                    setup_string += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(fun_name, type_name)
                    setup_string += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(arg_name, type_name)
                    setup_string += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(fun_name, type_name)
                    declaration_string += 'extern Variable {};\n'.format(arg_name)
                    declaration_string += 'extern Function {};\n'.format(fun_name)
                    definition_string += 'Variable {};\\\n'.format(arg_name)
                    definition_string += 'Function {};\\\n'.format(fun_name)
                    list_string += '        std::pair{{ "operator{}({})"_c, &{}}},\n'.format(op, data_type_name, fun_name)

                    spirv_function =  ''
                    spirv_function += '    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);\n'
                    spirv_function += '    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);\n'

                    if op == '||':
                        spirv_op = 'OpLogicalOr'
                    elif op == '&&':
                        spirv_op = 'OpLogicalAnd'
                    elif op == '==':
                        spirv_op = 'OpIEqual'
                    elif op == '!=':
                        spirv_op = 'OpINotEqual'
                    spirv_function += '    uint32_t ret = g->writer->MappedInstruction({}, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);\n'.format(spirv_op)
                    spirv_code += spirv_intrinsic(fun_name, spirv_function)
            else:
                operator_sets = [
                    zip(scalar_operator_names, scalar_operators), 
                    zip(assignment_operator_names, assignment_operators),
                    zip(comparison_operator_names, comparison_operators)
                    ]
                for operator_set in operator_sets:
                    for name, op in operator_set:
                        fun_name = '{}_operator_{}_{}'.format(type_name, name, type_name)
                        arg_name = '{}_operator_{}_{}_arg0'.format(type_name, name, type_name)
                        setup_string += '    // operator{}({})\n'.format(op, data_type_name)
                        setup_string += '    {}.name = "_arg0"_c;\n'.format(arg_name, name)
                        setup_string += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(arg_name, type_name)
                        setup_string += '    {}.name = "operator{}"_c;\n'.format(fun_name, op)
                        setup_string += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(fun_name, type_name)
                        setup_string += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(arg_name, type_name)
                        setup_string += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(fun_name, type_name)
                        declaration_string += 'extern Variable {};\n'.format(arg_name)
                        declaration_string += 'extern Function {};\n'.format(fun_name)
                        definition_string += 'Variable {};\\\n'.format(arg_name)
                        definition_string += 'Function {};\\\n'.format(fun_name)
                        list_string += '        std::pair{{ "operator{}({})"_c, &{}}},\n'.format(op, data_type_name, fun_name)

                        spirv_function = ''
                        spirv_function += '    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);\n'
                        spirv_function += '    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);\n'

                        spirv_op_type = ''
                        if type.startswith('Float'):
                            spirv_op_type = 'F'
                        elif type.startswith('Int'):
                            if op == '/' or op == '%' or op == '<' or op == '>' or op == '<=' or op == '>=':
                                spirv_op_type = 'S'
                            else:
                                spirv_op_type = 'I'
                        elif type.startswith('UInt'):
                            if op == '/' or op == '%' or op == '<' or op == '>' or op == '<=' or op == '>=':
                                spirv_op_type = 'S'
                            else:
                                spirv_op_type = 'I'

                        if op == '+' or op == '+=':
                            spirv_op = 'Op{}Add'.format(spirv_op_type)
                        elif op == '-' or op == '-=':
                            spirv_op = 'Op{}Sub'.format(spirv_op_type)
                        elif op == '*' or op == '*=':
                            spirv_op = 'Op{}Mul'.format(spirv_op_type)
                        elif op == '/' or op == '/=':
                            spirv_op = 'Op{}Div'.format(spirv_op_type)
                        elif op == '%' or op == '%=':
                            spirv_op = 'Op{}Mod'.format(spirv_op_type)
                        elif op == '<':
                            spirv_op = 'Op{}LessThan'.format(spirv_op_type)
                        elif op == '>':
                            spirv_op = 'Op{}GreaterThan'.format(spirv_op_type)
                        elif op == '<=':
                            spirv_op = 'Op{}LessThanEqual'.format(spirv_op_type)
                        elif op == '>=':
                            spirv_op = 'Op{}GreaterThanEqual'.format(spirv_op_type)
                        elif op == '==':
                            spirv_op = 'Op{}Equal'.format(spirv_op_type)
                        elif op == '!=':
                            spirv_op = 'Op{}NotEqual'.format(spirv_op_type)
                        spirv_function += '    uint32_t ret = g->writer->MappedInstruction({}, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);\n'.format(spirv_op)
                        spirv_code += spirv_intrinsic(fun_name, spirv_function)
                
                if size > 1:
                    for name, op, scale_type, scale_data_type in zip(scale_operator_names, scale_operators, scale_operator_types, scale_operator_data_types):
                        fun_name = '{}_operator_{}_{}_{}'.format(type_name, name, type_name, scale_type)
                        arg_name = '{}_operator_{}_{}_{}_arg0'.format(type_name, name, type_name, scale_type)
                        setup_string += '    // operator{}({})\n'.format(op, scale_data_type)
                        setup_string += '    {}.name = "_arg0"_c;\n'.format(arg_name, name)
                        setup_string += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(arg_name, scale_type)
                        setup_string += '    {}.name = "operator{}"_c;\n'.format(fun_name, op)
                        setup_string += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(fun_name, type_name)
                        setup_string += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(arg_name, scale_type)
                        setup_string += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(fun_name, type_name)
                        declaration_string += 'extern Variable {};\n'.format(arg_name)
                        declaration_string += 'extern Function {};\n'.format(fun_name)
                        definition_string += 'Variable {};\\\n'.format(arg_name)
                        definition_string += 'Function {};\\\n'.format(fun_name)
                        list_string += '        std::pair{{ "operator{}({})"_c, &{}}},\n'.format(op, scale_data_type, fun_name)

                        spirv_function = ''
                        spirv_function += '    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);\n'
                        if scale_type.startswith('Float'):
                            spirv_function += '    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);\n'
                        else:
                            spirv_function += '    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {}<, args[1]);\n'.format(size)
                        spirv_function += '    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);\n'
                        spirv_code += spirv_intrinsic(fun_name, spirv_function)

            # Matrix transform
            if type.startswith('Float') and size > 1:
                for cols in range(2, 5):
                    compatible_matrix_type = 'Float32x{}x{}'.format(size, cols)
                    compatible_matrix_data_type = 'f32x{}x{}'.format(size, cols)
                    return_type = '{}x{}'.format(type, cols)
                    return_data_type = 'f32x{}'.format(cols)
                    for name, op in zip(vector_matrix_operator_names, vector_matrix_operators):
                        fun_name = '{}_operator_{}_{}'.format(type_name, name, compatible_matrix_type)
                        arg_name = '{}_operator_{}_{}_arg0'.format(type_name, name, compatible_matrix_type)
                        setup_string += '    // operator{}({})\n'.format(op, compatible_matrix_data_type)
                        setup_string += '    {}.name = "_arg0"_c;\n'.format(arg_name, name)
                        setup_string += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(arg_name, compatible_matrix_type)
                        setup_string += '    {}.name = "operator{}"_c;\n'.format(fun_name, op)
                        setup_string += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(fun_name, return_type)
                        setup_string += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(arg_name, compatible_matrix_type)
                        setup_string += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(fun_name, return_type)
                        declaration_string += 'extern Variable {};\n'.format(arg_name)
                        declaration_string += 'extern Function {};\n'.format(fun_name)
                        definition_string += 'Variable {};\\\n'.format(arg_name)
                        definition_string += 'Function {};\\\n'.format(fun_name)
                        list_string += '        std::pair{{ "operator{}({})"_c, &{}}},\n'.format(op, compatible_matrix_data_type, fun_name)  

                        spirv_function = ''
                        spirv_function += '    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);\n'
                        spirv_function += '    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);\n'
                        spirv_function += '    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);\n'
                        spirv_code += spirv_intrinsic(fun_name, spirv_function)

            if type.startswith("UInt") or type.startswith("Int"):
                operator_sets = [
                    zip(bit_operator_names, bit_operators)
                    , zip(bit_assignment_operator_names, bit_assignment_operators)
                    ]
                for operator_set in operator_sets:
                    for name, op in operator_set:
                        fun_name = '{}_operator_{}_{}'.format(type_name, name, type_name)
                        arg_name = '{}_operator_{}_{}_arg0'.format(type_name, name, type_name)
                        setup_string += '    // operator{}\n'.format(op)
                        setup_string += '    {}.name = "_arg0"_c;\n'.format(arg_name, name)
                        setup_string += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(arg_name, type_name)
                        setup_string += '    {}.name = "operator{}"_c;\n'.format(fun_name, op)
                        setup_string += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(fun_name, type_name)
                        setup_string += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(arg_name, type_name)
                        setup_string += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(fun_name, type_name)
                        
                        declaration_string += 'extern Variable {};\n'.format(arg_name)
                        declaration_string += 'extern Function {};\n'.format(fun_name)
                        definition_string += 'Variable {};\\\n'.format(arg_name)
                        definition_string += 'Function {};\\\n'.format(fun_name)
                        list_string += '        std::pair{{ "operator{}({})"_c, &{}}},\n'.format(op, data_type_name, fun_name)

                        if op == '&':
                            spirv_op = 'OpBitwiseAnd'
                        elif op == '|':
                            spirv_op = 'OpBitwiseOr'
                        elif op == '^':
                            spirv_op = 'OpBitwiseXor'
                        elif op == '<<':
                            spirv_op = 'OpShiftLeftLogical'
                        elif op == '>>':
                            spirv_op = 'OpShiftRightLogical'
                        spirv_function = ''
                        spirv_function += '    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);\n'
                        spirv_function += '    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);\n'
                        spirv_function += '    uint32_t ret = g->writer->MappedInstruction({}, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);\n'.format(spirv_op)
                        spirv_code += spirv_intrinsic(fun_name, spirv_function)

            class_def = ""
            class_def += '{}::{}()\n'.format(type_name, type_name)
            class_def += '{\n'
            class_def += '    this->name = "{}";\n'.format(data_type)
            class_def += '    this->columnSize = {};\n'.format(size)
            class_def += '    this->rowSize = 1;\n'
            class_def += '    this->byteSize = {:d};\n'.format(trunc((bits * size) / 8))
            class_def += '    this->category = Type::ScalarCategory;\n'
            class_def += '    this->baseType = TypeCode::{};\n'.format(type)
            class_def += '    this->builtin = true;\n'
            class_def += '\n'
            class_def += '{}'.format(setup_string)
            class_def += '    this->scope.symbolLookup = StaticMap {{ std::array{{\n{}\n    }}}};   \n'.format(list_string[0:-2])
            class_def += '}\n\n'

            header_file.write(declaration_string[0:-1] + '\n')
            header_file.write("\n")
            header_file.write(definition_string[0:-2] + '\n')
            header_file.write("\n")
            source_file.write(class_def)
            header_file.write("\n")

    # Matrix types
    types = ['Float32', 'Float16']
    bit_widths = [32, 16]
    data_types = ["f32", "f16"]

    scalar_operator_names = ['add', 'sub', 'mul']
    scalar_operators = ['+', '-', '*']

    assignment_operator_names = ['addasg', 'subasg', 'mulasg']
    assignment_operators = ['+=', '-=', '*=']

    scale_operator_names = ['scale', 'scale']
    scale_operators = ['*', '*']
    scale_operator_types = ['Float32', 'Float16']
    scale_operator_data_types = ['f32', 'f16']

    for type, data_type, bits in zip(types, data_types, bit_widths):
        for row_size in range(2, 5):
            for column_size in range(2, 5):

                type_name = '{}x{}x{}'.format(type, row_size, column_size)
                data_type_name = '{}x{}x{}'.format(data_type, row_size, column_size)

                declaration_string = ""
                definition_string = "#define DEF_{}_ctors\\\n".format(type_name)
                list_string = ""
                setup_string = ""
                
                class_decl = ""
                class_decl += 'struct {} : public Type\n'.format(type_name)
                class_decl += '{\n'
                class_decl += '    {}();\n'.format(type_name)
                class_decl += '};\n'
                class_decl += 'extern {} {}Type;\n\n'.format(type_name, type_name)

                header_file.write(class_decl)

                vector_ctor_name = '{}_{}x{}_ctor'.format(type_name, type, column_size)
                
                for arg_index in range(0, row_size):
                    arg_name = '{}_arg{}'.format(vector_ctor_name, arg_index)
                    declaration_string += 'extern Variable {};\n'.format(arg_name)
                    definition_string += 'Variable {};\\\n'.format(arg_name)

                declaration_string += 'extern Function {};\n'.format(vector_ctor_name)
                definition_string += 'Function {};\\\n'.format(vector_ctor_name)
                list_string += '        std::pair{{ "{}"_c, &{}}},\n'.format(data_type_name, vector_ctor_name)

                declaration_string += 'extern Function {}_identity;\n'.format(type_name)
                definition_string += 'Function {}_identity;\\\n'.format(type_name)
                list_string += '        std::pair{{ "{}"_c, &{}_identity}},\n'.format(data_type_name, type_name)

                array_ctor_name = '{}_{}_{}_ctor'.format(type_name, type, column_size * row_size)
                for arg_index in range(0, column_size * row_size):
                    arg_name = '{}_arg{}'.format(array_ctor_name, arg_index)
                    declaration_string += 'extern Variable {};\n'.format(arg_name)
                    definition_string += 'Variable {};\\\n'.format(arg_name)

                declaration_string += 'extern Function {};\n'.format(array_ctor_name)
                definition_string += 'Function {};\n'.format(array_ctor_name)
                list_string += '        std::pair{{ "{}"_c, &{}}},\n'.format(data_type_name, array_ctor_name)

                header_file.write(declaration_string[0:-1] + '\n')
                header_file.write("\n")
                header_file.write(definition_string[0:-2] + '\n')
                header_file.write("\n")
                header_file.write("\n")
        
                definition_string = "#define DEF_{}_operators\\\n".format(type_name)
                declaration_string = ""

                vec_type = '{}x{}'.format(type, column_size)
                for name, op, idx_type, idx_data_type in zip(index_operator_names, index_operators, index_types, index_data_types):
                    fun_name = '{}_operator_{}'.format(type_name, name)
                    arg_name = '{}_operator_{}_arg0'.format(type_name, name)
                    declaration_string += 'extern Variable {};\n'.format(arg_name)
                    declaration_string += 'extern Function {};\n'.format(fun_name)
                    definition_string += 'Variable {};\\\n'.format(arg_name)
                    definition_string += 'Function {};\\\n'.format(fun_name)
                    setup_string += '    // operator{}({})\n'.format(op, idx_data_type)
                    setup_string += '    {}.name = "_arg0"_c;\n'.format(arg_name, name)
                    setup_string += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(arg_name, idx_type)
                    setup_string += '    {}.name = "operator{}"_c;\n'.format(fun_name, op)
                    setup_string += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(fun_name, vec_type)
                    setup_string += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(arg_name, idx_type)
                    setup_string += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(fun_name, vec_type)
                    list_string += '        std::pair{{ "operator{}({})"_c, &{}}},\n'.format(op, idx_data_type, fun_name)

                    spirv_function =  '    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, {}.returnType, &{}Type, args[0].scope);\n'.format(fun_name, type)
                    spirv_function += '    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);\n'
                    spirv_function += '    SPIRVResult ret = args[0];\n'
                    spirv_function += '    ret.AddAccessChainLink({loadedIndex});\n'
                    spirv_function += '    ret.typeName = returnTypePtr.typeName;\n'
                    spirv_function += '    ret.parentTypes = returnTypePtr.parentTypes;\n'
                    spirv_function += '    ret.scope = args[0].scope;\n'
                    spirv_function += '    ret.isValue = false;\n'
                    spirv_function += '    return ret;\n'
                    spirv_code += spirv_intrinsic(fun_name, spirv_function)

                operator_sets = [
                    zip(scalar_operator_names, scalar_operators), 
                    zip(assignment_operator_names, assignment_operators)
                ]
                for operator_set in operator_sets:
                    for name, op in operator_set:
                        fun_name = '{}_operator_{}_{}'.format(type_name, name, type_name)
                        arg_name = '{}_operator_{}_{}_arg0'.format(type_name, name, type_name)
                        setup_string += '    // operator{}\n'.format(op)
                        setup_string += '    {}.name = "_arg0"_c;\n'.format(arg_name, name)
                        setup_string += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(arg_name, type_name)
                        setup_string += '    {}.name = "operator{}"_c;\n'.format(fun_name, op)
                        setup_string += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(fun_name, type_name)
                        setup_string += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(arg_name, type_name)
                        setup_string += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(fun_name, type_name)
                        
                        declaration_string += 'extern Variable {};\n'.format(arg_name)
                        declaration_string += 'extern Function {};\n'.format(fun_name)
                        definition_string += 'Variable {};\\\n'.format(arg_name)
                        definition_string += 'Function {};\\\n'.format(fun_name)
                        list_string += '        std::pair{{ "operator{}({})"_c, &{}}},\n'.format(op, data_type_name, fun_name)

                        spirv_function = ''
                        spirv_function += '    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);\n'
                        spirv_function += '    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);\n'

                        if op == '+' or op == '+=':
                            spirv_function += '    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, {});\n'.format(column_size)
                            spirv_function += '    TransientArray<SPVArg> intermediateArgs({});\n'.format(column_size)
                            spirv_function += '    for (uint32_t i = 0; i < {}; i++);\n'.format(column_size)
                            spirv_function += '    {\n'
                            spirv_function += '        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);\n'
                            spirv_function += '        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);\n'
                            spirv_function += '        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));\n'
                            spirv_function += '        intermediateArgs.Append(SPVArg(res));\n'
                            spirv_function += '    }\n'
                            spirv_function += '    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));\n'
                        elif op == '-' or op == '-=':
                            spirv_function += '    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, {});\n'.format(column_size)
                            spirv_function += '    TransientArray<SPVArg> intermediateArgs({});\n'.format(column_size)
                            spirv_function += '    for (uint32_t i = 0; i < {}; i++);\n'.format(column_size)
                            spirv_function += '    {\n'
                            spirv_function += '        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);\n'
                            spirv_function += '        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);\n'
                            spirv_function += '        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));\n'
                            spirv_function += '        intermediateArgs.Append(SPVArg(res));\n'
                            spirv_function += '    }\n'
                            spirv_function += '    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));\n'
                        elif op == '*' or op == '*=':
                            spirv_function += '    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);\n'
                        spirv_code += spirv_intrinsic(fun_name, spirv_function)

                op = '*'
                fun_name = '{}_operator_{}_{}_{}'.format(type_name, 'scale', type_name, type)
                arg_name = '{}_operator_{}_{}_{}_arg0'.format(type_name, 'scale', type_name, type)
                setup_string += '    // operator{}({})\n'.format(op, data_type)
                setup_string += '    {}.name = "_arg0"_c;\n'.format(arg_name, name)
                setup_string += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(arg_name, type)
                setup_string += '    {}.name = "operator{}"_c;\n'.format(fun_name, op)
                setup_string += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(fun_name, type_name)
                setup_string += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(arg_name, type)
                setup_string += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(fun_name, type_name)
                declaration_string += 'extern Variable {};\n'.format(arg_name)
                declaration_string += 'extern Function {};\n'.format(fun_name)
                definition_string += 'Variable {};\\\n'.format(arg_name)
                definition_string += 'Function {};\\\n'.format(fun_name)
                list_string += '        std::pair{{ "operator{}({})"_c, &{}}},\n'.format(op, data_type, fun_name)

                spirv_function = ''
                spirv_function += '    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);\n'
                spirv_function += '    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);\n'
                spirv_function += '    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);\n'
                spirv_code += spirv_intrinsic(fun_name, spirv_function)

                class_def = ""
                class_def += '{}::{}()\n'.format(type_name, type_name)
                class_def += '{\n'
                class_def += '    this->name = "{}";\n'.format(data_type)
                class_def += '    this->columnSize = {};\n'.format(column_size)
                class_def += '    this->rowSize = {};\n'.format(row_size)
                class_def += '    this->byteSize = {:d};\n'.format(trunc((bits * row_size * column_size) / 8))
                class_def += '    this->category = Type::ScalarCategory;\n'
                class_def += '    this->baseType = TypeCode::{};\n'.format(type)
                class_def += '    this->builtin = true;\n'
                class_def += '\n'
                class_def += '{}'.format(setup_string)
                class_def += '    this->scope.symbolLookup = StaticMap {{ \n    std::array{{\n{}\n    }}\n    }};   \n'.format(list_string[0:-2])
                class_def += '}\n\n'

                header_file.write(declaration_string[0:-1] + '\n')
                header_file.write("\n")
                header_file.write(definition_string[0:-2] + '\n')
                header_file.write("\n")
                source_file.write(class_def)
                #source_file.write("\n")
                header_file.write("\n")

    # Texture types
    texture_dimensions = ['1D', '2D', '3D', 'Cube']
    texture_multisampling = ['MS', 'MS', '', '']
    texture_array = ['Array', 'Array', '', 'Array']
    for dim, ms, array in zip(texture_dimensions, texture_multisampling, texture_array):

        class_decl = ""
        class_decl += 'struct Texture{} : public Type\n'.format(dim)
        class_decl += '{\n'
        class_decl += '    Texture{}();\n'.format(dim)
        class_decl += '};\n'
        class_decl += 'extern Texture{} Texture{}Type;\n\n'.format(dim, dim)
    
        class_def = ""
        class_def += 'Texture{}::Texture{}()\n'.format(dim, dim)
        class_def += '{\n'
        class_def += '    this->name = "texture{}";\n'.format(dim)
        class_def += '    this->category = Type::TextureCategory;\n'
        class_def += '    this->baseType = TypeCode::Texture{};\n'.format(dim)
        class_def += '    this->builtin = true;\n'
        class_def += '};\n\n'
        if ms : 
            class_decl += 'struct Texture{}MS : public Type\n'.format(dim)
            class_decl += '{\n'
            class_decl += '    Texture{}MS();\n'.format(dim)
            class_decl += '};\n'
            class_decl += 'extern Texture{}MS Texture{}MSType;\n\n'.format(dim, dim)

            class_def += 'Texture{}MS::Texture{}MS()\n'.format(dim, dim)
            class_def += '{\n'
            class_def += '    this->name = "texture{}MS";\n'.format(dim)
            class_def += '    this->category = Type::TextureCategory;\n'
            class_def += '    this->baseType = TypeCode::Texture{};\n'.format(dim)
            class_def += '    this->builtin = true;\n'
            class_def += '};\n\n'
            if array:
                class_decl += 'struct Texture{}MSArray : public Type\n'.format(dim)
                class_decl += '{\n'
                class_decl += '    Texture{}MSArray();\n'.format(dim)
                class_decl += '};\n'
                class_decl += 'extern Texture{}MSArray Texture{}MSArrayType;\n\n'.format(dim, dim)

                class_def += 'Texture{}MSArray::Texture{}MSArray()\n'.format(dim, dim)
                class_def += '{\n'
                class_def += '    this->name = "texture{}MSArray";\n'.format(dim)
                class_def += '    this->category = Type::TextureCategory;\n'
                class_def += '    this->baseType = TypeCode::Texture{};\n'.format(dim)
                class_def += '    this->builtin = true;\n'
                class_def += '};\n\n'
        if array:
            class_decl += 'struct Texture{}Array : public Type\n'.format(dim)
            class_decl += '{\n'
            class_decl += '    Texture{}Array();\n'.format(dim)
            class_decl += '};\n'
            class_decl += 'extern Texture{}Array Texture{}ArrayType;\n\n'.format(dim, dim)

            class_def += 'Texture{}Array::Texture{}Array()\n'.format(dim, dim)
            class_def += '{\n'
            class_def += '    this->name = "texture{}Array";\n'.format(dim)
            class_def += '    this->category = Type::TextureCategory;\n'
            class_def += '    this->baseType = TypeCode::Texture{};\n'.format(dim)
            class_def += '    this->builtin = true;\n'
            class_def += '};\n\n'

        header_file.write(class_decl)
        source_file.write(class_def)

    # Pixel cache types
    class_decl = ""
    class_decl += 'struct PixelCache : public Type\n'
    class_decl += '{\n'
    class_decl += '    PixelCache();\n'
    class_decl += '};\n'
    class_decl += 'extern PixelCache PixelCacheType;\n\n'

    class_decl += 'struct PixelCacheMS : public Type\n'
    class_decl += '{\n'
    class_decl += '    PixelCacheMS();\n'
    class_decl += '};\n'
    class_decl += 'extern PixelCacheMS PixelCacheMSType;\n\n'

    class_def = ""
    class_def += 'PixelCache::PixelCache()\n'.format(dim, dim)
    class_def += '{\n'
    class_def += '    this->name = "pixelCache";\n'.format(dim)
    class_def += '    this->category = Type::PixelCacheCategory;\n'
    class_def += '    this->baseType = TypeCode::PixelCache;\n'.format(type)
    class_def += '    this->builtin = true;\n'
    class_def += '};\n\n'

    class_def += 'PixelCacheMS::PixelCacheMS()\n'.format(dim, dim)
    class_def += '{\n'
    class_def += '    this->name = "pixelCacheMS";\n'.format(dim)
    class_def += '    this->category = Type::PixelCacheCategory;\n'
    class_def += '    this->baseType = TypeCode::PixelCache;\n'.format(type)
    class_def += '    this->builtin = true;\n'
    class_def += '};\n\n'

    class_decl += 'struct Sampler : public Type\n'
    class_decl += '{\n'
    class_decl += '    Sampler();\n'
    class_decl += '};\n'
    class_decl += 'extern Sampler SamplerType;\n\n'

    class_def = ""
    class_def += 'Sampler::Sampler()\n'.format(dim, dim)
    class_def += '{\n'
    class_def += '    this->name = "sampler"_c;\n'.format(dim)
    class_def += '    this->category = Type::SamplerCategory;\n'
    class_def += '    this->baseType = TypeCode::Sampler;\n'.format(type)
    class_def += '    this->builtin = true;\n'
    class_def += '};\n\n'

    header_file.write(class_decl)
    source_file.write(class_def)

    # Acceleration Structure
    class_decl = ""
    class_decl += 'struct AccelerationStructure : public Type\n'
    class_decl += '{\n'
    class_decl += '    AccelerationStructure();\n'
    class_decl += '};\n'
    class_decl += 'extern AccelerationStructure AccelerationStructureType;\n\n'

    class_def = ""
    class_def += 'AccelerationStructure::AccelerationStructure()\n'.format(dim, dim)
    class_def += '{\n'
    class_def += '    this->name = "accelerationStructure";\n'.format(dim)
    class_def += '    this->category = Type::AccelerationStructureCategory;\n'
    class_def += '    this->baseType = TypeCode::AccelerationStructure;\n'.format(type)
    class_def += '    this->builtin = true;\n'
    class_def += '};\n\n'

    header_file.write(class_decl)
    source_file.write(class_def)

    class_decl = ""
    class_decl += 'struct Void : public Type\n'
    class_decl += '{\n'
    class_decl += '    Void();\n'
    class_decl += '};\n'
    class_decl += 'extern Void VoidType;\n\n'

    class_def = ""
    class_def += 'Void::Void()\n'
    class_def += '{\n'
    class_def += '    this->name = "void";\n'
    class_def += '    this->category = Type::VoidCategory;\n'
    class_def += '    this->baseType = TypeCode::Void;\n'
    class_def += '    this->builtin = true;\n'
    class_def += '};\n\n' 

    header_file.write(class_decl)
    source_file.write(class_def)

    class_decl = ""
    class_def = ""
    class_decl += 'struct CompareMode : public Enumeration\n'
    class_decl += '{\n'
    class_decl += '    CompareMode();\n'
    class_decl += '};\n'
    class_decl += 'extern CompareMode CompareModeType;\n\n'
    compare_mode_names = [
        'Less',
        'LessEqual',
        'Greater',
        'GreaterEqual',
        'Equal',
        'NotEqual',
        'Always',
        'Never'
    ]
    for name in compare_mode_names:
        class_decl += 'extern EnumExpression CompareMode{};\n'.format(name)
        class_def += 'EnumExpression CompareMode{};\n'.format(name)
    class_def += 'CompareMode CompareModeType;\n'
    class_def += 'CompareMode::CompareMode()\n'
    class_def += '{\n' 
    class_def += '    this->name = "CompareMode";\n'
    class_def += '    this->category = Type::EnumCategory;\n'
    class_def += '    this->type = Type::FullType{{ UInt32Type.name }};\n'
    class_def += '    Symbol::Resolved(this)->typeSymbol = &UInt32Type;\n'
    class_def += '    this->baseType = TypeCode::UInt;\n'
    class_def += '    this->type.literal = true;\n'
    class_def += '    this->builtin = true;\n'
    for i, name in enumerate(compare_mode_names):
        class_def += '    CompareMode{}.value = {};\n'.format(name, hex(i))
        class_def += '    CompareMode{}.type = Type::FullType{{ CompareModeType.name, true }};\n'.format(name)
        class_def += '    CompareMode{}.underlyingType = Type::FullType{{ UInt32Type.name }};\n'.format(name)
        class_def += '    Symbol::Resolved(&CompareMode{})->type = this;\n'.format(name)
    class_def += '    this->scope.symbolLookup = StaticMap { std::array{\n'
    for name in compare_mode_names:
        class_def += '        std::pair{{ "{}"_c, &CompareMode{} }},\n'.format(name, name)
    class_def += '    }};\n'
    class_def += '};\n\n'

    class_decl += 'struct StencilOp : public Enumeration\n'
    class_decl += '{\n'
    class_decl += '    StencilOp();\n'
    class_decl += '};\n'

    stencil_op_names = [
        'Keep', 'Zero', 'Replace', 'Increment', 'Decrement', 'Invert', 'IncrementWrap', 'DecrementWrap'
    ]
    class_decl += 'extern StencilOp StencilOpType;\n\n'
    for name in stencil_op_names:
        class_decl += 'extern EnumExpression StencilOp{};\n'.format(name)
        class_def += 'EnumExpression StencilOp{};\n'.format(name)
    class_def += 'StencilOp StencilOpType;\n'
    class_def += 'StencilOp::StencilOp()\n'
    class_def += '{\n'
    class_def += '    this->name = "StencilOp";\n'
    class_def += '    this->category = Type::EnumCategory;\n'
    class_def += '    this->type = Type::FullType{{ UInt32Type.name }};\n'
    class_def += '    Symbol::Resolved(this)->typeSymbol = &UInt32Type;\n'
    class_def += '    this->baseType = TypeCode::UInt;\n'
    class_def += '    this->type.literal = true;\n'
    class_def += '    this->builtin = true;\n'

    for i, name in enumerate(stencil_op_names):
        class_def += '    StencilOp{}.value = {};\n'.format(name, hex(i))
        class_def += '    StencilOp{}.type = Type::FullType{{ StencilOpType.name, true }};\n'.format(name)
        class_def += '    StencilOp{}.underlyingType = Type::FullType{{ UInt32Type.name }};\n'.format(name)
        class_def += '    Symbol::Resolved(&StencilOp{})->type = this;\n'.format(name)
    class_def += '    this->scope.symbolLookup = StaticMap { std::array{\n'
    for name in stencil_op_names:
        class_def += '        std::pair{{ "{}"_c, &StencilOp{} }},\n'.format(name, name)
    class_def += '    }};\n'
    class_def += '};\n\n'

    class_decl += 'struct ExecutionScope : public Enumeration\n'
    class_decl += '{\n'
    class_decl += '    ExecutionScope();\n'
    class_decl += '};\n'
    class_decl += 'extern ExecutionScope ExecutionScopeType;\n\n'

    execution_scope_names = [
        'Global', 'Device', 'Workgroup', 'Subgroup', 'Invocation', 'Queue'
    ]
    for name in execution_scope_names:
        class_decl += 'extern EnumExpression ExecutionScope{};\n'.format(name)
        class_def += 'EnumExpression ExecutionScope{};\n'.format(name)
    class_def += 'ExecutionScope ExecutionScopeType;\n'
    class_def += 'ExecutionScope::ExecutionScope()\n'
    class_def += '{\n'
    class_def += '    this->name = "ExecutionScope";\n'
    class_def += '    this->category = Type::EnumCategory;\n'
    class_def += '    this->type = Type::FullType{{ UInt32Type.name }};\n'
    class_def += '    Symbol::Resolved(this)->typeSymbol = &UInt32Type;\n'
    class_def += '    this->baseType = TypeCode::UInt;\n'
    class_def += '    this->type.literal = true;\n'
    class_def += '    this->builtin = true;\n'  
    for i, name in enumerate(execution_scope_names):
        class_def += '    ExecutionScope{}.value = {};\n'.format(name, hex(i))
        class_def += '    ExecutionScope{}.type = Type::FullType{{ ExecutionScopeType.name, true }};\n'.format(name)
        class_def += '    ExecutionScope{}.underlyingType = Type::FullType{{ UInt32Type.name }};\n'.format(name)
        class_def += '    Symbol::Resolved(&ExecutionScope{})->type = this;\n'.format(name)
    class_def += '    this->scope.symbolLookup = StaticMap { std::array{\n'
    for name in execution_scope_names:
        class_def += '        std::pair{{ "{}"_c, &ExecutionScope{} }},\n'.format(name, name)
    class_def += '    }};\n'
    class_def += '};\n\n'

    class_decl += 'struct MemorySemantics : public Enumeration\n'
    class_decl += '{\n'
    class_decl += '    MemorySemantics();\n'
    class_decl += '};\n'
    class_decl += 'extern MemorySemantics MemorySemanticsType;\n\n'
    memory_semantics_names = [
        'Acquire', 'Release', 'AcquireRelease', 'SequentiallyConsistent', 'Relaxed'
    ]
    for name in memory_semantics_names:
        class_decl += 'extern EnumExpression MemorySemantics{};\n'.format(name)
        class_def += 'EnumExpression MemorySemantics{};\n'.format(name)
    class_def += 'MemorySemantics MemorySemanticsType;\n'
    class_def += 'MemorySemantics::MemorySemantics()\n'
    class_def += '{\n'
    class_def += '    this->name = "MemorySemantics";\n'
    class_def += '    this->category = Type::EnumCategory;\n'
    class_def += '    this->type = Type::FullType{{ UInt32Type.name }};\n'
    class_def += '    Symbol::Resolved(this)->typeSymbol = &UInt32Type;\n'
    class_def += '    this->baseType = TypeCode::UInt;\n'
    class_def += '    this->type.literal = true;\n'
    class_def += '    this->builtin = true;\n'
    for i, name in enumerate(memory_semantics_names):
        class_def += '    MemorySemantics{}.value = {};\n'.format(name, hex(1 << i))
        class_def += '    MemorySemantics{}.type = Type::FullType{{ MemorySemanticsType.name, true }};\n'.format(name)
        class_def += '    MemorySemantics{}.underlyingType = Type::FullType{{ UInt32Type.name }};\n'.format(name)
        class_def += '    Symbol::Resolved(&MemorySemantics{})->type = this;\n'.format(name)
    class_def += '    this->scope.symbolLookup = StaticMap { std::array{\n'
    for name in memory_semantics_names:
        class_def += '        std::pair{{ "{}"_c, &MemorySemantics{} }},\n'.format(name, name)
    class_def += '    }};\n'
    class_def += '};\n\n'

    class_decl += 'struct PolygonMode : public Enumeration\n'
    class_decl += '{\n'
    class_decl += '    PolygonMode();\n'
    class_decl += '};\n'
    class_decl += 'extern PolygonMode PolygonModeType;\n\n'
    polygon_mode_names = [
        'Fill', 'Line', 'Point'
    ]
    for name in polygon_mode_names:
        class_decl += 'extern EnumExpression PolygonMode{};\n'.format(name)
        class_def += 'EnumExpression PolygonMode{};\n'.format(name)
    class_def += 'PolygonMode PolygonModeType;\n'
    class_def += 'PolygonMode::PolygonMode()\n'
    class_def += '{\n'
    class_def += '    this->name = "PolygonMode";\n'
    class_def += '    this->category = Type::EnumCategory;\n'
    class_def += '    this->type = Type::FullType{{ UInt32Type.name }};\n'
    class_def += '    Symbol::Resolved(this)->typeSymbol = &UInt32Type;\n'
    class_def += '    this->baseType = TypeCode::UInt;\n'
    class_def += '    this->type.literal = true;\n'
    class_def += '    this->builtin = true;\n'
    for i, name in enumerate(polygon_mode_names):
        class_def += '    PolygonMode{}.value = {};\n'.format(name, hex(i))
        class_def += '    PolygonMode{}.type = Type::FullType{{ PolygonModeType.name, true }};\n'.format(name)
        class_def += '    PolygonMode{}.underlyingType = Type::FullType{{ UInt32Type.name }};\n'.format(name)
        class_def += '    Symbol::Resolved(&PolygonMode{})->type = this;\n'.format(name)
    class_def += '    this->scope.symbolLookup = StaticMap { std::array{\n'
    for name in polygon_mode_names:
        class_def += '        std::pair{{ "{}"_c, &PolygonMode{} }},\n'.format(name, name)
    class_def += '    }};\n'
    class_def += '};\n\n'

    class_decl += 'struct CullMode : public Enumeration\n'
    class_decl += '{\n'
    class_decl += '    CullMode();\n'
    class_decl += '};\n'
    class_decl += 'extern CullMode CullModeType;\n\n'
    cull_mode_names = [
        'None', 'Front', 'Back', 'FrontAndBack'
    ]
    for name in cull_mode_names:
        class_decl += 'extern EnumExpression CullMode{};\n'.format(name)
        class_def += 'EnumExpression CullMode{};\n'.format(name)
    class_def += 'CullMode CullModeType;\n'
    class_def += 'CullMode::CullMode()\n'
    class_def += '{\n'
    class_def += '    this->name = "CullMode";\n'
    class_def += '    this->category = Type::EnumCategory;\n'
    class_def += '    this->type = Type::FullType{{ UInt32Type.name }};\n'
    class_def += '    Symbol::Resolved(this)->typeSymbol = &UInt32Type;\n'
    class_def += '    this->baseType = TypeCode::UInt;\n'
    class_def += '    this->type.literal = true;\n'
    class_def += '    this->builtin = true;\n'
    for i, name in enumerate(cull_mode_names):
        class_def += '    CullMode{}.value = {};\n'.format(name, hex(i))
        class_def += '    CullMode{}.type = Type::FullType{{ CullModeType.name, true }};\n'.format(name)
        class_def += '    CullMode{}.underlyingType = Type::FullType{{ UInt32Type.name }};\n'.format(name)
        class_def += '    Symbol::Resolved(&CullMode{})->type = this;\n'.format(name)
    class_def += '    this->scope.symbolLookup = StaticMap { std::array{\n'
    for name in cull_mode_names:
        class_def += '        std::pair{{ "{}"_c, &CullMode{} }},\n'.format(name, name)
    class_def += '    }};\n'
    class_def += '};\n\n'

    class_decl += 'struct WindingOrder : public Enumeration\n'
    class_decl += '{\n'
    class_decl += '    WindingOrder();\n'
    class_decl += '};\n'
    class_decl += 'extern WindingOrder WindingOrderType;\n\n'
    winding_order_names = [
        'Clockwise', 'CounterClockwise'
    ]
    for name in winding_order_names:
        class_decl += 'extern EnumExpression WindingOrder{};\n'.format(name)
        class_def += 'EnumExpression WindingOrder{};\n'.format(name)
    class_def += 'WindingOrder WindingOrderType;\n'
    class_def += 'WindingOrder::WindingOrder()\n'
    class_def += '{\n'
    class_def += '    this->name = "WindingOrder";\n'
    class_def += '    this->category = Type::EnumCategory;\n'
    class_def += '    this->type = Type::FullType{{ UInt32Type.name }};\n'
    class_def += '    Symbol::Resolved(this)->typeSymbol = &UInt32Type;\n'
    class_def += '    this->baseType = TypeCode::UInt;\n'
    class_def += '    this->type.literal = true;\n'
    class_def += '    this->builtin = true;\n'
    for i, name in enumerate(winding_order_names):
        class_def += '    WindingOrder{}.value = {};\n'.format(name, hex(i))
        class_def += '    WindingOrder{}.type = Type::FullType{{ WindingOrderType.name, true }};\n'.format(name)
        class_def += '    WindingOrder{}.underlyingType = Type::FullType{{ UInt32Type.name }};\n'.format(name)
        class_def += '    Symbol::Resolved(&WindingOrder{})->type = this;\n'.format(name)
    class_def += '    this->scope.symbolLookup = StaticMap { std::array{\n'
    for name in winding_order_names:
        class_def += '        std::pair{{ "{}"_c, &WindingOrder{} }},\n'.format(name, name)
    class_def += '    }};\n'
    class_def += '};\n\n'

    class_decl += 'struct LogicOp : public Enumeration\n'
    class_decl += '{\n'
    class_decl += '    LogicOp();\n'
    class_decl += '};\n'
    class_decl += 'extern LogicOp LogicOpType;\n'
    logic_op_names = [
        'And', 'AndInverted', 'AndReverse', 'Clear', 'Copy', 'CopyInverted', 'Equivalence', 'Invert', 'Nand', 'No', 'Nor', 'Or', 'OrInverted', 'OrReverse', 'Set', 'Xor'
    ]
    for name in logic_op_names:
        class_decl += 'extern EnumExpression LogicOp{};\n'.format(name)
        class_def += 'EnumExpression LogicOp{};\n'.format(name)
    class_def += 'LogicOp LogicOpType;\n'
    class_def += 'LogicOp::LogicOp()\n'
    class_def += '{\n'
    class_def += '    this->name = "LogicOp";\n'
    class_def += '    this->category = Type::EnumCategory;\n'
    class_def += '    this->type = Type::FullType{{ UInt32Type.name }};\n'
    class_def += '    Symbol::Resolved(this)->typeSymbol = &UInt32Type;\n'
    class_def += '    this->baseType = TypeCode::UInt;\n'
    class_def += '    this->type.literal = true;\n'
    class_def += '    this->builtin = true;\n'
    for i, name in enumerate(logic_op_names):
        class_def += '    LogicOp{}.value = {};\n'.format(name, hex(i))
        class_def += '    LogicOp{}.type = Type::FullType{{ LogicOpType.name, true }};\n'.format(name)
        class_def += '    LogicOp{}.underlyingType = Type::FullType{{ UInt32Type.name }};\n'.format(name)
        class_def += '    Symbol::Resolved(&LogicOp{})->type = this;\n'.format(name)
    class_def += '    this->scope.symbolLookup = StaticMap { std::array{\n'
    for name in logic_op_names:
        class_def += '        std::pair{{ "{}"_c, &LogicOp{} }},\n'.format(name, name)
    class_def += '    }};\n'
    class_def += '};\n\n'

    class_decl += 'struct BlendFactor : public Enumeration\n'
    class_decl += '{\n'
    class_decl += '    BlendFactor();\n'
    class_decl += '};\n'
    class_decl += 'extern BlendFactor BlendFactorType;\n\n'
    blend_factor_names = [
        'Zero', 'One', 'SourceColor', 'OneMinusSourceColor', 'SourceAlpha', 'OneMinusSourceAlpha',
        'DestinationColor', 'OneMinusDestinationColor', 'DestinationAlpha', 'OneMinusDestinationAlpha', 'ConstantColor',
        'OneMinusConstantColor', 'ConstantAlpha', 'OneMinusConstantAlpha'
    ]
    for name in blend_factor_names:
        class_decl += 'extern EnumExpression BlendFactor{};\n'.format(name)
        class_def += 'EnumExpression BlendFactor{};\n'.format(name)
    class_def += 'BlendFactor BlendFactorType;\n'
    class_def += 'BlendFactor::BlendFactor()\n'
    class_def += '{\n'
    class_def += '    this->name = "BlendFactor";\n'
    class_def += '    this->category = Type::EnumCategory;\n'
    class_def += '    this->type = Type::FullType{{ UInt32Type.name }};\n'
    class_def += '    Symbol::Resolved(this)->typeSymbol = &UInt32Type;\n'
    class_def += '    this->baseType = TypeCode::UInt;\n'
    class_def += '    this->type.literal = true;\n'
    class_def += '    this->builtin = true;\n'
    for i, name in enumerate(blend_factor_names):
        class_def += '    BlendFactor{}.value = {};\n'.format(name, hex(i))
        class_def += '    BlendFactor{}.type = Type::FullType{{ BlendFactorType.name, true }};\n'.format(name)
        class_def += '    BlendFactor{}.underlyingType = Type::FullType{{ UInt32Type.name }};\n'.format(name)
        class_def += '    Symbol::Resolved(&BlendFactor{})->type = this;\n'.format(name)
    class_def += '    this->scope.symbolLookup = StaticMap { std::array{\n'
    for name in blend_factor_names:
        class_def += '        std::pair{{ "{}"_c, &BlendFactor{} }},\n'.format(name, name)
    class_def += '    }};\n'
    class_def += '};\n\n'

    class_decl += 'struct BlendOperation : public Enumeration\n'
    class_decl += '{\n'
    class_decl += '    BlendOperation();\n'
    class_decl += '};\n'
    class_decl += 'extern BlendOperation BlendOperationType;\n\n'
    blend_operation_names = [
        'Add', 'Subtract', 'ReverseSubtract', 'Min', 'Max'
    ]
    for name in blend_operation_names:
        class_decl += 'extern EnumExpression BlendOperation{};\n'.format(name)
        class_def += 'EnumExpression BlendOperation{};\n'.format(name)
    class_def += 'BlendOperation BlendOperationType;\n'
    class_def += 'BlendOperation::BlendOperation()\n'
    class_def += '{\n'
    class_def += '    this->name = "BlendOperation";\n'
    class_def += '    this->category = Type::EnumCategory;\n'
    class_def += '    this->type = Type::FullType{{ UInt32Type.name }};\n'
    class_def += '    Symbol::Resolved(this)->typeSymbol = &UInt32Type;\n'
    class_def += '    this->baseType = TypeCode::UInt;\n'
    class_def += '    this->type.literal = true;\n'
    class_def += '    this->builtin = true;\n'
    for i, name in enumerate(blend_operation_names):
        class_def += '    BlendOperation{}.value = {};\n'.format(name, hex(i))
        class_def += '    BlendOperation{}.type = Type::FullType{{ BlendOperationType.name, true }};\n'.format(name)
        class_def += '    BlendOperation{}.underlyingType = Type::FullType{{ UInt32Type.name }};\n'.format(name)
        class_def += '    Symbol::Resolved(&BlendOperation{})->type = this;\n'.format(name)
    class_def += '    this->scope.symbolLookup = StaticMap { std::array{\n'
    for name in blend_operation_names:
        class_def += '        std::pair{{ "{}"_c, &BlendOperation{} }},\n'.format(name, name)
    class_def += '    }};\n'
    class_def += '};\n\n'

    class_decl += 'struct BlendColorMask : public Enumeration\n'
    class_decl += '{\n'
    class_decl += '    BlendColorMask();\n'
    class_decl += '};\n'
    class_decl += 'extern BlendColorMask BlendColorMaskType;\n\n'
    blend_color_mask_names = [
        'None', 'R', 'RG', 'RGB', 'RGBA'
    ]
    for name in blend_color_mask_names:
        class_decl += 'extern EnumExpression BlendColorMask{};\n'.format(name)
        class_def += 'EnumExpression BlendColorMask{};\n'.format(name)
    class_def += 'BlendColorMask BlendColorMaskType;\n'
    class_def += 'BlendColorMask::BlendColorMask()\n'
    class_def += '{\n'
    class_def += '    this->name = "BlendColorMask";\n' 
    class_def += '    this->category = Type::EnumCategory;\n'
    class_def += '    this->type = Type::FullType{{ UInt32Type.name }};\n'
    class_def += '    Symbol::Resolved(this)->typeSymbol = &UInt32Type;\n'
    class_def += '    this->baseType = TypeCode::UInt;\n'
    class_def += '    this->type.literal = true;\n'
    class_def += '    this->builtin = true;\n'
    for i, name in enumerate(blend_color_mask_names):
        class_def += '    BlendColorMask{}.value = {};\n'.format(name, hex(i))
        class_def += '    BlendColorMask{}.type = Type::FullType{{ BlendColorMaskType.name, true }};\n'.format(name)
        class_def += '    BlendColorMask{}.underlyingType = Type::FullType{{ UInt32Type.name }};\n'.format(name)
        class_def += '    Symbol::Resolved(&BlendColorMask{})->type = this;\n'.format(name)
    class_def += '    this->scope.symbolLookup = StaticMap { std::array{\n'
    for name in blend_color_mask_names:
        class_def += '        std::pair{{ "{}"_c, &BlendColorMask{} }},\n'.format(name, name)
    class_def += '    }};\n'
    class_def += '};\n\n'

    class_decl += 'struct FilterMode : public Enumeration\n'
    class_decl += '{\n'
    class_decl += '    FilterMode();\n'
    class_decl += '};\n'
    class_decl += 'extern FilterMode FilterModeType;\n\n'
    filter_mode_names = [
        'Point', 'Linear', 'MinMagMipmapLinear', 'MinMagLinearMipPoint', 'MinLinearMagMipPoint', 'MinMagMipPoint', 'MinMagPointMipLinear', 'MinPointMagMipLinear', 'MinLinearMagPointMipLinear', 'MinPointMagLinearMipPoint'
    ]
    for name in filter_mode_names:
        class_decl += 'extern EnumExpression FilterMode{};\n'.format(name)
        class_def += 'EnumExpression FilterMode{};\n'.format(name)
    class_def += 'FilterMode FilterModeType;\n'
    class_def += 'FilterMode::FilterMode()\n'
    class_def += '{\n'
    class_def += '    this->name = "FilterMode";\n'
    class_def += '    this->category = Type::EnumCategory;\n'
    class_def += '    this->type = Type::FullType{{ UInt32Type.name }};\n'
    class_def += '    Symbol::Resolved(this)->typeSymbol = &UInt32Type;\n'
    class_def += '    this->baseType = TypeCode::UInt;\n'
    class_def += '    this->type.literal = true;\n'
    class_def += '    this->builtin = true;\n'
    for i, name in enumerate(filter_mode_names):
        class_def += '    FilterMode{}.value = {};\n'.format(name, hex(i))
        class_def += '    FilterMode{}.type = Type::FullType{{ FilterModeType.name, true }};\n'.format(name)
        class_def += '    FilterMode{}.underlyingType = Type::FullType{{ UInt32Type.name }};\n'.format(name)
        class_def += '    Symbol::Resolved(&FilterMode{})->type = this;\n'.format(name)
    class_def += '    this->scope.symbolLookup = StaticMap { std::array{\n'
    for name in filter_mode_names:
        class_def += '        std::pair{{ "{}"_c, &FilterMode{} }},\n'.format(name, name)
    class_def += '    }};\n'
    class_def += '};\n\n'

    class_decl += 'struct AddressMode : public Enumeration\n'
    class_decl += '{\n'
    class_decl += '    AddressMode();\n'
    class_decl += '};\n'
    class_decl += 'extern AddressMode AddressModeType;\n\n'
    address_mode_names = [
        'Repeat', 'Mirror', 'Clamp', 'Border'
    ]
    for name in address_mode_names:
        class_decl += 'extern EnumExpression AddressMode{};\n'.format(name)
        class_def += 'EnumExpression AddressMode{};\n'.format(name)
    class_def += 'AddressMode AddressModeType;\n'
    class_def += 'AddressMode::AddressMode()\n'
    class_def += '{\n'
    class_def += '    this->name = "AddressMode";\n'
    class_def += '    this->category = Type::EnumCategory;\n'
    class_def += '    this->type = Type::FullType{{ UInt32Type.name }};\n'
    class_def += '    Symbol::Resolved(this)->typeSymbol = &UInt32Type;\n'
    class_def += '    this->baseType = TypeCode::UInt;\n'
    class_def += '    this->type.literal = true;\n'
    class_def += '    this->builtin = true;\n'
    for i, name in enumerate(address_mode_names):
        class_def += '    AddressMode{}.value = {};\n'.format(name, hex(i))
        class_def += '    AddressMode{}.type = Type::FullType{{ AddressModeType.name, true }};\n'.format(name)
        class_def += '    AddressMode{}.underlyingType = Type::FullType{{ UInt32Type.name }};\n'.format(name)
        class_def += '    Symbol::Resolved(&AddressMode{})->type = this;\n'.format(name)
    class_def += '    this->scope.symbolLookup = StaticMap { std::array{\n'
    for name in address_mode_names:
        class_def += '        std::pair{{ "{}"_c, &AddressMode{} }},\n'.format(name, name)
    class_def += '    }};\n'
    class_def += '};\n\n'

    class_decl += 'struct BorderColor : public Enumeration\n'
    class_decl += '{\n'
    class_decl += '    BorderColor();\n'
    class_decl += '};\n'
    class_decl += 'extern BorderColor BorderColorType;\n\n'
    border_color_names = [
        'Transparent', 'Black', 'White'
    ]
    for name in border_color_names:
        class_decl += 'extern EnumExpression BorderColor{};\n'.format(name)
        class_def += 'EnumExpression BorderColor{};\n'.format(name)
    class_def += 'BorderColor BorderColorType;\n'
    class_def += 'BorderColor::BorderColor()\n'
    class_def += '{\n'
    class_def += '    this->name = "BorderColor";\n'
    class_def += '    this->category = Type::EnumCategory;\n'
    class_def += '    this->type = Type::FullType{{ UInt32Type.name }};\n'
    class_def += '    Symbol::Resolved(this)->typeSymbol = &UInt32Type;\n'
    class_def += '    this->baseType = TypeCode::UInt;\n'
    class_def += '    this->type.literal = true;\n'
    class_def += '    this->builtin = true;\n'
    for i, name in enumerate(border_color_names):
        class_def += '    BorderColor{}.value = {};\n'.format(name, hex(i))
        class_def += '    BorderColor{}.type = Type::FullType{{ BorderColorType.name, true }};\n'.format(name)
        class_def += '    BorderColor{}.underlyingType = Type::FullType{{ UInt32Type.name }};\n'.format(name)
        class_def += '    Symbol::Resolved(&BorderColor{})->type = this;\n'.format(name)
    class_def += '    this->scope.symbolLookup = StaticMap { std::array{\n'
    for name in border_color_names:
        class_def += '        std::pair{{ "{}"_c, &BorderColor{} }},\n'.format(name, name)
    class_def += '    }};\n'
    class_def += '};\n\n'

    class StateMember:
        def __init__(self, name, data_type, array_size=1):
            self.name = name
            self.data_type = data_type
            self.array_size = array_size

    class_decl += 'struct StencilState : public Type\n'
    class_decl += '{\n'
    class_decl += '    StencilState();\n'
    class_decl += '};\n'
    class_decl += 'extern StencilState StencilStateType;\n'

    stencil_state_members = [
        StateMember('Fail', 'StencilOp'),
        StateMember('Pass', 'StencilOp'),
        StateMember('DepthFail', 'StencilOp'),
        StateMember('CompareFunction', 'CompareMode'),
        StateMember('CompareMask', 'UInt32'),
        StateMember('WriteMask', 'UInt32'),
        StateMember('Reference', 'UInt32'),
    ]
    for member in stencil_state_members:
        class_decl += 'extern Variable StencilState{};\n'.format(member.name)
        class_def += 'Variable StencilState{};\n'.format(member.name)

    class_def += 'StencilState StencilStateType;\n'
    class_def += 'StencilState::StencilState()\n'
    class_def += '{\n'
    class_def += '    this->name = "StencilState";\n'
    class_def += '    this->category = Type::UserTypeCategory;\n'
    class_def += '    this->builtin = true;\n'
    for member in stencil_state_members:
        class_def += '    StencilState{}.name = "{}"_c;\n'.format(member.name, member.name)
        class_def += '    StencilState{}.type = Type::FullType{{ {}Type.name }};\n'.format(member.name, member.data_type)
        class_def += '    Symbol::Resolved(&StencilState{})->typeSymbol = &{}Type;\n\n'.format(member.name, member.data_type)
    class_def += '    this->scope.symbolLookup = StaticMap { std::array{\n'
    for member in stencil_state_members:
        class_def += '        std::pair{{ "{}"_c, &StencilState{} }},\n'.format(member.name, member.name)
    class_def += '    }};\n'
    class_def += '};\n\n'

    class_decl += 'struct RenderState : public Type\n'
    class_decl += '{\n'
    class_decl += '    RenderState();\n'
    class_decl += '};\n'
    class_decl += 'extern RenderState RenderStateType;\n'

    render_state_members = [ 
        StateMember('DepthClampEnabled', 'Bool8'),
        StateMember('DepthTestEnabled', 'Bool8'),
        StateMember('DepthWriteEnabled', 'Bool8'),
        StateMember('DepthBiasEnabled', 'Bool8'),
        StateMember('DepthBiasConstantFactor', 'Float32'),
        StateMember('DepthBiasClamp', 'Float32'),
        StateMember('DepthBiasSlopeFactor', 'Float32'),
        StateMember('DepthTestFunction', 'CompareMode'),
        StateMember('DepthBoundsTestEnabled', 'Bool8'),
        StateMember('DepthBoundsMin', 'Float32'),
        StateMember('DepthBoundsMax', 'Float32'),
        StateMember('NoRasterization', 'Bool8'),
        StateMember('PolygonMode', 'PolygonMode'),
        StateMember('CullMode', 'CullMode'),
        StateMember('WindingOrder', 'WindingOrder'),
        StateMember('StencilEnabled', 'Bool8'),
        StateMember('StencilFront', 'StencilState'),
        StateMember('StencilBack', 'StencilState'),
        StateMember('LogicOpEnabled', 'Bool8'),
        StateMember('LogicOp', 'LogicOp'),
        StateMember('BlendEnabled', 'Bool8', 8),
        StateMember('SourceBlend', 'BlendFactor', 8),
        StateMember('DestinationBlend', 'BlendFactor', 8),
        StateMember('SourceAlphaBlend', 'BlendFactor', 8),
        StateMember('DestinationAlphaBlend', 'BlendFactor', 8),
        StateMember('ColorBlendOp', 'BlendOperation', 8),
        StateMember('AlphaBlendOp', 'BlendOperation', 8),
        StateMember('Mask', 'BlendColorMask', 8),
    ]
    for member in render_state_members:
        class_decl += 'extern Variable RenderState{};\n'.format(member.name)
        class_def += 'Variable RenderState{};\n'.format(member.name)
        if member.array_size > 1:
            class_decl += 'extern IntExpression RenderState{}ArraySize;\n'.format(member.name)
            class_def += 'IntExpression RenderState{}ArraySize({});\n'.format(member.name, member.array_size)

    class_def += 'RenderState RenderStateType;\n'
    class_def += 'RenderState::RenderState()\n'
    class_def += '{\n'
    class_def += '    this->name = "RenderState";\n'
    class_def += '    this->category = Type::UserTypeCategory;\n'
    class_def += '    this->builtin = true;\n'
    for member in render_state_members:
        class_def += '    RenderState{}.name = "{}"_c;\n'.format(member.name, member.name)
        if member.array_size > 1:
            class_def += '    RenderState{}.type = Type::FullType{{ {}Type.name, {{Type::FullType::Modifier::Array}}, {{&RenderState{}ArraySize}} }};\n'.format(member.name, member.data_type, member.name)
        else:
            class_def += '    RenderState{}.type = Type::FullType{{ {}Type.name }};\n'.format(member.name, member.data_type)
        class_def += '    Symbol::Resolved(&RenderState{})->typeSymbol = &{}Type;\n\n'.format(member.name, member.data_type)
    class_def += '    this->scope.symbolLookup = StaticMap { std::array{\n'
    for member in render_state_members:
        class_def += '        std::pair{{ "{}"_c, &RenderState{} }},\n'.format(member.name, member.name)
    class_def += '    }};\n'
    class_def += '};\n\n'

    class_decl += 'struct SamplerState : public Type\n'
    class_decl += '{\n'
    class_decl += '    SamplerState();\n'
    class_decl += '};\n'
    class_decl += 'extern SamplerState SamplerStateType;\n'

    sampler_state_members = [
        StateMember('Address', 'AddressMode'),
        StateMember('AddressU', 'AddressMode'),
        StateMember('AddressV', 'AddressMode'),
        StateMember('AddressW', 'AddressMode'),
        StateMember('Filter', 'FilterMode'),
        StateMember('MinFilter', 'FilterMode'),
        StateMember('MagFilter', 'FilterMode'),
        StateMember('MipFilter', 'FilterMode'),
        StateMember('MipLodBias', 'Float32'),
        StateMember('AnisotropyEnabled', 'Bool8'),
        StateMember('MaxAnisotropy', 'UInt32'),
        StateMember('CompareEnabled', 'Bool8'),
        StateMember('CompareFunction', 'CompareMode'),
        StateMember('MinLod', 'Float32'),
        StateMember('MaxLod', 'Float32'),
        StateMember('BorderColor', 'BorderColor'),
        StateMember('UnnormalizedSamplingEnabled', 'Bool8')
    ]
    for member in sampler_state_members:
        class_decl += 'extern Variable SamplerState{};\n'.format(member.name)
        class_def += 'Variable SamplerState{};\n'.format(member.name)
    
    class_def += 'SamplerState SamplerStateType;\n'
    class_def += 'SamplerState::SamplerState()\n'
    class_def += '{\n'
    class_def += '    this->name = "SamplerState";\n'
    class_def += '    this->category = Type::UserTypeCategory;\n'
    class_def += '    this->builtin = true;\n'
    for member in sampler_state_members:
        class_def += '    SamplerState{}.name = "{}"_c;\n'.format(member.name, member.name)
        class_def += '    SamplerState{}.type = Type::FullType{{ {}Type.name }};\n'.format(member.name, member.data_type)
        class_def += '    Symbol::Resolved(&SamplerState{})->typeSymbol = &{}Type;\n\n'.format(member.name, member.data_type)
    class_def += '    this->scope.symbolLookup = StaticMap { std::array{\n'
    for member in sampler_state_members:
        class_def += '        std::pair{{ "{}"_c, &SamplerState{} }},\n'.format(member.name, member.name)
    class_def += '    }};\n'
    class_def += '};\n\n' 

    header_file.write(class_decl)
    source_file.write(class_def)

    header_file.write('} // namespace GPULang\n\n')
    source_file.write('} // namespace GPULang\n\n')

    ### Intrinsics
    intrinsics_header = open("../generated/intrinsics.h", "w")
    intrinsics_source = open("../generated/intrinsics.cc", "w")

    float_types = ['Float32', 'Float32x2', 'Float32x3', 'Float32x4', 'Float16', 'Float16x2', 'Float16x3', 'Float16x4']
    integer_types = ['Int32', 'Int32x2', 'Int32x3', 'Int32x4', 'Int16', 'Int16x2', 'Int16x3', 'Int16x4', 'UInt32', 'UInt32x2', 'UInt32x3', 'UInt32x4', 'UInt16', 'UInt16x2', 'UInt16x3', 'UInt16x4']
    scalar_types = float_types + integer_types
    float_vec_types = ['Float32x2', 'Float32x3', 'Float32x4', 'Float16x2', 'Float16x3', 'Float16x4']
    signed_types = ['Int32', 'Int32x2', 'Int32x3', 'Int32x4', 'Int16', 'Int16x2', 'Int16x3', 'Int16x4', 'Float32', 'Float32x2', 'Float32x3', 'Float32x4', 'Float16', 'Float16x2', 'Float16x3', 'Float16x4']
    bool_types = ['Bool8', 'Bool8x2', 'Bool8x3', 'Bool8x4']

    intrinsics_header.write("//-------------------------------------------------\n")
    intrinsics_header.write("// *** Generated by type_gen.py. ***\n")
    intrinsics_header.write("//       DO NOT MODIFY!!!\n")
    intrinsics_header.write("//-------------------------------------------------\n")
    intrinsics_header.write('namespace GPULang\n')
    intrinsics_header.write('{\n')

    intrinsics_source.write("//-------------------------------------------------\n")
    intrinsics_source.write("// *** Generated by type_gen.py. ***\n")
    intrinsics_source.write("//       DO NOT MODIFY!!!\n")
    intrinsics_source.write("//-------------------------------------------------\n")
    intrinsics_source.write('#include "ast/function.h"\n')
    intrinsics_source.write('#include "ast/variable.h"\n')
    intrinsics_source.write('#include "types.h"\n')

    intrinsics_source.write('namespace GPULang\n')
    intrinsics_source.write('{\n')

    intrinsic_decls = ''
    intrinsic_defs = ''
    intrinsic_setup = ''

    class Parameter:
        def __init__(self, name, data_type, is_mutable, is_pointer):
            self.name = name
            self.data_type = data_type
            self.is_mutable = is_mutable
            self.is_pointer = is_pointer


    float_only_single_argument_intrinsics = [
        'acos', 'acosh', 'asin', 'asinh', 'atan', 'atanh', 'cos', 'cosh', 'exp',
        'exp2', 'invSqrt', 'log', 'log2', 'sin', 'sinh', 'sqrt', 'tan', 'tanh'
    ]

    for intrinsic in float_only_single_argument_intrinsics:
        for float_type in float_types:
            function_name = '{}_{}'.format(intrinsic, float_type)
            argument_name = '{}_{}_arg'.format(intrinsic, float_type)
            intrinsic_decls += 'extern Variable {};\n'.format(argument_name)
            intrinsic_decls += 'extern Function {};\n'.format(function_name)
            intrinsic_defs += 'Variable {};\n'.format(argument_name)
            intrinsic_defs += 'Function {};\n'.format(function_name)
            intrinsic_setup += '    {}.name = "val"_c;\n'.format(argument_name)
            intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(argument_name, float_type)
            intrinsic_setup += '    {}.name = "{}"_c;\n'.format(function_name, intrinsic)
            intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, float_type)
            intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(argument_name, float_type)
            intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, float_type)

    # Atan2
    for float_type in float_types:
        function_name = 'atan2_{}'.format(float_type)
        y_name = 'atan2_{}_y'.format(float_type)
        x_name = 'atan2_{}_x'.format(float_type)
        intrinsic_decls += 'extern Variable {};\n'.format(y_name)
        intrinsic_decls += 'extern Variable {};\n'.format(x_name)
        intrinsic_decls += 'extern Function {};\n'.format(function_name)
        intrinsic_defs += 'Variable {};\n'.format(y_name)
        intrinsic_defs += 'Variable {};\n'.format(x_name)
        intrinsic_defs += 'Function {};\n'.format(function_name)
        intrinsic_setup += '    {}.name = "y"_c;\n'.format(y_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(y_name, float_type)
        intrinsic_setup += '    {}.name = "x"_c;\n'.format(x_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(x_name, float_type)
        intrinsic_setup += '    {}.name = "{}"_c;\n'.format(function_name, intrinsic)
        intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, float_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(y_name, float_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(x_name, float_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, float_type)
        
    # Pow
    for float_type in float_types:
        intrinsic = 'pow'
        function_name = '{}_{}'.format(intrinsic, float_type)
        argument_name = '{}_{}_arg'.format(intrinsic, float_type)
        exponent_name = '{}_{}_exp'.format(intrinsic, float_type)
        intrinsic_decls += 'extern Variable {};\n'.format(argument_name)
        intrinsic_decls += 'extern Variable {};\n'.format(exponent_name)
        intrinsic_decls += 'extern Function {};\n'.format(function_name)
        intrinsic_defs += 'Variable {};\n'.format(argument_name)
        intrinsic_defs += 'Variable {};\n'.format(exponent_name)
        intrinsic_defs += 'Function {};\n'.format(function_name)
        intrinsic_setup += '    {}.name = "val"_c;\n'.format(argument_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(argument_name, float_type)
        intrinsic_setup += '    {}.name = "exponent"_c;\n'.format(exponent_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(exponent_name, float_type)
        intrinsic_setup += '    {}.name = "{}"_c;\n'.format(function_name, intrinsic)
        intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, float_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(argument_name, float_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(exponent_name, float_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, float_type)

    # Mad
    for float_type in scalar_types:
        intrinsic = 'mad'
        function_name = '{}_{}'.format(intrinsic, float_type)
        argument_name = '{}_{}_arg'.format(intrinsic, float_type)
        multiplier_name = '{}_{}_mul'.format(intrinsic, float_type)
        addend_name = '{}_{}_add'.format(intrinsic, float_type)
        intrinsic_decls += 'extern Variable {};\n'.format(argument_name)
        intrinsic_decls += 'extern Variable {};\n'.format(multiplier_name)
        intrinsic_decls += 'extern Variable {};\n'.format(addend_name)
        intrinsic_decls += 'extern Function {};\n'.format(function_name)
        intrinsic_defs += 'Variable {};\n'.format(argument_name)
        intrinsic_defs += 'Variable {};\n'.format(multiplier_name)
        intrinsic_defs += 'Variable {};\n'.format(addend_name)
        intrinsic_defs += 'Function {};\n'.format(function_name)
        intrinsic_setup += '    {}.name = "val"_c;\n'.format(argument_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(argument_name, float_type)
        intrinsic_setup += '    {}.name = "multiplier"_c;\n'.format(multiplier_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(multiplier_name, float_type)
        intrinsic_setup += '    {}.name = "addend"_c;\n'.format(addend_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(addend_name, float_type)
        intrinsic_setup += '    {}.name = "{}"_c;\n'.format(function_name, intrinsic)
        intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, float_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(argument_name, float_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(multiplier_name, float_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(addend_name, float_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, float_type)

    # Dot
    for float_type in float_vec_types:
        intrinsic = 'dot'
        function_name = '{}_{}'.format(intrinsic, float_type)
        x_name = '{}_{}_x'.format(intrinsic, float_type)
        y_name = '{}_{}_y'.format(intrinsic, float_type)
        intrinsic_decls += 'extern Variable {};\n'.format(x_name)
        intrinsic_decls += 'extern Variable {};\n'.format(y_name)
        intrinsic_decls += 'extern Function {};\n'.format(function_name)
        intrinsic_defs += 'Variable {};\n'.format(x_name)
        intrinsic_defs += 'Variable {};\n'.format(y_name)
        intrinsic_defs += 'Function {};\n'.format(function_name)
        intrinsic_setup += '    {}.name = "x"_c;\n'.format(x_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(x_name, float_type)
        intrinsic_setup += '    {}.name = "y"_c;\n'.format(y_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(y_name, float_type)
        intrinsic_setup += '    {}.name = "{}"_c;\n'.format(function_name, intrinsic)
        intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, float_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(x_name, float_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(y_name, float_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, float_type.split('x')[0])

    # Reflect
    for float_type in float_vec_types:
        intrinsic = 'reflect'
        function_name = '{}_{}'.format(intrinsic, float_type) 
        incident_name = '{}_{}_incident'.format(intrinsic, float_type)
        normal_name = '{}_{}_normal'.format(intrinsic, float_type)
        intrinsic_decls += 'extern Variable {};\n'.format(incident_name)
        intrinsic_decls += 'extern Variable {};\n'.format(normal_name)
        intrinsic_decls += 'extern Function {};\n'.format(function_name)
        intrinsic_defs += 'Variable {};\n'.format(incident_name)
        intrinsic_defs += 'Variable {};\n'.format(normal_name)
        intrinsic_defs += 'Function {};\n'.format(function_name)
        intrinsic_setup += '    {}.name = "incident"_c;\n'.format(incident_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(incident_name, float_type)
        intrinsic_setup += '    {}.name = "normal"_c;\n'.format(normal_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(normal_name, float_type)
        intrinsic_setup += '    {}.name = "{}"_c;\n'.format(function_name, intrinsic)
        intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, float_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(incident_name, float_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(normal_name, float_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, float_type)

    # Refract
    for float_type in float_vec_types:
        intrinsic = 'refract'
        function_name = '{}_{}'.format(intrinsic, float_type)
        incident_name = '{}_{}_incident'.format(intrinsic, float_type)
        normal_name = '{}_{}_normal'.format(intrinsic, float_type)
        ior_name = '{}_{}_ior'.format(intrinsic, float_type)
        intrinsic_decls += 'extern Variable {};\n'.format(incident_name)
        intrinsic_decls += 'extern Variable {};\n'.format(normal_name)
        intrinsic_decls += 'extern Variable {};\n'.format(ior_name)
        intrinsic_decls += 'extern Function {};\n'.format(function_name)
        intrinsic_defs += 'Variable {};\n'.format(incident_name)
        intrinsic_defs += 'Variable {};\n'.format(normal_name)
        intrinsic_defs += 'Variable {};\n'.format(ior_name)
        intrinsic_defs += 'Function {};\n'.format(function_name)
        intrinsic_setup += '    {}.name = "incident"_c;\n'.format(incident_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(incident_name, float_type)
        intrinsic_setup += '    {}.name = "normal"_c;\n'.format(normal_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(normal_name, float_type)
        intrinsic_setup += '    {}.name = "ior"_c;\n'.format(ior_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(ior_name, float_type)
        intrinsic_setup += '    {}.name = "{}"_c;\n'.format(function_name, intrinsic)
        intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, float_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(incident_name, float_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(normal_name, float_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(ior_name, float_type.split('x')[0])
        intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, float_type)

    # Cross
    cross_product_types = ['Float32x3', 'Float16x3']
    intrinsic = 'cross'
    for float_type in cross_product_types:
        function_name = '{}_{}'.format(intrinsic, float_type)
        v0_name = '{}_{}_v0'.format(intrinsic, float_type)
        v1_name = '{}_{}_v1'.format(intrinsic, float_type)
        intrinsic_decls += 'extern Variable {};\n'.format(v0_name)
        intrinsic_decls += 'extern Variable {};\n'.format(v1_name)
        intrinsic_decls += 'extern Function {};\n'.format(function_name)
        intrinsic_defs += 'Variable {};\n'.format(v0_name)
        intrinsic_defs += 'Variable {};\n'.format(v1_name)
        intrinsic_defs += 'Function {};\n'.format(function_name)
        intrinsic_setup += '    {}.name = "v0"_c;\n'.format(v0_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(v0_name, float_type)
        intrinsic_setup += '    {}.name = "v1"_c;\n'.format(v1_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(v1_name, float_type)
        intrinsic_setup += '    {}.name = "{}"_c;\n'.format(function_name, intrinsic)
        intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, float_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(v0_name, float_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(v1_name, float_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, float_type)

    # Length & Normalize
    ops = ['length', 'normalize']
    for op in ops:
        for float_type in float_vec_types:
            function_name = '{}_{}'.format(op, float_type)
            argument_name = '{}_{}_arg'.format(op, float_type)
            intrinsic_decls += 'extern Variable {};\n'.format(argument_name)
            intrinsic_decls += 'extern Function {};\n'.format(function_name)
            intrinsic_defs += 'Variable {};\n'.format(argument_name)
            intrinsic_defs += 'Function {};\n'.format(function_name)
            intrinsic_setup += '    {}.name = "val"_c;\n'.format(argument_name)
            intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(argument_name, float_type)
            intrinsic_setup += '    {}.name = "{}"_c;\n'.format(function_name, op)
            intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, float_type)
            intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(argument_name, float_type)
            intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, float_type)

    # Distance
    for float_type in float_vec_types:
        intrinsic = 'distance'
        function_name = '{}_{}'.format(intrinsic, float_type)
        p0_name = '{}_{}_p0'.format(intrinsic, float_type)
        p1_name = '{}_{}_p1'.format(intrinsic, float_type)
        intrinsic_decls += 'extern Variable {};\n'.format(p0_name)
        intrinsic_decls += 'extern Variable {};\n'.format(p1_name)
        intrinsic_decls += 'extern Function {};\n'.format(function_name)
        intrinsic_defs += 'Variable {};\n'.format(p0_name)
        intrinsic_defs += 'Variable {};\n'.format(p1_name)
        intrinsic_defs += 'Function {};\n'.format(function_name)
        intrinsic_setup += '    {}.name = "p0"_c;\n'.format(p0_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(p0_name, float_type)
        intrinsic_setup += '    {}.name = "p1"_c;\n'.format(p1_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(p1_name, float_type)
        intrinsic_setup += '    {}.name = "{}"_c;\n'.format(function_name, intrinsic)
        intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, float_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(p0_name, float_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(p1_name, float_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, float_type.split('x')[0])

    # Min & Max
    ops = ['min', 'max']
    for op in ops:
        for float_type in scalar_types:
            function_name = '{}_{}'.format(op, float_type)
            x_name = '{}_{}_x'.format(op, float_type)
            y_name = '{}_{}_y'.format(op, float_type)
            intrinsic_decls += 'extern Variable {};\n'.format(x_name)
            intrinsic_decls += 'extern Variable {};\n'.format(y_name)
            intrinsic_decls += 'extern Function {};\n'.format(function_name)
            intrinsic_defs += 'Variable {};\n'.format(x_name)
            intrinsic_defs += 'Variable {};\n'.format(y_name)
            intrinsic_defs += 'Function {};\n'.format(function_name)
            intrinsic_setup += '    {}.name = "x"_c;\n'.format(x_name)
            intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(x_name, float_type)
            intrinsic_setup += '    {}.name = "y"_c;\n'.format(y_name)
            intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(y_name, float_type)
            intrinsic_setup += '    {}.name = "{}"_c;\n'.format(function_name, op)
            intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, float_type)
            intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(x_name, float_type)
            intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(y_name, float_type)
            intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, float_type)

    # Clamp
    for float_type in scalar_types:
        intrinsic = 'clamp'
        function_name = '{}_{}'.format(intrinsic, float_type)
        value_name = '{}_{}_val'.format(intrinsic, float_type)
        min_name = '{}_{}_min'.format(intrinsic, float_type)
        max_name = '{}_{}_max'.format(intrinsic, float_type)
        intrinsic_decls += 'extern Variable {};\n'.format(value_name)
        intrinsic_decls += 'extern Variable {};\n'.format(min_name)
        intrinsic_decls += 'extern Variable {};\n'.format(max_name)
        intrinsic_decls += 'extern Function {};\n'.format(function_name)
        intrinsic_defs += 'Variable {};\n'.format(value_name)
        intrinsic_defs += 'Variable {};\n'.format(min_name)
        intrinsic_defs += 'Variable {};\n'.format(max_name)
        intrinsic_defs += 'Function {};\n'.format(function_name)
        intrinsic_setup += '    {}.name = "val"_c;\n'.format(value_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(value_name, float_type)
        intrinsic_setup += '    {}.name = "min"_c;\n'.format(min_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(min_name, float_type)
        intrinsic_setup += '    {}.name = "max"_c;\n'.format(max_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(max_name, float_type)
        intrinsic_setup += '    {}.name = "{}"_c;\n'.format(function_name, intrinsic)
        intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, float_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(value_name, float_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(min_name, float_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(max_name, float_type.split('x')[0])
        intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, float_type)
    
    # Lerp
    for float_type in float_vec_types:
        intrinsic = 'lerp'
        function_name = '{}_{}'.format(intrinsic, float_type)
        a_name = '{}_{}_a'.format(intrinsic, float_type)
        b_name = '{}_{}_b'.format(intrinsic, float_type)
        t_name = '{}_{}_t'.format(intrinsic, float_type)
        intrinsic_decls += 'extern Variable {};\n'.format(a_name)
        intrinsic_decls += 'extern Variable {};\n'.format(b_name)
        intrinsic_decls += 'extern Variable {};\n'.format(t_name)
        intrinsic_decls += 'extern Function {};\n'.format(function_name)
        intrinsic_defs += 'Variable {};\n'.format(a_name)
        intrinsic_defs += 'Variable {};\n'.format(b_name)
        intrinsic_defs += 'Variable {};\n'.format(t_name)
        intrinsic_defs += 'Function {};\n'.format(function_name)
        intrinsic_setup += '    {}.name = "a"_c;\n'.format(a_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(a_name, float_type)
        intrinsic_setup += '    {}.name = "b"_c;\n'.format(b_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(b_name, float_type)
        intrinsic_setup += '    {}.name = "t"_c;\n'.format(t_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(t_name, float_type.split('x')[0])
        intrinsic_setup += '    {}.name = "{}"_c;\n'.format(function_name, intrinsic)
        intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, float_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(a_name, float_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(b_name, float_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(t_name, float_type.split('x')[0])
        intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, float_type)

    # Step
    for float_type in float_types:
        intrinsic = 'step'
        function_name = '{}_{}'.format(intrinsic, float_type)
        edge_name = '{}_{}_edge'.format(intrinsic, float_type)
        x_name = '{}_{}_x'.format(intrinsic, float_type)
        intrinsic_decls += 'extern Variable {};\n'.format(edge_name)
        intrinsic_decls += 'extern Variable {};\n'.format(x_name)
        intrinsic_decls += 'extern Function {};\n'.format(function_name)
        intrinsic_defs += 'Variable {};\n'.format(edge_name)
        intrinsic_defs += 'Variable {};\n'.format(x_name)
        intrinsic_defs += 'Function {};\n'.format(function_name)
        intrinsic_setup += '    {}.name = "edge"_c;\n'.format(edge_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(edge_name, float_type)
        intrinsic_setup += '    {}.name = "x"_c;\n'.format(x_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(x_name, float_type)
        intrinsic_setup += '    {}.name = "{}"_c;\n'.format(function_name, intrinsic)
        intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, float_type.split('x')[0])
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(edge_name, float_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(x_name, float_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, float_type)
    
    # Smoothstep
    for float_type in float_types:
        intrinsic = 'smoothstep'
        function_name = '{}_{}'.format(intrinsic, float_type)
        edge0_name = '{}_{}_edge0'.format(intrinsic, float_type)
        edge1_name = '{}_{}_edge1'.format(intrinsic, float_type)
        x_name = '{}_{}_x'.format(intrinsic, float_type)
        intrinsic_decls += 'extern Variable {};\n'.format(edge0_name)
        intrinsic_decls += 'extern Variable {};\n'.format(edge1_name)
        intrinsic_decls += 'extern Variable {};\n'.format(x_name)
        intrinsic_decls += 'extern Function {};\n'.format(function_name)
        intrinsic_defs += 'Variable {};\n'.format(edge0_name)
        intrinsic_defs += 'Variable {};\n'.format(edge1_name)
        intrinsic_defs += 'Variable {};\n'.format(x_name)
        intrinsic_defs += 'Function {};\n'.format(function_name)
        intrinsic_setup += '    {}.name = "edge0"_c;\n'.format(edge0_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(edge0_name, float_type)
        intrinsic_setup += '    {}.name = "edge1"_c;\n'.format(edge1_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(edge1_name, float_type)
        intrinsic_setup += '    {}.name = "x"_c;\n'.format(x_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(x_name, float_type)
        intrinsic_setup += '    {}.name = "{}"_c;\n'.format(function_name, intrinsic)
        intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, float_type.split('x')[0])
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(edge0_name, float_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(edge1_name, float_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(x_name, float_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, float_type)

    # Ceil, Floor, Fract, Saturate, Trunc, Ddx, Ddy, Fwidth
    ops = ['ceil', 'floor', 'fract', 'saturate', 'trunc', 'ddx', 'ddy', 'fwidth']
    for op in ops:
        for float_type in float_types:
            function_name = '{}_{}'.format(op, float_type)
            argument_name = '{}_{}_arg'.format(op, float_type)
            intrinsic_decls += 'extern Variable {};\n'.format(argument_name)
            intrinsic_decls += 'extern Function {};\n'.format(function_name)
            intrinsic_defs += 'Variable {};\n'.format(argument_name)
            intrinsic_defs += 'Function {};\n'.format(function_name)
            intrinsic_setup += '    {}.name = "val"_c;\n'.format(argument_name)
            intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(argument_name, float_type)
            intrinsic_setup += '    {}.name = "{}"_c;\n'.format(function_name, op)
            intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, float_type)
            intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(argument_name, float_type)
            intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, float_type)

    # Sign and Abs
    ops = ['sign', 'abs']
    for op in ops:
        for float_type in signed_types:
            intrinsic = op
            function_name = '{}_{}'.format(intrinsic, float_type)
            argument_name = '{}_{}_arg'.format(intrinsic, float_type)
            intrinsic_decls += 'extern Variable {};\n'.format(argument_name)
            intrinsic_decls += 'extern Function {};\n'.format(function_name)
            intrinsic_defs += 'Variable {};\n'.format(argument_name)
            intrinsic_defs += 'Function {};\n'.format(function_name)
            intrinsic_setup += '    {}.name = "val"_c;\n'.format(argument_name)
            intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(argument_name, float_type)
            intrinsic_setup += '    {}.name = "{}"_c;\n'.format(function_name, intrinsic)
            intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, float_type)
            intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(argument_name, float_type)
            intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, float_type)

    types = ["Float16", "UInt16", "Int16"]
    data_types = ["f16", "u16", "i16"]

    for type1, data_type1 in zip(types, data_types):
        for type2, data_type2 in zip(types, data_types):
            if type1 != type2:
                intrinsic = 'castTo{}'.format(data_type1.title())
                function_name = '{}_{}'.format(intrinsic, type2)
                argument_name = '{}_{}_arg'.format(intrinsic, type2)
                intrinsic_decls += 'extern Variable {};\n'.format(argument_name)
                intrinsic_decls += 'extern Function {};\n'.format(function_name)
                intrinsic_defs += 'Variable {};\n'.format(argument_name)
                intrinsic_defs += 'Function {};\n'.format(function_name)
                intrinsic_setup += '    {}.name = "val"_c;\n'.format(argument_name)
                intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(argument_name, type2)
                intrinsic_setup += '    {}.name = "{}"_c;\n'.format(function_name, intrinsic)
                intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, type1)
                intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(argument_name, type1)
                intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, type1)

    types = ["Float32", "UInt32", "Int32"]
    data_types = ["f32", "u32", "i32"]

    for type1, data_type1 in zip(types, data_types):
        for type2, data_type2 in zip(types, data_types):
            if type1 != type2:
                intrinsic = 'castTo{}'.format(data_type1.title())
                function_name = '{}_{}'.format(intrinsic, type2)
                argument_name = '{}_{}_arg'.format(intrinsic, type2)
                intrinsic_decls += 'extern Variable {};\n'.format(argument_name)
                intrinsic_decls += 'extern Function {};\n'.format(function_name)
                intrinsic_defs += 'Variable {};\n'.format(argument_name)
                intrinsic_defs += 'Function {};\n'.format(function_name)
                intrinsic_setup += '    {}.name = "val"_c;\n'.format(argument_name)
                intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(argument_name, type2)
                intrinsic_setup += '    {}.name = "{}"_c;\n'.format(function_name, intrinsic)
                intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, type1)
                intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(argument_name, type1)
                intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, type1)

    # Any and all
    ops = ['any', 'all']
    for op in ops:
        for float_type in bool_types:
            intrinsic = op
            function_name = '{}_{}'.format(intrinsic, float_type)
            argument_name = '{}_{}_arg'.format(intrinsic, float_type)
            intrinsic_decls += 'extern Variable {};\n'.format(argument_name)
            intrinsic_decls += 'extern Function {};\n'.format(function_name)
            intrinsic_defs += 'Variable {};\n'.format(argument_name)
            intrinsic_defs += 'Function {};\n'.format(function_name)
            intrinsic_setup += '    {}.name = "val"_c;\n'.format(argument_name)
            intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(argument_name, float_type)
            intrinsic_setup += '    {}.name = "{}"_c;\n'.format(function_name, intrinsic)
            intrinsic_setup += '    {}.returnType = Type::FullType{{ Bool8Type.name }};\n'.format(function_name)
            intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(argument_name, float_type)
            intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &Bool8Type;\n\n'.format(function_name)

    ops = ['transpose', 'inverse']
    matrix_types = []
    for i in range(2, 5):
        for j in range(2, 5):
            matrix_types.append('Float32x{}x{}'.format(i, j))
            matrix_types.append('Float16x{}x{}'.format(i, j))
            
    for op in ops:
        for float_type in matrix_types:
            intrinsic = op
            function_name = '{}_{}'.format(intrinsic, float_type)
            argument_name = '{}_{}_arg'.format(intrinsic, float_type)
            intrinsic_decls += 'extern Variable {};\n'.format(argument_name)
            intrinsic_decls += 'extern Function {};\n'.format(function_name)
            intrinsic_defs += 'Variable {};\n'.format(argument_name)
            intrinsic_defs += 'Function {};\n'.format(function_name)
            intrinsic_setup += '    {}.name = "val"_c;\n'.format(argument_name)
            intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(argument_name, float_type)
            intrinsic_setup += '    {}.name = "{}"_c;\n'.format(function_name, intrinsic)
            intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, float_type)
            intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(argument_name, float_type)
            intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, float_type)

    # Builtin value getters
    vertex_value_builtins = ['OutputLayer', 'OutputViewport', 'Index', 'InstanceIndex', 'BaseIndex', 'BaseInstanceIndex', 'DrawIndex']
    for builtin in vertex_value_builtins:
        intrinsic = builtin
        function_name = 'VertexGet{}'.format(intrinsic)
        intrinsic_decls += 'extern Function {};\n'.format(function_name)
        intrinsic_defs += 'Function {};\n'.format(function_name)
        intrinsic_setup += '    {}.name = "vertexGet{}"_c;\n'.format(function_name, intrinsic)
        intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, 'UInt32')
        intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, 'UInt32')

    unsigned_types = ['UInt16', 'UInt32']
    vertex_value_builtins = ['OutputLayer', 'OutputViewport']
    for builtin in vertex_value_builtins:
        for type in unsigned_types:
            intrinsic = builtin
            function_name = 'VertexSet{}_{}'.format(intrinsic, type)
            argument_name = 'VertexSet{}_{}_arg'.format(intrinsic, type)
            intrinsic_decls += 'extern Variable {};\n'.format(argument_name)
            intrinsic_decls += 'extern Function {};\n'.format(function_name)
            intrinsic_defs += 'Variable {};\n'.format(argument_name)
            intrinsic_defs += 'Function {};\n'.format(function_name)
            intrinsic_setup += '    {}.name = "val"_c;\n'.format(argument_name)
            intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(argument_name, type)
            intrinsic_setup += '    {}.name = "vertexSet{}"_c;\n'.format(function_name, intrinsic)
            intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, 'Void')
            intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n\n'.format(argument_name, type)
            intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, 'Void')

    # Export vertex coordinates
    four_component_float_vec_types = ['Float32x4', 'Float16x4']
    for type in four_component_float_vec_types:
        intrinsic = 'VertexExportCoordinates'
        function_name = '{}_{}'.format(intrinsic, type)
        argument_name = '{}_{}_arg'.format(intrinsic, type)
        intrinsic_decls += 'extern Variable {};\n'.format(argument_name)
        intrinsic_decls += 'extern Function {};\n'.format(function_name)
        intrinsic_defs += 'Variable {};\n'.format(argument_name)
        intrinsic_defs += 'Function {};\n'.format(function_name)
        intrinsic_setup += '    {}.name = "coordinate"_c;\n'.format(argument_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(argument_name, type)
        intrinsic_setup += '    {}.name = "vertexExportCoordinates"_c;\n'.format(function_name)
        intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, 'Void')
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n\n'.format(argument_name, type)
        intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, 'Void')

    geometry_export_builtins = ['Vertex', 'Primitive']
    for builtin in geometry_export_builtins:
        intrinsic = builtin
        function_name = 'GeometryExport{}'.format(intrinsic)
        intrinsic_decls += 'extern Function {};\n'.format(function_name)
        intrinsic_defs += 'Function {};\n'.format(function_name)
        intrinsic_setup += '    {}.name = "geometryExport{}"_c;\n'.format(function_name, intrinsic)
        intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, 'Void')
        intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, 'Void')

    for type in four_component_float_vec_types:
        intrinsic = 'Coordinates'
        function_name = 'PixelGet{}_{}'.format(intrinsic, type)
        intrinsic_decls += 'extern Function {};\n'.format(function_name)
        intrinsic_defs += 'Function {};\n'.format(function_name)
        intrinsic_setup += '    {}.name = "pixelGet{}"_c;\n'.format(function_name, intrinsic)
        intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, type)
        intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, type)
    
    intrinsic = 'Depth'
    function_name = 'PixelGet{}'.format(intrinsic)
    intrinsic_decls += 'extern Function {};\n'.format(function_name)
    intrinsic_defs += 'Function {};\n'.format(function_name)
    intrinsic_setup += '    {}.name = "pixelGet{}"_c;\n'.format(function_name, intrinsic)
    intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, 'Float32')
    intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, 'Float32')

    intrinsic = 'ExportColor'
    for type in scalar_types:
        for idx in index_types:
            function_name = 'Pixel{}_{}_{}'.format(intrinsic, type, idx)
            color_argument_name = '{}_color'.format(function_name)
            index_argument_name = '{}_index'.format(function_name)
            intrinsic_decls += 'extern Variable {};\n'.format(color_argument_name)
            intrinsic_decls += 'extern Variable {};\n'.format(index_argument_name)
            intrinsic_decls += 'extern Function {};\n'.format(function_name)
            intrinsic_defs += 'Variable {};\n'.format(color_argument_name)
            intrinsic_defs += 'Variable {};\n'.format(index_argument_name)
            intrinsic_defs += 'Function {};\n'.format(function_name)
            intrinsic_setup += '    {}.name = "color"_c;\n'.format(color_argument_name)
            intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(color_argument_name, type)
            intrinsic_setup += '    {}.name = "index"_c;\n'.format(index_argument_name)
            intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(index_argument_name, idx)
            intrinsic_setup += '    {}.name = "pixel{}"_c;\n'.format(function_name, intrinsic)
            intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, 'Void')
            intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(color_argument_name, type)
            intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(index_argument_name, idx)
            intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, 'Void')

    # TODO: Hmm maybe these should all be UInt16?
    compute_builtin_getters = ['LocalInvocationIndices', 'GlobalInvocationIndices', 'WorkgroupIndices', 'WorkGroupDimensions']
    for intrinsic in compute_builtin_getters:
        function_name = 'ComputeGet{}'.format(intrinsic)
        intrinsic_decls += 'extern Function {};\n'.format(function_name)
        intrinsic_defs += 'Function {};\n'.format(function_name)
        intrinsic_setup += '    {}.name = "computeGet{}"_c;\n'.format(function_name, intrinsic)
        intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, 'UInt32x3')
        intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, 'UInt32x3')

    intrinsic = 'IndexInWorkgroup'
    function_name = 'ComputeGet{}'.format(intrinsic)
    intrinsic_decls += 'extern Function {};\n'.format(function_name)
    intrinsic_defs += 'Function {};\n'.format(function_name)
    intrinsic_setup += '    {}.name = "computeGet{}"_c;\n'.format(function_name, intrinsic)
    intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, 'UInt32')
    intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, 'UInt32')

    subgroup_builtin_getters = ['Id', 'Size', 'Num']
    for intrinsic in subgroup_builtin_getters:
        function_name = 'SubgroupGet{}'.format(intrinsic)
        intrinsic_decls += 'extern Function {};\n'.format(function_name)
        intrinsic_defs += 'Function {};\n'.format(function_name)
        intrinsic_setup += '    {}.name = "subgroupGet{}"_c;\n'.format(function_name, intrinsic)
        intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, 'UInt32')
        intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, 'UInt32')

    subgroup_builtin_masks = ['InvocationMask', 'InvocationAndLowerMask', 'LowerMask', 'InvocationAndGreaterMask', 'GreaterMask']
    for intrinsic in subgroup_builtin_masks:
        function_name = 'SubgroupGet{}'.format(intrinsic)
        intrinsic_decls += 'extern Function {};\n'.format(function_name)
        intrinsic_defs += 'Function {};\n'.format(function_name)
        intrinsic_setup += '    {}.name = "subgroupGet{}"_c;\n'.format(function_name, intrinsic)
        intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, 'UInt32x4')
        intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, 'UInt32x4')

    
    intrinsic = 'FirstInvocation'
    function_name = 'Subgroup{}'.format(intrinsic)
    intrinsic_decls += 'extern Function {};\n'.format(function_name)
    intrinsic_defs += 'Function {};\n'.format(function_name)
    intrinsic_setup += '    {}.name = "subgroup{}"_c;\n'.format(function_name, intrinsic)
    intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, 'UInt32')
    intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, 'UInt32')
        
    intrinsic = 'Read'
    function_name = 'Subgroup{}'.format(intrinsic)
    value_argument_name = '{}_{}_value'.format(intrinsic, 'UInt32')
    intrinsic_decls += 'extern Variable {};\n'.format(value_argument_name)
    intrinsic_decls += 'extern Function {};\n'.format(function_name)
    intrinsic_defs += 'Variable {};\n'.format(value_argument_name)
    intrinsic_defs += 'Function {};\n'.format(function_name)
    intrinsic_setup += '    {}.name = "value"_c;\n'.format(value_argument_name)
    intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(value_argument_name, 'UInt32')
    intrinsic_setup += '    {}.name = "subgroup{}"_c;\n'.format(function_name, intrinsic)
    intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, 'UInt32')
    intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, 'UInt32')

    subgroup_ballot_ops = ['Ballot', 'InverseBallot']
    subgroup_ballot_ops_doc = ['Constructs a subgroup mask within the workgroup where predicate is true', 'Constructs a subgroup mask within the workgroup where predicate is false']
    for intrinsic, doc in zip(subgroup_ballot_ops, subgroup_ballot_ops_doc):
        function_name = 'Subgroup{}'.format(intrinsic)
        predicate_argument_name = 'Subgroup{}_{}_predicate'.format(intrinsic, 'Bool8')
        intrinsic_decls += 'extern Variable {};\n'.format(predicate_argument_name)
        intrinsic_decls += 'extern Function {};\n'.format(function_name)
        intrinsic_defs += 'Variable {};\n'.format(predicate_argument_name)
        intrinsic_defs += 'Function {};\n'.format(function_name)
        intrinsic_setup += '    {}.name = "value"_c;\n'.format(predicate_argument_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(predicate_argument_name, 'Bool8')
        intrinsic_setup += '    {}.name = "subgroup{}"_c;\n'.format(function_name, intrinsic)
        intrinsic_setup += '    {}.documentation = "{}"_c;\n'.format(function_name, doc)
        intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, 'UInt32x4')
        intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, 'UInt32x4')

    intrinsic = 'BitCount'
    function_name = 'SubgroupBallot{}'.format(intrinsic)
    mask_name = 'SubgroupBallot{}_{}_mask'.format(intrinsic, 'UInt32x4')
    intrinsic_decls += 'extern Variable {};\n'.format(mask_name)
    intrinsic_decls += 'extern Function {};\n'.format(function_name)
    intrinsic_defs += 'Variable {};\n'.format(mask_name)
    intrinsic_defs += 'Function {};\n'.format(function_name)
    intrinsic_setup += '    {}.name = "value"_c;\n'.format(mask_name)
    intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(mask_name, 'UInt32x4')
    intrinsic_setup += '    {}.name = "subgroupBallot{}"_c;\n'.format(function_name, intrinsic)
    intrinsic_setup += '    {}.documentation = "{}"_c;\n'.format(function_name, 'Returns the number of bits in the mask set to 1.')
    intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, 'UInt32')
    intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, 'UInt32')

    intrinsic = 'FirstOne'
    function_name = 'SubgroupBallot{}'.format(intrinsic)
    mask_name = 'SubgroupBallot{}_{}_mask'.format(intrinsic, 'UInt32x4')
    intrinsic_decls += 'extern Variable {};\n'.format(mask_name)
    intrinsic_decls += 'extern Function {};\n'.format(function_name)
    intrinsic_defs += 'Variable {};\n'.format(mask_name)
    intrinsic_defs += 'Function {};\n'.format(function_name)
    intrinsic_setup += '    {}.name = "value"_c;\n'.format(mask_name)
    intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(mask_name, 'UInt32x4')
    intrinsic_setup += '    {}.name = "subgroupBallot{}"_c;\n'.format(function_name, intrinsic)
    intrinsic_setup += '    {}.documentation = "{}"_c;\n'.format(function_name, 'Returns the first one (ctz) in a subgroup thread mask.')
    intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, 'UInt32')
    intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, 'UInt32')

    intrinsic = 'LastOne'
    function_name = 'SubgroupBallot{}'.format(intrinsic)
    mask_name = 'SubgroupBallot{}_{}_mask'.format(intrinsic, 'UInt32x4')
    intrinsic_decls += 'extern Variable {};\n'.format(mask_name)
    intrinsic_decls += 'extern Function {};\n'.format(function_name)
    intrinsic_defs += 'Variable {};\n'.format(mask_name)
    intrinsic_defs += 'Function {};\n'.format(function_name)
    intrinsic_setup += '    {}.name = "value"_c;\n'.format(mask_name)
    intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(mask_name, 'UInt32x4')
    intrinsic_setup += '    {}.name = "subgroupBallot{}"_c;\n'.format(function_name, intrinsic)
    intrinsic_setup += '    {}.documentation = "{}"_c;\n'.format(function_name, 'Returns the first one (clz) in a subgroup thread mask.')
    intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, 'UInt32')
    intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, 'UInt32')

    intrinsic = 'Bit'
    function_name = 'SubgroupBallot{}'.format(intrinsic)
    mask_name = 'SubgroupBallot{}_{}_mask'.format(intrinsic, 'UInt32x4')
    index_name = 'SubgroupBallot{}_{}_index'.format(intrinsic, 'UInt32')
    intrinsic_decls += 'extern Variable {};\n'.format(mask_name)
    intrinsic_decls += 'extern Variable {};\n'.format(index_name)
    intrinsic_decls += 'extern Function {};\n'.format(function_name)
    intrinsic_defs += 'Variable {};\n'.format(mask_name)
    intrinsic_defs += 'Variable {};\n'.format(index_name)
    intrinsic_defs += 'Function {};\n'.format(function_name)
    intrinsic_setup += '    {}.name = "value"_c;\n'.format(mask_name)
    intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(mask_name, 'UInt32x4')
    intrinsic_setup += '    {}.name = "value"_c;\n'.format(index_name)
    intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(index_name, 'UInt32')
    intrinsic_setup += '    {}.name = "subgroupBallot{}"_c;\n'.format(function_name, intrinsic)
    intrinsic_setup += '    {}.documentation = "{}"_c;\n'.format(function_name, 'Returns true if bit at index in mask is 1.')
    intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, 'Bool8')
    intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, 'Bool8')

    subgroup_swap_ops = ['Diagonal', 'Vertical', 'Horizontal']
    for op in subgroup_swap_ops:
        for type in scalar_types:
            intrinsic = op
            function_name = 'SubgroupSwap{}_{}'.format(intrinsic, type)
            value_argument_name = 'SubgroupSwap{}_{}_color'.format(intrinsic, type)
            intrinsic_decls += 'extern Variable {};\n'.format(value_argument_name)
            intrinsic_decls += 'extern Function {};\n'.format(function_name)
            intrinsic_defs += 'Variable {};\n'.format(value_argument_name)
            intrinsic_defs += 'Function {};\n'.format(function_name)
            intrinsic_setup += '    {}.name = "color"_c;\n'.format(value_argument_name)
            intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(value_argument_name, type)
            intrinsic_setup += '    {}.name = "subgroupSwap{}"_c;\n'.format(function_name, intrinsic)
            intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, 'Void')
            intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(value_argument_name, type)
            intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, 'Void')

    # Atomics
    atomic_types = ['UInt32', 'Int32', 'UInt16', 'Int16']
    atomic_functions_no_value = ['Load', 'Increment', 'Decrement']

    for atomic_type in atomic_types:
        for atomic_function in atomic_functions_no_value:
            function_name = 'Atomic{}_{}'.format(atomic_function, atomic_type)
            ptr_argument_name = 'Atomic{}_{}_ptr'.format(atomic_function, atomic_type)
            semantics_argument_name = 'Atomic{}_{}_semantics'.format(atomic_function, atomic_type)
            intrinsic_decls += 'extern Variable {};\n'.format(ptr_argument_name)
            intrinsic_decls += 'extern Variable {};\n'.format(semantics_argument_name)
            intrinsic_decls += 'extern Function {};\n'.format(function_name)
            intrinsic_defs += 'Variable {};\n'.format(ptr_argument_name)
            intrinsic_defs += 'Variable {};\n'.format(semantics_argument_name)
            intrinsic_defs += 'Function {};\n'.format(function_name)
            intrinsic_setup += '    {}.name = "ptr"_c;\n'.format(ptr_argument_name)
            intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(ptr_argument_name, atomic_type)
            intrinsic_setup += '    {}.type.AddModifier(Type::FullType::Modifier::Pointer);\n'.format(ptr_argument_name, atomic_type)
            intrinsic_setup += '    {}.name = "semantics"_c;\n'.format(semantics_argument_name)
            intrinsic_setup += '    {}.type = Type::FullType{{ MemorySemanticsType.name }};\n'.format(semantics_argument_name)
            intrinsic_setup += '    {}.type.literal = true;\n'.format(semantics_argument_name)
            intrinsic_setup += '    {}.name = "atomic{}"_c;\n'.format(function_name, atomic_function)
            intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, atomic_type)
            intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(ptr_argument_name, atomic_type)
            intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(semantics_argument_name, 'MemorySemantics')
            intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, atomic_type)

    atomic_functions_with_argument = ['Exchange', 'Add', 'Subtract', 'And', 'Or', 'Xor']
    for atomic_type in atomic_types:
        for atomic_function in atomic_functions_with_argument:
            function_name = 'Atomic{}_{}'.format(atomic_function, atomic_type)
            ptr_argument_name = 'Atomic{}_{}_ptr'.format(atomic_function, atomic_type)
            value_argument_name = 'Atomic{}_{}_value'.format(atomic_function, atomic_type)
            semantics_argument_name = 'Atomic{}_{}_semantics'.format(atomic_function, atomic_type)
            intrinsic_decls += 'extern Variable {};\n'.format(ptr_argument_name)
            intrinsic_decls += 'extern Variable {};\n'.format(value_argument_name)
            intrinsic_decls += 'extern Variable {};\n'.format(semantics_argument_name)
            intrinsic_decls += 'extern Function {};\n'.format(function_name)
            intrinsic_defs += 'Variable {};\n'.format(ptr_argument_name)
            intrinsic_defs += 'Variable {};\n'.format(value_argument_name)
            intrinsic_defs += 'Variable {};\n'.format(semantics_argument_name)
            intrinsic_defs += 'Function {};\n'.format(function_name)
            intrinsic_setup += '    {}.name = "ptr"_c;\n'.format(ptr_argument_name)
            intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(ptr_argument_name, atomic_type)
            intrinsic_setup += '    {}.type.AddModifier(Type::FullType::Modifier::Pointer);\n'.format(ptr_argument_name, atomic_type)
            intrinsic_setup += '    {}.name = "value"_c;\n'.format(value_argument_name)
            intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(value_argument_name, atomic_type)
            intrinsic_setup += '    {}.name = "semantics"_c;\n'.format(semantics_argument_name)
            intrinsic_setup += '    {}.type = Type::FullType{{ MemorySemanticsType.name }};\n'.format(semantics_argument_name)
            intrinsic_setup += '    {}.type.literal = true;\n'.format(semantics_argument_name)
            intrinsic_setup += '    {}.name = "atomic{}"_c;\n'.format(function_name, atomic_function)
            intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, atomic_type)
            intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(ptr_argument_name, atomic_type)
            intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(value_argument_name, atomic_type)
            intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(semantics_argument_name, 'MemorySemantics')
            intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, atomic_type)

    for atomic_type in atomic_types:
        atomic_function = 'CompareExchange'
        function_name = 'Atomic{}_{}'.format(atomic_function, atomic_type)
        ptr_argument_name = 'Atomic{}_{}_ptr'.format(atomic_function, atomic_type)
        value_argument_name = 'Atomic{}_{}_value'.format(atomic_function, atomic_type)
        compare_argument_name = 'Atomic{}_{}_compare'.format(atomic_function, atomic_type)
        semantics_argument_name = 'Atomic{}_{}_semantics'.format(atomic_function, atomic_type)
        intrinsic_decls += 'extern Variable {};\n'.format(ptr_argument_name)
        intrinsic_decls += 'extern Variable {};\n'.format(value_argument_name)
        intrinsic_decls += 'extern Variable {};\n'.format(compare_argument_name)
        intrinsic_decls += 'extern Variable {};\n'.format(semantics_argument_name)
        intrinsic_decls += 'extern Function {};\n'.format(function_name)
        intrinsic_defs += 'Variable {};\n'.format(ptr_argument_name)
        intrinsic_defs += 'Variable {};\n'.format(value_argument_name)
        intrinsic_defs += 'Variable {};\n'.format(compare_argument_name)
        intrinsic_defs += 'Variable {};\n'.format(semantics_argument_name)
        intrinsic_defs += 'Function {};\n'.format(function_name)
        intrinsic_setup += '    {}.name = "ptr"_c;\n'.format(ptr_argument_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(ptr_argument_name, atomic_type)
        intrinsic_setup += '    {}.type.AddModifier(Type::FullType::Modifier::Pointer);\n'.format(ptr_argument_name, atomic_type)
        intrinsic_setup += '    {}.name = "value"_c;\n'.format(value_argument_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(value_argument_name, atomic_type)
        intrinsic_setup += '    {}.name = "compare"_c;\n'.format(compare_argument_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(compare_argument_name, atomic_type)
        intrinsic_setup += '    {}.name = "semantics"_c;\n'.format(semantics_argument_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ MemorySemanticsType.name }};\n'.format(semantics_argument_name)
        intrinsic_setup += '    {}.type.literal = true;\n'.format(semantics_argument_name)
        intrinsic_setup += '    {}.name = "atomic{}"_c;\n'.format(function_name, atomic_function)
        intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, atomic_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(ptr_argument_name, atomic_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(value_argument_name, atomic_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(compare_argument_name, atomic_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(semantics_argument_name, 'MemorySemantics')
        intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, atomic_type)

    intrinsic = 'Insert'
    for type in unsigned_types:
        function_name = 'Bit{}'.format(intrinsic)
        base_argument_name = 'Bit{}_{}_base'.format(intrinsic, type)
        value_argument_name = 'Bit{}_{}_value'.format(intrinsic, type)
        offset_argument_name = 'Bit{}_{}_offset'.format(intrinsic, type)
        count_argument_name = 'Bit{}_{}_count'.format(intrinsic, type)
        intrinsic_decls += 'extern Variable {};\n'.format(base_argument_name)
        intrinsic_decls += 'extern Variable {};\n'.format(value_argument_name)
        intrinsic_decls += 'extern Variable {};\n'.format(offset_argument_name)
        intrinsic_decls += 'extern Variable {};\n'.format(count_argument_name)
        intrinsic_decls += 'extern Function {};\n'.format(function_name)
        intrinsic_defs += 'Variable {};\n'.format(base_argument_name)
        intrinsic_defs += 'Variable {};\n'.format(value_argument_name)
        intrinsic_defs += 'Variable {};\n'.format(offset_argument_name)
        intrinsic_defs += 'Variable {};\n'.format(count_argument_name)
        intrinsic_defs += 'Function {};\n'.format(function_name)
        intrinsic_setup += '    {}.name = "base"_c;\n'.format(base_argument_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(base_argument_name, type)
        intrinsic_setup += '    {}.name = "value"_c ;\n'.format(value_argument_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(value_argument_name, type)
        intrinsic_setup += '    {}.name = "offset"_c;\n'.format(offset_argument_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(offset_argument_name, type)
        intrinsic_setup += '    {}.name = "count"_c;\n'.format(count_argument_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(count_argument_name, type)
        intrinsic_setup += '    {}.name = "bit{}"_c;\n'.format(function_name, intrinsic)
        intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, type)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(base_argument_name, type)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(value_argument_name, type)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(offset_argument_name, type)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(count_argument_name, type)
        intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, type)

    intrinsic = 'Extract'
    for type in integer_types:
        function_name = 'Bit{}'.format(intrinsic)
        base_argument_name = 'Bit{}_{}_base'.format(intrinsic, type)
        offset_argument_name = 'Bit{}_{}_offset'.format(intrinsic, type)
        count_argument_name = 'Bit{}_{}_count'.format(intrinsic, type)
        intrinsic_decls += 'extern Variable {};\n'.format(base_argument_name)
        intrinsic_decls += 'extern Variable {};\n'.format(offset_argument_name)
        intrinsic_decls += 'extern Variable {};\n'.format(count_argument_name)
        intrinsic_decls += 'extern Function {};\n'.format(function_name)
        intrinsic_defs += 'Variable {};\n'.format(base_argument_name)
        intrinsic_defs += 'Variable {};\n'.format(offset_argument_name)
        intrinsic_defs += 'Variable {};\n'.format(count_argument_name)
        intrinsic_defs += 'Function {};\n'.format(function_name)
        intrinsic_setup += '    {}.name = "base"_c;\n'.format(base_argument_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(base_argument_name, type)
        intrinsic_setup += '    {}.name = "offset"_c ;\n'.format(offset_argument_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(offset_argument_name, type)
        intrinsic_setup += '    {}.name = "count"_c;\n'.format(count_argument_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(count_argument_name, type)
        intrinsic_setup += '    {}.name = "bit{}"_c;\n'.format(function_name, intrinsic)
        intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, type)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(base_argument_name, type)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(offset_argument_name, type)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(count_argument_name, type)
        intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, type)

    intrinsics = ['Reverse', 'Count']
    for intrinsic in intrinsics:
        for type in integer_types:
            function_name = 'Bit{}'.format(intrinsic)
            base_argument_name = 'Bit{}_{}_base'.format(intrinsic, type)
            intrinsic_decls += 'extern Variable {};\n'.format(base_argument_name)
            intrinsic_decls += 'extern Function {};\n'.format(function_name)
            intrinsic_defs += 'Variable {};\n'.format(base_argument_name)
            intrinsic_defs += 'Function {};\n'.format(function_name)
            intrinsic_setup += '    {}.name = "base"_c;\n'.format(base_argument_name)
            intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(base_argument_name, type)
            intrinsic_setup += '    {}.name = "bit{}"_c;\n'.format(function_name, intrinsic)
            intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, type)
            intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(base_argument_name, type)
            intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, type)

    barrier_intrinsics = ['ExecutionBarrier', 'ExecutionBarrierSubgroup', 'ExecutionBarrierWorkgroup', 'MemoryBarrier', 'MemoryBarrierBuffer', 'MemoryBarrierTexture', 'MemoryBarrierAtomic', 'MemoryBarrierSubgroup', 'MemoryBarrierWorkgroup']
    for intrinsic in barrier_intrinsics:
        function_name = '{}'.format(intrinsic)
        intrinsic_decls += 'extern Function {};\n'.format(function_name)
        intrinsic_defs += 'Function {};\n'.format(function_name)
        intrinsic_setup += '    {}.name = "{}"_c;\n'.format(function_name, intrinsic[0].lower() + intrinsic[1:])
        intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, 'Void')
        intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, 'Void')

    texture_types_no_ms = ['Texture1D', 'Texture2D', 'Texture3D', 'TextureCube', 'Texture1DArray', 'Texture2DArray', 'TextureCubeArray']
    texture_types_ms = ['Texture2DMS', 'Texture2DMSArray']

    texture_types = texture_types_no_ms + texture_types_ms

    type = 'UInt32'
    texture_size_types = {
        'Texture1D': f"{type}",
        'Texture2D': f"{type}x2",
        'Texture3D': f"{type}x3",
        'TextureCube': f"{type}x3",
        'Texture1DArray': f"{type}x2",
        'Texture2DArray': f"{type}x3",
        'TextureCubeArray': f"{type}x4",
        'Texture2DMS': f"{type}x2",
        'Texture2DMSArray': f"{type}x3"
    }

    type = 'Int32'
    texture_denormalized_index_types = {
        'Texture1D': f"{type}",
        'Texture2D': f"{type}x2",
        'Texture3D': f"{type}x3",
        'TextureCube': f"{type}x3",
        'Texture1DArray': f"{type}x2",
        'Texture2DArray': f"{type}x3",
        'TextureCubeArray': f"{type}x4",
        'Texture2DMS': f"{type}x2",
        'Texture2DMSArray': f"{type}x3"
    }

    type = 'Float32'
    texture_float_index_types = {
        'Texture1D': f"{type}",
        'Texture2D': f"{type}x2",
        'Texture3D': f"{type}x3",
        'TextureCube': f"{type}x3",
        'Texture1DArray': f"{type}x2",
        'Texture2DArray': f"{type}x3",
        'TextureCubeArray': f"{type}x4",
        'Texture2DMS': f"{type}x2",
        'Texture2DMSArray': f"{type}x3"
    }

    intrinsic = 'GetSize'
    for type in texture_types_no_ms:
        return_type = texture_size_types[type]
        function_name = 'Texture{}_{}'.format(intrinsic, type)
        texture_argument_name = 'Texture{}_{}_texture'.format(intrinsic, type)
        intrinsic_decls += 'extern Variable {};\n'.format(texture_argument_name)
        intrinsic_decls += 'extern Function {};\n'.format(function_name)
        intrinsic_defs += 'Variable {};\n'.format(texture_argument_name)
        intrinsic_defs += 'Function {};\n'.format(function_name)
        intrinsic_setup += '    {}.name = "texture"_c;\n'.format(texture_argument_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(texture_argument_name, type)
        intrinsic_setup += '    {}.type.AddModifier(Type::FullType::Modifier::Pointer);\n'.format(texture_argument_name, type)
        intrinsic_setup += '    {}.name = "texture{}"_c;\n'.format(function_name, intrinsic)
        intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, return_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(texture_argument_name, type)
        intrinsic_setup += '    Symbol::Resolved(&{})->storage = Storage::Uniform;\n'.format(texture_argument_name)
        intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, return_type)

    intrinsic = 'GetSizeMip'
    for type in texture_types_no_ms:
        return_type = texture_size_types[type]
        texture_argument_name = 'Texture{}_{}_texture'.format(intrinsic, type)
        mip_argument_name = 'Texture{}_{}_mip'.format(intrinsic, 'UInt32')
        function_name = 'Texture{}_{}'.format(intrinsic, type)
        intrinsic_decls += 'extern Variable {};\n'.format(texture_argument_name)
        intrinsic_decls += 'extern Variable {};\n'.format(mip_argument_name)
        intrinsic_decls += 'extern Function {};\n'.format(function_name)
        intrinsic_defs += 'Variable {};\n'.format(texture_argument_name)
        intrinsic_defs += 'Variable {};\n'.format(mip_argument_name)
        intrinsic_defs += 'Function {};\n'.format(function_name)
        intrinsic_setup += '    {}.name = "texture"_c;\n'.format(texture_argument_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(texture_argument_name, type)
        intrinsic_setup += '    {}.type.AddModifier(Type::FullType::Modifier::Pointer);\n'.format(texture_argument_name, type)
        intrinsic_setup += '    {}.name = "mip"_c;\n'.format(mip_argument_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(mip_argument_name, 'UInt32')
        intrinsic_setup += '    {}.name = "texture{}"_c;\n'.format(function_name, intrinsic)
        intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, return_type)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(texture_argument_name, type)
        intrinsic_setup += '    Symbol::Resolved(&{})->storage = Storage::Uniform;\n'.format(texture_argument_name)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(mip_argument_name, 'UInt32')
        intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, return_type)

    intrinsic = 'GetMips'
    for type in texture_types_no_ms:
        function_name = 'Texture{}_{}'.format(intrinsic, type)
        texture_argument_name = 'Texture{}_{}_texture'.format(intrinsic, type)
        intrinsic_decls += 'extern Variable {};\n'.format(texture_argument_name)
        intrinsic_decls += 'extern Function {};\n'.format(function_name)
        intrinsic_defs += 'Variable {};\n'.format(texture_argument_name)
        intrinsic_defs += 'Function {};\n'.format(function_name)
        intrinsic_setup += '    {}.name = "texture"_c;\n'.format(texture_argument_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(texture_argument_name, type)
        intrinsic_setup += '    {}.type.AddModifier(Type::FullType::Modifier::Pointer);\n'.format(texture_argument_name, type)
        intrinsic_setup += '    {}.name = "texture{}"_c;\n'.format(function_name, intrinsic)
        intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, 'UInt32')
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(texture_argument_name, type)
        intrinsic_setup += '    Symbol::Resolved(&{})->storage = Storage::Uniform;\n'.format(texture_argument_name)
        intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, 'UInt32')

    intrinsic = 'GetSamples'
    for type in texture_types_ms:
        function_name = 'Texture{}_{}'.format(intrinsic, type)
        texture_argument_name = 'Texture{}_{}_texture'.format(intrinsic, type)
        intrinsic_decls += 'extern Variable {};\n'.format(texture_argument_name)
        intrinsic_decls += 'extern Function {};\n'.format(function_name)
        intrinsic_defs += 'Variable {};\n'.format(texture_argument_name)
        intrinsic_defs += 'Function {};\n'.format(function_name)
        intrinsic_setup += '    {}.name = "texture"_c;\n'.format(texture_argument_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(texture_argument_name, type)
        intrinsic_setup += '    {}.type.AddModifier(Type::FullType::Modifier::Pointer);\n'.format(texture_argument_name, type)
        intrinsic_setup += '    {}.name = "texture{}"_c;\n'.format(function_name, intrinsic)
        intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, 'UInt32')
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(texture_argument_name, type)
        intrinsic_setup += '    Symbol::Resolved(&{})->storage = Storage::Uniform;\n'.format(texture_argument_name)
        intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(function_name, 'UInt32')

    # Helper function to generate a version of the texture sampling method both for combined texture-samplers and for textures with samplers provided separately.
    def generate_texture_intrinsic_base(intrinsic):
        texture_argument_name = '{}_texture'.format(intrinsic)
        sampler_argument_name = '{}_sampler'.format(intrinsic)
        decls = ''
        decls += 'extern Variable {};\n'.format(texture_argument_name)
        decls += 'extern Variable {};\n'.format(sampler_argument_name)

        defs = ''
        defs += 'Variable {};\n'.format(texture_argument_name)
        defs += 'Variable {};\n'.format(sampler_argument_name)

        setup = ''
        setup += '    {}.name = "texture"_c;\n'.format(texture_argument_name)
        setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(texture_argument_name, type)
        setup += '    {}.type.AddModifier(Type::FullType::Modifier::Pointer);\n'.format(texture_argument_name, type)
        setup += '    {}.name = "sampler"_c;\n'.format(sampler_argument_name)
        setup += '    {}.type = Type::FullType{{ SamplerType.name }};\n'.format(sampler_argument_name)
        setup += '    {}.type.AddModifier(Type::FullType::Modifier::Pointer);\n'.format(sampler_argument_name)
        setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(texture_argument_name, type)
        setup += '    Symbol::Resolved(&{})->storage = Storage::Uniform;\n'.format(texture_argument_name)
        setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(sampler_argument_name, 'Sampler')
        setup += '    Symbol::Resolved(&{})->storage = Storage::Uniform;\n'.format(sampler_argument_name)

        sampled_decls = ''
        sampled_decls += 'extern Variable Sampled{};\n'.format(texture_argument_name)

        sampled_defs = ''
        sampled_defs += 'Variable Sampled{};\n'.format(texture_argument_name)

        sampled_setup = ''
        sampled_setup += '    Sampled{}.name = "texture"_c;\n'.format(texture_argument_name)
        sampled_setup += '    Sampled{}.type = Type::FullType{{ {}Type.name }};\n'.format(texture_argument_name, type)
        sampled_setup += '    Sampled{}.type.AddModifier(Type::FullType::Modifier::Pointer);\n'.format(texture_argument_name, type)
        sampled_setup += '    Symbol::Resolved(&Sampled{})->typeSymbol = &{}Type;\n'.format(texture_argument_name, type)
        sampled_setup += '    Symbol::Resolved(&Sampled{})->storage = Storage::Uniform;\n'.format(texture_argument_name)
        return [(decls, defs, setup, ''), (sampled_decls, sampled_defs, sampled_setup, 'Sampled')]

    intrinsic = 'GetSampledMip'
    for type in texture_types_no_ms:
        coordinate_type = texture_float_index_types[type]
        function_name = 'Texture{}_{}'.format(intrinsic, type)

        for defs in generate_texture_intrinsic_base(function_name):
            base_decls, base_defs, base_setup, prefix = defs
            coordinate_argument_name = '{}{}_coordinate'.format(prefix, function_name)
            intrinsic_decls += base_decls
            intrinsic_decls += 'extern Variable {};\n'.format(coordinate_argument_name)
            intrinsic_decls += 'extern Function {}{};\n'.format(prefix, function_name)
            intrinsic_defs += base_defs
            intrinsic_defs += 'Variable {};\n'.format(coordinate_argument_name)
            intrinsic_defs += 'Function {}{};\n'.format(prefix, function_name)

            intrinsic_setup += '    {}.name = "coordinate"_c;\n'.format(coordinate_argument_name)
            intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(coordinate_argument_name, coordinate_type)
            intrinsic_setup += '    {}{}.name = "texture{}"_c;\n'.format(prefix, function_name, intrinsic)
            intrinsic_setup += '    {}{}.returnType = Type::FullType{{ {}Type.name }};\n'.format(prefix, function_name, 'Float32x2')
            intrinsic_setup += base_setup
            intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(coordinate_argument_name, coordinate_type)
            intrinsic_setup += '    Symbol::Resolved(&{}{})->returnTypeSymbol = &{}Type;\n\n'.format(prefix, function_name, 'Float32x2')

            spirv_func = ''
            if prefix: # Prefix here is merely 'Sampled'
                spirv_func += '    SPIRVResult sampledImage = args[0];\n'
                spirv_func += '    SPIRVResult coord = args[1];\n'
            else:
                spirv_func += '    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);\n'
                spirv_func += '    SPIRVResult coord = args[2];\n'
            spirv_func += '    g->writer->Capability(Capabilities::ImageQuery);\n'
            spirv_func += '    uint32_t ret;\n'
            spirv_func += '    ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);\n'
            spirv_func += '    return SPIRVResult(ret, returnType, true);\n'
            spirv_code += spirv_intrinsic('{}{}'.format(prefix, function_name), spirv_func)

    texture_load_store_intrinsics = ['Load', 'LoadMip', 'Store', 'StoreMip']
    for type in texture_types:
        coordinate_type = texture_denormalized_index_types[type]
        for intrinsic in texture_load_store_intrinsics:
            hasMip = intrinsic in ['LoadMip', 'StoreMip']
            hasStore = intrinsic in ['Store', 'StoreMip']
            function_name = 'Texture{}_{}'.format(intrinsic, type)
            texture_argument_name = 'Texture{}_{}_texture'.format(intrinsic, type)

            coordinate_argument_name = '{}_coordinate'.format(function_name)
            if hasMip:
                mip_argument_name = '{}_mip'.format(function_name)
            if hasStore:
                value_argument_name = '{}_value'.format(function_name)

            intrinsic_decls += 'extern Variable {};\n'.format(texture_argument_name)
            intrinsic_decls += 'extern Variable {};\n'.format(coordinate_argument_name)
            if hasMip:
                intrinsic_decls += 'extern Variable {};\n'.format(mip_argument_name)
            if hasStore:
                intrinsic_decls += 'extern Variable {};\n'.format(value_argument_name)
            intrinsic_decls += 'extern Function {};\n'.format(function_name)

            intrinsic_defs += 'Variable {};\n'.format(texture_argument_name)
            intrinsic_defs += 'Variable {};\n'.format(coordinate_argument_name)
            if hasMip:
                intrinsic_defs += 'Variable {};\n'.format(mip_argument_name)
            if hasStore:
                intrinsic_defs += 'Variable {};\n'.format(value_argument_name)
            intrinsic_defs += 'Function {};\n'.format(function_name)

            intrinsic_setup += '    {}.name = "texture"_c;\n'.format(texture_argument_name)
            intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(texture_argument_name, type)
            intrinsic_setup += '    {}.type.AddModifier(Type::FullType::Modifier::Pointer);\n'.format(texture_argument_name, type)
            
            intrinsic_setup += '    {}.name = "coordinate"_c;\n'.format(coordinate_argument_name)
            intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(coordinate_argument_name, coordinate_type)
            if hasMip:
                intrinsic_setup += '    {}.name = "mip"_c;\n'.format(mip_argument_name)
                intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(mip_argument_name, 'Int32')
            if hasStore:
                intrinsic_setup += '    {}.name = "value"_c;\n'.format(value_argument_name)
                intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(value_argument_name, 'Float32x4')
            intrinsic_setup += '    {}.name = "texture{}"_c;\n'.format(function_name, intrinsic)

            if not hasStore:
                intrinsic_setup += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(function_name, type)
            else:
                intrinsic_setup += '    {}.returnType = Type::FullType{{ VoidType.name }};\n'.format(function_name)

            intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(texture_argument_name, type)
            intrinsic_setup += '    Symbol::Resolved(&{})->storage = Storage::Uniform;\n'.format(texture_argument_name)
            if hasMip:
                intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(mip_argument_name, 'Int32')
            if hasStore:
                intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(value_argument_name, 'Float32x4')
            intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n\n'.format(coordinate_argument_name, coordinate_type)

    intrinsic = 'PixelCacheLoad'
    for type in ['PixelCache', 'PixelCacheMS']:
        function_name = 'Texture{}_{}'.format(intrinsic, type)
        texture_argument_name = 'Texture{}_{}_texture'.format(intrinsic, type)
        coordinate_argument_name = '{}_coordinate'.format(function_name)
        intrinsic_decls += 'extern Variable {};\n'.format(texture_argument_name)
        intrinsic_decls += 'extern Function {};\n'.format(function_name)
        intrinsic_defs += 'Variable {};\n'.format(texture_argument_name)
        intrinsic_defs += 'Function {};\n'.format(function_name)
        intrinsic_setup += '    {}.name = "texture"_c;\n'.format(texture_argument_name)
        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(texture_argument_name, type)
        intrinsic_setup += '    {}.type.AddModifier(Type::FullType::Modifier::Pointer);\n'.format(texture_argument_name, type)
        intrinsic_setup += '    {}.name = "texture{}"_c;\n'.format(function_name, intrinsic)
        intrinsic_setup += '    {}.returnType = Type::FullType{{ Float32x4Type.name }};\n'.format(function_name)
        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(texture_argument_name, type)
        intrinsic_setup += '    Symbol::Resolved(&{})->storage = Storage::Uniform;\n'.format(texture_argument_name)
        intrinsic_setup += '    Symbol::Resolved(&{})->returnTypeSymbol = &Float32x4Type;\n\n'.format(function_name)

    intrinsic = 'Sample'
    lod_modifiers = ['', 'Lod', 'Grad', 'Bias']
    compare_modifiers = ['', 'Compare']
    projection_modifiers = ['', 'Proj']
    for lod in lod_modifiers:
        for comp in compare_modifiers:
            for proj in projection_modifiers:
                for type in texture_types_no_ms:
                    function_name = 'Texture{}{}{}{}_{}'.format(intrinsic, lod, proj, comp, type)

                    for defs in generate_texture_intrinsic_base(function_name):
                        base_decls, base_defs, base_setup, prefix = defs

                        if comp == 'Compare' and type.startswith('TextureCube'):
                            continue

                        if proj == 'Proj' and type.endswith('Array'):
                            continue

                        if proj == 'Proj' and type.startswith('TextureCube'):
                            continue

                        coordinate_type = texture_float_index_types[type]
                        coordinate_argument_name = '{}{}_coordinate'.format(prefix, function_name)
                        if lod == 'Lod':
                            lod_argument_name = '{}{}_lod'.format(prefix, function_name)
                        elif lod == 'Grad':
                            lodx_argument_name = '{}{}_gradx'.format(prefix, function_name)
                            lody_argument_name = '{}{}_grady'.format(prefix, function_name)
                        elif lod == 'Bias':
                            lod_argument_name = '{}{}_bias'.format(prefix, function_name)
                        if proj == 'Proj':
                            proj_argument_name = '{}{}_proj'.format(prefix, function_name)
                        if comp == 'Compare':
                            compare_argument_name = '{}{}_compare'.format(prefix, function_name)
                        

                        intrinsic_decls += base_decls
                        intrinsic_decls += 'extern Variable {};\n'.format(coordinate_argument_name)
                        if lod == 'Lod' or lod == 'Bias':
                            intrinsic_decls += 'extern Variable {};\n'.format(lod_argument_name)
                        elif lod == 'Grad':
                            intrinsic_decls += 'extern Variable {};\n'.format(lodx_argument_name)
                            intrinsic_decls += 'extern Variable {};\n'.format(lody_argument_name)
                        if proj == 'Proj':
                            intrinsic_decls += 'extern Variable {};\n'.format(proj_argument_name)
                        if comp == 'Compare':
                            intrinsic_decls += 'extern Variable {};\n'.format(compare_argument_name)
                        
                        intrinsic_decls += 'extern Function {}{};\n'.format(prefix, function_name)

                        intrinsic_defs += base_defs
                        intrinsic_defs += 'Variable {};\n'.format(coordinate_argument_name)
                        if lod:
                            intrinsic_defs += 'Variable {};\n'.format(lod_argument_name)
                        if proj == 'Proj':
                            intrinsic_defs += 'Variable {};\n'.format(proj_argument_name)
                        if comp == 'Compare':
                            intrinsic_defs += 'Variable {};\n'.format(compare_argument_name)
                        
                        intrinsic_defs += 'Function {}{};\n'.format(prefix, function_name)

                        intrinsic_setup += base_setup
                        intrinsic_setup += '    {}.name = "coordinate"_c;\n'.format(coordinate_argument_name)
                        intrinsic_setup += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(coordinate_argument_name, coordinate_type)
                        if lod == 'Lod':
                            intrinsic_setup += '    {}.name = "lod"_c;\n'.format(lod_argument_name)
                            intrinsic_setup += '    {}.type = Type::FullType{{ Float32Type.name }};\n'.format(lod_argument_name)
                        elif lod == 'Bias':
                            intrinsic_setup += '    {}.name = "bias"_c;\n'.format(lod_argument_name)
                            intrinsic_setup += '    {}.type = Type::FullType{{ Float32Type.name }};\n'.format(lod_argument_name)
                        elif lod == 'Grad':
                            intrinsic_setup += '    {}.name = "grad_x"_c;\n'.format(lodx_argument_name)
                            intrinsic_setup += '    {}.type = Type::FullType{{ {}.name }};\n'.format(lodx_argument_name, coordinate_type)
                            intrinsic_setup += '    {}.name = "grad_y"_c;\n'.format(lody_argument_name)
                            intrinsic_setup += '    {}.type = Type::FullType{{ {}.name }};\n'.format(lody_argument_name, coordinate_type)
                        if proj == 'Proj':
                            intrinsic_setup += '    {}.name = "proj"_c;\n'.format(proj_argument_name)
                            intrinsic_setup += '    {}.type = Type::FullType{{ Float32Type.name }};\n'.format(proj_argument_name)
                        if comp == 'Compare':
                            intrinsic_setup += '    {}.name = "compare"_c;\n'.format(compare_argument_name)
                            intrinsic_setup += '    {}.type = Type::FullType{{ Float32Type.name }};\n'.format(compare_argument_name)
                        
                        intrinsic_setup += '    {}{}.name = "texture{}{}{}{}"_c;\n'.format(prefix, function_name, intrinsic, lod, proj, comp)
                        intrinsic_setup += '    {}{}.returnType = Type::FullType{{ Float32x4Type.name }};\n'.format(prefix, function_name)
                        intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(coordinate_argument_name, coordinate_type)
                        if lod == 'Lod' or lod == 'Bias':
                            intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &Float32Type;\n'.format(lod_argument_name)
                        elif lod == 'Grad':
                            intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{};\n'.format(lodx_argument_name, coordinate_type)
                            intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &{};\n'.format(lody_argument_name, coordinate_type)
                        if comp == 'Compare':
                            intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &Float32Type;\n'.format(compare_argument_name)
                        if proj == 'Proj':
                            intrinsic_setup += '    Symbol::Resolved(&{})->typeSymbol = &Float32Type;\n'.format(proj_argument_name)
                        intrinsic_setup += '    Symbol::Resolved(&{}{})->returnTypeSymbol = &Float32x4Type;\n\n'.format(prefix, function_name)



    spirv_intrinsics.write(spirv_code)
    spirv_intrinsics.write('};\n')
    spirv_intrinsics.write('} // namespace GPULang\n\n')
    
    intrinsics_header.write(intrinsic_decls)
    intrinsics_header.write('} // namespace GPULang\n\n')

    intrinsics_source.write(intrinsic_defs)

    intrinsics_source.write('void SetupIntrinsics()\n')
    intrinsics_source.write('{\n')
    intrinsics_source.write(intrinsic_setup)
    intrinsics_source.write('}\n')
    intrinsics_source.write('} // namespace GPULang\n')




generate_swizzle_four()
generate_swizzle_three()
generate_swizzle_two()
generate_types()

open_file.close()
print("Types generated!")