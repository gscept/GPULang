
import os
from math import trunc

os.makedirs('../generated', exist_ok=True)
os.makedirs('../generated/spirv', exist_ok=True)
open_file = open('../generated/swizzle.h', 'w')
open_file.write("//-------------------------------------------------\n")
open_file.write("// *** Generated by type_gen.py. ***\n")
open_file.write("//         DO NOT MODIFY!!!\n")
open_file.write("//-------------------------------------------------\n\n")

def generate_swizzle_four():
    components = ['x', 'y', 'z', 'w']
    open_file.write("#define SWIZZLE4()\\\n")
    for x in components:
        open_file.write(f"X(" + x + ")\\\n")
        for y in components:
            open_file.write(f"X(" + x + y + ")\\\n")
            for z in components:
                open_file.write(f"X(" + x + y + z + ")\\\n")
                for w in components:
                    open_file.write(f"X(" + x + y + z + w + ")\\\n")
    components = ['r', 'g', 'b', 'a']
    for x in components:
        open_file.write(f"X(" + x + ")\\\n")
        for y in components:
            open_file.write(f"X(" + x + y + ")\\\n")
            for z in components:
                open_file.write(f"X(" + x + y + z + ")\\\n")
                for w in components:
                    open_file.write(f"X(" + x + y + z + w + ")\\\n")
    open_file.write("\n")

def generate_swizzle_three():
    components = ['x', 'y', 'z']

    open_file.write("#define SWIZZLE3()\\\n")
    for x in components:
        open_file.write(f"X(" + x + ")\\\n")
        for y in components:
            open_file.write(f"X(" + x + y + ")\\\n")
            for z in components:
                open_file.write(f"X(" + x + y + z + ")\\\n")
    components = ['r', 'g', 'b']
    for x in components:
        open_file.write(f"X(" + x + ")\\\n")
        for y in components:
            open_file.write(f"X(" + x + y + ")\\\n")
            for z in components:
                open_file.write(f"X(" + x + y + z + ")\\\n")
    open_file.write("\n")

def generate_swizzle_two():
    components = ['x', 'y']
    open_file.write("#define SWIZZLE2()\\\n")
    for x in components:
        open_file.write(f"X(" + x + ")\\\n")
        for y in components:
            open_file.write(f"X(" + x + y + ")\\\n")
    components = ['r', 'g']
    for x in components:
        open_file.write(f"X(" + x + ")\\\n")
        for y in components:
            open_file.write(f"X(" + x + y + ")\\\n")
    open_file.write("\n")

def generate_types():
    types = ["Float32", "UInt32", "Int32", "Bool8", "Float16", "UInt16", "Int16"]

    bit_widths = [32, 32, 32, 8, 16, 16, 16]

    data_type_mapping = {
        "Float32": "f32",
        "UInt32": "u32",
        "Int32": "i32",
        "Bool8": "b8",
        "Float16": "f16",
        "UInt16": "u16",
        "Int16": "i16",
        "Float32x2": "f32x2",
        "Float32x3": "f32x3",
        "Float32x4": "f32x4",
        "UInt32x2": "u32x2",
        "UInt32x3": "u32x3",
        "UInt32x4": "u32x4",
        "Int32x2": "i32x2",
        "Int32x3": "i32x3",
        "Int32x4": "i32x4",
        "Bool8x2": "b8x2",
        "Bool8x3": "b8x3",
        "Bool8x4": "b8x4",
        "Float16x2": "f16x2",
        "Float16x3": "f16x3",
        "Float16x4": "f16x4",
        "UInt16x2": "u16x2",
        "UInt16x3": "u16x3",
        "UInt16x4": "u16x4",
        "Int16x2": "i16x2",
        "Int16x3": "i16x3",
        "Int16x4": "i16x4",
        "Float32x2x2": "f32x2x2",
        "Float32x2x3": "f32x2x3",
        "Float32x2x4": "f32x2x4",
        "Float32x3x2": "f32x3x2",
        "Float32x3x3": "f32x3x3",
        "Float32x3x4": "f32x3x4",
        "Float32x4x2": "f32x4x2",
        "Float32x4x3": "f32x4x3",
        "Float32x4x4": "f32x4x4",
        "Float16x2x2": "f16x2x2",
        "Float16x2x3": "f16x2x3",
        "Float16x2x4": "f16x2x4",
        "Float16x3x2": "f16x3x2",
        "Float16x3x3": "f16x3x3",
        "Float16x3x4": "f16x3x4",
        "Float16x4x2": "f16x4x2",
        "Float16x4x3": "f16x4x3",
        "Float16x4x4": "f16x4x4"
    }

    bit_operator_names = ['or', 'and', 'xor', 'lsh', 'rsh']
    bit_operators = ['|', '&', '^', '<<', '>>']

    scalar_operator_names = ['add', 'sub', 'mul', 'div', 'mod']
    scalar_operators = ['+', '-', '*', '/', '%']

    comparison_operator_names = ['lt', 'lte', 'gt', 'gte', 'eq', 'neq']
    comparison_operators = ['<', '<=', '>', '>=', '==', '!=']

    bool_operator_names = ['oror', 'andand', 'eq', 'neq']
    bool_operators = ['||', '&&', '==', '!=']

    assignment_operator_names = ['addasg', 'subasg', 'mulasg', 'divasg']
    assignment_operators = ['+=', '-=', '*=', '/=']

    bit_assignment_operator_names = ['orasg', 'andasg', 'xorasg', 'lshasg', 'rhsasg']
    bit_assignment_operators = ['|=', '&=', '^=', '<<=', '>>=']

    scale_operator_names = ['scale', 'scale', 'scale', 'scale', 'scale', 'scale']
    scale_operators = ['*', '*', '*', '*', '*', '*']
    scale_operator_types = ['Float32', 'Float16', 'UInt32', 'UInt16', 'Int32', 'Int16']

    index_operator_names = ['index_Int32', 'index_UInt32', 'index_Int16', 'index_UInt16']
    index_operators = ['[]', '[]', '[]', '[]']
    index_types = ['Int32', 'UInt32', 'Int16', 'UInt16']

    vector_matrix_operator_names = ['mul']
    vector_matrix_operators = ['*']

    header_file = open("../generated/types.h", 'w')
    source_file = open("../generated/types.cc", 'w')

    ### Type conversion enum and SPIRV conversion methods ###
    spirv_intrinsics = open("../generated/spirv.h", 'w')

    namer_line = ''

    conversion_table_enum = "enum TypeConversionTable\n"
    conversion_table_enum += '{\n'

    class TypeConverter:
        def __init__(self, enu, target, source_data_type, spirv_conversion_function, spirv_conversion_prep, spirv_conversion_arguments):
            self.enum = enu
            self.target = target
            self.source_data_type = source_data_type    
            self.spirv_conversion_function = spirv_conversion_function
            self.spirv_conversion_prep = spirv_conversion_prep
            self.spirv_conversion_arguments = spirv_conversion_arguments

    type_conversions = []
    for type1, width1 in zip(types, bit_widths):
        for type2, width2 in zip(types, bit_widths):
            if type1 != type2:
                conversion_table_enum += f'    {type1}To{type2},\n'
                spirv_conversion_function = ''
                spirv_conversion_prep = ''

                if type1.startswith('Bool'):
                    if type2.startswith('Int') or type2.startswith('UInt'):
                        spirv_conversion_prep = f'            SPIRVResult trueValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::{type2}(1));\n'
                        spirv_conversion_prep += f'            SPIRVResult falseValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::{type2}(0));\n'
                        type_conversions.append(TypeConverter(f'{type1}To{type2}', type2, data_type_mapping[type1], 'OpSelect', spirv_conversion_prep, 'trueValue, falseValue'))
                else:    
                    if not type2.startswith('Bool'):
                        spirv_conversion_prep = ''
                        if type1.startswith('Float'):                    
                            if width1 != width2:
                                spirv_conversion_function = 'OpFConvert'
                            if type2.startswith('UInt'):
                                spirv_conversion_function = 'OpConvertFToU'
                            elif type2.startswith('Int'):
                                spirv_conversion_function = 'OpConvertFToS'
                        elif type1.startswith('UInt'):
                            if width1 != width2:
                                spirv_conversion_function = 'OpUConvert'
                            if type2.startswith('Int'):
                                spirv_conversion_function = 'OpBitcast'
                            elif type2.startswith('Float'):
                                spirv_conversion_function = 'OpConvertUToF'
                        elif type1.startswith('Int'):
                            if width1 != width2:
                                spirv_conversion_function = 'OpSConvert'
                            if type2.startswith('UInt'):
                                spirv_conversion_function = 'OpBitcast'
                            elif type2.startswith('Float'):
                                spirv_conversion_function = 'OpConvertSToF'
                        type_conversions.append(TypeConverter(f'{type1}To{type2}', type2, data_type_mapping[type1], spirv_conversion_function, spirv_conversion_prep, ''))
                    else:
                        if type1.startswith('UInt') or type1.startswith('Int'):
                            spirv_conversion_prep += f'            SPIRVResult falseValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::{type1}(0));\n'
                            type_conversions.append(TypeConverter(f'{type1}To{type2}', type2, data_type_mapping[type1], 'OpINotEqual', spirv_conversion_prep, 'falseValue'))


    conversion_table_enum = conversion_table_enum[0:-2]
    conversion_table_enum += '\n};\n\n'

    spirv_type_construction = ''

    spirv_intrinsics.write("#pragma once\n")
    spirv_intrinsics.write("//-------------------------------------------------\n")
    spirv_intrinsics.write("// *** Generated by type_gen.py. ***\n")
    spirv_intrinsics.write("//       DO NOT MODIFY!!!\n")
    spirv_intrinsics.write("//-------------------------------------------------\n")
    spirv_intrinsics.write("static auto CreateSampledImageSPIRV = [](const Compiler* c, SPIRVGenerator* g, SPIRVResult img, SPIRVResult samp) -> SPIRVResult\n")
    spirv_intrinsics.write("{\n")
    spirv_intrinsics.write("        assert(img.parentTypes.size() > 0);\n")
    spirv_intrinsics.write("        SPIRVResult image = LoadValueSPIRV(c, g, img, true);\n")
    spirv_intrinsics.write("        SPIRVResult sampler = LoadValueSPIRV(c, g, samp, true);\n")
    spirv_intrinsics.write("        uint32_t typeSymbol = AddType(g, TStr::Compact(\"sampledImage_\", img.parentTypes[0]), OpTypeSampledImage, SPVArg{img.parentTypes[0]});\n")
    spirv_intrinsics.write("        uint32_t sampledImage = g->writer->MappedInstruction(OpSampledImage, SPVWriter::Section::LocalFunction, typeSymbol, image, sampler);\n")
    spirv_intrinsics.write("        return SPIRVResult(sampledImage, typeSymbol, true);\n")
    spirv_intrinsics.write("};\n\n")

    spirv_type_converter_list = []
    spirv_type_construction = ''
    for converter in type_conversions:
        spirv_type_construction += f'SPIRVResult SPIRV_{converter.enum}(const Compiler* c, SPIRVGenerator* g, uint32_t vectorSize, SPIRVResult value) \n{{\n'
        spirv_type_construction += f'    if (value.isLiteral)\n'
        spirv_type_construction += f'    {{\n'
        spirv_type_construction += f'        assert(vectorSize == 1);\n'
        spirv_type_construction += f'        return GenerateConstantSPIRV(c, g, ConstantCreationInfo::{converter.target}(value.literalValue.{converter.source_data_type}));\n'
        spirv_type_construction += f'    }}\n'
        spirv_type_construction += f'    else\n'
        spirv_type_construction += f'    {{\n'
        spirv_type_construction += f'        uint32_t type;\n'
        spirv_type_construction += f'        if (vectorSize > 1)\n'
        spirv_type_construction += f'            type = GeneratePODTypeSPIRV(c, g, TypeCode::{converter.target}, vectorSize);\n'
        spirv_type_construction += f'        else\n'
        spirv_type_construction += f'            type = GeneratePODTypeSPIRV(c, g, TypeCode::{converter.target});\n'
        if not converter.spirv_conversion_arguments:
            spirv_type_construction += f'        value = LoadValueSPIRV(c, g, value);\n'
        if converter.spirv_conversion_prep:
            spirv_type_construction += converter.spirv_conversion_prep
        if not converter.spirv_conversion_arguments:
            spirv_type_construction += f'        uint32_t res = g->writer->MappedInstruction({converter.spirv_conversion_function}, SPVWriter::Section::LocalFunction, type, value);\n'
        else:
            spirv_type_construction += f'        uint32_t res = g->writer->MappedInstruction({converter.spirv_conversion_function}, SPVWriter::Section::LocalFunction, type, value, {converter.spirv_conversion_arguments});\n'
        spirv_type_construction += f'        return SPIRVResult(res, type, true);\n'
        spirv_type_construction += f'    }}\n'
        spirv_type_construction += f'}}\n\n'
        spirv_type_converter_list.append(f'    std::pair{{ TypeConversionTable::{converter.enum}, &SPIRV_{converter.enum} }}')

    
    spirv_intrinsics.write(spirv_type_construction[0:-2])
    spirv_intrinsics.write('\n\n')
    spirv_intrinsics.write('constexpr StaticMap ConverterTable = std::array{\n')
    spirv_intrinsics.write(",\n".join(spirv_type_converter_list))
    spirv_intrinsics.write('\n};\n\n')

    spirv_atomic_tables = ""
    spirv_atomic_tables += "static const uint32_t SemanticsTable[] =\n"
    spirv_atomic_tables += "{\n"
    spirv_atomic_tables += "    0x0,\n"
    spirv_atomic_tables += "    0x1,\n"
    spirv_atomic_tables += "    0x2,\n"
    spirv_atomic_tables += "    0x4,\n"
    spirv_atomic_tables += "    0x8,\n"
    spirv_atomic_tables += "    0x10,\n"
    spirv_atomic_tables += "    0x20,\n"
    spirv_atomic_tables += "    0x40,\n"
    spirv_atomic_tables += "    0x80,\n"
    spirv_atomic_tables += "    0x100\n"
    spirv_atomic_tables += "};\n"
    spirv_atomic_tables += "\n"
    spirv_atomic_tables += "static auto ScopeToAtomicScope = [](SPIRVResult::Storage scope) -> uint32_t\n"
    spirv_atomic_tables += "{\n"
    spirv_atomic_tables += "    switch (scope)\n"
    spirv_atomic_tables += "    {\n"
    spirv_atomic_tables += "        case SPIRVResult::Storage::Function:\n"
    spirv_atomic_tables += "        case SPIRVResult::Storage::Input:\n"
    spirv_atomic_tables += "        case SPIRVResult::Storage::Output:\n"
    spirv_atomic_tables += "        case SPIRVResult::Storage::PushConstant:\n"
    spirv_atomic_tables += "        case SPIRVResult::Storage::Private:\n"
    spirv_atomic_tables += "            return 4;\n"
    spirv_atomic_tables += "        case SPIRVResult::Storage::WorkGroup:\n"
    spirv_atomic_tables += "            return 2;\n"
    spirv_atomic_tables += "        case SPIRVResult::Storage::Device:\n"
    spirv_atomic_tables += "        case SPIRVResult::Storage::Uniform:\n"
    spirv_atomic_tables += "        case SPIRVResult::Storage::UniformConstant:\n"
    spirv_atomic_tables += "        case SPIRVResult::Storage::StorageBuffer:\n"
    spirv_atomic_tables += "        case SPIRVResult::Storage::MutableImage:\n"
    spirv_atomic_tables += "            return 1;\n"
    spirv_atomic_tables += "        case SPIRVResult::Storage::Sampler:\n"
    spirv_atomic_tables += "        case SPIRVResult::Storage::Image:\n"
    spirv_atomic_tables += "            assert(false);\n"
    spirv_atomic_tables += "    }\n"
    spirv_atomic_tables += "    return 0;\n"
    spirv_atomic_tables += "};\n"
    spirv_atomic_tables += "\n"
    spirv_atomic_tables += "static auto ScopeToMemorySemantics = [](SPIRVResult::Storage scope) -> uint32_t\n"
    spirv_atomic_tables += "{\n"
    spirv_atomic_tables += "    switch (scope)\n"
    spirv_atomic_tables += "    {\n"
    spirv_atomic_tables += "        case SPIRVResult::Storage::WorkGroup:\n"
    spirv_atomic_tables += "            return 0x100; // WorkgroupMemory\n"
    spirv_atomic_tables += "        case SPIRVResult::Storage::Uniform:\n"
    spirv_atomic_tables += "        case SPIRVResult::Storage::UniformConstant:\n"
    spirv_atomic_tables += "        case SPIRVResult::Storage::StorageBuffer:\n"
    spirv_atomic_tables += "        case SPIRVResult::Storage::Sampler:\n"
    spirv_atomic_tables += "            return 0x40; // UniformMemory\n"
    spirv_atomic_tables += "        case SPIRVResult::Storage::Image:\n"
    spirv_atomic_tables += "        case SPIRVResult::Storage::MutableImage:\n"
    spirv_atomic_tables += "            return 0x800; // ImageMemory\n"
    spirv_atomic_tables += "    }\n"
    spirv_atomic_tables += "    return 0x0;\n"
    spirv_atomic_tables += "};\n\n"
    spirv_intrinsics.write(spirv_atomic_tables)
    #spirv_intrinsics.write('constexpr StaticMap default_intrinsics = std::array{\n')
    

    intrinsic_list = []

    ### Built-in data types (Float, Int, UInt, Bool and their vector/matrix variants)
    header_file.write("#pragma once\n")
    header_file.write("//-------------------------------------------------\n")
    header_file.write("// *** Generated by type_gen.py. ***\n")
    header_file.write("//       DO NOT MODIFY!!!\n")
    header_file.write("//-------------------------------------------------\n")
    header_file.write('#include "ast/types/type.h"\n')
    header_file.write('#include "ast/variable.h"\n')
    header_file.write('#include "ast/function.h"\n')
    header_file.write('#include "ast/enumeration.h"\n')
    header_file.write('#include "ast/expressions/intexpression.h"\n')
    header_file.write('#include "ast/expressions/enumexpression.h"\n')
    header_file.write('namespace GPULang\n')
    header_file.write('{\n')
    
    header_file.write(conversion_table_enum)

    source_file.write("//-------------------------------------------------\n")
    source_file.write("// *** Generated by type_gen.py. ***\n")
    source_file.write("//       DO NOT MODIFY!!!\n")
    source_file.write("//-------------------------------------------------\n")
    source_file.write('#include "types.h"\n')
    source_file.write('namespace GPULang\n')
    source_file.write('{\n')

    spirv_type_construction = ''
    spirv_code = ''

    spirv_intrinsic_list = []
    def spirv_intrinsic(fun, arg):
        spirv_intrinsic_code = f'SPIRVResult SPIRV_{fun}(const Compiler* c, SPIRVGenerator* g, uint32_t returnType, const std::vector<SPIRVResult>& args)\n'
        spirv_intrinsic_code += '{\n'
        spirv_intrinsic_code += f'{arg}'
        spirv_intrinsic_code += '}\n\n'
        spirv_intrinsic_list.append(f'std::pair{{ &{fun}, &SPIRV_{fun} }}')
        return spirv_intrinsic_code

    class Variable():
        def __init__(self, decl_name, api_name, type_name, pointer=False, uniform=False, literal=False):
            self.decl_name = decl_name
            self.api_name = api_name
            self.type_name = type_name
            self.pointer = pointer
            self.uniform = uniform
            self.literal = literal

    class Function():
        def __init__(self, decl_name, api_name, return_type, parameters, documentation=None):
            self.decl_name = decl_name
            self.api_name = api_name
            self.return_type = return_type
            self.parameters = parameters
            self.documentation = documentation

        def declaration(self):
            return_string = f'/// {self.api_name}\n'
            for param in self.parameters:
                return_string += f'extern Variable {param.decl_name};\n'
            return_string += f'extern Function {self.decl_name};\n'
            return_string += '\n'
            return return_string

        def definition(self):
            return_string = f'/// {self.api_name}\n'
            for param in self.parameters:
                return_string += f'Variable {param.decl_name};\n'
            return_string += f'Function {self.decl_name};\n'
            if self.parameters.__len__() > 0:
                return_string += f'inline constexpr std::array {self.decl_name}_args = {{ {", ".join([f"&{param.decl_name}" for param in self.parameters])} }};\n'
            return_string += '\n'
            return return_string

        def setup(self):
            return_string = f'    /// {self.api_name}\n'
            for param in self.parameters:
                return_string += f'    {param.decl_name}.name = "{param.api_name}"_c;\n'
                return_string += f'    {param.decl_name}.type = Type::FullType{{ {param.type_name}Type.name }};\n'
                if param.literal:
                    return_string += f'    {param.decl_name}.literal = true;\n'
                if param.pointer:
                    return_string += f'    {param.decl_name}.type.AddModifier(Type::FullType::Modifier::Pointer);\n'
            if self.documentation:
                return_string += f'    {self.decl_name}.documentation = "{self.documentation}"_c;\n'
            return_string += f'    {self.decl_name}.name = "{self.api_name}"_c;\n'
            return_string += f'    {self.decl_name}.returnType = Type::FullType {{ {self.return_type}Type.name }};\n'
            if self.parameters.__len__() > 0:
                return_string += f'    {self.decl_name}.parameters = {self.decl_name}_args;\n'
            for param in self.parameters:
                return_string += f'    Symbol::Resolved(&{param.decl_name})->typeSymbol = &{param.type_name}Type;\n'
                if param.uniform:
                    return_string += f'    Symbol::Resolved(&{param.decl_name})->storage = Storage::Uniform;\n'

            return_string += f'    Symbol::Resolved(&{self.decl_name})->returnTypeSymbol = &{self.return_type}Type;\n'
            return_string += '\n'
            return return_string

        def pair(self):
            return f'    std::pair{{ "{self.api_name}"_c, &{self.decl_name} }}'
        
        def constructor_pair(self):
            return f'    std::pair{{ "{self.api_name}({",".join([data_type_mapping[param.type_name] for param in self.parameters])})"_c, &{self.decl_name} }}'

    class_def = ""
    declaration_string = ""
    definition_string = ""
    for size in range(1, 5):
        for type, bits in zip(types, bit_widths):
            if size == 1:
                data_type_name = data_type_mapping[type]
                type_name = type
            else:
                type_name = f'{type}x{size}'
                data_type_name = f'{data_type_mapping[type]}x{size}'
            spirv_type_construction = ''
            class_decl = ''
            class_decl += f'struct {type_name} : public Type\n'
            class_decl += '{\n'
            class_decl += f'    {type_name}();\n'
            class_decl += '};\n'
            class_decl += f'extern {type_name} {type_name}Type;\n\n'
            declaration_string += class_decl

            namer_line += f'        {type_name}Type.name = "{data_type_name}"_c;\n'
            setup_string = ""
            list_string = []

            # Conversions
            for type2, bits2 in zip(types, bit_widths):
                if type2 == 'Bool8' and type != 'Bool8':
                    continue

                if size == 1 and type2 == type:
                    continue

                if type == 'Bool8' and not (type2.startswith('Int') or type2.startswith('UInt')):
                    continue

                if size == 1:
                    data_type_name2 = data_type_mapping[type2]
                    type_name2 = type2
                else:
                    type_name2 = f'{type2}x{size}'
                    data_type_name2 = f'{data_type_mapping[type2]}x{size}'

                function_name = f'{type_name}_convert_{type_name2}'
                arg_name = f'{type_name}_convert_{type_name2}_arg0'

                fun = Function(
                    decl_name=function_name,
                    api_name=data_type_name,
                    return_type=type_name,
                    parameters=[Variable(decl_name=arg_name, api_name='val', type_name=type_name2)],
                    documentation=f'Convert {data_type_name2} to {data_type_name}'
                )

                declaration_string += fun.declaration()
                definition_string += fun.definition()
                setup_string += fun.setup()

                intrinsic_list.append(fun.pair())
                intrinsic_list.append(fun.constructor_pair())
                if type == type2:
                    spirv_type_construction += spirv_intrinsic(function_name, '    return args[0];\n')
                else:
                    spirv_type_construction += spirv_intrinsic(function_name, f'    return ConverterTable[TypeConversionTable::{type}To{type2}](c, g, {size}, args[0]);\n')
                if size > 1:
                    function_name = f'{type_name}_splat_{type2}'
                    arg_name = f'{type_name}_splat_{type2}_arg0'

                    fun = Function(
                        decl_name=function_name,
                        api_name=data_type_name,
                        return_type=type_name,
                        parameters=[Variable(decl_name=arg_name, api_name='val', type_name=type2)],
                        documentation=f'Splat {data_type_name2} to {data_type_name}'
                    )
                    declaration_string += fun.declaration()
                    definition_string += fun.definition()
                    setup_string += fun.setup()

                    intrinsic_list.append(fun.pair())
                    intrinsic_list.append(fun.constructor_pair())
                    spirv_function = '    SPIRVResult val = args[0];\n'
                    if type != type2:
                        spirv_function += f'    val = ConverterTable[TypeConversionTable::{type2}To{type}](c, g, 1, val);\n'
                    spirv_function += f'    return GenerateSplatCompositeSPIRV(c, g, returnType, {size}, val);\n'
                    spirv_type_construction += spirv_intrinsic(function_name, spirv_function)


            four_component_combinations = [[1, 1, 1, 1], [2, 1, 1], [1, 2, 1], [1, 1, 2], [3, 1], [1,3]]
            three_component_combiations = [[1,1,1], [2, 1], [1, 2]]
            two_component_combinations = [[1, 1]]
            if size == 1:
                combinations = [[1]]
            elif size == 2:
                combinations = two_component_combinations
            elif size == 3:
                combinations = three_component_combiations
            elif size == 4:
                combinations = four_component_combinations
            for ctor_idx, comb in enumerate(combinations):
                function_name = f'{type_name}_ctor{ctor_idx}'

                list_entry_key = []
                args = []
                spirv_function =  "        SPIRVResult loadedArg = LoadValueSPIRV(c, g, args[0]);\n"
                spirv_function += "        if (returnType == loadedArg.typeName) {\n"
                spirv_function += "            return loadedArg;\n"
                spirv_function += "        }\n"
                if type != type2:
                    spirv_function += f'    loadedArg = GenerateConversionSPIRV(c, g, TypeConversionTable::{type}To{type2}, {size}, loadedArg);\n'
                spirv_function += '    return loadedArg;\n'

                fun = Function(
                    decl_name =function_name,
                    api_name = f'{data_type_mapping[type_name]}',
                    return_type = type_name,
                    parameters = []
                )
                for arg_idx, s in enumerate(comb):
                    if s == 1:
                        arg_type_name = type
                    else:
                        arg_type_name = f'{type}x{s}'
                    arg_name = f'{type_name}_ctor{ctor_idx}_arg{arg_idx}_{arg_type_name}'
                    fun.parameters.append(Variable(decl_name=arg_name, api_name=f'_arg{arg_idx}', type_name=arg_type_name))
                    args.append(arg_name)
                    if s == 1:
                        list_entry_key.append(f'{data_type_mapping[type]}')
                    else:
                        list_entry_key.append(f'{data_type_mapping[type]}x{s}')

                declaration_string += fun.declaration()
                definition_string += fun.definition()
                setup_string += fun.setup()

                intrinsic_list.append(fun.pair())
                intrinsic_list.append(fun.constructor_pair())
                spirv_function = f'    return GenerateCompositeSPIRV(c, g, returnType, {{{", ".join([f"args[{idx}]" for idx, arg in enumerate(args)])}}});\n'
                spirv_type_construction += spirv_intrinsic(function_name, spirv_function)


            spirv_intrinsics.write(spirv_type_construction)
        

            for name, op, idx_type in zip(index_operator_names, index_operators, index_types):
                function_name = f'{type_name}_operator_{name}'
                arg_name = f'{type_name}_operator_{name}_arg0'
                fun = Function(
                    decl_name=function_name,
                    api_name=f'operator{op}',
                    return_type=type,
                    parameters=[Variable(decl_name=arg_name, api_name='_arg0', type_name=idx_type)],
                )
                declaration_string += fun.declaration()
                definition_string += fun.definition()
                setup_string += fun.setup()
                list_string.append(fun.pair())

                spirv_function =  f'    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, {function_name}.returnType, &{type}Type, args[0].scope);\n'
                spirv_function += '    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);\n'
                spirv_function += '    SPIRVResult ret = args[0];\n'
                spirv_function += '    ret.AddAccessChainLink({index});\n'
                spirv_function += '    ret.typeName = returnTypePtr.typeName;\n'
                spirv_function += '    ret.parentTypes = returnTypePtr.parentTypes;\n'
                spirv_function += '    ret.scope = args[0].scope;\n'
                spirv_function += '    ret.isValue = false;\n'
                spirv_function += '    return ret;\n'
                spirv_code += spirv_intrinsic(function_name, spirv_function)

            if type == 'Bool8':
                for name, op in zip(bool_operator_names, bool_operators):
                    function_name = f'{type_name}_operator_{name}_{type_name}'
                    arg_name = f'{function_name}_arg0'
                    fun = Function(
                        decl_name=function_name,
                        api_name=f'operator{op}',
                        return_type=type,
                        parameters=[Variable(decl_name=arg_name, api_name='_arg0', type_name=type_name)],
                    )
                    declaration_string += fun.declaration()
                    definition_string += fun.definition()
                    setup_string += fun.setup()
                    list_string.append(fun.pair())

                    spirv_function =  ''
                    spirv_function += '    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);\n'
                    spirv_function += '    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);\n'

                    if op == '||':
                        spirv_op = 'OpLogicalOr'
                    elif op == '&&':
                        spirv_op = 'OpLogicalAnd'
                    elif op == '==':
                        spirv_op = 'OpIEqual'
                    elif op == '!=':
                        spirv_op = 'OpINotEqual'
                    spirv_function += f'    uint32_t ret = g->writer->MappedInstruction({spirv_op}, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);\n'
                    spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
                    spirv_code += spirv_intrinsic(function_name, spirv_function)
            else:
                operator_sets = [
                    zip(scalar_operator_names, scalar_operators), 
                    zip(assignment_operator_names, assignment_operators),
                    zip(comparison_operator_names, comparison_operators)
                    ]
                for operator_set in operator_sets:
                    for name, op in operator_set:
                        function_name = f'{type_name}_operator_{name}_{type_name}'
                        arg_name = f'{function_name}_arg0'
                        fun = Function(
                            decl_name=function_name,
                            api_name=f'operator{op}',
                            return_type=type_name,
                            parameters=[Variable(decl_name=arg_name, api_name='_arg0', type_name=type_name)],
                        )

                        declaration_string += fun.declaration()
                        definition_string += fun.definition()
                        setup_string += fun.setup()
                        list_string.append(fun.pair())

                        spirv_function = ''
                        spirv_function += '    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);\n'
                        spirv_function += '    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);\n'

                        spirv_op_type = ''
                        if type.startswith('Float'):
                            spirv_op_type = 'F'
                            if op == '<' or op == '>' or op == '<=' or op == '>=' or op == '==' or op == '!=':
                                spirv_op_type += 'Ord'
                        elif type.startswith('Int'):
                            if op == '/' or op == '/=' or op == '%' or op == '%=' or op == '<' or op == '>' or op == '<=' or op == '>=':
                                spirv_op_type = 'S'
                            else:
                                spirv_op_type = 'I'
                        elif type.startswith('UInt'):
                            if op == '/' or op == '/=' or op == '%' or op == '%=' or op == '<' or op == '>' or op == '<=' or op == '>=':
                                spirv_op_type = 'S'
                            else:
                                spirv_op_type = 'I'

                        if op == '+' or op == '+=':
                            spirv_op = f'Op{spirv_op_type}Add'
                        elif op == '-' or op == '-=':
                            spirv_op = f'Op{spirv_op_type}Sub'
                        elif op == '*' or op == '*=':
                            spirv_op = f'Op{spirv_op_type}Mul'
                        elif op == '/' or op == '/=':
                            spirv_op = f'Op{spirv_op_type}Div'
                        elif op == '%' or op == '%=':
                            spirv_op = f'Op{spirv_op_type}Mod'
                        elif op == '<':
                            spirv_op = f'Op{spirv_op_type}LessThan'
                        elif op == '>':
                            spirv_op = f'Op{spirv_op_type}GreaterThan'
                        elif op == '<=':
                            spirv_op = f'Op{spirv_op_type}LessThanEqual'
                        elif op == '>=':
                            spirv_op = f'Op{spirv_op_type}GreaterThanEqual'
                        elif op == '==':
                            spirv_op = f'Op{spirv_op_type}Equal'
                        elif op == '!=':
                            spirv_op = f'Op{spirv_op_type}NotEqual'
                        spirv_function += f'    uint32_t ret = g->writer->MappedInstruction({spirv_op}, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);\n'
                        spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
                        spirv_code += spirv_intrinsic(function_name, spirv_function)
                
                if size > 1:
                    for name, op, scale_type in zip(scale_operator_names, scale_operators, scale_operator_types):
                        function_name = f'{type_name}_operator_{name}_{scale_type}'
                        arg_name = f'{function_name}_arg0'


                        fun = Function(
                            decl_name=function_name,
                            api_name=f'operator{op}',
                            return_type=type_name,
                            parameters=[Variable(decl_name=arg_name, api_name='_arg0', type_name=scale_type)],
                        )
                        declaration_string += fun.declaration()
                        definition_string += fun.definition()
                        setup_string += fun.setup()
                        list_string.append(fun.pair())

                        spirv_function = ''
                        spirv_function += '    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);\n'
                        if scale_type.startswith('Float'):
                            spirv_function += '    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);\n'
                        else:
                            spirv_function += f'    SPIRVResult rhs = GenerateSplatCompositeSPIRV(c, g, returnType, {size}, args[1]);\n'
                        spirv_function += '    uint32_t ret = g->writer->MappedInstruction(OpIMul, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);\n'
                        spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
                        spirv_code += spirv_intrinsic(function_name, spirv_function)

            # Matrix transform
            if type.startswith('Float') and size > 1:
                for cols in range(2, 5):
                    compatible_matrix_type = f'Float32x{size}x{cols}'
                    return_type = f'{type}x{cols}'
                    for name, op in zip(vector_matrix_operator_names, vector_matrix_operators):
                        function_name = f'{type_name}_operator_{name}_{compatible_matrix_type}'
                        arg_name = f'{function_name}_arg0'

                        fun = Function(
                            decl_name=function_name,
                            api_name=f'operator{op}',
                            return_type=return_type,
                            parameters=[Variable(decl_name=arg_name, api_name='_arg0', type_name=compatible_matrix_type)],
                        )
                        declaration_string += fun.declaration()
                        definition_string += fun.definition()
                        setup_string += fun.setup()
                        list_string.append(fun.pair())

                        spirv_function = ''
                        spirv_function += '    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);\n'
                        spirv_function += '    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);\n'
                        spirv_function += '    uint32_t ret = g->writer->MappedInstruction(OpVectorTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);\n'
                        spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
                        spirv_code += spirv_intrinsic(function_name, spirv_function)

            if type.startswith("UInt") or type.startswith("Int"):
                operator_sets = [
                    zip(bit_operator_names, bit_operators)
                    , zip(bit_assignment_operator_names, bit_assignment_operators)
                    ]
                for operator_set in operator_sets:
                    for name, op in operator_set:
                        function_name = f'{type_name}_operator_{name}_{type_name}'
                        arg_name = f'{function_name}_arg0'
                        fun = Function(
                            decl_name=function_name,
                            api_name=f'operator{op}',
                            return_type=type_name,
                            parameters=[Variable(decl_name=arg_name, api_name='_arg0', type_name=type_name)],
                        )
                        declaration_string += fun.declaration()
                        definition_string += fun.definition()
                        setup_string += fun.setup()
                        list_string.append(fun.pair())

                        if op == '&':
                            spirv_op = 'OpBitwiseAnd'
                        elif op == '|':
                            spirv_op = 'OpBitwiseOr'
                        elif op == '^':
                            spirv_op = 'OpBitwiseXor'
                        elif op == '<<':
                            spirv_op = 'OpShiftLeftLogical'
                        elif op == '>>':
                            spirv_op = 'OpShiftRightLogical'
                        spirv_function = ''
                        spirv_function += '    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);\n'
                        spirv_function += '    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);\n'
                        spirv_function += f'    uint32_t ret = g->writer->MappedInstruction({spirv_op}, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);\n'
                        spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
                        spirv_code += spirv_intrinsic(function_name, spirv_function)

            class_def += f'{type_name}::{type_name}()\n'
            class_def += '{\n'
            class_def += f'    this->name = "{data_type_mapping[type_name]}";\n'
            class_def += f'    this->columnSize = {size};\n'
            class_def += f'    this->rowSize = 1;\n'
            class_def += f'    this->byteSize = {trunc((bits * size) / 8)};\n'
            class_def += f'    this->category = Type::ScalarCategory;\n'
            class_def += f'    this->baseType = TypeCode::{type};\n'
            class_def += f'    this->builtin = true;\n'
            class_def += f'\n'
            class_def += f'{setup_string}'
            class_def += f'    this->scope.symbolLookup = StaticMap {{ std::array{{\n'
            class_def += f'    {{\n'
            class_def += f'{",\n".join(list_string)}\n'
            class_def += f'    }} }};\n'
            class_def += '}\n\n'


    # Matrix types
    types = ['Float32', 'Float16']
    bit_widths = [32, 16]
    data_types = ["f32", "f16"]

    scalar_operator_names = ['add', 'sub', 'mul']
    scalar_operators = ['+', '-', '*']

    assignment_operator_names = ['addasg', 'subasg', 'mulasg']
    assignment_operators = ['+=', '-=', '*=']

    scale_operator_names = ['scale', 'scale']
    scale_operators = ['*', '*']
    scale_operator_types = ['Float32', 'Float16']

    for type, bits in zip(types, bit_widths):
        for row_size in range(2, 5):
            for column_size in range(2, 5):

                type_name = f'{type}x{row_size}x{column_size}'
                data_type_name = f'{data_type_mapping[type]}x{row_size}x{column_size}'

                namer_line += f'        {type_name}Type.name = "{data_type_name}"_c;\n'

                setup_string = ""
                
                class_decl = ''
                class_decl += f'struct {type_name} : public Type\n'
                class_decl += '{\n'
                class_decl += f'    {type_name}();\n'
                class_decl += '};\n'
                class_decl += f'extern {type_name} {type_name}Type;\n\n'
                declaration_string += class_decl

                vector_ctor_name = f'{type_name}_{type}_{column_size}_ctor'

                fun = Function(
                    decl_name=vector_ctor_name,
                    api_name=f'{data_type_name}',
                    return_type=type_name,
                    parameters=[]
                )

                for arg_index in range(0, row_size):
                    fun.parameters.append(Variable(
                        decl_name=f'{vector_ctor_name}_arg{arg_index}',
                        api_name=f'_arg{arg_index}',
                        type_name=f'{type}x{column_size}'
                    ))

                declaration_string += fun.declaration()
                definition_string += fun.definition()
                setup_string += fun.setup()
                intrinsic_list.append(fun.pair())
                intrinsic_list.append(fun.constructor_pair())

                fun = Function(
                    decl_name=f'{type_name}_identity',
                    api_name=f'{data_type_name}',
                    return_type=type_name,
                    parameters=[]
                )

                declaration_string += fun.declaration()
                definition_string += fun.definition()
                setup_string += fun.setup()
                intrinsic_list.append(fun.pair())
                intrinsic_list.append(fun.constructor_pair())

                fun = Function(
                    decl_name=f'{type_name}_raw_list',
                    api_name=f'{data_type_name}',
                    return_type=type_name,
                    parameters=[]
                )
                for arg_index in range(0, column_size * row_size):
                    fun.parameters.append(Variable(
                        decl_name=f'{type_name}_raw_list_arg{arg_index}',
                        api_name=f'_arg{arg_index}',
                        type_name=type
                    ))
                declaration_string += fun.declaration()
                definition_string += fun.definition()
                setup_string += fun.setup()
                intrinsic_list.append(fun.pair())
                intrinsic_list.append(fun.constructor_pair())

                vec_type = f'{type}x{column_size}'
                for name, op, idx_type in zip(index_operator_names, index_operators, index_types):
                    function_name = f'{type_name}_operator_{name}'
                    arg_name = f'{type_name}_operator_{name}_arg0'
                    fun = Function(
                        decl_name=function_name,
                        api_name=f'operator{op}',
                        return_type=vec_type,
                        parameters=[Variable(decl_name=arg_name, api_name='idx', type_name=idx_type)],
                    )
                    declaration_string += fun.declaration()
                    definition_string += fun.definition()
                    setup_string += fun.setup()
                    list_string.append(fun.pair())

                    spirv_function =  f'    SPIRVResult returnTypePtr = GeneratePointerTypeSPIRV(c, g, {function_name}.returnType, &{type}Type, args[0].scope);\n'
                    spirv_function += '    SPIRVResult index = LoadValueSPIRV(c, g, args[0]);\n'
                    spirv_function += '    SPIRVResult ret = args[0];\n'
                    spirv_function += '    ret.AddAccessChainLink({index});\n'
                    spirv_function += '    ret.typeName = returnTypePtr.typeName;\n'
                    spirv_function += '    ret.parentTypes = returnTypePtr.parentTypes;\n'
                    spirv_function += '    ret.scope = args[0].scope;\n'
                    spirv_function += '    ret.isValue = false;\n'
                    spirv_function += '    return ret;\n'
                    spirv_code += spirv_intrinsic(function_name, spirv_function)

                operator_sets = [
                    zip(scalar_operator_names, scalar_operators), 
                    zip(assignment_operator_names, assignment_operators)
                ]
                for operator_set in operator_sets:
                    for name, op in operator_set:
                        function_name = f'{type_name}_operator_{name}_{type_name}'
                        arg_name = f'{function_name}_arg0'

                        fun = Function(
                            decl_name=function_name,
                            api_name=f'operator{op}',
                            return_type=type_name,
                            parameters=[Variable(decl_name=arg_name, api_name='_arg0', type_name=type_name)],
                        )
                        declaration_string += fun.declaration()
                        definition_string += fun.definition()
                        setup_string += fun.setup()
                        list_string.append(fun.pair())

                        spirv_function = ''
                        spirv_function += '    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);\n'
                        spirv_function += '    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);\n'

                        if op == '+' or op == '+=':
                            spirv_function += f'    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, {column_size});\n'
                            spirv_function += f'    TransientArray<SPVArg> intermediateArgs({column_size});\n'
                            spirv_function += f'    for (uint32_t i = 0; i < {column_size}; i++)\n'
                            spirv_function += '    {\n'
                            spirv_function += '        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);\n'
                            spirv_function += '        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);\n'
                            spirv_function += '        uint32_t res = g->writer->MappedInstruction(OpFAdd, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));\n'
                            spirv_function += '        intermediateArgs.Append(SPVArg(res));\n'
                            spirv_function += '    }\n'
                            spirv_function += '    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));\n'
                        elif op == '-' or op == '-=':
                            spirv_function += f'    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float, {column_size});\n'
                            spirv_function += f'    TransientArray<SPVArg> intermediateArgs({column_size});\n'
                            spirv_function += f'    for (uint32_t i = 0; i < {column_size}; i++)\n'
                            spirv_function += '    {\n'
                            spirv_function += '        uint32_t lhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, lhs, i);\n'
                            spirv_function += '        uint32_t rhsVec = g->writer->MappedInstruction(OpCompositeExtract, SPVWriter::Section::LocalFunction, vectorType, rhs, i);\n'
                            spirv_function += '        uint32_t res = g->writer->MappedInstruction(OpFSub, SPVWriter::Section::LocalFunction, vectorType, SPVArg(lhsVec), SPVArg(rhsVec));\n'
                            spirv_function += '        intermediateArgs.Append(SPVArg(res));\n'
                            spirv_function += '    }\n'
                            spirv_function += '    uint32_t ret = g->writer->MappedInstruction(OpCompositeConstruct, SPVWriter::Section::LocalFunction, returnType, SPVArgList(intermediateArgs));\n'
                        elif op == '*' or op == '*=':
                            spirv_function += '    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesMatrix, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);\n'
                        spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
                        spirv_code += spirv_intrinsic(function_name, spirv_function)

                op = '*'
                function_name = f'{type_name}_operator_scale_{type}'
                arg_name = f'{function_name}_arg0'
                fun = Function(
                    decl_name=function_name,
                    api_name=f'operator{op}',
                    return_type=type_name,
                    parameters=[Variable(decl_name=arg_name, api_name='_arg0', type_name=type)],
                )
                declaration_string += fun.declaration()
                definition_string += fun.definition()
                setup_string += fun.setup()
                list_string.append(fun.pair())

                spirv_function = ''
                spirv_function += '    SPIRVResult lhs = LoadValueSPIRV(c, g, args[0]);\n'
                spirv_function += '    SPIRVResult rhs = LoadValueSPIRV(c, g, args[1]);\n'
                spirv_function += '    uint32_t ret = g->writer->MappedInstruction(OpMatrixTimesScalar, SPVWriter::Section::LocalFunction, returnType, lhs, rhs);\n'
                spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
                spirv_code += spirv_intrinsic(function_name, spirv_function)

                class_def += f'{type_name}::{type_name}()\n'
                class_def += '{\n'
                class_def += f'    this->name = "{data_type_mapping[type]}";\n'
                class_def += f'    this->columnSize = {column_size};\n'
                class_def += f'    this->rowSize = {row_size};\n'
                class_def += f'    this->byteSize = {trunc((bits * row_size * column_size) / 8)};\n'
                class_def += '    this->category = Type::ScalarCategory;\n'
                class_def += f'    this->baseType = TypeCode::{type};\n'
                class_def += '    this->builtin = true;\n'
                class_def += '\n'
                class_def += f'{setup_string}'
                class_def += f'    this->scope.symbolLookup = StaticMap {{ \n    std::array{{\n{list_string[0:-2]}\n    }}\n    }};   \n'
                class_def += '}\n\n'


    namer_struct = 'struct Namer\n'
    namer_struct += '{\n'
    namer_struct += '    Namer()\n'
    namer_struct += '    {\n'
    namer_struct += f'{namer_line[0:-1]}\n'
    namer_struct += '    }\n'
    namer_struct += '};\n'
    namer_struct += 'Namer namer;\n\n'
    source_file.write(namer_struct)

    header_file.write(declaration_string[0:-1] + '\n')
    header_file.write("\n")
    source_file.write(definition_string[0:-1] + '\n')
    source_file.write("\n")
    source_file.write(class_def)
    header_file.write("\n")

    # Texture types
    texture_dimensions = ['1D', '2D', '3D', 'Cube']
    texture_multisampling = ['MS', 'MS', '', '']
    texture_array = ['Array', 'Array', '', 'Array']
    for dim, ms, array in zip(texture_dimensions, texture_multisampling, texture_array):

        class_decl = ""
        class_decl += f'struct Texture{dim} : public Type\n'
        class_decl += '{\n'
        class_decl += f'    Texture{dim}();\n'
        class_decl += '};\n'
        class_decl += f'extern Texture{dim} Texture{dim}Type;\n\n'

        class_def = ""
        class_def += f'Texture{dim}::Texture{dim}()\n'
        class_def += '{\n'
        class_def += f'    this->name = "texture{dim}";\n'
        class_def += '    this->category = Type::TextureCategory;\n'
        class_def += f'    this->baseType = TypeCode::Texture{dim};\n'
        class_def += '    this->builtin = true;\n'
        class_def += '};\n\n'
        if ms : 
            class_decl += f'struct Texture{dim}MS : public Type\n'
            class_decl += '{\n'
            class_decl += f'    Texture{dim}MS();\n'
            class_decl += '};\n'
            class_decl += f'extern Texture{dim}MS Texture{dim}MSType;\n\n'

            class_def += f'Texture{dim}MS::Texture{dim}MS()\n'
            class_def += '{\n'
            class_def += f'    this->name = "texture{dim}MS";\n'
            class_def += '    this->category = Type::TextureCategory;\n'
            class_def += f'    this->baseType = TypeCode::Texture{dim};\n'
            class_def += '    this->builtin = true;\n'
            class_def += '};\n\n'
            if array:
                class_decl += f'struct Texture{dim}MSArray : public Type\n'
                class_decl += '{\n'
                class_decl += f'    Texture{dim}MSArray();\n'
                class_decl += '};\n'
                class_decl += f'extern Texture{dim}MSArray Texture{dim}MSArrayType;\n\n'

                class_def += f'Texture{dim}MSArray::Texture{dim}MSArray()\n'
                class_def += '{\n'
                class_def += f'    this->name = "texture{dim}MSArray";\n'
                class_def += '    this->category = Type::TextureCategory;\n'
                class_def += f'    this->baseType = TypeCode::Texture{dim};\n'
                class_def += '    this->builtin = true;\n'
                class_def += '};\n\n'
        if array:
            class_decl += f'struct Texture{dim}Array : public Type\n'
            class_decl += '{\n'
            class_decl += f'    Texture{dim}Array();\n'
            class_decl += '};\n'
            class_decl += f'extern Texture{dim}Array Texture{dim}ArrayType;\n\n'

            class_def += f'Texture{dim}Array::Texture{dim}Array()\n'
            class_def += '{\n'
            class_def += f'    this->name = "texture{dim}Array";\n'
            class_def += '    this->category = Type::TextureCategory;\n'
            class_def += f'    this->baseType = TypeCode::Texture{dim};\n'
            class_def += '    this->builtin = true;\n'
            class_def += '};\n\n'

        header_file.write(class_decl)
        source_file.write(class_def)

    # Pixel cache types
    class_decl = ""
    class_decl += 'struct PixelCache : public Type\n'
    class_decl += '{\n'
    class_decl += '    PixelCache();\n'
    class_decl += '};\n'
    class_decl += 'extern PixelCache PixelCacheType;\n\n'

    class_decl += 'struct PixelCacheMS : public Type\n'
    class_decl += '{\n'
    class_decl += '    PixelCacheMS();\n'
    class_decl += '};\n'
    class_decl += 'extern PixelCacheMS PixelCacheMSType;\n\n'

    class_def = ""
    class_def += 'PixelCache::PixelCache()\n'
    class_def += '{\n'
    class_def += '    this->name = "pixelCache";\n'
    class_def += '    this->category = Type::PixelCacheCategory;\n'
    class_def += '    this->baseType = TypeCode::PixelCache;\n'
    class_def += '    this->builtin = true;\n'
    class_def += '};\n\n'

    class_def += 'PixelCacheMS::PixelCacheMS()\n'
    class_def += '{\n'
    class_def += '    this->name = "pixelCacheMS";\n'
    class_def += '    this->category = Type::PixelCacheCategory;\n'
    class_def += '    this->baseType = TypeCode::PixelCache;\n'
    class_def += '    this->builtin = true;\n'
    class_def += '};\n\n'

    class_decl += 'struct Sampler : public Type\n'
    class_decl += '{\n'
    class_decl += '    Sampler();\n'
    class_decl += '};\n'
    class_decl += 'extern Sampler SamplerType;\n\n'

    class_def = ""
    class_def += 'Sampler::Sampler()\n'
    class_def += '{\n'
    class_def += '    this->name = "sampler"_c;\n'
    class_def += '    this->category = Type::SamplerCategory;\n'
    class_def += '    this->baseType = TypeCode::Sampler;\n'
    class_def += '    this->builtin = true;\n'
    class_def += '};\n\n'

    class_decl += 'struct FunctionPtr : public Type\n'
    class_decl += '{\n'
    class_decl += '    FunctionPtr();\n'
    class_decl += '};\n'
    class_decl += 'extern FunctionPtr FunctionPtrType;\n\n'

    class_def = ""
    class_def += f'FunctionPtr::FunctionPtr()\n'
    class_def += '{\n'
    class_def += '    this->name = "function"_c;\n'
    class_def += '    this->builtin = true;\n'
    class_def += '};\n\n'

    header_file.write(class_decl)
    source_file.write(class_def)

    # Acceleration Structure
    class_decl = ""
    class_decl += 'struct AccelerationStructure : public Type\n'
    class_decl += '{\n'
    class_decl += '    AccelerationStructure();\n'
    class_decl += '};\n'
    class_decl += 'extern AccelerationStructure AccelerationStructureType;\n\n'

    class_def = ""
    class_def += f'AccelerationStructure::AccelerationStructure()\n'
    class_def += '{\n'
    class_def += '    this->name = "accelerationStructure";\n'
    class_def += '    this->category = Type::AccelerationStructureCategory;\n'
    class_def += '    this->baseType = TypeCode::AccelerationStructure;\n'
    class_def += '    this->builtin = true;\n'
    class_def += '};\n\n'

    header_file.write(class_decl)
    source_file.write(class_def)

    class_decl = ""
    class_decl += 'struct Void : public Type\n'
    class_decl += '{\n'
    class_decl += '    Void();\n'
    class_decl += '};\n'
    class_decl += 'extern Void VoidType;\n\n'

    class_def = ""
    class_def += 'Void::Void()\n'
    class_def += '{\n'
    class_def += '    this->name = "void";\n'
    class_def += '    this->category = Type::VoidCategory;\n'
    class_def += '    this->baseType = TypeCode::Void;\n'
    class_def += '    this->builtin = true;\n'
    class_def += '};\n\n' 

    header_file.write(class_decl)
    source_file.write(class_def)

    class_decl = ""
    class_def = ""
    class_decl += 'struct CompareMode : public Enumeration\n'
    class_decl += '{\n'
    class_decl += '    CompareMode();\n'
    class_decl += '};\n'
    class_decl += 'extern CompareMode CompareModeType;\n\n'
    compare_mode_names = [
        'Less',
        'LessEqual',
        'Greater',
        'GreaterEqual',
        'Equal',
        'NotEqual',
        'Always',
        'Never'
    ]
    for name in compare_mode_names:
        class_decl += f'extern EnumExpression CompareMode{name};\n'
        class_def += f'EnumExpression CompareMode{name};\n'
    class_def += 'CompareMode CompareModeType;\n'
    class_def += 'CompareMode::CompareMode()\n'
    class_def += '{\n' 
    class_def += '    this->name = "CompareMode";\n'
    class_def += '    this->category = Type::EnumCategory;\n'
    class_def += '    this->type = Type::FullType{{ UInt32Type.name }};\n'
    class_def += '    Symbol::Resolved(this)->typeSymbol = &UInt32Type;\n'
    class_def += '    this->baseType = TypeCode::UInt;\n'
    class_def += '    this->type.literal = true;\n'
    class_def += '    this->builtin = true;\n'
    for i, name in enumerate(compare_mode_names):
        class_def += f'    CompareMode{name}.value = {hex(i)};\n'
        class_def += f'    CompareMode{name}.type = Type::FullType{{ CompareModeType.name, true }};\n'
        class_def += f'    CompareMode{name}.underlyingType = Type::FullType{{ UInt32Type.name }};\n'
        class_def += f'    Symbol::Resolved(&CompareMode{name})->type = this;\n'
    class_def += '    this->scope.symbolLookup = StaticMap { std::array{\n'
    for name in compare_mode_names:
        class_def += f'        std::pair{{ "{name}"_c, &CompareMode{name} }},\n'
    class_def += '    }};\n'
    class_def += '};\n\n'

    class_decl += 'struct StencilOp : public Enumeration\n'
    class_decl += '{\n'
    class_decl += '    StencilOp();\n'
    class_decl += '};\n'

    stencil_op_names = [
        'Keep', 'Zero', 'Replace', 'Increment', 'Decrement', 'Invert', 'IncrementWrap', 'DecrementWrap'
    ]
    class_decl += 'extern StencilOp StencilOpType;\n\n'
    for name in stencil_op_names:
        class_decl += f'extern EnumExpression StencilOp{name};\n'
        class_def += f'EnumExpression StencilOp{name};\n'
    class_def += 'StencilOp StencilOpType;\n'
    class_def += 'StencilOp::StencilOp()\n'
    class_def += '{\n'
    class_def += '    this->name = "StencilOp";\n'
    class_def += '    this->category = Type::EnumCategory;\n'
    class_def += '    this->type = Type::FullType{{ UInt32Type.name }};\n'
    class_def += '    Symbol::Resolved(this)->typeSymbol = &UInt32Type;\n'
    class_def += '    this->baseType = TypeCode::UInt;\n'
    class_def += '    this->type.literal = true;\n'
    class_def += '    this->builtin = true;\n'

    for i, name in enumerate(stencil_op_names):
        class_def += f'    StencilOp{name}.value = {hex(i)};\n'
        class_def += f'    StencilOp{name}.type = Type::FullType{{ StencilOpType.name, true }};\n'
        class_def += f'    StencilOp{name}.underlyingType = Type::FullType{{ UInt32Type.name }};\n'
        class_def += f'    Symbol::Resolved(&StencilOp{name})->type = this;\n'
    class_def += '    this->scope.symbolLookup = StaticMap { std::array{\n'
    for name in stencil_op_names:
        class_def += f'        std::pair{{ "{name}"_c, &StencilOp{name} }},\n'
    class_def += '    }};\n'
    class_def += '};\n\n'

    class_decl += 'struct ExecutionScope : public Enumeration\n'
    class_decl += '{\n'
    class_decl += '    ExecutionScope();\n'
    class_decl += '};\n'
    class_decl += 'extern ExecutionScope ExecutionScopeType;\n\n'

    execution_scope_names = [
        'Global', 'Device', 'Workgroup', 'Subgroup', 'Invocation', 'Queue'
    ]
    for name in execution_scope_names:
        class_decl += f'extern EnumExpression ExecutionScope{name};\n'
        class_def += f'EnumExpression ExecutionScope{name};\n'
    class_def += 'ExecutionScope ExecutionScopeType;\n'
    class_def += 'ExecutionScope::ExecutionScope()\n'
    class_def += '{\n'
    class_def += '    this->name = "ExecutionScope";\n'
    class_def += '    this->category = Type::EnumCategory;\n'
    class_def += '    this->type = Type::FullType{{ UInt32Type.name }};\n'
    class_def += '    Symbol::Resolved(this)->typeSymbol = &UInt32Type;\n'
    class_def += '    this->baseType = TypeCode::UInt;\n'
    class_def += '    this->type.literal = true;\n'
    class_def += '    this->builtin = true;\n'  
    for i, name in enumerate(execution_scope_names):
        class_def += f'    ExecutionScope{name}.value = {hex(i)};\n'
        class_def += f'    ExecutionScope{name}.type = Type::FullType{{ ExecutionScopeType.name, true }};\n'
        class_def += f'    ExecutionScope{name}.underlyingType = Type::FullType{{ UInt32Type.name }};\n'
        class_def += f'    Symbol::Resolved(&ExecutionScope{name})->type = this;\n'
    class_def += '    this->scope.symbolLookup = StaticMap { std::array{\n'
    for name in execution_scope_names:
        class_def += f'        std::pair{{ "{name}"_c, &ExecutionScope{name} }},\n'
    class_def += '    }};\n'
    class_def += '};\n\n'

    class_decl += 'struct MemorySemantics : public Enumeration\n'
    class_decl += '{\n'
    class_decl += '    MemorySemantics();\n'
    class_decl += '};\n'
    class_decl += 'extern MemorySemantics MemorySemanticsType;\n\n'
    memory_semantics_names = [
        'Acquire', 'Release', 'AcquireRelease', 'SequentiallyConsistent', 'Relaxed'
    ]
    for name in memory_semantics_names:
        class_decl += f'extern EnumExpression MemorySemantics{name};\n'
        class_def += f'EnumExpression MemorySemantics{name};\n'
    class_def += 'MemorySemantics MemorySemanticsType;\n'
    class_def += 'MemorySemantics::MemorySemantics()\n'
    class_def += '{\n'
    class_def += '    this->name = "MemorySemantics";\n'
    class_def += '    this->category = Type::EnumCategory;\n'
    class_def += '    this->type = Type::FullType{{ UInt32Type.name }};\n'
    class_def += '    Symbol::Resolved(this)->typeSymbol = &UInt32Type;\n'
    class_def += '    this->baseType = TypeCode::UInt;\n'
    class_def += '    this->type.literal = true;\n'
    class_def += '    this->builtin = true;\n'
    for i, name in enumerate(memory_semantics_names):
        class_def += f'    MemorySemantics{name}.value = {hex(1 << i)};\n'
        class_def += f'    MemorySemantics{name}.type = Type::FullType{{ MemorySemanticsType.name, true }};\n'
        class_def += f'    MemorySemantics{name}.underlyingType = Type::FullType{{ UInt32Type.name }};\n'
        class_def += f'    Symbol::Resolved(&MemorySemantics{name})->type = this;\n'
    class_def += '    this->scope.symbolLookup = StaticMap { std::array{\n'
    for name in memory_semantics_names:
        class_def += f'        std::pair{{ "{name}"_c, &MemorySemantics{name} }},\n'
    class_def += '    }};\n'
    class_def += '};\n\n'

    class_decl += 'struct PolygonMode : public Enumeration\n'
    class_decl += '{\n'
    class_decl += '    PolygonMode();\n'
    class_decl += '};\n'
    class_decl += 'extern PolygonMode PolygonModeType;\n\n'
    polygon_mode_names = [
        'Fill', 'Line', 'Point'
    ]
    for name in polygon_mode_names:
        class_decl += f'extern EnumExpression PolygonMode{name};\n'
        class_def += f'EnumExpression PolygonMode{name};\n'
    class_def += 'PolygonMode PolygonModeType;\n'
    class_def += 'PolygonMode::PolygonMode()\n'
    class_def += '{\n'
    class_def += '    this->name = "PolygonMode";\n'
    class_def += '    this->category = Type::EnumCategory;\n'
    class_def += '    this->type = Type::FullType{{ UInt32Type.name }};\n'
    class_def += '    Symbol::Resolved(this)->typeSymbol = &UInt32Type;\n'
    class_def += '    this->baseType = TypeCode::UInt;\n'
    class_def += '    this->type.literal = true;\n'
    class_def += '    this->builtin = true;\n'
    for i, name in enumerate(polygon_mode_names):
        class_def += f'    PolygonMode{name}.value = {hex(i)};\n'
        class_def += f'    PolygonMode{name}.type = Type::FullType{{ PolygonModeType.name, true }};\n'
        class_def += f'    PolygonMode{name}.underlyingType = Type::FullType{{ UInt32Type.name }};\n'
        class_def += f'    Symbol::Resolved(&PolygonMode{name})->type = this;\n'
    class_def += '    this->scope.symbolLookup = StaticMap { std::array{\n'
    for name in polygon_mode_names:
        class_def += f'        std::pair{{ "{name}"_c, &PolygonMode{name} }},\n'
    class_def += '    }};\n'
    class_def += '};\n\n'

    class_decl += 'struct CullMode : public Enumeration\n'
    class_decl += '{\n'
    class_decl += '    CullMode();\n'
    class_decl += '};\n'
    class_decl += 'extern CullMode CullModeType;\n\n'
    cull_mode_names = [
        'None', 'Front', 'Back', 'FrontAndBack'
    ]
    for name in cull_mode_names:
        class_decl += f'extern EnumExpression CullMode{name};\n'
        class_def += f'EnumExpression CullMode{name};\n'
    class_def += 'CullMode CullModeType;\n'
    class_def += 'CullMode::CullMode()\n'
    class_def += '{\n'
    class_def += '    this->name = "CullMode";\n'
    class_def += '    this->category = Type::EnumCategory;\n'
    class_def += '    this->type = Type::FullType{{ UInt32Type.name }};\n'
    class_def += '    Symbol::Resolved(this)->typeSymbol = &UInt32Type;\n'
    class_def += '    this->baseType = TypeCode::UInt;\n'
    class_def += '    this->type.literal = true;\n'
    class_def += '    this->builtin = true;\n'
    for i, name in enumerate(cull_mode_names):
        class_def += f'    CullMode{name}.value = {hex(i)};\n'
        class_def += f'    CullMode{name}.type = Type::FullType{{ CullModeType.name, true }};\n'
        class_def += f'    CullMode{name}.underlyingType = Type::FullType{{ UInt32Type.name }};\n'
        class_def += f'    Symbol::Resolved(&CullMode{name})->type = this;\n'
    class_def += '    this->scope.symbolLookup = StaticMap { std::array{\n'
    for name in cull_mode_names:
        class_def += f'        std::pair{{ "{name}"_c, &CullMode{name} }},\n'
    class_def += '    }};\n'
    class_def += '};\n\n'

    class_decl += 'struct WindingOrder : public Enumeration\n'
    class_decl += '{\n'
    class_decl += '    WindingOrder();\n'
    class_decl += '};\n'
    class_decl += 'extern WindingOrder WindingOrderType;\n\n'
    winding_order_names = [
        'Clockwise', 'CounterClockwise'
    ]
    for name in winding_order_names:
        class_decl += f'extern EnumExpression WindingOrder{name};\n'
        class_def += f'EnumExpression WindingOrder{name};\n'
    class_def += 'WindingOrder WindingOrderType;\n'
    class_def += 'WindingOrder::WindingOrder()\n'
    class_def += '{\n'
    class_def += '    this->name = "WindingOrder";\n'
    class_def += '    this->category = Type::EnumCategory;\n'
    class_def += '    this->type = Type::FullType{{ UInt32Type.name }};\n'
    class_def += '    Symbol::Resolved(this)->typeSymbol = &UInt32Type;\n'
    class_def += '    this->baseType = TypeCode::UInt;\n'
    class_def += '    this->type.literal = true;\n'
    class_def += '    this->builtin = true;\n'
    for i, name in enumerate(winding_order_names):
        class_def += f'    WindingOrder{name}.value = {hex(i)};\n'
        class_def += f'    WindingOrder{name}.type = Type::FullType{{ WindingOrderType.name, true }};\n'
        class_def += f'    WindingOrder{name}.underlyingType = Type::FullType{{ UInt32Type.name }};\n'
        class_def += f'    Symbol::Resolved(&WindingOrder{name})->type = this;\n'
    class_def += '    this->scope.symbolLookup = StaticMap { std::array{\n'
    for name in winding_order_names:
        class_def += f'        std::pair{{ "{name}"_c, &WindingOrder{name} }},\n'
    class_def += '    }};\n'
    class_def += '};\n\n'

    class_decl += 'struct LogicOp : public Enumeration\n'
    class_decl += '{\n'
    class_decl += '    LogicOp();\n'
    class_decl += '};\n'
    class_decl += 'extern LogicOp LogicOpType;\n'
    logic_op_names = [
        'And', 'AndInverted', 'AndReverse', 'Clear', 'Copy', 'CopyInverted', 'Equivalence', 'Invert', 'Nand', 'No', 'Nor', 'Or', 'OrInverted', 'OrReverse', 'Set', 'Xor'
    ]
    for name in logic_op_names:
        class_decl += f'extern EnumExpression LogicOp{name};\n'
        class_def += f'EnumExpression LogicOp{name};\n'
    class_def += 'LogicOp LogicOpType;\n'
    class_def += 'LogicOp::LogicOp()\n'
    class_def += '{\n'
    class_def += '    this->name = "LogicOp";\n'
    class_def += '    this->category = Type::EnumCategory;\n'
    class_def += '    this->type = Type::FullType{{ UInt32Type.name }};\n'
    class_def += '    Symbol::Resolved(this)->typeSymbol = &UInt32Type;\n'
    class_def += '    this->baseType = TypeCode::UInt;\n'
    class_def += '    this->type.literal = true;\n'
    class_def += '    this->builtin = true;\n'
    for i, name in enumerate(logic_op_names):
        class_def += f'    LogicOp{name}.value = {hex(i)};\n'
        class_def += f'    LogicOp{name}.type = Type::FullType{{ LogicOpType.name, true }};\n'
        class_def += f'    LogicOp{name}.underlyingType = Type::FullType{{ UInt32Type.name }};\n'
        class_def += f'    Symbol::Resolved(&LogicOp{name})->type = this;\n'
    class_def += '    this->scope.symbolLookup = StaticMap { std::array{\n'
    for name in logic_op_names:
        class_def += f'        std::pair{{ "{name}"_c, &LogicOp{name} }},\n'
    class_def += '    }};\n'
    class_def += '};\n\n'

    class_decl += 'struct BlendFactor : public Enumeration\n'
    class_decl += '{\n'
    class_decl += '    BlendFactor();\n'
    class_decl += '};\n'
    class_decl += 'extern BlendFactor BlendFactorType;\n\n'
    blend_factor_names = [
        'Zero', 'One', 'SourceColor', 'OneMinusSourceColor', 'SourceAlpha', 'OneMinusSourceAlpha',
        'DestinationColor', 'OneMinusDestinationColor', 'DestinationAlpha', 'OneMinusDestinationAlpha', 'ConstantColor',
        'OneMinusConstantColor', 'ConstantAlpha', 'OneMinusConstantAlpha'
    ]
    for name in blend_factor_names:
        class_decl += f'extern EnumExpression BlendFactor{name};\n'
        class_def += f'EnumExpression BlendFactor{name};\n'
    class_def += 'BlendFactor BlendFactorType;\n'
    class_def += 'BlendFactor::BlendFactor()\n'
    class_def += '{\n'
    class_def += '    this->name = "BlendFactor";\n'
    class_def += '    this->category = Type::EnumCategory;\n'
    class_def += '    this->type = Type::FullType{{ UInt32Type.name }};\n'
    class_def += '    Symbol::Resolved(this)->typeSymbol = &UInt32Type;\n'
    class_def += '    this->baseType = TypeCode::UInt;\n'
    class_def += '    this->type.literal = true;\n'
    class_def += '    this->builtin = true;\n'
    for i, name in enumerate(blend_factor_names):
        class_def += f'    BlendFactor{name}.value = {hex(i)};\n'
        class_def += f'    BlendFactor{name}.type = Type::FullType{{ BlendFactorType.name, true }};\n'
        class_def += f'    BlendFactor{name}.underlyingType = Type::FullType{{ UInt32Type.name }};\n'
        class_def += f'    Symbol::Resolved(&BlendFactor{name})->type = this;\n'
    class_def += '    this->scope.symbolLookup = StaticMap { std::array{\n'
    for name in blend_factor_names:
        class_def += f'        std::pair{{ "{name}"_c, &BlendFactor{name} }},\n'
    class_def += '    }};\n'
    class_def += '};\n\n'

    class_decl += 'struct BlendOperation : public Enumeration\n'
    class_decl += '{\n'
    class_decl += '    BlendOperation();\n'
    class_decl += '};\n'
    class_decl += 'extern BlendOperation BlendOperationType;\n\n'
    blend_operation_names = [
        'Add', 'Subtract', 'ReverseSubtract', 'Min', 'Max'
    ]
    for name in blend_operation_names:
        class_decl += f'extern EnumExpression BlendOperation{name};\n'
        class_def += f'EnumExpression BlendOperation{name};\n'
    class_def += 'BlendOperation BlendOperationType;\n'
    class_def += 'BlendOperation::BlendOperation()\n'
    class_def += '{\n'
    class_def += '    this->name = "BlendOperation";\n'
    class_def += '    this->category = Type::EnumCategory;\n'
    class_def += '    this->type = Type::FullType{{ UInt32Type.name }};\n'
    class_def += '    Symbol::Resolved(this)->typeSymbol = &UInt32Type;\n'
    class_def += '    this->baseType = TypeCode::UInt;\n'
    class_def += '    this->type.literal = true;\n'
    class_def += '    this->builtin = true;\n'
    for i, name in enumerate(blend_operation_names):
        class_def += f'    BlendOperation{name}.value = {hex(i)};\n'
        class_def += f'    BlendOperation{name}.type = Type::FullType{{ BlendOperationType.name, true }};\n'
        class_def += f'    BlendOperation{name}.underlyingType = Type::FullType{{ UInt32Type.name }};\n'
        class_def += f'    Symbol::Resolved(&BlendOperation{name})->type = this;\n'
    class_def += '    this->scope.symbolLookup = StaticMap { std::array{\n'
    for name in blend_operation_names:
        class_def += f'        std::pair{{ "{name}"_c, &BlendOperation{name} }},\n'
    class_def += '    }};\n'
    class_def += '};\n\n'

    class_decl += 'struct BlendColorMask : public Enumeration\n'
    class_decl += '{\n'
    class_decl += '    BlendColorMask();\n'
    class_decl += '};\n'
    class_decl += 'extern BlendColorMask BlendColorMaskType;\n\n'
    blend_color_mask_names = [
        'None', 'R', 'RG', 'RGB', 'RGBA'
    ]
    for name in blend_color_mask_names:
        class_decl += f'extern EnumExpression BlendColorMask{name};\n'
        class_def += f'EnumExpression BlendColorMask{name};\n'
    class_def += 'BlendColorMask BlendColorMaskType;\n'
    class_def += 'BlendColorMask::BlendColorMask()\n'
    class_def += '{\n'
    class_def += '    this->name = "BlendColorMask";\n' 
    class_def += '    this->category = Type::EnumCategory;\n'
    class_def += '    this->type = Type::FullType{{ UInt32Type.name }};\n'
    class_def += '    Symbol::Resolved(this)->typeSymbol = &UInt32Type;\n'
    class_def += '    this->baseType = TypeCode::UInt;\n'
    class_def += '    this->type.literal = true;\n'
    class_def += '    this->builtin = true;\n'
    for i, name in enumerate(blend_color_mask_names):
        class_def += f'    BlendColorMask{name}.value = {hex(i)};\n'
        class_def += f'    BlendColorMask{name}.type = Type::FullType{{ BlendColorMaskType.name, true }};\n'
        class_def += f'    BlendColorMask{name}.underlyingType = Type::FullType{{ UInt32Type.name }};\n'
        class_def += f'    Symbol::Resolved(&BlendColorMask{name})->type = this;\n'
    class_def += '    this->scope.symbolLookup = StaticMap { std::array{\n'
    for name in blend_color_mask_names:
        class_def += f'        std::pair{{ "{name}"_c, &BlendColorMask{name} }},\n'
    class_def += '    }};\n'
    class_def += '};\n\n'

    class_decl += 'struct FilterMode : public Enumeration\n'
    class_decl += '{\n'
    class_decl += '    FilterMode();\n'
    class_decl += '};\n'
    class_decl += 'extern FilterMode FilterModeType;\n\n'
    filter_mode_names = [
        'Point', 'Linear', 'MinMagMipmapLinear', 'MinMagLinearMipPoint', 'MinLinearMagMipPoint', 'MinMagMipPoint', 'MinMagPointMipLinear', 'MinPointMagMipLinear', 'MinLinearMagPointMipLinear', 'MinPointMagLinearMipPoint'
    ]
    for name in filter_mode_names:
        class_decl += f'extern EnumExpression FilterMode{name};\n'
        class_def += f'EnumExpression FilterMode{name};\n'
    class_def += 'FilterMode FilterModeType;\n'
    class_def += 'FilterMode::FilterMode()\n'
    class_def += '{\n'
    class_def += '    this->name = "FilterMode";\n'
    class_def += '    this->category = Type::EnumCategory;\n'
    class_def += '    this->type = Type::FullType{{ UInt32Type.name }};\n'
    class_def += '    Symbol::Resolved(this)->typeSymbol = &UInt32Type;\n'
    class_def += '    this->baseType = TypeCode::UInt;\n'
    class_def += '    this->type.literal = true;\n'
    class_def += '    this->builtin = true;\n'
    for i, name in enumerate(filter_mode_names):
        class_def += f'    FilterMode{name}.value = {hex(i)};\n'
        class_def += f'    FilterMode{name}.type = Type::FullType{{ FilterModeType.name, true }};\n'
        class_def += f'    FilterMode{name}.underlyingType = Type::FullType{{ UInt32Type.name }};\n'
        class_def += f'    Symbol::Resolved(&FilterMode{name})->type = this;\n'
    class_def += '    this->scope.symbolLookup = StaticMap { std::array{\n'
    for name in filter_mode_names:
        class_def += f'        std::pair{{ "{name}"_c, &FilterMode{name} }},\n'
    class_def += '    }};\n'
    class_def += '};\n\n'

    class_decl += 'struct AddressMode : public Enumeration\n'
    class_decl += '{\n'
    class_decl += '    AddressMode();\n'
    class_decl += '};\n'
    class_decl += 'extern AddressMode AddressModeType;\n\n'
    address_mode_names = [
        'Repeat', 'Mirror', 'Clamp', 'Border'
    ]
    for name in address_mode_names:
        class_decl += f'extern EnumExpression AddressMode{name};\n'
        class_def += f'EnumExpression AddressMode{name};\n'
    class_def += 'AddressMode AddressModeType;\n'
    class_def += 'AddressMode::AddressMode()\n'
    class_def += '{\n'
    class_def += '    this->name = "AddressMode";\n'
    class_def += '    this->category = Type::EnumCategory;\n'
    class_def += '    this->type = Type::FullType{{ UInt32Type.name }};\n'
    class_def += '    Symbol::Resolved(this)->typeSymbol = &UInt32Type;\n'
    class_def += '    this->baseType = TypeCode::UInt;\n'
    class_def += '    this->type.literal = true;\n'
    class_def += '    this->builtin = true;\n'
    for i, name in enumerate(address_mode_names):
        class_def += f'    AddressMode{name}.value = {hex(i)};\n'
        class_def += f'    AddressMode{name}.type = Type::FullType{{ AddressModeType.name, true }};\n'
        class_def += f'    AddressMode{name}.underlyingType = Type::FullType{{ UInt32Type.name }};\n'
        class_def += f'    Symbol::Resolved(&AddressMode{name})->type = this;\n'
    class_def += '    this->scope.symbolLookup = StaticMap { std::array{\n'
    for name in address_mode_names:
        class_def += f'        std::pair{{ "{name}"_c, &AddressMode{name} }},\n'
    class_def += '    }};\n'
    class_def += '};\n\n'

    class_decl += 'struct BorderColor : public Enumeration\n'
    class_decl += '{\n'
    class_decl += '    BorderColor();\n'
    class_decl += '};\n'
    class_decl += 'extern BorderColor BorderColorType;\n\n'
    border_color_names = [
        'Transparent', 'Black', 'White'
    ]
    for name in border_color_names:
        class_decl += f'extern EnumExpression BorderColor{name};\n'
        class_def += f'EnumExpression BorderColor{name};\n'
    class_def += 'BorderColor BorderColorType;\n'
    class_def += 'BorderColor::BorderColor()\n'
    class_def += '{\n'
    class_def += '    this->name = "BorderColor";\n'
    class_def += '    this->category = Type::EnumCategory;\n'
    class_def += '    this->type = Type::FullType{{ UInt32Type.name }};\n'
    class_def += '    Symbol::Resolved(this)->typeSymbol = &UInt32Type;\n'
    class_def += '    this->baseType = TypeCode::UInt;\n'
    class_def += '    this->type.literal = true;\n'
    class_def += '    this->builtin = true;\n'
    for i, name in enumerate(border_color_names):
        class_def += f'    BorderColor{name}.value = {hex(i)};\n'
        class_def += f'    BorderColor{name}.type = Type::FullType{{ BorderColorType.name, true }};\n'
        class_def += f'    BorderColor{name}.underlyingType = Type::FullType{{ UInt32Type.name }};\n'
        class_def += f'    Symbol::Resolved(&BorderColor{name})->type = this;\n'
    class_def += '    this->scope.symbolLookup = StaticMap { std::array{\n'
    for name in border_color_names:
        class_def += f'        std::pair{{ "{name}"_c, &BorderColor{name} }},\n'
    class_def += '    }};\n'
    class_def += '};\n\n'
    class_decl += '\n'

    class StateMember:
        def __init__(self, name, data_type, array_size=1):
            self.name = name
            self.data_type = data_type
            self.array_size = array_size

    class_decl += 'struct StencilState : public Type\n'
    class_decl += '{\n'
    class_decl += '    StencilState();\n'
    class_decl += '};\n'
    class_decl += 'extern StencilState StencilStateType;\n'

    stencil_state_members = [
        StateMember('Fail', 'StencilOp'),
        StateMember('Pass', 'StencilOp'),
        StateMember('DepthFail', 'StencilOp'),
        StateMember('CompareFunction', 'CompareMode'),
        StateMember('CompareMask', 'UInt32'),
        StateMember('WriteMask', 'UInt32'),
        StateMember('Reference', 'UInt32'),
    ]
    for member in stencil_state_members:
        class_decl += f'extern Variable StencilState{member.name};\n'
        class_def += f'Variable StencilState{member.name};\n'

    class_def += 'StencilState StencilStateType;\n'
    class_def += 'StencilState::StencilState()\n'
    class_def += '{\n'
    class_def += '    this->name = "StencilState";\n'
    class_def += '    this->category = Type::UserTypeCategory;\n'
    class_def += '    this->builtin = true;\n'
    for member in stencil_state_members:
        class_def += f'    StencilState{member.name}.name = "{member.name}"_c;\n'
        class_def += f'    StencilState{member.name}.type = Type::FullType{{ {member.data_type}Type.name }};\n'
        class_def += f'    Symbol::Resolved(&StencilState{member.name})->typeSymbol = &{member.data_type}Type;\n\n'
    class_def += '    this->scope.symbolLookup = StaticMap { std::array{\n'
    for member in stencil_state_members:
        class_def += f'        std::pair{{ "{member.name}"_c, &StencilState{member.name} }},\n'
    class_def += '    }};\n'
    class_def += '};\n\n'
    class_decl += '\n'

    class_decl += 'struct RenderState : public Type\n'
    class_decl += '{\n'
    class_decl += '    RenderState();\n'
    class_decl += '};\n'
    class_decl += 'extern RenderState RenderStateType;\n'

    render_state_members = [ 
        StateMember('DepthClampEnabled', 'Bool8'),
        StateMember('DepthTestEnabled', 'Bool8'),
        StateMember('DepthWriteEnabled', 'Bool8'),
        StateMember('DepthBiasEnabled', 'Bool8'),
        StateMember('DepthBiasConstantFactor', 'Float32'),
        StateMember('DepthBiasClamp', 'Float32'),
        StateMember('DepthBiasSlopeFactor', 'Float32'),
        StateMember('DepthTestFunction', 'CompareMode'),
        StateMember('DepthBoundsTestEnabled', 'Bool8'),
        StateMember('DepthBoundsMin', 'Float32'),
        StateMember('DepthBoundsMax', 'Float32'),
        StateMember('NoRasterization', 'Bool8'),
        StateMember('PolygonMode', 'PolygonMode'),
        StateMember('CullMode', 'CullMode'),
        StateMember('WindingOrder', 'WindingOrder'),
        StateMember('StencilEnabled', 'Bool8'),
        StateMember('StencilFront', 'StencilState'),
        StateMember('StencilBack', 'StencilState'),
        StateMember('LogicOpEnabled', 'Bool8'),
        StateMember('LogicOp', 'LogicOp'),
        StateMember('BlendEnabled', 'Bool8', 8),
        StateMember('SourceBlend', 'BlendFactor', 8),
        StateMember('DestinationBlend', 'BlendFactor', 8),
        StateMember('SourceAlphaBlend', 'BlendFactor', 8),
        StateMember('DestinationAlphaBlend', 'BlendFactor', 8),
        StateMember('ColorBlendOp', 'BlendOperation', 8),
        StateMember('AlphaBlendOp', 'BlendOperation', 8),
        StateMember('Mask', 'BlendColorMask', 8),
    ]
    for member in render_state_members:
        class_decl += f'extern Variable RenderState{member.name};\n'
        class_def += f'Variable RenderState{member.name};\n'
        if member.array_size > 1:
            class_decl += f'extern IntExpression RenderState{member.name}ArraySize;\n'
            class_def += f'IntExpression RenderState{member.name}ArraySize({member.array_size});\n'

    class_def += 'RenderState RenderStateType;\n'
    class_def += 'RenderState::RenderState()\n'
    class_def += '{\n'
    class_def += '    this->name = "RenderState";\n'
    class_def += '    this->category = Type::UserTypeCategory;\n'
    class_def += '    this->builtin = true;\n'
    for member in render_state_members:
        class_def += f'    RenderState{member.name}.name = "{member.name}"_c;\n'
        if member.array_size > 1:
            class_def += f'    RenderState{member.name}.type = Type::FullType{{ {member.data_type}Type.name, {{Type::FullType::Modifier::Array}}, {{&RenderState{member.name}ArraySize}} }};\n'
        else:
            class_def += f'    RenderState{member.name}.type = Type::FullType{{ {member.data_type}Type.name }};\n'
        class_def += f'    Symbol::Resolved(&RenderState{member.name})->typeSymbol = &{member.data_type}Type;\n\n'
    class_def += '    this->scope.symbolLookup = StaticMap { std::array{\n'
    for member in render_state_members:
        class_def += f'        std::pair{{ "{member.name}"_c, &RenderState{member.name} }},\n'
    class_def += '    }};\n'
    class_def += '};\n\n'
    class_decl += '\n'

    class_decl += 'struct SamplerState : public Type\n'
    class_decl += '{\n'
    class_decl += '    SamplerState();\n'
    class_decl += '};\n'
    class_decl += 'extern SamplerState SamplerStateType;\n'

    sampler_state_members = [
        StateMember('Address', 'AddressMode'),
        StateMember('AddressU', 'AddressMode'),
        StateMember('AddressV', 'AddressMode'),
        StateMember('AddressW', 'AddressMode'),
        StateMember('Filter', 'FilterMode'),
        StateMember('MinFilter', 'FilterMode'),
        StateMember('MagFilter', 'FilterMode'),
        StateMember('MipFilter', 'FilterMode'),
        StateMember('MipLodBias', 'Float32'),
        StateMember('AnisotropyEnabled', 'Bool8'),
        StateMember('MaxAnisotropy', 'UInt32'),
        StateMember('CompareEnabled', 'Bool8'),
        StateMember('CompareFunction', 'CompareMode'),
        StateMember('MinLod', 'Float32'),
        StateMember('MaxLod', 'Float32'),
        StateMember('BorderColor', 'BorderColor'),
        StateMember('UnnormalizedSamplingEnabled', 'Bool8')
    ]
    for member in sampler_state_members:
        class_decl += f'extern Variable SamplerState{member.name};\n'
        class_def += f'Variable SamplerState{member.name};\n'

    class_decl += '\n'

    class_def += 'SamplerState SamplerStateType;\n'
    class_def += 'SamplerState::SamplerState()\n'
    class_def += '{\n'
    class_def += '    this->name = "SamplerState";\n'
    class_def += '    this->category = Type::UserTypeCategory;\n'
    class_def += '    this->builtin = true;\n'
    for member in sampler_state_members:
        class_def += f'    SamplerState{member.name}.name = "{member.name}"_c;\n'
        class_def += f'    SamplerState{member.name}.type = Type::FullType{{ {member.data_type}Type.name }};\n'
        class_def += f'    Symbol::Resolved(&SamplerState{member.name})->typeSymbol = &{member.data_type}Type;\n\n'
    class_def += '    this->scope.symbolLookup = StaticMap { std::array{\n'
    for member in sampler_state_members:
        class_def += f'        std::pair{{ "{member.name}"_c, &SamplerState{member.name} }},\n'
    class_def += '    }};\n'
    class_def += '};\n\n' 


    class_decl += 'struct Program : public Type\n'
    class_decl += '{\n'
    class_decl += '    Program();\n'
    class_decl += '};\n'
    class_decl += 'extern Program ProgramType;\n'

    program_members = [
        StateMember('VertexShader', 'FunctionPtr'),
        StateMember('HullShader', 'FunctionPtr'),
        StateMember('DomainShader', 'FunctionPtr'),
        StateMember('GeometryShader', 'FunctionPtr'),
        StateMember('PixelShader', 'FunctionPtr'),
        StateMember('ComputeShader', 'FunctionPtr'),
        StateMember('TaskShader', 'FunctionPtr'),
        StateMember('MeshShader', 'FunctionPtr'),
        StateMember('RayGenerationShader', 'FunctionPtr'),
        StateMember('RayAnyHitShader', 'FunctionPtr'),
        StateMember('RayClosestHitShader', 'FunctionPtr'),
        StateMember('RayMissShader', 'FunctionPtr'),
        StateMember('RayIntersectionShader', 'FunctionPtr'),
        StateMember('RayCallableShader', 'FunctionPtr'),
        StateMember('RenderState', 'RenderState'),
    ]
    for member in program_members:
        class_decl += f'extern Variable Program{member.name};\n'
        class_def += f'Variable Program{member.name};\n'


    class_def += 'Program ProgramType;\n'
    class_def += 'Program::Program()\n'
    class_def += '{\n'
    class_def += '    this->name = "Program";\n'
    class_def += '    this->category = Type::UserTypeCategory;\n'
    class_def += '    this->builtin = true;\n'
    for member in program_members:
        class_def += f'    Program{member.name}.name = "{member.name}"_c;\n'
        class_def += f'    Program{member.name}.type = Type::FullType{{ {member.data_type}Type.name }};\n'
        class_def += f'    Symbol::Resolved(&Program{member.name})->typeSymbol = &{member.data_type}Type;\n\n'
    class_def += '    this->scope.symbolLookup = StaticMap { std::array{\n'
    for member in program_members:
        class_def += f'        std::pair{{ "{member.name}"_c, &Program{member.name} }},\n'
    class_def += '    }};\n'
    class_def += '};\n\n' 

    header_file.write(class_decl)
    source_file.write(class_def)

    header_file.write('} // namespace GPULang\n\n')
    source_file.write('} // namespace GPULang\n\n')

    ### Intrinsics
    intrinsics_header = open("../generated/intrinsics.h", "w")
    intrinsics_source = open("../generated/intrinsics.cc", "w")

    float_types = ['Float32', 'Float32x2', 'Float32x3', 'Float32x4', 'Float16', 'Float16x2', 'Float16x3', 'Float16x4']
    integer_types = ['Int32', 'Int32x2', 'Int32x3', 'Int32x4', 'Int16', 'Int16x2', 'Int16x3', 'Int16x4', 'UInt32', 'UInt32x2', 'UInt32x3', 'UInt32x4', 'UInt16', 'UInt16x2', 'UInt16x3', 'UInt16x4']
    scalar_types = float_types + integer_types
    float_vec_types = ['Float32x2', 'Float32x3', 'Float32x4', 'Float16x2', 'Float16x3', 'Float16x4']
    signed_types = ['Int32', 'Int32x2', 'Int32x3', 'Int32x4', 'Int16', 'Int16x2', 'Int16x3', 'Int16x4', 'Float32', 'Float32x2', 'Float32x3', 'Float32x4', 'Float16', 'Float16x2', 'Float16x3', 'Float16x4']
    bool_types = ['Bool8', 'Bool8x2', 'Bool8x3', 'Bool8x4']

    vector_sizes = {
        'Float32': 1, 'Float32x2': 2, 'Float32x3': 3, 'Float32x4': 4,
        'Float16': 1, 'Float16x2': 2, 'Float16x3': 3, 'Float16x4': 4,
        'Int32': 1, 'Int32x2': 2, 'Int32x3': 3, 'Int32x4': 4,
        'Int16': 1, 'Int16x2': 2, 'Int16x3': 3, 'Int16x4': 4,
        'UInt32': 1, 'UInt32x2': 2, 'UInt32x3': 3, 'UInt32x4': 4,
        'UInt16': 1, 'UInt16x2': 2, 'UInt16x3': 3, 'UInt16x4': 4,
        'Bool8': 1, 'Bool8x2': 2, 'Bool8x3': 3, 'Bool8x4': 4
    }

    intrinsics_header.write("//-------------------------------------------------\n")
    intrinsics_header.write("// *** Generated by type_gen.py. ***\n")
    intrinsics_header.write("//       DO NOT MODIFY!!!\n")
    intrinsics_header.write("//-------------------------------------------------\n")
    intrinsics_header.write('namespace GPULang\n')
    intrinsics_header.write('{\n')

    intrinsics_source.write("//-------------------------------------------------\n")
    intrinsics_source.write("// *** Generated by type_gen.py. ***\n")
    intrinsics_source.write("//       DO NOT MODIFY!!!\n")
    intrinsics_source.write("//-------------------------------------------------\n")
    intrinsics_source.write('#include "ast/function.h"\n')
    intrinsics_source.write('#include "ast/variable.h"\n')
    intrinsics_source.write('#include "types.h"\n')

    intrinsics_source.write('namespace GPULang\n')
    intrinsics_source.write('{\n')

    intrinsic_decls = ''
    intrinsic_defs = ''
    intrinsic_setup = ''


    float_only_single_argument_intrinsics = [
        'acos', 'acosh', 'asin', 'asinh', 'atan', 'atanh', 'cos', 'cosh', 'exp',
        'exp2', 'invSqrt', 'log', 'log2', 'sin', 'sinh', 'sqrt', 'tan', 'tanh'
    ]

    float_only_single_argument_spirv_intrinsics = [
        'Acos', 'Acosh', 'Asin', 'Asinh', 'Atan', 'Atanh', 'Cos', 'Cosh', 'Exp',
        'Exp2', 'InverseSqrt', 'Log', 'Log2', 'Sin', 'Sinh', 'Sqrt', 'Tan', 'Tanh'
    ]

    for intrinsic, spirv_op in zip(float_only_single_argument_intrinsics, float_only_single_argument_spirv_intrinsics):
        for type in float_types:
            function_name = f'{intrinsic}_{type}'
            argument_name = f'{function_name}_arg'
            fun = Function(
                decl_name = function_name,
                api_name = intrinsic,
                return_type = type,
                parameters = [Variable(decl_name = argument_name, api_name = "val", type_name=type)],
                
            )
            intrinsic_decls += fun.declaration()
            intrinsic_defs += fun.definition()
            intrinsic_setup += fun.setup()
            intrinsic_list.append(fun.pair())

            spirv_function = ''
            spirv_function += '    SPIRVResult arg = LoadValueSPIRV(c, g, args[0]);\n'
            spirv_function += f'    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), {spirv_op}, arg);\n'
            spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
            spirv_code += spirv_intrinsic(function_name, spirv_function)

    # Atan2
    for type in float_types:
        function_name = f'atan2_{type}'
        y_name = f'atan2_{type}_y'
        x_name = f'atan2_{type}_x'
        fun = Function(
                decl_name = function_name,
                api_name = intrinsic,
                return_type = type,
                parameters = [
                    Variable(decl_name = y_name, api_name = "y", type_name=type),
                    Variable(decl_name = x_name, api_name = "x", type_name=type)
                ]
            )
        intrinsic_decls += fun.declaration()
        intrinsic_defs += fun.definition()
        intrinsic_setup += fun.setup()
        intrinsic_list.append(fun.pair())

        spirv_function = ''
        spirv_function += '    SPIRVResult y = LoadValueSPIRV(c, g, args[0]);\n'
        spirv_function += '    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);\n'
        spirv_function += '    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Atan2, y, x);\n'
        spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
        spirv_code += spirv_intrinsic(function_name, spirv_function)
        
    # Pow
    for type in float_types:
        intrinsic = 'pow'
        function_name = f'{intrinsic}_{type}'
        argument_name = f'{function_name}_arg'
        exponent_name = f'{function_name}_exp'
        fun = Function(
            decl_name = function_name,
            api_name = intrinsic,
            return_type = type,
            parameters = [
                Variable(decl_name = argument_name, api_name = "val", type_name=type),
                Variable(decl_name = exponent_name, api_name = "exponent", type_name=type)
            ]
        )
        intrinsic_decls += fun.declaration()
        intrinsic_defs += fun.definition()
        intrinsic_setup += fun.setup()
        intrinsic_list.append(fun.pair())

        spirv_function = ''
        spirv_function += '    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);\n'
        spirv_function += '    SPIRVResult exponent = LoadValueSPIRV(c, g, args[1]);\n'
        spirv_function += '    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Pow, val, exponent);\n'
        spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
        spirv_code += spirv_intrinsic(function_name, spirv_function)

    # Mad
    for type in scalar_types:
        intrinsic = 'mad'
        function_name = f'{intrinsic}_{type}'
        argument_name = f'{function_name}_arg'
        multiplier_name = f'{function_name}_mul'
        addend_name = f'{function_name}_add'

        fun = Function(
            decl_name = function_name,
            api_name = intrinsic,
            return_type = type,
            parameters = [
                Variable(decl_name = argument_name, api_name = "val", type_name=type),
                Variable(decl_name = multiplier_name, api_name = "multiplier", type_name=type),
                Variable(decl_name = addend_name, api_name = "addend", type_name=type)
            ]
        )
        intrinsic_decls += fun.declaration()
        intrinsic_defs += fun.definition()
        intrinsic_setup += fun.setup()
        intrinsic_list.append(fun.pair())

        spirv_function = ''
        spirv_function += '    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);\n'
        spirv_function += '    SPIRVResult multiplicant = LoadValueSPIRV(c, g, args[1]);\n'
        spirv_function += '    SPIRVResult addend = LoadValueSPIRV(c, g, args[2]);\n'
        spirv_function += '    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Fma, val, multiplicant, addend);\n'
        spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
        spirv_code += spirv_intrinsic(function_name, spirv_function)

    # Dot
    for type in float_vec_types:
        intrinsic = 'dot'
        function_name = f'{intrinsic}_{type}'
        x_name = f'{function_name}_x'
        y_name = f'{function_name}_y'

        fun = Function(
            decl_name = function_name,
            api_name = intrinsic,
            return_type = type,
            parameters = [
                Variable(decl_name = x_name, api_name = "x", type_name=type),
                Variable(decl_name = y_name, api_name = "y", type_name=type)
            ]
        )
        intrinsic_decls += fun.declaration()
        intrinsic_defs += fun.definition()
        intrinsic_setup += fun.setup()
        intrinsic_list.append(fun.pair())

        spirv_function = ''
        spirv_function += '    SPIRVResult x = LoadValueSPIRV(c, g, args[0]);\n'
        spirv_function += '    SPIRVResult y = LoadValueSPIRV(c, g, args[1]);\n'
        spirv_function += '    uint32_t ret = g->writer->MappedInstruction(OpDot, SPVWriter::Section::LocalFunction, returnType, x, y);\n'
        spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
        spirv_code += spirv_intrinsic(function_name, spirv_function)

    # Reflect
    for type in float_vec_types:
        intrinsic = 'reflect'
        function_name = f'{intrinsic}_{type}'
        incident_name = f'{function_name}_incident'
        normal_name = f'{function_name}_normal'

        fun = Function(
            decl_name = function_name,
            api_name = intrinsic,
            return_type = type,
            parameters = [
                Variable(decl_name = incident_name, api_name = "incident", type_name=type),
                Variable(decl_name = normal_name, api_name = "normal", type_name=type)
            ]
        )
        intrinsic_decls += fun.declaration()
        intrinsic_defs += fun.definition()
        intrinsic_setup += fun.setup()
        intrinsic_list.append(fun.pair())

        spirv_function = ''
        spirv_function += '    SPIRVResult incident = LoadValueSPIRV(c, g, args[0]);\n'
        spirv_function += '    SPIRVResult normal = LoadValueSPIRV(c, g, args[1]);\n'
        spirv_function += '    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Reflect, incident, normal);\n'
        spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
        spirv_code += spirv_intrinsic(function_name, spirv_function)

    # Refract
    for type in float_vec_types:
        intrinsic = 'refract'
        function_name = f'{intrinsic}_{type}'
        incident_name = f'{function_name}_incident'
        normal_name = f'{function_name}_normal'
        ior_name = f'{function_name}_ior'
        fun = Function(
            decl_name = function_name,
            api_name = intrinsic,
            return_type = type,
            parameters = [
                Variable(decl_name = incident_name, api_name = "incident", type_name=type),
                Variable(decl_name = normal_name, api_name = "normal", type_name=type),
                Variable(decl_name = ior_name, api_name = "ior", type_name=type)
            ]
        )
        intrinsic_decls += fun.declaration()
        intrinsic_defs += fun.definition()
        intrinsic_setup += fun.setup()
        intrinsic_list.append(fun.pair())

        spirv_function = ''
        spirv_function += '    SPIRVResult incident = LoadValueSPIRV(c, g, args[0]);\n'
        spirv_function += '    SPIRVResult normal = LoadValueSPIRV(c, g, args[1]);\n'
        spirv_function += '    SPIRVResult ior = LoadValueSPIRV(c, g, args[2]);\n'
        spirv_function += '    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Refract, incident, normal, ior);\n'
        spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
        spirv_code += spirv_intrinsic(function_name, spirv_function)

    # Cross
    cross_product_types = ['Float32x3', 'Float16x3']
    intrinsic = 'cross'
    for type in cross_product_types:
        function_name = f'{intrinsic}_{type}'
        v0_name = f'{function_name}_v0'
        v1_name = f'{function_name}_v1'
        fun = Function(
            decl_name = function_name,
            api_name = intrinsic,
            return_type = type,
            parameters = [
                Variable(decl_name = v0_name, api_name = "v0", type_name=type),
                Variable(decl_name = v1_name, api_name = "v1", type_name=type)
            ]
        )
        intrinsic_decls += fun.declaration()
        intrinsic_defs += fun.definition()
        intrinsic_setup += fun.setup()
        intrinsic_list.append(fun.pair())

        spirv_function = ''
        spirv_function += '    SPIRVResult x = LoadValueSPIRV(c, g, args[0]);\n'
        spirv_function += '    SPIRVResult y = LoadValueSPIRV(c, g, args[1]);\n'
        spirv_function += '    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Cross, x, y);\n'
        spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
        spirv_code += spirv_intrinsic(function_name, spirv_function)

    # Length & Normalize
    ops = ['length', 'normalize']
    spirv_ops = ['Length', 'Normalize']
    for op, spirv_op in zip(ops, spirv_ops):
        for type in float_vec_types:
            function_name = f'{op}_{type}'
            argument_name = f'{function_name}_arg'

            fun = Function(
                decl_name = function_name,
                api_name = intrinsic,
                return_type = type,
                parameters = [
                    Variable(decl_name = argument_name, api_name = "val", type_name=type)
                ]
            )
            intrinsic_decls += fun.declaration()
            intrinsic_defs += fun.definition()
            intrinsic_setup += fun.setup()
            intrinsic_list.append(fun.pair())

            spirv_function = ''
            spirv_function += '    SPIRVResult vec = LoadValueSPIRV(c, g, args[0]);\n'    
            spirv_function += f'    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), {spirv_op}, vec);\n'
            spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
            spirv_code += spirv_intrinsic(function_name, spirv_function)

    # Distance
    for type in float_vec_types:
        intrinsic = 'distance'
        function_name = f'{intrinsic}_{type}'
        p0_name = f'{function_name}_p0'
        p1_name = f'{function_name}_p1'
        fun = Function(
            decl_name = function_name,
            api_name = intrinsic,
            return_type = type,
            parameters = [
                Variable(decl_name = p0_name, api_name = "p0", type_name=type),
                Variable(decl_name = p1_name, api_name = "p1", type_name=type)
            ]
        )
        intrinsic_decls += fun.declaration()
        intrinsic_defs += fun.definition()
        intrinsic_setup += fun.setup()
        intrinsic_list.append(fun.pair())

        spirv_function = ''
        spirv_function += '    SPIRVResult v0 = LoadValueSPIRV(c, g, args[0]);\n'    
        spirv_function += '    SPIRVResult v1 = LoadValueSPIRV(c, g, args[1]);\n'    
        spirv_function += '    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Distance, v0, v1);\n'
        spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
        spirv_code += spirv_intrinsic(function_name, spirv_function)

    # Min & Max
    ops = ['min', 'max']
    spirv_ops = ['Min', 'Max']
    for op, spirv_op in zip(ops, spirv_ops):
        for type in scalar_types:
            function_name = f'{op}_{type}'
            x_name = f'{function_name}_x'
            y_name = f'{function_name}_y'
            fun = Function(
                decl_name = function_name,
                api_name = intrinsic,
                return_type = type,
                parameters = [
                    Variable(decl_name = x_name, api_name = "x", type_name=type),
                    Variable(decl_name = y_name, api_name = "y", type_name=type)
                ]
            )
            intrinsic_decls += fun.declaration()
            intrinsic_defs += fun.definition()
            intrinsic_setup += fun.setup()
            intrinsic_list.append(fun.pair())

            if  type.startswith('Float'):
                spirv_op_type = 'F'
            elif type.startswith('Int'):
                spirv_op_type = 'S'
            elif type.startswith('UInt'):
                spirv_op_type = 'U'
            spirv_function = ''
            spirv_function += '    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);\n'    
            spirv_function += '    SPIRVResult limit = LoadValueSPIRV(c, g, args[1]);\n'    
            spirv_function += f'    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), {spirv_op_type}{spirv_op}, val, limit);\n'
            spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
            spirv_code += spirv_intrinsic(function_name, spirv_function)

    # Clamp
    for type in scalar_types:
        intrinsic = 'clamp'
        function_name = f'{intrinsic}_{type}'
        value_name = f'{function_name}_val'
        min_name = f'{function_name}_min'
        max_name = f'{function_name}_max'
        fun = Function(
            decl_name = function_name,
            api_name = intrinsic,
            return_type = type,
            parameters = [
                Variable(decl_name = value_name, api_name = "val", type_name=type),
                Variable(decl_name = min_name, api_name = "min", type_name=type),
                Variable(decl_name = max_name, api_name = "max", type_name=type)
            ]
        )
        intrinsic_decls += fun.declaration()
        intrinsic_defs += fun.definition()
        intrinsic_setup += fun.setup()
        intrinsic_list.append(fun.pair())
   
        if  type.startswith('Float'):
            spirv_op_type = 'F'
        elif type.startswith('Int'):
            spirv_op_type = 'S'
        elif type.startswith('UInt'):
            spirv_op_type = 'U'
        spirv_function = ''
        spirv_function += '    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);\n'    
        spirv_function += '    SPIRVResult min = LoadValueSPIRV(c, g, args[1]);\n'    
        spirv_function += '    SPIRVResult max = LoadValueSPIRV(c, g, args[2]);\n'    
        spirv_function += f'    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), {spirv_op_type}Clamp, val, min, max);\n'
        spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
        spirv_code += spirv_intrinsic(function_name, spirv_function)
    
    # Lerp
    for type in float_vec_types:
        intrinsic = 'lerp'
        function_name = f'{intrinsic}_{type}'
        a_name = f'{function_name}_a'
        b_name = f'{function_name}_b'
        t_name = f'{function_name}_t'

        fun = Function(
            decl_name = function_name,
            api_name = intrinsic,
            return_type = type,
            parameters = [
                Variable(decl_name = a_name, api_name = "a", type_name=type),
                Variable(decl_name = b_name, api_name = "b", type_name=type),
                Variable(decl_name = t_name, api_name = "t", type_name=type)
            ]
        )
        intrinsic_decls += fun.declaration()
        intrinsic_defs += fun.definition()
        intrinsic_setup += fun.setup()
        intrinsic_list.append(fun.pair())

        spirv_function = ''
        spirv_function += '    SPIRVResult a = LoadValueSPIRV(c, g, args[0]);\n'    
        spirv_function += '    SPIRVResult b = LoadValueSPIRV(c, g, args[1]);\n'    
        spirv_function += '    SPIRVResult t = LoadValueSPIRV(c, g, args[2]);\n'    
        spirv_function += '    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FMix, a, b, t);\n'
        spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
        spirv_code += spirv_intrinsic(function_name, spirv_function)

    # Step
    for type in float_types:
        intrinsic = 'step'
        function_name = f'{intrinsic}_{type}'
        edge_name = f'{function_name}_edge'
        x_name = f'{function_name}_x'
        
        fun = Function(
            decl_name = function_name,
            api_name = intrinsic,
            return_type = type,
            parameters = [
                Variable(decl_name = edge_name, api_name = "edge", type_name=type),
                Variable(decl_name = x_name, api_name = "x", type_name=type)
            ]
        )
        intrinsic_decls += fun.declaration()
        intrinsic_defs += fun.definition()
        intrinsic_setup += fun.setup()
        intrinsic_list.append(fun.pair())

        spirv_function = ''
        spirv_function += '    SPIRVResult edge = LoadValueSPIRV(c, g, args[0]);\n'    
        spirv_function += '    SPIRVResult x = LoadValueSPIRV(c, g, args[1]);\n'    
        spirv_function += '    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), Step, edge, x);\n'
        spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
        spirv_code += spirv_intrinsic(function_name, spirv_function)
    
    # Smoothstep
    for type in float_types:
        intrinsic = 'smoothstep'
        function_name = f'{intrinsic}_{type}'
        edge0_name = f'{function_name}_edge0'
        edge1_name = f'{function_name}_edge1'
        x_name = f'{function_name}_x'
        fun = Function(
            decl_name = function_name,
            api_name = intrinsic,
            return_type = type,
            parameters = [
                Variable(decl_name = edge0_name, api_name = "edge0", type_name=type),
                Variable(decl_name = edge1_name, api_name = "edge1", type_name=type),
                Variable(decl_name = x_name, api_name = "x", type_name=type)
            ]
        )
        intrinsic_decls += fun.declaration()
        intrinsic_defs += fun.definition()
        intrinsic_setup += fun.setup()
        intrinsic_list.append(fun.pair())
    
        spirv_function = ''
        spirv_function += '    SPIRVResult edge0 = LoadValueSPIRV(c, g, args[0]);\n'    
        spirv_function += '    SPIRVResult edge1 = LoadValueSPIRV(c, g, args[1]);\n'
        spirv_function += '    SPIRVResult x = LoadValueSPIRV(c, g, args[2]);\n'    
        spirv_function += f'    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), SmoothStep, edge0, edge1, x);\n'
        spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
        spirv_code += spirv_intrinsic(function_name, spirv_function)

    # Ceil, Floor, Fract, Saturate, Trunc, Ddx, Ddy, Fwidth
    ops = ['ceil', 'floor', 'fract', 'saturate', 'trunc', 'ddx', 'ddy', 'fwidth']
    spirv_ops = ['Ceil', 'Floor', 'Fract', 'Saturate', 'Trunc', 'DPdx', 'DPdy', 'Fwidth']
    for op, spirv_op in zip(ops, spirv_ops):
        for type in float_types:
            function_name = f'{op}_{type}'
            argument_name = f'{function_name}_arg'
            fun = Function(
                decl_name = function_name,
                api_name = intrinsic,
                return_type = type,
                parameters = [
                    Variable(decl_name = argument_name, api_name = "val", type_name=type)
                ]
            )
            intrinsic_decls += fun.declaration()
            intrinsic_defs += fun.definition()
            intrinsic_setup += fun.setup()
            intrinsic_list.append(fun.pair())

            spirv_function = ''
            spirv_function += '    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);\n' 
            if op == 'ddx' or op == 'ddy' or op == 'fwidth':
                spirv_function += f'    uint32_t ret = g->writer->MappedInstruction(Op{spirv_op}, SPVWriter::Section::LocalFunction, returnType, val);\n'
            elif op == 'saturate':
                size = vector_sizes[type]
                spirv_function += f'    SPIRVResult min = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float(0));\n'
                spirv_function += f'    SPIRVResult max = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float(1));\n'
                if size > 1:
                    spirv_function += f'    min = GenerateSplatCompositeSPIRV(c, g, returnType, {size}, min);\n'
                    spirv_function += f'    max = GenerateSplatCompositeSPIRV(c, g, returnType, {size}, max);\n'
                spirv_function += f'    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), FClamp, val, min, max);\n'
            else:
                spirv_function += f'    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), {spirv_op}, val);\n'
            spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
            spirv_code += spirv_intrinsic(function_name, spirv_function)

    # Sign and Abs
    ops = ['sign', 'abs']
    spirv_ops = ['Sign', 'Abs']
    for op, spirv_op in zip(ops, spirv_ops):
        for type in signed_types:
            intrinsic = op
            function_name = f'{intrinsic}_{type}'
            argument_name = f'{function_name}_arg'
            fun = Function( 
                decl_name = function_name,
                api_name = intrinsic,
                return_type = type,
                parameters = [
                    Variable(decl_name = argument_name, api_name = "val", type_name=type)
                ]
            )
            intrinsic_decls += fun.declaration()
            intrinsic_defs += fun.definition()
            intrinsic_setup += fun.setup()
            intrinsic_list.append(fun.pair())

            if  type.startswith('Float'):
                spirv_op_type = 'F'
            elif type.startswith('Int'):
                spirv_op_type = 'S'
            spirv_function = ''
            spirv_function += '    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);\n'    
            spirv_function += f'    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), {spirv_op_type}{spirv_op}, val);\n'
            spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
            spirv_code += spirv_intrinsic(function_name, spirv_function)

    types = ["Float16", "UInt16", "Int16"]

    for type1 in types:
        for type2 in types:
            if type1 != type2:
                intrinsic = f'castTo{data_type_mapping[type1].title()}'
                function_name = f'{intrinsic}_{type2}'
                argument_name = f'{function_name}_arg'
                fun = Function( 
                    decl_name = function_name,
                    api_name = intrinsic,
                    return_type = type1,
                    parameters = [
                        Variable(decl_name = argument_name, api_name = "val", type_name=type)
                    ]
                )
                intrinsic_decls += fun.declaration()
                intrinsic_defs += fun.definition()
                intrinsic_setup += fun.setup()
                intrinsic_list.append(fun.pair())

                spirv_function = ''
                spirv_function += '    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);\n'    
                spirv_function += '    uint32_t ret = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, returnType, val);\n'
                spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
                spirv_code += spirv_intrinsic(function_name, spirv_function)

    types = ["Float32", "UInt32", "Int32"]

    for type1 in types:
        for type2 in types:
            if type1 != type2:
                intrinsic = f'castTo{data_type_mapping[type1].title()}'
                function_name = f'{intrinsic}_{type2}'
                argument_name = f'{function_name}_arg'
                fun = Function( 
                    decl_name = function_name,
                    api_name = intrinsic,
                    return_type = type1,
                    parameters = [
                        Variable(decl_name = argument_name, api_name = "val", type_name=type)
                    ]
                )
                intrinsic_decls += fun.declaration()
                intrinsic_defs += fun.definition()
                intrinsic_setup += fun.setup()
                intrinsic_list.append(fun.pair())

                spirv_function = ''
                spirv_function += '    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);\n'    
                spirv_function += '    uint32_t ret = g->writer->MappedInstruction(OpBitcast, SPVWriter::Section::LocalFunction, returnType, val);\n'
                spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
                spirv_code += spirv_intrinsic(function_name, spirv_function)

    # Any and all
    ops = ['any', 'all']
    spirv_op = ['Any', 'All']
    for op, spirv_op in zip(ops, spirv_op):
        for type in bool_types:
            intrinsic = op
            function_name = f'{intrinsic}_{type}'
            argument_name = f'{function_name}_arg'

            fun = Function( 
                    decl_name = function_name,
                    api_name = intrinsic,
                    return_type = type,
                    parameters = [
                        Variable(decl_name = argument_name, api_name = "val", type_name=type)
                    ]
                )
            intrinsic_decls += fun.declaration()
            intrinsic_defs += fun.definition()
            intrinsic_setup += fun.setup()
            intrinsic_list.append(fun.pair())

            spirv_function = ''
            spirv_function += '    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);\n'    
            spirv_function += f'    uint32_t ret = g->writer->MappedInstruction(Op{spirv_op}, SPVWriter::Section::LocalFunction, returnType, val);\n'
            spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
            spirv_code += spirv_intrinsic(function_name, spirv_function)

    ops = ['transpose', 'inverse']
    matrix_types = []
    for i in range(2, 5):
        for j in range(2, 5):
            matrix_types.append(f'Float32x{i}x{j}')
            matrix_types.append(f'Float16x{i}x{j}')

    for op in ops:
        for type in matrix_types:
            intrinsic = op
            function_name = f'{intrinsic}_{type}'
            argument_name = f'{function_name}_arg'

            fun = Function( 
                decl_name = function_name,
                api_name = intrinsic,
                return_type = type,
                parameters = [
                    Variable(decl_name = argument_name, api_name = "val", type_name=type)
                ]
            )
            intrinsic_decls += fun.declaration()
            intrinsic_defs += fun.definition()
            intrinsic_setup += fun.setup()
            intrinsic_list.append(fun.pair())
            
            spirv_function = ''
            spirv_function += '    SPIRVResult val = LoadValueSPIRV(c, g, args[0]);\n'    
            if op == 'transpose':
                spirv_function += f'    uint32_t ret = g->writer->MappedInstruction(OpTranspose, SPVWriter::Section::LocalFunction, returnType, val);\n'
            else:
                spirv_function += '    uint32_t ret = g->writer->MappedInstruction(OpExtInst, SPVWriter::Section::LocalFunction, returnType, SPVArg(g->writer->Import(GLSL)), MatrixInverse, val);\n'
            spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
            spirv_code += spirv_intrinsic(function_name, spirv_function)


    # Builtin value getters
    vertex_value_builtins = ['OutputLayer', 'OutputViewport', 'Index', 'InstanceIndex', 'BaseIndex', 'BaseInstanceIndex', 'DrawIndex']
    vertex_value_builtins_spirv = ['Layer', 'ViewportIndex', 'VertexId', 'InstanceId', 'BaseVertex', 'BaseInstance', 'DrawIndex']
    for builtin, spirv_builtin in zip(vertex_value_builtins, vertex_value_builtins_spirv):
        intrinsic = builtin
        function_name = f'VertexGet{intrinsic}'

        fun = Function( 
            decl_name = function_name,
            api_name = intrinsic,
            return_type = 'UInt32',
            parameters = [
            ]
        )
        intrinsic_decls += fun.declaration()
        intrinsic_defs += fun.definition()
        intrinsic_setup += fun.setup()
        intrinsic_list.append(fun.pair())

        spirv_function = ''
        if builtin == 'OutputLayer':
            spirv_function += '    g->writer->Capability(Capabilities::ShaderLayer);\n'
        elif builtin == 'OutputViewport':
            spirv_function += '    g->writer->Capability(Capabilities::ShaderViewportIndex);\n'
        elif builtin == 'Index' or builtin == 'InstanceIndex' or builtin == 'BaseIndex' or builtin == 'BaseInstanceIndex' or builtin == 'DrawIndex':
            spirv_function += '    g->writer->Capability(Capabilities::Shader);\n'
        spirv_function += '    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);\n'
        spirv_function += '    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));\n'
        spirv_function += f'    uint32_t ret = GPULang::AddSymbol(g, TStr("gpl{builtin}"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);\n'
        spirv_function += f'    g->writer->Decorate(SPVArg{{ret}}, Decorations::BuiltIn, Builtins::{spirv_builtin});\n'
        spirv_function += '    g->interfaceVariables.Insert(ret);\n'
        spirv_function += '    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);\n'
        spirv_function += '    res.parentTypes.push_back(baseType);\n'
        spirv_function += '    return res;\n'
        spirv_code += spirv_intrinsic(function_name, spirv_function)

    unsigned_types = ['UInt16', 'UInt32']
    vertex_value_builtins = ['OutputLayer', 'OutputViewport']
    vertex_value_builtins_spirv = ['Layer', 'ViewportIndex']
    for builtin, spirv_builtin in zip(vertex_value_builtins, vertex_value_builtins_spirv):
        for type in unsigned_types:
            intrinsic = builtin
            function_name = f'VertexSet{intrinsic}_{type}'
            argument_name = f'{function_name}_arg'

            fun = Function( 
                decl_name = function_name,
                api_name = intrinsic,
                return_type = 'Void',
                parameters = [
                    Variable(decl_name = argument_name, api_name = "val", type_name=type)
                ]
            )
            intrinsic_decls += fun.declaration()
            intrinsic_defs += fun.definition()
            intrinsic_setup += fun.setup()
            intrinsic_list.append(fun.pair())

            spirv_function = '' 
            if builtin == 'OutputLayer':
                spirv_function += '    g->writer->Capability(Capabilities::ShaderLayer);\n'
            elif builtin == 'OutputViewport':
                spirv_function += '    g->writer->Capability(Capabilities::ShaderViewportIndex);\n'
            spirv_function += '    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);\n'
            spirv_function += '    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));\n'
            spirv_function += f'    uint32_t ret = GPULang::AddSymbol(g, TStr("gpl{builtin}"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);\n'
            spirv_function += f'    g->writer->Decorate(SPVArg{{ret}}, Decorations::BuiltIn, Builtins::{spirv_builtin});\n'
            spirv_function += '    g->interfaceVariables.Insert(ret);\n'
            spirv_function += '    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, args[0]);\n'
            spirv_function += '    return SPIRVResult::Invalid();\n'
            spirv_code += spirv_intrinsic(function_name, spirv_function)

    # Export vertex coordinates
    four_component_float_vec_types = ['Float32x4', 'Float16x4']
    vertex_value_builtins_spirv = ['Position', 'Position']

    for type, spirv_builtin in zip(four_component_float_vec_types, vertex_value_builtins_spirv):
        intrinsic = 'ExportCoordinates'
        function_name = f'Vertex{intrinsic}_{type}'
        argument_name = f'{function_name}_arg'
        fun = Function( 
            decl_name = function_name,
            api_name = f'vertexExport{intrinsic}',
            return_type = 'Void',
            parameters = [
                Variable(decl_name = argument_name, api_name = "val", type_name=type)
            ]
        )
        intrinsic_decls += fun.declaration()
        intrinsic_defs += fun.definition()
        intrinsic_setup += fun.setup()
        intrinsic_list.append(fun.pair())

        spirv_function += '    g->writer->Capability(Capabilities::Shader);\n'
        spirv_function += '    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);\n'
        spirv_function += '    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Output"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));\n'
        spirv_function += f'    uint32_t ret = GPULang::AddSymbol(g, TStr("gpl{builtin}"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);\n'
        spirv_function += f'    g->writer->Decorate(SPVArg{{ret}}, Decorations::BuiltIn, Builtins::{spirv_builtin});\n'
        spirv_function += '    g->interfaceVariables.Insert(ret);\n'
        spirv_function += '    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);\n'
        spirv_function += '    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);\n'
        spirv_function += '    return SPIRVResult::Invalid();\n'
        spirv_code += spirv_intrinsic(function_name, spirv_function)

    geometry_export_builtins = ['ExportVertex', 'ExportPrimitive']
    geometry_export_builtins_spirv = ['EmitVertex', 'EndPrimitive']

    for builtin, spirv_builtin in zip(geometry_export_builtins, geometry_export_builtins_spirv):
        intrinsic = builtin
        function_name = f'Geometry{intrinsic}'
        fun = Function( 
            decl_name = function_name,
            api_name = f'geometry{intrinsic}',
            return_type = 'Void',
            parameters = [
            ]
        )
        intrinsic_decls += fun.declaration()
        intrinsic_defs += fun.definition()
        intrinsic_setup += fun.setup()
        intrinsic_list.append(fun.pair())

        spirv_function = ''
        spirv_function += '    g->writer->Capability(Capabilities::Geometry);\n'
        spirv_function += f'    g->writer->Instruction(Op{spirv_builtin}, SPVWriter::Section::LocalFunction);\n'
        spirv_function += '    return SPIRVResult::Invalid();\n'
        spirv_code += spirv_intrinsic(function_name, spirv_function)

    for type in four_component_float_vec_types:
        intrinsic = 'GetCoordinates'
        spirv_builtin = 'FragCoord'
        function_name = f'Pixel{intrinsic}_{type}'

        fun = Function( 
            decl_name = function_name,
            api_name = f'pixel{intrinsic}',
            return_type = type,
            parameters = [
            ]
        )
        intrinsic_decls += fun.declaration()
        intrinsic_defs += fun.definition()
        intrinsic_setup += fun.setup()
        intrinsic_list.append(fun.pair())

        spirv_function = ''
        spirv_function += '    g->writer->Capability(Capabilities::Shader);\n'
        spirv_function += '    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);\n'
        spirv_function += '    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));\n'
        spirv_function += f'    uint32_t ret = GPULang::AddSymbol(g, TStr("gpl{function_name}"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);\n'
        spirv_function += f'    g->writer->Decorate(SPVArg{{ret}}, Decorations::BuiltIn, Builtins::{spirv_builtin});\n'
        spirv_function += '    g->interfaceVariables.Insert(ret);\n'
        spirv_function += '    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);\n'
        spirv_function += '    res.parentTypes.push_back(baseType);\n'
        spirv_function += '    return res;\n'
        spirv_code += spirv_intrinsic(function_name, spirv_function)
    
    intrinsic = 'GetDepth'
    spirv_builtin = 'FragDepth'
    function_name = f'Pixel{intrinsic}'
    fun = Function( 
        decl_name = function_name,
        api_name = f'pixel{intrinsic}',
        return_type = 'Float32',
        parameters = [
        ]
    )
    intrinsic_decls += fun.declaration()
    intrinsic_defs += fun.definition()
    intrinsic_setup += fun.setup()
    intrinsic_list.append(fun.pair())

    spirv_function = ''
    spirv_function += '    g->writer->Capability(Capabilities::Shader);\n'
    spirv_function += '    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 1);\n'
    spirv_function += '    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));\n'
    spirv_function += f'    uint32_t ret = GPULang::AddSymbol(g, TStr("gpl{function_name}"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);\n'
    spirv_function += f'    g->writer->Decorate(SPVArg{{ret}}, Decorations::BuiltIn, Builtins::{spirv_builtin});\n'
    spirv_function += '    g->interfaceVariables.Insert(ret);\n'
    spirv_function += '    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);\n'
    spirv_function += '    res.parentTypes.push_back(baseType);\n'
    spirv_function += '    return res;\n'
    spirv_code += spirv_intrinsic(function_name, spirv_function)

    intrinsic = 'SetDepth'
    function_name = f'Pixel{intrinsic}'
    fun = Function( 
        decl_name = function_name,
        api_name = f'pixel{intrinsic}',
        return_type = 'Void',
        parameters = [
            Variable(decl_name = f'{function_name}_val', api_name = "val", type_name='Float32')
        ]
    )
    intrinsic_decls += fun.declaration()
    intrinsic_defs += fun.definition()
    intrinsic_setup += fun.setup()
    intrinsic_list.append(fun.pair())

    spirv_function = ''
    spirv_function += '    g->writer->Capability(Capabilities::Shader);\n'
    spirv_function += '    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 1);\n'
    spirv_function += '    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32_Input"), OpTypePointer, VariableStorage::Output, SPVArg(baseType));\n'
    spirv_function += f'    uint32_t ret = GPULang::AddSymbol(g, TStr("gpl{function_name}"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Output);\n'
    spirv_function += f'    g->writer->Decorate(SPVArg{{ret}}, Decorations::BuiltIn, Builtins::{spirv_builtin});\n'
    spirv_function += '    g->interfaceVariables.Insert(ret);\n'
    spirv_function += '    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);\n'
    spirv_function += '    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);\n'
    spirv_function += '    return SPIRVResult::Invalid();\n' 
    spirv_code += spirv_intrinsic(function_name, spirv_function)

    intrinsic = 'ExportColor'
    for type in scalar_types:
        for idx in index_types:
            function_name = f'Pixel{intrinsic}_{type}_{idx}'
            color_argument_name = f'{function_name}_color'
            index_argument_name = f'{function_name}_index'

            fun = Function( 
                decl_name = function_name,
                api_name = f'pixel{intrinsic}',
                return_type = 'Void',
                parameters = [
                    Variable(decl_name = color_argument_name, api_name = "color", type_name=type),
                    Variable(decl_name = index_argument_name, api_name = "index", type_name=idx, literal=True)
                ]
            )
            intrinsic_decls += fun.declaration()
            intrinsic_defs += fun.definition()
            intrinsic_setup += fun.setup()
            intrinsic_list.append(fun.pair())

            spirv_function = ''
            spirv_function += '    g->writer->Capability(Capabilities::Shader);\n'
            spirv_function += '    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, 4);\n'
            spirv_function += '    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_f32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));\n'
            spirv_function += f'    uint32_t ret = GPULang::AddSymbol(g, TStr("gpl{function_name}"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);\n'
            spirv_function += '    g->writer->Decorate(SPVArg{ret}, Decorations::Index, args[1].literalValue.i);\n'
            spirv_function += '    g->writer->Decorate(SPVArg{ret}, Decorations::Location, args[1].literalValue.i);\n'
            spirv_function += '    g->interfaceVariables.Insert(ret);\n'
            spirv_function += '    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);\n'
            spirv_function += '    g->writer->Instruction(OpStore, SPVWriter::Section::LocalFunction, SPVArg{ret}, loaded);\n'
            spirv_function += '    return SPIRVResult::Invalid();\n' 
            spirv_code += spirv_intrinsic(function_name, spirv_function)

    # TODO: Hmm maybe these should all be UInt16 considering dispatch sizes can't exceed 65535?????
    compute_builtin_getters = ['GetLocalThreadIndices', 'GetGlobalThreadIndices', 'GetWorkgroupIndices', 'GetWorkGroupDimensions']
    compute_builtin_getters_spirv = ['LocalInvocationId', 'GlobalInvocationId', 'WorkgroupId', 'WorkgroupSize']
    for intrinsic, spirv_builtin in zip(compute_builtin_getters, compute_builtin_getters_spirv):
        function_name = f'Compute{intrinsic}'

        fun = Function( 
            decl_name = function_name,
            api_name = f'compute{intrinsic}',
            return_type = 'Uint32x3',
            parameters = [
            ]
        )
        intrinsic_decls += fun.declaration()
        intrinsic_defs += fun.definition()
        intrinsic_setup += fun.setup()
        intrinsic_list.append(fun.pair())

        spirv_function = ''
        spirv_function += '    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 3);\n'
        spirv_function += '    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x3_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));\n'
        spirv_function += f'    uint32_t ret = GPULang::AddSymbol(g, TStr("gpl{function_name}"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);\n'
        spirv_function += f'    g->writer->Decorate(SPVArg{{ret}}, Decorations::BuiltIn, Builtins::{spirv_builtin});\n'
        spirv_function += '    g->interfaceVariables.Insert(ret);\n'
        spirv_function += '    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);\n'
        spirv_function += '    res.parentTypes.push_back(baseType);\n'
        spirv_function += '    return res;\n'
        spirv_code += spirv_intrinsic(function_name, spirv_function)

    intrinsic = 'GetIndexInWorkgroup'
    spirv_builtin = 'LocalInvocationIndex'
    function_name = f'Compute{intrinsic}'

    fun = Function( 
        decl_name = function_name,
        api_name = f'compute{intrinsic}',
        return_type = 'Uint32',
        parameters = [
        ]
    )
    intrinsic_decls += fun.declaration()
    intrinsic_defs += fun.definition()
    intrinsic_setup += fun.setup()
    intrinsic_list.append(fun.pair())

    spirv_function = ''
    spirv_function += '    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 1);\n'
    spirv_function += '    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));\n'
    spirv_function += f'    uint32_t ret = GPULang::AddSymbol(g, TStr("gpl{function_name}"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);\n'
    spirv_function += f'    g->writer->Decorate(SPVArg{{ret}}, Decorations::BuiltIn, Builtins::{spirv_builtin});\n'
    spirv_function += '    g->interfaceVariables.Insert(ret);\n'
    spirv_function += '    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);\n'
    spirv_function += '    res.parentTypes.push_back(baseType);\n'
    spirv_function += '    return res;\n'
    spirv_code += spirv_intrinsic(function_name, spirv_function)

    subgroup_builtin_getters = ['GetId', 'GetSize', 'GetNum']
    subgroup_builtin_getters_spirv = ['SubgroupId', 'SubgroupSize', 'SubgroupNum']
    subgroup_builtin_getters_docs = [
        'Returns the subgroup ID of the current thread',
        'Returns the size of the subgroup',
        'Returns the number of subgroups in the workgroup'
    ]
    for intrinsic, spirv_builtin, doc in zip(subgroup_builtin_getters, subgroup_builtin_getters_spirv, subgroup_builtin_getters_docs):
        function_name = f'Subgroup{intrinsic}'

        fun = Function( 
            decl_name = function_name,
            api_name = f'subgroup{intrinsic}',
            return_type = 'Uint32x3',
            documentation = doc,
            parameters = [
            ]
        )
        intrinsic_decls += fun.declaration()
        intrinsic_defs += fun.definition()
        intrinsic_setup += fun.setup()
        intrinsic_list.append(fun.pair())

        spirv_function = ''
        spirv_function += '    g->writer->Capability(Capabilities::GroupNonUniform);\n'
        spirv_function += '    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 3);\n'
        spirv_function += '    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x3_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));\n'
        spirv_function += f'    uint32_t ret = GPULang::AddSymbol(g, TStr("gpl{function_name}"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);\n'
        spirv_function += f'    g->writer->Decorate(SPVArg{{ret}}, Decorations::BuiltIn, Builtins::{spirv_builtin});\n'
        spirv_function += '    g->interfaceVariables.Insert(ret);\n'
        spirv_function += '    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);\n'
        spirv_function += '    res.parentTypes.push_back(baseType);\n'
        spirv_function += '    return res;\n'
        spirv_code += spirv_intrinsic(function_name, spirv_function)

    subgroup_builtin_masks = ['GetThreadMask', 'GetThreadAndLowerMask', 'GetLowerMask', 'GetThreadAndGreaterMask', 'GetGreaterMask']
    subgroup_builtin_masks_spirv = ['SubgroupEqMask', 'SubgroupLeMask', 'SubgroupLtMask', 'SubgroupGeMask', 'SubgroupGtMask']
    subgroup_builtin_docs = [
        'Returns a subgroup mask where the current thread is active',
        'Returns a subgroup mask where the current thread and all lower threads are active',
        'Returns a subgroup mask where all lower threads are active',
        'Returns a subgroup mask where the current thread and all greater threads are active',
        'Returns a subgroup mask where all greater threads are active'
    ]
    for intrinsic, spirv_builtin, doc in zip(subgroup_builtin_masks, subgroup_builtin_masks_spirv, subgroup_builtin_docs):
        function_name = f'Subgroup{intrinsic}'

        fun = Function( 
            decl_name = function_name,
            api_name = f'subgroup{intrinsic}',
            return_type = 'Uint32x4',
            documentation = doc,
            parameters = [
            ]
        )
        intrinsic_decls += fun.declaration()
        intrinsic_defs += fun.definition()
        intrinsic_setup += fun.setup()
        intrinsic_list.append(fun.pair())

        spirv_function = ''
        spirv_function += '    g->writer->Capability(Capabilities::GroupNonUniform);\n'
        spirv_function += '    uint32_t baseType = GeneratePODTypeSPIRV(c, g, TypeCode::UInt32, 4);\n'
        spirv_function += '    uint32_t typePtr = GPULang::AddType(g, TStr("ptr_u32x4_Input"), OpTypePointer, VariableStorage::Input, SPVArg(baseType));\n'
        spirv_function += f'    uint32_t ret = GPULang::AddSymbol(g, TStr("gpl{function_name}"), SPVWriter::Section::Declarations, OpVariable, typePtr, VariableStorage::Input);\n'
        spirv_function += f'    g->writer->Decorate(SPVArg{{ret}}, Decorations::BuiltIn, Builtins::{spirv_builtin});\n'
        spirv_function += '    g->interfaceVariables.Insert(ret);\n'
        spirv_function += '    SPIRVResult res(ret, typePtr, false, false, SPIRVResult::Storage::Input);\n'
        spirv_function += '    res.parentTypes.push_back(baseType);\n'
        spirv_function += '    return res;\n'
        spirv_code += spirv_intrinsic(function_name, spirv_function)

    
    intrinsic = 'GetFirstActiveThread'
    function_name = f'Subgroup{intrinsic}'

    fun = Function( 
        decl_name = function_name,
        api_name = f'subgroup{intrinsic}',
        return_type = 'Uint32',
        parameters = [
        ]
    )
    intrinsic_decls += fun.declaration()
    intrinsic_defs += fun.definition()
    intrinsic_setup += fun.setup()
    intrinsic_list.append(fun.pair())

    spirv_function += '    g->writer->Capability(Capabilities::GroupNonUniform);\n'
    spirv_function += '    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformElect, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup);\n'
    spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
    spirv_code += spirv_intrinsic(function_name, spirv_function)

    intrinsic = 'BroadcastFirstActiveThread'
    function_name = f'Subgroup{intrinsic}'
    value_argument_name = f'{intrinsic}_UInt32_value'
    intrinsic_decls += f'extern Variable {value_argument_name};\n'
    intrinsic_decls += f'extern Function {function_name};\n'
    intrinsic_defs += f'Variable {value_argument_name};\n'
    intrinsic_defs += f'Function {function_name};\n'
    intrinsic_setup += f'    {value_argument_name}.name = "value"_c;\n'
    intrinsic_setup += f'    {value_argument_name}.type = Type::FullType{{ UInt32Type.name }};\n'
    intrinsic_setup += f'    {function_name}.name = "subgroup{intrinsic}"_c;\n'
    intrinsic_setup += f'    {function_name}.documentation = "Returns the value of the provided argument for the first active thread in the subgroup"_c;\n'
    intrinsic_setup += f'    {function_name}.returnType = Type::FullType{{ UInt32Type.name }};\n'
    intrinsic_setup += f'    Symbol::Resolved(&{function_name})->returnTypeSymbol = &UInt32Type;\n\n'

    spirv_function = ''
    spirv_function += '    g->writer->Capability(Capabilities::GroupNonUniformBallot);\n'
    spirv_function += '    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);\n'
    spirv_function += '    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBroadcastFirst, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);\n'
    spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
    spirv_code += spirv_intrinsic(function_name, spirv_function)

    subgroup_ballot_ops = ['Ballot', 'InverseBallot']
    subgroup_ballot_ops_doc = ['Constructs a subgroup mask within the workgroup where predicate is true', 'Constructs a subgroup mask within the workgroup where predicate is false']
    subgroup_ballot_ops_spirv = ['GroupNonUniformBallot', 'GroupNonUniformInverseBallot']
    for intrinsic, doc, spirv in zip(subgroup_ballot_ops, subgroup_ballot_ops_doc, subgroup_ballot_ops_spirv):
        function_name = f'Subgroup{intrinsic}'
        predicate_argument_name = f'Subgroup{intrinsic}_Bool8_predicate'
        intrinsic_decls += f'extern Variable {predicate_argument_name};\n'
        intrinsic_decls += f'extern Function {function_name};\n'
        intrinsic_defs += f'Variable {predicate_argument_name};\n'
        intrinsic_defs += f'Function {function_name};\n'
        intrinsic_setup += f'    {predicate_argument_name}.name = "value"_c;\n'
        intrinsic_setup += f'    {predicate_argument_name}.type = Type::FullType{{ Bool8Type.name }};\n'
        intrinsic_setup += f'    {function_name}.name = "subgroup{intrinsic}"_c;\n'
        intrinsic_setup += f'    {function_name}.documentation = "{doc}"_c;\n'
        intrinsic_setup += f'    {function_name}.returnType = Type::FullType{{ UInt32x4Type.name }};\n'
        intrinsic_setup += f'    Symbol::Resolved(&{function_name})->returnTypeSymbol = &UInt32x4Type;\n\n'

        spirv_function = ''
        spirv_function += '    g->writer->Capability(Capabilities::GroupNonUniformBallot);\n'
        spirv_function += '    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);\n'
        spirv_function += f'    uint32_t ret = g->writer->MappedInstruction(Op{spirv}, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);\n'
        spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
        spirv_code += spirv_intrinsic(function_name, spirv_function)

    intrinsic = 'BitCount'
    function_name = f'SubgroupBallot{intrinsic}'
    mask_name = f'SubgroupBallot{intrinsic}_UInt32x4_mask'
    intrinsic_decls += f'extern Variable {mask_name};\n'
    intrinsic_decls += f'extern Function {function_name};\n'
    intrinsic_defs += f'Variable {mask_name};\n'
    intrinsic_defs += f'Function {function_name};\n'
    intrinsic_setup += f'    {mask_name}.name = "value"_c;\n'
    intrinsic_setup += f'    {mask_name}.type = Type::FullType{{ UInt32x4Type.name }};\n'
    intrinsic_setup += f'    {function_name}.name = "subgroupBallot{intrinsic}"_c;\n'
    intrinsic_setup += f'    {function_name}.documentation = "Returns the number of bits in the mask set to 1."_c;\n'
    intrinsic_setup += f'    {function_name}.returnType = Type::FullType{{ UInt32Type.name }};\n'
    intrinsic_setup += f'    Symbol::Resolved(&{function_name})->returnTypeSymbol = &UInt32Type;\n\n'

    spirv_function = ''
    spirv_function += '    g->writer->Capability(Capabilities::GroupNonUniformBallot);\n'
    spirv_function += '    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);\n'
    spirv_function += '    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitCount, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, 0, loaded);\n'
    spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
    spirv_code += spirv_intrinsic(function_name, spirv_function)

    intrinsic = 'FirstOne'
    function_name = f'SubgroupBallot{intrinsic}'
    mask_name = f'SubgroupBallot{intrinsic}_UInt32x4_mask'
    intrinsic_decls += f'extern Variable {mask_name};\n'
    intrinsic_decls += f'extern Function {function_name};\n'
    intrinsic_defs += f'Variable {mask_name};\n'
    intrinsic_defs += f'Function {function_name};\n'
    intrinsic_setup += f'    {mask_name}.name = "value"_c;\n'
    intrinsic_setup += f'    {mask_name}.type = Type::FullType{{ UInt32x4Type.name }};\n'
    intrinsic_setup += f'    {function_name}.name = "subgroupBallot{intrinsic}"_c;\n'
    intrinsic_setup += f'    {function_name}.documentation = "Returns the first one (ctz) in a subgroup thread mask."_c;\n'
    intrinsic_setup += f'    {function_name}.returnType = Type::FullType{{ UInt32Type.name }};\n'
    intrinsic_setup += f'    Symbol::Resolved(&{function_name})->returnTypeSymbol = &UInt32Type;\n\n'

    spirv_function = ''
    spirv_function += '    g->writer->Capability(Capabilities::GroupNonUniformBallot);\n'
    spirv_function += '    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);\n'
    spirv_function += '    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotFindLSB, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);\n'
    spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
    spirv_code += spirv_intrinsic(function_name, spirv_function)

    intrinsic = 'LastOne'
    function_name = f'SubgroupBallot{intrinsic}'
    mask_name = f'SubgroupBallot{intrinsic}_UInt32x4_mask'
    intrinsic_decls += f'extern Variable {mask_name};\n'
    intrinsic_decls += f'extern Function {function_name};\n'
    intrinsic_defs += f'Variable {mask_name};\n'
    intrinsic_defs += f'Function {function_name};\n'
    intrinsic_setup += f'    {mask_name}.name = "value"_c;\n'
    intrinsic_setup += f'    {mask_name}.type = Type::FullType{{ UInt32x4Type.name }};\n'
    intrinsic_setup += f'    {function_name}.name = "subgroupBallot{intrinsic}"_c;\n'
    intrinsic_setup += f'    {function_name}.documentation = "Returns the first one (clz) in a subgroup thread mask."_c;\n'
    intrinsic_setup += f'    {function_name}.returnType = Type::FullType{{ UInt32Type.name }};\n'
    intrinsic_setup += f'    Symbol::Resolved(&{function_name})->returnTypeSymbol = &UInt32Type;\n\n'

    spirv_function = ''
    spirv_function += '    g->writer->Capability(Capabilities::GroupNonUniformBallot);\n'
    spirv_function += '    SPIRVResult loaded = LoadValueSPIRV(c, g, args[0]);\n'
    spirv_function += '    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotFindMSB, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, loaded);\n'
    spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
    spirv_code += spirv_intrinsic(function_name, spirv_function)

    intrinsic = 'Bit'
    function_name = f'SubgroupBallot{intrinsic}'
    mask_name = f'SubgroupBallot{intrinsic}_UInt32x4_mask'
    index_name = f'SubgroupBallot{intrinsic}_UInt32_index'
    intrinsic_decls += f'extern Variable {mask_name};\n'
    intrinsic_decls += f'extern Variable {index_name};\n'
    intrinsic_decls += f'extern Function {function_name};\n'
    intrinsic_defs += f'Variable {mask_name};\n'
    intrinsic_defs += f'Variable {index_name};\n'
    intrinsic_defs += f'Function {function_name};\n'
    intrinsic_setup += f'    {mask_name}.name = "value"_c;\n'
    intrinsic_setup += f'    {mask_name}.type = Type::FullType{{ UInt32x4Type.name }};\n'
    intrinsic_setup += f'    {index_name}.name = "value"_c;\n'
    intrinsic_setup += f'    {index_name}.type = Type::FullType{{ UInt32Type.name }};\n'
    intrinsic_setup += f'    {function_name}.name = "subgroupBallot{intrinsic}"_c;\n'
    intrinsic_setup += f'    {function_name}.documentation = "Returns true if bit at index in mask is 1."_c;\n'
    intrinsic_setup += f'    {function_name}.returnType = Type::FullType{{ Bool8Type.name }};\n'
    intrinsic_setup += f'    Symbol::Resolved(&{function_name})->returnTypeSymbol = &Bool8Type;\n\n'

    spirv_function = ''
    spirv_function += '    g->writer->Capability(Capabilities::GroupNonUniformBallot);\n'
    spirv_function += '    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);\n'
    spirv_function += '    SPIRVResult bit = LoadValueSPIRV(c, g, args[1]);\n'
    spirv_function += '    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, bit);\n'
    spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
    spirv_code += spirv_intrinsic(function_name, spirv_function)

    subgroup_swap_ops = ['Diagonal', 'Vertical', 'Horizontal']
    subgroup_swap_op_directions = [2, 1, 0]
    for op, direction in zip(subgroup_swap_ops, subgroup_swap_op_directions):
        for type in scalar_types:
            intrinsic = op
            function_name = f'SubgroupSwap{intrinsic}_{type}'
            value_argument_name = f'{function_name}_color'
            intrinsic_decls += f'extern Variable {value_argument_name};\n'
            intrinsic_decls += f'extern Function {function_name};\n'
            intrinsic_defs += f'Variable {value_argument_name};\n'
            intrinsic_defs += f'Function {function_name};\n'
            intrinsic_setup += f'    {value_argument_name}.name = "color"_c;\n'
            intrinsic_setup += f'    {value_argument_name}.type = Type::FullType{{ {type}Type.name }};\n'
            intrinsic_setup += f'    {function_name}.name = "subgroupSwap{intrinsic}"_c;\n'
            intrinsic_setup += f'    {function_name}.returnType = Type::FullType{{ VoidType.name }};\n'
            intrinsic_setup += f'    Symbol::Resolved(&{value_argument_name})->typeSymbol = &{type}Type;\n'
            intrinsic_setup += f'    Symbol::Resolved(&{function_name})->returnTypeSymbol = &VoidType;\n\n'

            spirv_function = ''
            spirv_function += '    g->writer->Capability(Capabilities::GroupNonUniformQuad);\n'
            spirv_function += '    SPIRVResult mask = LoadValueSPIRV(c, g, args[0]);\n'
            spirv_function += f'    SPIRVResult direction = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int({direction}));\n'
            spirv_function += '    uint32_t ret = g->writer->MappedInstruction(OpGroupNonUniformBallotBitExtract, SPVWriter::Section::LocalFunction, returnType, ExecutionScopes::Subgroup, mask, direction);\n'
            spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
            spirv_code += spirv_intrinsic(function_name, spirv_function)

    # Atomics
    atomic_types = ['UInt32', 'Int32', 'UInt16', 'Int16']
    atomic_functions_no_value = ['Load', 'Increment', 'Decrement']
    atomic_builtins_spirv = ['OpAtomicLoad', 'OpAtomicIIncrement', 'OpAtomicIDecrement']

    for atomic_type in atomic_types:
        for atomic_function, spirv_builtin in zip(atomic_functions_no_value, atomic_builtins_spirv):
            function_name = f'Atomic{atomic_function}_{atomic_type}'
            ptr_argument_name = f'{function_name}_ptr'
            semantics_argument_name = f'{function_name}_semantics'
            intrinsic_decls += f'extern Variable {ptr_argument_name};\n'
            intrinsic_decls += f'extern Variable {semantics_argument_name};\n'
            intrinsic_decls += f'extern Function {function_name};\n'
            intrinsic_defs += f'Variable {ptr_argument_name};\n'
            intrinsic_defs += f'Variable {semantics_argument_name};\n'
            intrinsic_defs += f'Function {function_name};\n'
            intrinsic_setup += f'    {ptr_argument_name}.name = "ptr"_c;\n'
            intrinsic_setup += f'    {ptr_argument_name}.type = Type::FullType{{ {atomic_type}Type.name }};\n'
            intrinsic_setup += f'    {ptr_argument_name}.type.AddModifier(Type::FullType::Modifier::Pointer);\n'
            intrinsic_setup += f'    {semantics_argument_name}.name = "semantics"_c;\n'
            intrinsic_setup += f'    {semantics_argument_name}.type = Type::FullType{{ MemorySemanticsType.name }};\n'
            intrinsic_setup += f'    {semantics_argument_name}.type.literal = true;\n'
            intrinsic_setup += f'    {function_name}.name = "atomic{atomic_function}"_c;\n'
            intrinsic_setup += f'    {function_name}.returnType = Type::FullType{{ {atomic_type}Type.name }};\n'
            intrinsic_setup += f'    Symbol::Resolved(&{ptr_argument_name})->typeSymbol = &{atomic_type}Type;\n'
            intrinsic_setup += f'    Symbol::Resolved(&{semantics_argument_name})->typeSymbol = &MemorySemanticsType;\n'
            intrinsic_setup += f'    Symbol::Resolved(&{function_name})->returnTypeSymbol = &{atomic_type}Type;\n\n'

            spirv_function = ''
            spirv_function += '    uint32_t scope = ScopeToAtomicScope(args[0].scope);\n'
            spirv_function += '    uint32_t semantics = SemanticsTable[args[1].literalValue.ui];\n'
            spirv_function += '    semantics |= ScopeToMemorySemantics(args[0].scope);\n'
            spirv_function += '    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));\n'
            spirv_function += '    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));\n'
            spirv_function += f'    uint32_t ret = g->writer->MappedInstruction({spirv_builtin}, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId);\n'
            spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
            spirv_code += spirv_intrinsic(function_name, spirv_function)

    atomic_functions_with_argument = ['Store', 'Exchange', 'Add', 'Subtract', 'And', 'Or', 'Xor']
    for atomic_type in atomic_types:
        for atomic_function in atomic_functions_with_argument:
            function_name = f'Atomic{atomic_function}_{atomic_type}'
            ptr_argument_name = f'{function_name}_ptr'
            value_argument_name = f'{function_name}_value'
            semantics_argument_name = f'{function_name}_semantics'
            intrinsic_decls += f'extern Variable {ptr_argument_name};\n'
            intrinsic_decls += f'extern Variable {value_argument_name};\n'
            intrinsic_decls += f'extern Variable {semantics_argument_name};\n'
            intrinsic_decls += f'extern Function {function_name};\n'
            intrinsic_defs += f'Variable {ptr_argument_name};\n'
            intrinsic_defs += f'Variable {value_argument_name};\n'
            intrinsic_defs += f'Variable {semantics_argument_name};\n'
            intrinsic_defs += f'Function {function_name};\n'
            intrinsic_setup += f'    {ptr_argument_name}.name = "ptr"_c;\n'
            intrinsic_setup += f'    {ptr_argument_name}.type = Type::FullType{{ {atomic_type}Type.name }};\n'
            intrinsic_setup += f'    {ptr_argument_name}.type.AddModifier(Type::FullType::Modifier::Pointer);\n'
            intrinsic_setup += f'    {value_argument_name}.name = "value"_c;\n'
            intrinsic_setup += f'    {value_argument_name}.type = Type::FullType{{ {atomic_type}Type.name }};\n'
            intrinsic_setup += f'    {semantics_argument_name}.name = "semantics"_c;\n'
            intrinsic_setup += f'    {semantics_argument_name}.type = Type::FullType{{ MemorySemanticsType.name }};\n'
            intrinsic_setup += f'    {semantics_argument_name}.type.literal = true;\n'
            intrinsic_setup += f'    {function_name}.name = "atomic{atomic_function}"_c;\n'
            intrinsic_setup += f'    {function_name}.returnType = Type::FullType{{ {atomic_type}Type.name }};\n'
            intrinsic_setup += f'    Symbol::Resolved(&{ptr_argument_name})->typeSymbol = &{atomic_type}Type;\n'
            intrinsic_setup += f'    Symbol::Resolved(&{value_argument_name})->typeSymbol = &{atomic_type}Type;\n'
            intrinsic_setup += f'    Symbol::Resolved(&{semantics_argument_name})->typeSymbol = &MemorySemanticsType;\n'
            intrinsic_setup += f'    Symbol::Resolved(&{function_name})->returnTypeSymbol = &{atomic_type}Type;\n\n'

            spirv_function = ''
            spirv_function += '    uint32_t scope = ScopeToAtomicScope(args[0].scope);\n'
            spirv_function += '    uint32_t semantics = SemanticsTable[args[2].literalValue.ui];\n'
            spirv_function += '    semantics |= ScopeToMemorySemantics(args[0].scope);\n'
            spirv_function += '    SPIRVResult valueLoaded = LoadValueSPIRV(c, g, args[1]);\n'
            spirv_function += '    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));\n'
            spirv_function += '    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));\n'
            spirv_function += f'    uint32_t ret = g->writer->MappedInstruction({spirv_builtin}, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, valueLoaded);\n'
            spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
            spirv_code += spirv_intrinsic(function_name, spirv_function)

    for atomic_type in atomic_types:
        atomic_function = 'CompareExchange'
        function_name = f'Atomic{atomic_function}_{atomic_type}'
        ptr_argument_name = f'{function_name}_ptr'
        value_argument_name = f'{function_name}_value'
        compare_argument_name = f'{function_name}_compare'
        semantics_argument_name = f'{function_name}_semantics'
        intrinsic_decls += f'extern Variable {ptr_argument_name};\n'
        intrinsic_decls += f'extern Variable {value_argument_name};\n'
        intrinsic_decls += f'extern Variable {compare_argument_name};\n'
        intrinsic_decls += f'extern Variable {semantics_argument_name};\n'
        intrinsic_decls += f'extern Function {function_name};\n'
        intrinsic_defs += f'Variable {ptr_argument_name};\n'
        intrinsic_defs += f'Variable {value_argument_name};\n'
        intrinsic_defs += f'Variable {compare_argument_name};\n'
        intrinsic_defs += f'Variable {semantics_argument_name};\n'
        intrinsic_defs += f'Function {function_name};\n'
        intrinsic_setup += f'    {ptr_argument_name}.name = "ptr"_c;\n'
        intrinsic_setup += f'    {ptr_argument_name}.type = Type::FullType{{ {atomic_type}Type.name }};\n'
        intrinsic_setup += f'    {ptr_argument_name}.type.AddModifier(Type::FullType::Modifier::Pointer);\n'
        intrinsic_setup += f'    {value_argument_name}.name = "value"_c;\n'
        intrinsic_setup += f'    {value_argument_name}.type = Type::FullType{{ {atomic_type}Type.name }};\n'
        intrinsic_setup += f'    {compare_argument_name}.name = "compare"_c;\n'
        intrinsic_setup += f'    {compare_argument_name}.type = Type::FullType{{ {atomic_type}Type.name }};\n'
        intrinsic_setup += f'    {semantics_argument_name}.name = "semantics"_c;\n'
        intrinsic_setup += f'    {semantics_argument_name}.type = Type::FullType{{ MemorySemanticsType.name }};\n'
        intrinsic_setup += f'    {semantics_argument_name}.type.literal = true;\n'
        intrinsic_setup += f'    {function_name}.name = "atomic{atomic_function}"_c;\n'
        intrinsic_setup += f'    {function_name}.returnType = Type::FullType{{ {atomic_type}Type.name }};\n'
        intrinsic_setup += f'    Symbol::Resolved(&{ptr_argument_name})->typeSymbol = &{atomic_type}Type;\n'
        intrinsic_setup += f'    Symbol::Resolved(&{value_argument_name})->typeSymbol = &{atomic_type}Type;\n'
        intrinsic_setup += f'    Symbol::Resolved(&{compare_argument_name})->typeSymbol = &{atomic_type}Type;\n'
        intrinsic_setup += f'    Symbol::Resolved(&{semantics_argument_name})->typeSymbol = &MemorySemanticsType;\n'
        intrinsic_setup += f'    Symbol::Resolved(&{function_name})->returnTypeSymbol = &{atomic_type}Type;\n\n'

        spirv_function = ''
        spirv_function += '    uint32_t scope = ScopeToAtomicScope(args[0].scope);\n'
        spirv_function += '    uint32_t semantics = SemanticsTable[args[3].literalValue.ui];\n'
        spirv_function += '    semantics |= ScopeToMemorySemantics(args[0].scope);\n'
        spirv_function += '    SPIRVResult value = LoadValueSPIRV(c, g, args[1]);\n'
        spirv_function += '    SPIRVResult compare = LoadValueSPIRV(c, g, args[2]);\n'
        spirv_function += '    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(scope));\n'
        spirv_function += '    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt(semantics));\n'
        spirv_function += f'    uint32_t ret = g->writer->MappedInstruction({spirv_builtin}, SPVWriter::Section::LocalFunction, returnType, args[0], scopeId, semanticsId, semanticsId, value, compare);\n'
        spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
        spirv_code += spirv_intrinsic(function_name, spirv_function)

    intrinsic = 'Insert'
    for type in unsigned_types:
        function_name = f'Bit{intrinsic}_{type}'
        base_argument_name = f'{function_name}_base'
        value_argument_name = f'{function_name}_value'
        offset_argument_name = f'{function_name}_offset'
        count_argument_name = f'{function_name}_count'
        intrinsic_decls += f'extern Variable {base_argument_name};\n'
        intrinsic_decls += f'extern Variable {value_argument_name};\n'
        intrinsic_decls += f'extern Variable {offset_argument_name};\n'
        intrinsic_decls += f'extern Variable {count_argument_name};\n'
        intrinsic_decls += f'extern Function {function_name};\n'
        intrinsic_defs += f'Variable {base_argument_name};\n'
        intrinsic_defs += f'Variable {value_argument_name};\n'
        intrinsic_defs += f'Variable {offset_argument_name};\n'
        intrinsic_defs += f'Variable {count_argument_name};\n'
        intrinsic_defs += f'Function {function_name};\n'
        intrinsic_setup += f'    {base_argument_name}.name = "base"_c;\n'
        intrinsic_setup += f'    {base_argument_name}.type = Type::FullType{{ {type}Type.name }};\n'
        intrinsic_setup += f'    {value_argument_name}.name = "value"_c ;\n'
        intrinsic_setup += f'    {value_argument_name}.type = Type::FullType{{ {type}Type.name }};\n'
        intrinsic_setup += f'    {offset_argument_name}.name = "offset"_c;\n'
        intrinsic_setup += f'    {offset_argument_name}.type = Type::FullType{{ {type}Type.name }};\n'
        intrinsic_setup += f'    {count_argument_name}.name = "count"_c;\n'
        intrinsic_setup += f'    {count_argument_name}.type = Type::FullType{{ {type}Type.name }};\n'
        intrinsic_setup += f'    {function_name}.name = "bit{intrinsic}"_c;\n'
        intrinsic_setup += f'    {function_name}.returnType = Type::FullType{{ {type}Type.name }};\n'
        intrinsic_setup += f'    Symbol::Resolved(&{base_argument_name})->typeSymbol = &{type}Type;\n'
        intrinsic_setup += f'    Symbol::Resolved(&{value_argument_name})->typeSymbol = &{type}Type;\n'
        intrinsic_setup += f'    Symbol::Resolved(&{offset_argument_name})->typeSymbol = &{type}Type;\n'
        intrinsic_setup += f'    Symbol::Resolved(&{count_argument_name})->typeSymbol = &{type}Type;\n'
        intrinsic_setup += f'    Symbol::Resolved(&{function_name})->returnTypeSymbol = &{type}Type;\n\n'

        spirv_function = ''
        spirv_function += '    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);\n'
        spirv_function += '    SPIRVResult value = LoadValueSPIRV(c, g, args[1]);\n'
        spirv_function += '    SPIRVResult offset = LoadValueSPIRV(c, g, args[2]);\n'
        spirv_function += '    SPIRVResult count = LoadValueSPIRV(c, g, args[3]);\n'
        spirv_function += f'    uint32_t ret = g->writer->MappedInstruction(OpBitFieldInsert, SPVWriter::Section::LocalFunction, returnType, base, value, offset, count);\n'
        spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
        spirv_code += spirv_intrinsic(function_name, spirv_function)

    intrinsic = 'Extract'
    for type in integer_types:
        function_name = f'Bit{intrinsic}_{type}'
        base_argument_name = f'{function_name}_base'
        offset_argument_name = f'{function_name}_offset'
        count_argument_name = f'{function_name}_count'
        intrinsic_decls += f'extern Variable {base_argument_name};\n'
        intrinsic_decls += f'extern Variable {offset_argument_name};\n'
        intrinsic_decls += f'extern Variable {count_argument_name};\n'
        intrinsic_decls += f'extern Function {function_name};\n'
        intrinsic_defs += f'Variable {base_argument_name};\n'
        intrinsic_defs += f'Variable {offset_argument_name};\n'
        intrinsic_defs += f'Variable {count_argument_name};\n'
        intrinsic_defs += f'Function {function_name};\n'
        intrinsic_setup += f'    {base_argument_name}.name = "base"_c;\n'
        intrinsic_setup += f'    {base_argument_name}.type = Type::FullType{{ {type}Type.name }};\n'
        intrinsic_setup += f'    {offset_argument_name}.name = "offset"_c ;\n'
        intrinsic_setup += f'    {offset_argument_name}.type = Type::FullType{{ {type}Type.name }};\n'
        intrinsic_setup += f'    {count_argument_name}.name = "count"_c;\n'
        intrinsic_setup += f'    {count_argument_name}.type = Type::FullType{{ {type}Type.name }};\n'
        intrinsic_setup += f'    {function_name}.name = "bit{intrinsic}"_c;\n'
        intrinsic_setup += f'    {function_name}.returnType = Type::FullType{{ {type}Type.name }};\n'
        intrinsic_setup += f'    Symbol::Resolved(&{base_argument_name})->typeSymbol = &{type}Type;\n'
        intrinsic_setup += f'    Symbol::Resolved(&{offset_argument_name})->typeSymbol = &{type}Type;\n'
        intrinsic_setup += f'    Symbol::Resolved(&{count_argument_name})->typeSymbol = &{type}Type;\n'
        intrinsic_setup += f'    Symbol::Resolved(&{function_name})->returnTypeSymbol = &{type}Type;\n\n'


        if type.startswith('UInt'):
            spirv_op = "OpBitFieldUExtract"
        elif type.startswith('Int'):
            spirv_op = "OpBitFieldSExtract"
        spirv_function = ''
        spirv_function += '    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);\n'
        spirv_function += '    SPIRVResult offset = LoadValueSPIRV(c, g, args[1]);\n'
        spirv_function += '    SPIRVResult count = LoadValueSPIRV(c, g, args[2]);\n'
        spirv_function += f'    uint32_t ret = g->writer->MappedInstruction({spirv_op}, SPVWriter::Section::LocalFunction, returnType, base, offset, count);\n'
        spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
        spirv_code += spirv_intrinsic(function_name, spirv_function)

    intrinsics = ['Reverse', 'Count']
    for intrinsic in intrinsics:
        for type in integer_types:
            function_name = f'Bit{intrinsic}_{type}'
            base_argument_name = f'{function_name}_base'
            intrinsic_decls += f'extern Variable {base_argument_name};\n'
            intrinsic_decls += f'extern Function {function_name};\n'
            intrinsic_defs += f'Variable {base_argument_name};\n'
            intrinsic_defs += f'Function {function_name};\n'
            intrinsic_setup += f'    {base_argument_name}.name = "base"_c;\n'
            intrinsic_setup += f'    {base_argument_name}.type = Type::FullType{{ {type}Type.name }};\n'
            intrinsic_setup += f'    {function_name}.name = "bit{intrinsic}"_c;\n'
            intrinsic_setup += f'    {function_name}.returnType = Type::FullType{{ {type}Type.name }};\n'
            intrinsic_setup += f'    Symbol::Resolved(&{base_argument_name})->typeSymbol = &{type}Type;\n'
            intrinsic_setup += f'    Symbol::Resolved(&{function_name})->returnTypeSymbol = &{type}Type;\n\n'

            spirv_function = ''
            spirv_function += '    SPIRVResult base = LoadValueSPIRV(c, g, args[0]);\n'
            spirv_function += f'    uint32_t ret = g->writer->MappedInstruction(OpBitReverse, SPVWriter::Section::LocalFunction, returnType, base);\n'
            spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
            spirv_code += spirv_intrinsic(function_name, spirv_function)

    barrier_intrinsics = ['ExecutionBarrier', 'ExecutionBarrierSubgroup', 'ExecutionBarrierWorkgroup']
    for intrinsic in barrier_intrinsics:
        function_name = f'{intrinsic}'
        intrinsic_decls += f'extern Function {function_name};\n'
        intrinsic_defs += f'Function {function_name};\n'
        intrinsic_setup += f'    {function_name}.name = "{intrinsic[0].lower() + intrinsic[1:]}"_c;\n'
        intrinsic_setup += f'    {function_name}.returnType = Type::FullType{{ VoidType.name }};\n'
        intrinsic_setup += f'    Symbol::Resolved(&{function_name})->returnTypeSymbol = &VoidType;\n\n'

        if intrinsic.endswith('Subgroup'):
            scope = '3'
            semantics = '0x2 | 0x80'
        elif intrinsic.endswith('Workgroup'):
            scope = '2'
            semantics = '0x2 | 0x100'
        else:
            scope = '2'
            semantics = '0x2 | 0x40 | 0x80 | 0x100 | 0x200 | 0x400 | 0x800'
        spirv_function = ''
        spirv_function += f'    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt({scope}));\n'
        spirv_function += f'    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt({semantics}));\n'
        spirv_function += f'    uint32_t ret = g->writer->MappedInstruction(OpControlBarrier, SPVWriter::Section::LocalFunction, scopeId, scopeId, semanticsId);\n'
        spirv_function += '    return SPIRVResult(0xFFFFFFFF, returnType);\n'
        spirv_code += spirv_intrinsic(function_name, spirv_function)

    memory_barrier_intrinsics = ['MemoryBarrier', 'MemoryBarrierBuffer', 'MemoryBarrierTexture', 'MemoryBarrierAtomic', 'MemoryBarrierSubgroup', 'MemoryBarrierWorkgroup']
    for intrinsic in memory_barrier_intrinsics:
        function_name = f'{intrinsic}'
        intrinsic_decls += f'extern Function {function_name};\n'
        intrinsic_defs += f'Function {function_name};\n'
        intrinsic_setup += f'    {function_name}.name = "{intrinsic[0].lower() + intrinsic[1:]}"_c;\n'
        intrinsic_setup += f'    {function_name}.returnType = Type::FullType{{ VoidType.name }};\n'
        intrinsic_setup += f'    Symbol::Resolved(&{function_name})->returnTypeSymbol = &VoidType;\n\n'

        if intrinsic.endswith('Buffer'):
            scope = '2'
            semantics = '0x2 | 0x40'
        elif intrinsic.endswith('Texture'):
            scope = '2'
            semantics = '0x2 | 0x800'
        elif intrinsic.endswith('Atomic'):
            scope = '2'
            semantics = '0x2 | 0x400'
        elif intrinsic.endswith('Subgroup'):
            scope = '3'
            semantics = '0x2 | 0x80'
        elif intrinsic.endswith('Workgroup'):
            scope = '2'
            semantics = '0x2 | 0x100'
        else:
            semantics = '0x2 | 0x40 | 0x80 | 0x100 | 0x200 | 0x400 | 0x800'
        spirv_function = ''
        spirv_function += f'    SPIRVResult scopeId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt({scope}));\n'
        spirv_function += f'    SPIRVResult semanticsId = GenerateConstantSPIRV(c, g, ConstantCreationInfo::UInt({semantics}));\n'
        spirv_function += f'    uint32_t ret = g->writer->MappedInstruction(OpMemoryBarrier, SPVWriter::Section::LocalFunction, scopeId, scopeId, semanticsId);\n'
        spirv_function += '    return SPIRVResult(0xFFFFFFFF, returnType);\n'
        spirv_code += spirv_intrinsic(function_name, spirv_function)

    texture_types_no_ms = ['Texture1D', 'Texture2D', 'Texture3D', 'TextureCube', 'Texture1DArray', 'Texture2DArray', 'TextureCubeArray']
    texture_types_ms = ['Texture2DMS', 'Texture2DMSArray']

    texture_types = texture_types_no_ms + texture_types_ms

    type = 'UInt32'
    texture_size_types = {
        'Texture1D': f"{type}",
        'Texture2D': f"{type}x2",
        'Texture3D': f"{type}x3",
        'TextureCube': f"{type}x3",
        'Texture1DArray': f"{type}x2",
        'Texture2DArray': f"{type}x3",
        'TextureCubeArray': f"{type}x4",
        'Texture2DMS': f"{type}x2",
        'Texture2DMSArray': f"{type}x3"
    }

    type = 'Int32'
    texture_denormalized_index_types = {
        'Texture1D': f"{type}",
        'Texture2D': f"{type}x2",
        'Texture3D': f"{type}x3",
        'TextureCube': f"{type}x3",
        'Texture1DArray': f"{type}x2",
        'Texture2DArray': f"{type}x3",
        'TextureCubeArray': f"{type}x4",
        'Texture2DMS': f"{type}x2",
        'Texture2DMSArray': f"{type}x3"
    }

    type = 'Float32'
    texture_float_index_types = {
        'Texture1D': f"{type}",
        'Texture2D': f"{type}x2",
        'Texture3D': f"{type}x3",
        'TextureCube': f"{type}x3",
        'Texture1DArray': f"{type}x2",
        'Texture2DArray': f"{type}x3",
        'TextureCubeArray': f"{type}x4",
        'Texture2DMS': f"{type}x2",
        'Texture2DMSArray': f"{type}x3"
    }

    texture_float_index_proj_sizes = {
        'Texture1D': 2,
        'Texture2D': 3,
        'Texture3D': 4,
        'TextureCube': 4,
        'Texture1DArray': 3,
        'Texture2DArray': 4,
        'Texture2DMS': 3,
        'Texture2DMSArray': 4
    }

    intrinsic = 'GetSize'
    for type in texture_types_no_ms:
        return_type = texture_size_types[type]
        function_name = f'Texture{intrinsic}_{type}'
        texture_argument_name = f'{function_name}_texture'
        intrinsic_decls += f'extern Variable {texture_argument_name};\n'
        intrinsic_decls += f'extern Function {function_name};\n'
        intrinsic_defs += f'Variable {texture_argument_name};\n'
        intrinsic_defs += f'Function {function_name};\n'
        intrinsic_setup += f'    {texture_argument_name}.name = "texture"_c;\n'
        intrinsic_setup += f'    {texture_argument_name}.type = Type::FullType{{ {type}Type.name }};\n'
        intrinsic_setup += f'    {texture_argument_name}.type.AddModifier(Type::FullType::Modifier::Pointer);\n'
        intrinsic_setup += f'    {function_name}.name = "texture{intrinsic}"_c;\n'
        intrinsic_setup += f'    {function_name}.returnType = Type::FullType{{ {return_type}Type.name }};\n'
        intrinsic_setup += f'    Symbol::Resolved(&{texture_argument_name})->typeSymbol = &{type}Type;\n'
        intrinsic_setup += f'    Symbol::Resolved(&{texture_argument_name})->storage = Storage::Uniform;\n'
        intrinsic_setup += f'    Symbol::Resolved(&{function_name})->returnTypeSymbol = &{return_type}Type;\n\n'

        spirv_function = ''
        spirv_function += '    g->writer->Capability(Capabilities::ImageQuery);\n'
        spirv_function += '    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);\n'
        spirv_function += f'    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySize, SPVWriter::Section::LocalFunction, returnType, texture);\n'
        spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
        spirv_code += spirv_intrinsic(function_name, spirv_function)

    intrinsic = 'GetSizeMip'
    for type in texture_types_no_ms:
        return_type = texture_size_types[type]
        function_name = f'Texture{intrinsic}_{type}'
        texture_argument_name = f'{function_name}_texture'
        mip_argument_name = f'{function_name}_UInt32_mip'
        intrinsic_decls += f'extern Variable {texture_argument_name};\n'
        intrinsic_decls += f'extern Variable {mip_argument_name};\n'
        intrinsic_decls += f'extern Function {function_name};\n'
        intrinsic_defs += f'Variable {texture_argument_name};\n'
        intrinsic_defs += f'Variable {mip_argument_name};\n'
        intrinsic_defs += f'Function {function_name};\n'
        intrinsic_setup += f'    {texture_argument_name}.name = "texture"_c;\n'
        intrinsic_setup += f'    {texture_argument_name}.type = Type::FullType{{ {type}Type.name }};\n'
        intrinsic_setup += f'    {texture_argument_name}.type.AddModifier(Type::FullType::Modifier::Pointer);\n'
        intrinsic_setup += f'    {mip_argument_name}.name = "mip"_c;\n'
        intrinsic_setup += f'    {mip_argument_name}.type = Type::FullType{{ {type}Type.name }};\n'
        intrinsic_setup += f'    {function_name}.name = "texture{intrinsic}"_c;\n'
        intrinsic_setup += f'    {function_name}.returnType = Type::FullType{{ {return_type}Type.name }};\n'
        intrinsic_setup += f'    Symbol::Resolved(&{texture_argument_name})->typeSymbol = &{type}Type;\n'
        intrinsic_setup += f'    Symbol::Resolved(&{texture_argument_name})->storage = Storage::Uniform;\n'
        intrinsic_setup += f'    Symbol::Resolved(&{mip_argument_name})->typeSymbol = &UInt32Type;\n'
        intrinsic_setup += f'    Symbol::Resolved(&{function_name})->returnTypeSymbol = &{return_type}Type;\n\n'

        spirv_function = ''
        spirv_function += '    g->writer->Capability(Capabilities::ImageQuery);\n'
        spirv_function += '    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);\n'
        spirv_function += '    SPIRVResult mip = LoadValueSPIRV(c, g, args[1]);\n'
        spirv_function += f'    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySizeLod, SPVWriter::Section::LocalFunction, returnType, texture, mip);\n'
        spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
        spirv_code += spirv_intrinsic(function_name, spirv_function)

    intrinsic = 'GetMips'
    for type in texture_types_no_ms:
        function_name = f'Texture{intrinsic}_{type}'
        texture_argument_name = f'{function_name}_texture'
        intrinsic_decls += f'extern Variable {texture_argument_name};\n'
        intrinsic_decls += f'extern Function {function_name};\n'
        intrinsic_defs += f'Variable {texture_argument_name};\n'
        intrinsic_defs += f'Function {function_name};\n'
        intrinsic_setup += f'    {texture_argument_name}.name = "texture"_c;\n'
        intrinsic_setup += f'    {texture_argument_name}.type = Type::FullType{{ {type}Type.name }};\n'
        intrinsic_setup += f'    {texture_argument_name}.type.AddModifier(Type::FullType::Modifier::Pointer);\n'
        intrinsic_setup += f'    {function_name}.name = "texture{intrinsic}"_c;\n'
        intrinsic_setup += f'    {function_name}.returnType = Type::FullType{{ UInt32Type.name }};\n'
        intrinsic_setup += f'    Symbol::Resolved(&{texture_argument_name})->typeSymbol = &{type}Type;\n'
        intrinsic_setup += f'    Symbol::Resolved(&{texture_argument_name})->storage = Storage::Uniform;\n'
        intrinsic_setup += f'    Symbol::Resolved(&{function_name})->returnTypeSymbol = &UInt32Type;\n\n'

        spirv_function = ''
        spirv_function += '    g->writer->Capability(Capabilities::ImageQuery);\n'
        spirv_function += '    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);\n'
        spirv_function += f'    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLevels, SPVWriter::Section::LocalFunction, returnType, texture);\n'
        spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
        spirv_code += spirv_intrinsic(function_name, spirv_function)

    intrinsic = 'GetSamples'
    for type in texture_types_ms:
        function_name = f'Texture{intrinsic}_{type}'
        texture_argument_name = f'{function_name}_texture'
        intrinsic_decls += f'extern Variable {texture_argument_name};\n'
        intrinsic_decls += f'extern Function {function_name};\n'
        intrinsic_defs += f'Variable {texture_argument_name};\n'
        intrinsic_defs += f'Function {function_name};\n'
        intrinsic_setup += f'    {texture_argument_name}.name = "texture"_c;\n'
        intrinsic_setup += f'    {texture_argument_name}.type = Type::FullType{{ {type}Type.name }};\n'
        intrinsic_setup += f'    {texture_argument_name}.type.AddModifier(Type::FullType::Modifier::Pointer);\n'
        intrinsic_setup += f'    {function_name}.name = "texture{intrinsic}"_c;\n'
        intrinsic_setup += f'    {function_name}.returnType = Type::FullType{{ UInt32Type.name }};\n'
        intrinsic_setup += f'    Symbol::Resolved(&{texture_argument_name})->typeSymbol = &{type}Type;\n'
        intrinsic_setup += f'    Symbol::Resolved(&{texture_argument_name})->storage = Storage::Uniform;\n'
        intrinsic_setup += f'    Symbol::Resolved(&{function_name})->returnTypeSymbol = &UInt32Type;\n\n'

        spirv_function = ''
        spirv_function += '    g->writer->Capability(Capabilities::ImageQuery);\n'
        spirv_function += '    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);\n'
        spirv_function += f'    uint32_t ret = g->writer->MappedInstruction(OpImageQuerySamples, SPVWriter::Section::LocalFunction, returnType, texture);\n'
        spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
        spirv_code += spirv_intrinsic(function_name, spirv_function)

    # Helper function to generate a version of the texture sampling method both for combined texture-samplers and for textures with samplers provided separately.
    def generate_texture_intrinsic_base(intrinsic):
        texture_argument_name = f'{intrinsic}_texture'
        sampler_argument_name = f'{intrinsic}_sampler'
        decls = ''
        decls += f'extern Variable {texture_argument_name};\n'
        decls += f'extern Variable {sampler_argument_name};\n'

        defs = ''
        defs += f'Variable {texture_argument_name};\n'
        defs += f'Variable {sampler_argument_name};\n'

        setup = ''
        setup += f'    {texture_argument_name}.name = "texture"_c;\n'
        setup += f'    {texture_argument_name}.type = Type::FullType{{ {type}Type.name }};\n'
        setup += f'    {texture_argument_name}.type.AddModifier(Type::FullType::Modifier::Pointer);\n'
        setup += f'    {sampler_argument_name}.name = "sampler"_c;\n'
        setup += f'    {sampler_argument_name}.type = Type::FullType{{ SamplerType.name }};\n'
        setup += f'    {sampler_argument_name}.type.AddModifier(Type::FullType::Modifier::Pointer);\n'
        setup += f'    Symbol::Resolved(&{texture_argument_name})->typeSymbol = &{type}Type;\n'
        setup += f'    Symbol::Resolved(&{texture_argument_name})->storage = Storage::Uniform;\n'
        setup += f'    Symbol::Resolved(&{sampler_argument_name})->typeSymbol = &SamplerType;\n'
        setup += f'    Symbol::Resolved(&{sampler_argument_name})->storage = Storage::Uniform;\n'

        sampled_decls = ''
        sampled_decls += f'extern Variable Sampled{texture_argument_name};\n'

        sampled_defs = ''
        sampled_defs += f'Variable Sampled{texture_argument_name};\n'

        sampled_setup = ''
        sampled_setup += f'    Sampled{texture_argument_name}.name = "texture"_c;\n'
        sampled_setup += f'    Sampled{texture_argument_name}.type = Type::FullType{{ {type}Type.name }};\n'
        sampled_setup += f'    Sampled{texture_argument_name}.type.AddModifier(Type::FullType::Modifier::Pointer);\n'
        sampled_setup += f'    Symbol::Resolved(&Sampled{texture_argument_name})->typeSymbol = &{type}Type;\n'
        sampled_setup += f'    Symbol::Resolved(&Sampled{texture_argument_name})->storage = Storage::Uniform;\n'
        return [(decls, defs, setup, ''), (sampled_decls, sampled_defs, sampled_setup, 'Sampled')]

    intrinsic = 'GetSampledMip'
    for type in texture_types_no_ms:
        coordinate_type = texture_float_index_types[type]
        base_function_name = f'Texture{intrinsic}_{type}'

        for defs in generate_texture_intrinsic_base(base_function_name):
            base_decls, base_defs, base_setup, prefix = defs
            function_name = f'{prefix}{base_function_name}'
            coordinate_argument_name = f'{function_name}_coordinate'
            intrinsic_decls += base_decls
            intrinsic_decls += f'extern Variable {coordinate_argument_name};\n'
            intrinsic_decls += f'extern Function {function_name};\n'
            intrinsic_defs += base_defs
            intrinsic_defs += f'Variable {coordinate_argument_name};\n'
            intrinsic_defs += f'Function {function_name};\n'

            intrinsic_setup += f'    {coordinate_argument_name}.name = "coordinate"_c;\n'
            intrinsic_setup += f'    {coordinate_argument_name}.type = Type::FullType{{ {coordinate_type}Type.name }};\n'
            intrinsic_setup += f'    {function_name}.name = "texture{intrinsic}"_c;\n'
            intrinsic_setup += f'    {function_name}.returnType = Type::FullType{{ Float32x2Type.name }};\n'
            intrinsic_setup += base_setup
            intrinsic_setup += f'    Symbol::Resolved(&{coordinate_argument_name})->typeSymbol = &{coordinate_type}Type;\n'
            intrinsic_setup += f'    Symbol::Resolved(&{function_name})->returnTypeSymbol = &Float32x2Type;\n\n'

            spirv_function = ''
            if prefix: # Prefix here is merely 'Sampled'
                spirv_function += '    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);\n'
                spirv_function += '    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);\n'
            else:
                spirv_function += '    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);\n'
                spirv_function += '    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);\n'
            spirv_function += '    g->writer->Capability(Capabilities::ImageQuery);\n'
            spirv_function += '    uint32_t ret = g->writer->MappedInstruction(OpImageQueryLod, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);\n'
            spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
            spirv_code += spirv_intrinsic(function_name, spirv_function)

    texture_load_store_intrinsics = ['Load', 'LoadMip', 'Store', 'StoreMip']
    for type in texture_types:
        coordinate_type = texture_denormalized_index_types[type]
        for intrinsic in texture_load_store_intrinsics:
            hasMip = intrinsic in ['LoadMip', 'StoreMip']
            hasStore = intrinsic in ['Store', 'StoreMip']
            function_name = f'Texture{intrinsic}_{type}'
            texture_argument_name = f'{function_name}_texture'

            coordinate_argument_name = f'{function_name}_coordinate'
            if hasMip:
                mip_argument_name = f'{function_name}_mip'
            if hasStore:
                value_argument_name = f'{function_name}_value'

            intrinsic_decls += f'extern Variable {texture_argument_name};\n'
            intrinsic_decls += f'extern Variable {coordinate_argument_name};\n'
            if hasMip:
                intrinsic_decls += f'extern Variable {mip_argument_name};\n'
            if hasStore:
                intrinsic_decls += f'extern Variable {value_argument_name};\n'
            intrinsic_decls += f'extern Function {function_name};\n'

            intrinsic_defs += f'Variable {texture_argument_name};\n'
            intrinsic_defs += f'Variable {coordinate_argument_name};\n'
            if hasMip:
                intrinsic_defs += f'Variable {mip_argument_name};\n'
            if hasStore:
                intrinsic_defs += f'Variable {value_argument_name};\n'
            intrinsic_defs += f'Function {function_name};\n'

            intrinsic_setup += f'    {texture_argument_name}.name = "texture"_c;\n'
            intrinsic_setup += f'    {texture_argument_name}.type = Type::FullType{{ {type}Type.name }};\n'
            intrinsic_setup += f'    {texture_argument_name}.type.AddModifier(Type::FullType::Modifier::Pointer);\n'

            intrinsic_setup += f'    {coordinate_argument_name}.name = "coordinate"_c;\n'
            intrinsic_setup += f'    {coordinate_argument_name}.type = Type::FullType{{ {coordinate_type}Type.name }};\n'
            if hasMip:
                intrinsic_setup += f'    {mip_argument_name}.name = "mip"_c;\n'
                intrinsic_setup += f'    {mip_argument_name}.type = Type::FullType{{ Int32Type.name }};\n'
            if hasStore:
                intrinsic_setup += f'    {value_argument_name}.name = "value"_c;\n'
                intrinsic_setup += f'    {value_argument_name}.type = Type::FullType{{ Float32x4Type.name }};\n'
            intrinsic_setup += f'    {function_name}.name = "texture{intrinsic}"_c;\n'

            if not hasStore:
                intrinsic_setup += f'    {function_name}.returnType = Type::FullType{{ {type}Type.name }};\n'
            else:
                intrinsic_setup += f'    {function_name}.returnType = Type::FullType{{ VoidType.name }};\n'

            intrinsic_setup += f'    Symbol::Resolved(&{texture_argument_name})->typeSymbol = &{type}Type;\n'
            intrinsic_setup += f'    Symbol::Resolved(&{texture_argument_name})->storage = Storage::Uniform;\n'
            if hasMip:
                intrinsic_setup += f'    Symbol::Resolved(&{mip_argument_name})->typeSymbol = &Int32Type;\n'
            if hasStore:
                intrinsic_setup += f'    Symbol::Resolved(&{value_argument_name})->typeSymbol = &Float32x4Type;\n'
            intrinsic_setup += f'    Symbol::Resolved(&{coordinate_argument_name})->typeSymbol = &{coordinate_type}Type;\n\n'

            spirv_function = ''
            spirv_function += '    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);\n'
            spirv_function += '    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);\n'
            if hasStore:
                spirv_function += '    SPIRVResult value = LoadValueSPIRV(c, g, args[2]);\n'
                if hasMip:
                    spirv_function += '    SPIRVResult mip = LoadValueSPIRV(c, g, args[3]);\n'
            else:
                if hasMip:
                    spirv_function += '    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);\n'

            if hasStore:
                if hasMip:
                    spirv_function += f'    uint32_t ret = g->writer->MappedInstruction(OpImageWrite, SPVWriter::Section::LocalFunction, returnType, texture, coord, value, ImageOperands::Lod, mip);\n'
                else:
                    spirv_function += f'    uint32_t ret = g->writer->MappedInstruction(OpImageWrite, SPVWriter::Section::LocalFunction, returnType, texture, coord, value);\n'
            else:
                if hasMip:
                    spirv_function += f'    uint32_t ret = g->writer->MappedInstruction(OpImageRead, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip);\n'
                else:
                    spirv_function += f'    uint32_t ret = g->writer->MappedInstruction(OpImageRead, SPVWriter::Section::LocalFunction, returnType, texture, coord);\n'
            spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
            spirv_code += spirv_intrinsic(function_name, spirv_function)

    texture_fetch_intrinsics = ['Fetch', 'FetchSample']
    for type in texture_types:

        if type.startswith('TextureCube'):
            continue

        for intrinsic in texture_fetch_intrinsics:
            function_name = f'Texture{intrinsic}_{type}'
            texture_argument_name = f'{function_name}_texture'
            coordinate_argument_name = f'{function_name}_coordinate'
            lod_argument_name = f'{function_name}_lod'
            if intrinsic == 'FetchSample':
                sample_argument_name = f'{function_name}_sample'
            intrinsic_decls += f'extern Variable {texture_argument_name};\n'
            intrinsic_decls += f'extern Variable {coordinate_argument_name};\n'
            intrinsic_decls += f'extern Variable {lod_argument_name};\n'

            if intrinsic == 'FetchSample':
                intrinsic_decls += f'extern Variable {sample_argument_name};\n'
            intrinsic_decls += f'extern Function {function_name};\n'

            intrinsic_defs += f'Variable {texture_argument_name};\n'
            intrinsic_defs += f'Variable {coordinate_argument_name};\n'
            intrinsic_defs += f'Variable {lod_argument_name};\n'
            if intrinsic == 'FetchSample':
                intrinsic_defs += f'Variable {sample_argument_name};\n'
            intrinsic_defs += f'Function {function_name};\n'

            intrinsic_setup += f'    {texture_argument_name}.name = "texture"_c;\n'
            intrinsic_setup += f'    {texture_argument_name}.type = Type::FullType{{ {type}Type.name }};\n'
            intrinsic_setup += f'    {texture_argument_name}.type.AddModifier(Type::FullType::Modifier::Pointer);\n'
            intrinsic_setup += f'    {coordinate_argument_name}.name = "coordinate"_c;\n'
            intrinsic_setup += f'    {coordinate_argument_name}.type = Type::FullType{{ {texture_denormalized_index_types[type]}Type.name }};\n'
            intrinsic_setup += f'    {lod_argument_name}.name = "lod"_c;\n'
            intrinsic_setup += f'    {lod_argument_name}.type = Type::FullType{{ UInt32Type.name }};\n'
            if intrinsic == 'FetchSample':
                intrinsic_setup += f'    {sample_argument_name}.name = "sample"_c;\n'
                intrinsic_setup += f'    {sample_argument_name}.type = Type::FullType{{ UInt32Type.name }};\n'
            intrinsic_setup += f'    {function_name}.name = "texture{intrinsic}"_c;\n'
            intrinsic_setup += f'    {function_name}.returnType = Type::FullType{{ Float32x4Type.name }};\n'
            intrinsic_setup += f'    Symbol::Resolved(&{texture_argument_name})->typeSymbol = &{type}Type;\n'
            intrinsic_setup += f'    Symbol::Resolved(&{texture_argument_name})->storage = Storage::Uniform;\n'
            intrinsic_setup += f'    Symbol::Resolved(&{coordinate_argument_name})->typeSymbol = &{texture_denormalized_index_types[type]}Type;\n'
            intrinsic_setup += f'    Symbol::Resolved(&{lod_argument_name})->typeSymbol = &UInt32Type;\n'
            if intrinsic == 'FetchSample':
                intrinsic_setup += f'    Symbol::Resolved(&{sample_argument_name})->typeSymbol = &UInt32Type;\n'

            intrinsic_setup += f'    Symbol::Resolved(&{function_name})->returnTypeSymbol = &Float32x4Type;\n\n'

            spirv_function = ''
            spirv_function += '    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);\n'
            spirv_function += '    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);\n'
            spirv_function += '    SPIRVResult mip = LoadValueSPIRV(c, g, args[2]);\n'
            if intrinsic == 'FetchSample':
                spirv_function += '    SPIRVResult sample = LoadValueSPIRV(c, g, args[3]);\n'
                spirv_function += f'    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip, ImageOperands::Sample, sample);\n'
            else:
                spirv_function += f'    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, ImageOperands::Lod, mip);\n'
            spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
            spirv_code += spirv_intrinsic(function_name, spirv_function)

    texture_gather_intrinsics = ['Gather', 'GatherOffset']
    for type in texture_types_no_ms:

        if type.startswith('Texture1D') or type.startswith('Texture3D'):
            continue

        for intrinsic in texture_gather_intrinsics:
            base_function_name = f'Texture{intrinsic}_{type}'
            for defs in generate_texture_intrinsic_base(base_function_name):
                base_decls, base_defs, base_setup, prefix = defs
                function_name = f'{prefix}{base_function_name}'
                texture_argument_name = f'{function_name}_texture'
                coordinate_argument_name = f'{function_name}_coordinate'
                component_argument_name = f'{function_name}_component'
                if intrinsic == 'GatherOffset':
                    offset_argument_name = f'{function_name}_offset'
                intrinsic_decls += f'extern Variable {texture_argument_name};\n'
                intrinsic_decls += f'extern Variable {coordinate_argument_name};\n'
                intrinsic_decls += f'extern Variable {component_argument_name};\n'

                if intrinsic == 'GatherOffset':
                    intrinsic_decls += f'extern Variable {offset_argument_name};\n'
                intrinsic_decls += f'extern Function {function_name};\n'

                intrinsic_defs += f'Variable {texture_argument_name};\n'
                intrinsic_defs += f'Variable {coordinate_argument_name};\n'
                intrinsic_defs += f'Variable {component_argument_name};\n'
                if intrinsic == 'GatherOffset':
                    intrinsic_defs += f'Variable {offset_argument_name};\n'
                intrinsic_defs += f'Function {function_name};\n'

                intrinsic_setup += f'    {texture_argument_name}.name = "texture"_c;\n'
                intrinsic_setup += f'    {texture_argument_name}.type = Type::FullType{{ {type}Type.name }};\n'
                intrinsic_setup += f'    {texture_argument_name}.type.AddModifier(Type::FullType::Modifier::Pointer);\n'
                intrinsic_setup += f'    {coordinate_argument_name}.name = "coordinate"_c;\n'
                intrinsic_setup += f'    {coordinate_argument_name}.type = Type::FullType{{ {texture_denormalized_index_types[type]}Type.name }};\n'
                intrinsic_setup += f'    {component_argument_name}.name = "component"_c;\n'
                intrinsic_setup += f'    {component_argument_name}.type = Type::FullType{{ Int32Type.name }};\n'
                if intrinsic == 'GatherOffset':
                    intrinsic_setup += f'    {offset_argument_name}.name = "offset"_c;\n'
                    intrinsic_setup += f'    {offset_argument_name}.type = Type::FullType{{ UInt32Type.name }};\n'
                intrinsic_setup += f'    {function_name}.name = "texture{intrinsic}"_c;\n'
                intrinsic_setup += f'    {function_name}.returnType = Type::FullType{{ Float32x4Type.name }};\n'
                intrinsic_setup += f'    Symbol::Resolved(&{texture_argument_name})->typeSymbol = &{type}Type;\n'
                intrinsic_setup += f'    Symbol::Resolved(&{texture_argument_name})->storage = Storage::Uniform;\n'
                intrinsic_setup += f'    Symbol::Resolved(&{coordinate_argument_name})->typeSymbol = &{texture_denormalized_index_types[type]}Type;\n'
                intrinsic_setup += f'    Symbol::Resolved(&{component_argument_name})->typeSymbol = &Int32Type;\n'
                if intrinsic == 'GatherOffset':
                    intrinsic_setup += f'    Symbol::Resolved(&{offset_argument_name})->typeSymbol = &UInt32Type;\n'

                intrinsic_setup += f'    Symbol::Resolved(&{function_name})->returnTypeSymbol = &Float32x4Type;\n\n'

                spirv_function = ''
                spirv_function += '    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);\n'
                spirv_function += '    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);\n'
                spirv_function += '    SPIRVResult component = LoadValueSPIRV(c, g, args[2]);\n'
                if intrinsic == 'GatherOffset':
                    spirv_function += '    SPIRVResult offset = LoadValueSPIRV(c, g, args[3]);\n'
                    spirv_function += f'    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, component, ImageOperands::Offset, offset);\n'
                else:
                    spirv_function += f'    uint32_t ret = g->writer->MappedInstruction(OpImageFetch, SPVWriter::Section::LocalFunction, returnType, texture, coord, component);\n'
                spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
                spirv_code += spirv_intrinsic(function_name, spirv_function)

    intrinsic = 'PixelCacheLoad'
    for type in ['PixelCache', 'PixelCacheMS']:
        function_name = f'Texture{intrinsic}_{type}'
        texture_argument_name = f'{function_name}_texture'
        coordinate_argument_name = f'{function_name}_coordinate'
        intrinsic_decls += f'extern Variable {texture_argument_name};\n'
        intrinsic_decls += f'extern Function {function_name};\n'
        intrinsic_defs += f'Variable {texture_argument_name};\n'
        intrinsic_defs += f'Function {function_name};\n'
        intrinsic_setup += f'    {texture_argument_name}.name = "texture"_c;\n'
        intrinsic_setup += f'    {texture_argument_name}.type = Type::FullType{{ {type}Type.name }};\n'
        intrinsic_setup += f'    {texture_argument_name}.type.AddModifier(Type::FullType::Modifier::Pointer);\n'
        intrinsic_setup += f'    {function_name}.name = "texture{intrinsic}"_c;\n'
        intrinsic_setup += f'    {function_name}.returnType = Type::FullType{{ Float32x4Type.name }};\n'
        intrinsic_setup += f'    Symbol::Resolved(&{texture_argument_name})->typeSymbol = &{type}Type;\n'
        intrinsic_setup += f'    Symbol::Resolved(&{texture_argument_name})->storage = Storage::Uniform;\n'
        intrinsic_setup += f'    Symbol::Resolved(&{function_name})->returnTypeSymbol = &Float32x4Type;\n\n'

        spirv_function = ''
        spirv_function += '    SPIRVResult texture = LoadValueSPIRV(c, g, args[0]);\n'
        spirv_function += '    SPIRVResult coord = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Float32(0), 2);\n'
        spirv_function += f'    uint32_t ret = g->writer->MappedInstruction(OpImageRead, SPVWriter::Section::LocalFunction, returnType, texture, coord);\n'

    intrinsic = 'Sample'
    lod_modifiers = ['', 'Lod', 'Grad', 'Bias']
    compare_modifiers = ['', 'Compare']
    projection_modifiers = ['', 'Proj']
    offset_modifiers = ['', 'Offset']
    for lod in lod_modifiers:
        for comp in compare_modifiers:
            for proj in projection_modifiers:
                for offset in offset_modifiers:
                    for type in texture_types_no_ms:
                        base_function_name = f'Texture{intrinsic}{lod}{proj}{comp}{offset}_{type}'

                        for defs in generate_texture_intrinsic_base(base_function_name):
                            base_decls, base_defs, base_setup, prefix = defs
                            function_name = f'{prefix}{base_function_name}'
                            if comp == 'Compare' and type.startswith('TextureCube'):
                                continue

                            if proj == 'Proj' and type.endswith('Array'):
                                continue

                            if proj == 'Proj' and type.startswith('TextureCube'):
                                continue

                            if offset == 'Offset' and type.startswith('TextureCube'):
                                continue

                            coordinate_type = texture_float_index_types[type]
                            coordinate_argument_name = f'{function_name}_coordinate'
                            if lod == 'Lod':
                                lod_argument_name = f'{function_name}_lod'
                            elif lod == 'Grad':
                                lodx_argument_name = f'{function_name}_gradx'
                                lody_argument_name = f'{function_name}_grady'
                            elif lod == 'Bias':
                                lod_argument_name = f'{function_name}_bias'
                            if proj == 'Proj':
                                proj_argument_name = f'{function_name}_proj'
                            if comp == 'Compare':
                                compare_argument_name = f'{function_name}_compare'
                            if offset == 'Offset':
                                offset_argument_name = f'{function_name}_offset'


                            intrinsic_decls += base_decls
                            intrinsic_decls += f'extern Variable {coordinate_argument_name};\n'
                            if lod == 'Lod' or lod == 'Bias':
                                intrinsic_decls += f'extern Variable {lod_argument_name};\n'
                            elif lod == 'Grad':
                                intrinsic_decls += f'extern Variable {lodx_argument_name};\n'
                                intrinsic_decls += f'extern Variable {lody_argument_name};\n'
                            elif lod == 'Bias':
                                intrinsic_decls += f'extern Variable {lod_argument_name};\n'
                            if proj == 'Proj':
                                intrinsic_decls += f'extern Variable {proj_argument_name};\n'
                            if comp == 'Compare':
                                intrinsic_decls += f'extern Variable {compare_argument_name};\n'
                            if offset == 'Offset':
                                intrinsic_decls += f'extern Variable {offset_argument_name};\n'

                            intrinsic_decls += f'extern Function {function_name};\n'

                            intrinsic_defs += base_defs
                            intrinsic_defs += f'Variable {coordinate_argument_name};\n'
                            if lod == 'Lod' or lod == 'Bias':
                                intrinsic_defs += f'Variable {lod_argument_name};\n'
                            elif lod == 'Grad':
                                intrinsic_defs += f'Variable {lodx_argument_name};\n'
                                intrinsic_defs += f'Variable {lody_argument_name};\n'
                            elif lod == 'Bias':
                                intrinsic_defs += f'Variable {lod_argument_name};\n'
                            if proj == 'Proj':
                                intrinsic_defs += f'Variable {proj_argument_name};\n'
                            if comp == 'Compare':
                                intrinsic_defs += f'Variable {compare_argument_name};\n'
                            if offset == 'Offset':
                                intrinsic_defs += f'Variable {offset_argument_name};\n'

                            intrinsic_defs += f'Function {function_name};\n'

                            intrinsic_setup += base_setup
                            intrinsic_setup += f'    {coordinate_argument_name}.name = "coordinate"_c;\n'
                            intrinsic_setup += f'    {coordinate_argument_name}.type = Type::FullType{{ {coordinate_type}Type.name }};\n'
                            if lod == 'Lod':
                                intrinsic_setup += f'    {lod_argument_name}.name = "lod"_c;\n'
                                intrinsic_setup += f'    {lod_argument_name}.type = Type::FullType{{ Float32Type.name }};\n'
                            elif lod == 'Grad':
                                intrinsic_setup += f'    {lodx_argument_name}.name = "grad_x"_c;\n'
                                intrinsic_setup += f'    {lodx_argument_name}.type = Type::FullType{{ {coordinate_type}Type.name }};\n'
                                intrinsic_setup += f'    {lody_argument_name}.name = "grad_y"_c;\n'
                                intrinsic_setup += f'    {lody_argument_name}.type = Type::FullType{{ {coordinate_type}Type.name }};\n'
                            elif lod == 'Bias':
                                intrinsic_setup += f'    {lod_argument_name}.name = "bias"_c;\n'
                                intrinsic_setup += f'    {lod_argument_name}.type = Type::FullType{{ Float32Type.name }};\n'
                            if proj == 'Proj':
                                intrinsic_setup += f'    {proj_argument_name}.name = "proj"_c;\n'
                                intrinsic_setup += f'    {proj_argument_name}.type = Type::FullType{{ Float32Type.name }};\n'
                            if comp == 'Compare':
                                intrinsic_setup += f'    {compare_argument_name}.name = "compare"_c;\n'
                                intrinsic_setup += f'    {compare_argument_name}.type = Type::FullType{{ Float32Type.name }};\n'
                            if offset == 'Offset':
                                intrinsic_setup += f'    {offset_argument_name}.name = "offset"_c;\n'
                                intrinsic_setup += f'    {offset_argument_name}.type = Type::FullType{{ {coordinate_type}Type.name }};\n'

                            intrinsic_setup += f'    {function_name}.name = "texture{intrinsic}{lod}{proj}{comp}{offset}"_c;\n'
                            intrinsic_setup += f'    {function_name}.returnType = Type::FullType{{ Float32x4Type.name }};\n'
                            intrinsic_setup += f'    Symbol::Resolved(&{coordinate_argument_name})->typeSymbol = &{coordinate_type}Type;\n'
                            if lod == 'Lod' or lod == 'Bias':
                                intrinsic_setup += f'    Symbol::Resolved(&{lod_argument_name})->typeSymbol = &Float32Type;\n'
                            elif lod == 'Grad':
                                intrinsic_setup += f'    Symbol::Resolved(&{lodx_argument_name})->typeSymbol = &{coordinate_type}Type;\n'
                                intrinsic_setup += f'    Symbol::Resolved(&{lody_argument_name})->typeSymbol = &{coordinate_type}Type;\n'
                            elif lod == 'Bias':
                                intrinsic_setup += f'    Symbol::Resolved(&{lod_argument_name})->typeSymbol = &Float32Type;\n'
                            if proj == 'Proj':
                                intrinsic_setup += f'    Symbol::Resolved(&{proj_argument_name})->typeSymbol = &Float32Type;\n'
                            if comp == 'Compare':
                                intrinsic_setup += f'    Symbol::Resolved(&{compare_argument_name})->typeSymbol = &Float32Type;\n'
                            if offset == 'Offset':
                                intrinsic_setup += f'    Symbol::Resolved(&{offset_argument_name})->typeSymbol = &{coordinate_type}Type;\n'
                            
                            intrinsic_setup += f'    Symbol::Resolved(&{function_name})->returnTypeSymbol = &Float32x4Type;\n\n'

                            spirv_function = ''
                            spirv_function += '    g->writer->Capability(Capabilities::Shader);\n'
                            if prefix: # Prefix here is merely 'Sampled'
                                spirv_function += '    SPIRVResult sampledImage = LoadValueSPIRV(c, g, args[0]);\n'
                                spirv_function += '    SPIRVResult coord = LoadValueSPIRV(c, g, args[1]);\n'
                            else:
                                spirv_function += '    SPIRVResult sampledImage = CreateSampledImageSPIRV(c, g, args[0], args[1]);\n'
                                spirv_function += '    SPIRVResult coord = LoadValueSPIRV(c, g, args[2]);\n'
                            spirv_args = []
                            if prefix:
                                spirv_arg_counter = 2 # Sampled image + coordinate
                            else:
                                spirv_arg_counter = 3 # Texture + sampler + coordinate

                            spirv_proj = '' 
                            if proj:
                                spirv_proj = 'Proj'
                                spirv_function += f'    SPIRVResult proj = LoadValueSPIRV(c, g, args[{spirv_arg_counter}]);\n'
                                spirv_arg_counter += 1
                                spirv_function += f'    uint32_t vectorType = GeneratePODTypeSPIRV(c, g, TypeCode::Float32, {texture_float_index_proj_sizes[type]});\n'
                                spirv_function += f'    coord = GenerateCompositeSPIRV(c, g, vectorType, {{ coord, proj }});\n'
                            spirv_compare = ''
                            if comp:
                                spirv_compare = 'Dref'
                                spirv_function += f'    SPIRVResult compare = LoadValueSPIRV(c, g, args[{spirv_arg_counter}]);\n'
                                spirv_arg_counter += 1
                                spirv_args.append('compare')
                            spirv_lod = 'ImplicitLod'
                            if lod == 'Lod' or lod == 'Grad':
                                spirv_lod = 'ExplicitLod'
                                if lod == 'Lod':
                                    spirv_function += f'    SPIRVResult lod = LoadValueSPIRV(c, g, args[{spirv_arg_counter}]);\n'
                                    spirv_arg_counter += 1
                                    spirv_args.append('ImageOperands::Lod, lod')
                                elif lod == 'Grad':
                                    spirv_function += f'    SPIRVResult gradX = LoadValueSPIRV(c, g, args[{spirv_arg_counter}]);\n'
                                    spirv_arg_counter += 1
                                    spirv_function += f'    SPIRVResult gradY = LoadValueSPIRV(c, g, args[{spirv_arg_counter}]);\n'
                                    spirv_arg_counter += 1
                                    spirv_args.append('ImageOperands::Grad, gradX, gradY')
                            elif lod == 'Bias':
                                spirv_function += f'    SPIRVResult bias = LoadValueSPIRV(c, g, args[{spirv_arg_counter}]);\n'
                                spirv_arg_counter += 1
                                spirv_args.append('ImageOperands::Bias, bias')
                            if offset:
                                spirv_function += '    g->writer->Capability(Capabilities::ImageQuery);\n'
                                spirv_function += f'    SPIRVResult offset = GenerateConstantSPIRV(c, g, ConstantCreationInfo::Int32(0), 2);\n'
                                spirv_args.append('ImageOperands::Offset, offset')

                            if spirv_args:
                                spirv_arg_list = ', '.join(spirv_args)
                                spirv_function += f'    uint32_t ret = g->writer->MappedInstruction(OpImageSample{spirv_proj}{spirv_compare}{spirv_lod}, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord, {spirv_arg_list});\n'
                            else:
                                spirv_function += f'    uint32_t ret = g->writer->MappedInstruction(OpImageSample{spirv_proj}{spirv_compare}{spirv_lod}, SPVWriter::Section::LocalFunction, returnType, sampledImage, coord);\n'
                            spirv_function += '    return SPIRVResult(ret, returnType, true);\n'
                            spirv_code += spirv_intrinsic(function_name, spirv_function)



    spirv_intrinsics.write(spirv_code[0:-2])
    spirv_intrinsics.write('\n\n')
    spirv_intrinsics.write('const StaticMap SPIRVDefaultIntrinsics = std::array{\n')
    spirv_intrinsics.write(",\n".join(spirv_intrinsic_list))
    spirv_intrinsics.write('\n};\n')
    #spirv_intrinsics.write('} // namespace GPULang\n\n')
    
    intrinsics_header.write(intrinsic_decls)

    intrinsics_header.write('inline constexpr StaticMap Intrinsics = std::array{\n')
    intrinsics_header.write(',\n'.join(intrinsic_list))
    intrinsics_header.write('\n};\n\n')
    intrinsics_header.write('} // namespace GPULang\n\n')

    intrinsics_source.write(intrinsic_defs)

    intrinsics_source.write('void SetupIntrinsics()\n')
    intrinsics_source.write('{\n')
    intrinsics_source.write(intrinsic_setup)
    intrinsics_source.write('}\n')
    intrinsics_source.write('} // namespace GPULang\n')




generate_swizzle_four()
generate_swizzle_three()
generate_swizzle_two()
generate_types()

open_file.close()
print("Types generated!")