
import os
from math import trunc

os.makedirs('../generated', exist_ok=True)
os.makedirs('../generated/spirv', exist_ok=True)
open_file = open('../generated/swizzle.h', 'w')
open_file.write("//-------------------------------------------------\n")
open_file.write("// *** Generated by type_gen.py. ***\n")
open_file.write("//         DO NOT MODIFY!!!\n")
open_file.write("//-------------------------------------------------\n\n")

def generate_swizzle_four():
    components = ['x', 'y', 'z', 'w']
    open_file.write("#define SWIZZLE4()\\\n")
    for x in components:
        open_file.write(f"X(" + x + ")\\\n")
        for y in components:
            open_file.write(f"X(" + x + y + ")\\\n")
            for z in components:
                open_file.write(f"X(" + x + y + z + ")\\\n")
                for w in components:
                    open_file.write(f"X(" + x + y + z + w + ")\\\n")
    components = ['r', 'g', 'b', 'a']
    for x in components:
        open_file.write(f"X(" + x + ")\\\n")
        for y in components:
            open_file.write(f"X(" + x + y + ")\\\n")
            for z in components:
                open_file.write(f"X(" + x + y + z + ")\\\n")
                for w in components:
                    open_file.write(f"X(" + x + y + z + w + ")\\\n")
    open_file.write("\n")

def generate_swizzle_three():
    components = ['x', 'y', 'z']

    open_file.write("#define SWIZZLE3()\\\n")
    for x in components:
        open_file.write(f"X(" + x + ")\\\n")
        for y in components:
            open_file.write(f"X(" + x + y + ")\\\n")
            for z in components:
                open_file.write(f"X(" + x + y + z + ")\\\n")
    components = ['r', 'g', 'b']
    for x in components:
        open_file.write(f"X(" + x + ")\\\n")
        for y in components:
            open_file.write(f"X(" + x + y + ")\\\n")
            for z in components:
                open_file.write(f"X(" + x + y + z + ")\\\n")
    open_file.write("\n")

def generate_swizzle_two():
    components = ['x', 'y']
    open_file.write("#define SWIZZLE2()\\\n")
    for x in components:
        open_file.write(f"X(" + x + ")\\\n")
        for y in components:
            open_file.write(f"X(" + x + y + ")\\\n")
    components = ['r', 'g']
    for x in components:
        open_file.write(f"X(" + x + ")\\\n")
        for y in components:
            open_file.write(f"X(" + x + y + ")\\\n")
    open_file.write("\n")

def generate_types():
    types = ["Float32", "UInt32", "Int32", "Bool8", "Float16", "UInt16", "Int16"]
    base_types = ["Float", "UInt", "Int", "Bool", "Float", "UInt", "Int"]

    bit_widths = [32, 32, 32, 8, 16, 16, 16]
    data_types = ["f32", "u32", "i32", "b8", "f16", "u16", "i16"]

    bit_operator_names = ['or', 'and', 'xor', 'lsh', 'rsh']
    bit_operators = ['|', '&', '^', '<<', '>>']

    scalar_operator_names = ['add', 'sub', 'mul', 'div', 'mod']
    scalar_operators = ['+', '-', '*', '/', '%']

    comparison_operator_names = ['lt', 'lte', 'gt', 'gte', 'eq', 'neq']
    comparison_operators = ['<', '<=', '>', '>=', '==', '!=']

    bool_operator_names = ['oror', 'andand', 'eq', 'neq']
    bool_operators = ['||', '&&', '==', '!=']

    assignment_operator_names = ['addasg', 'subasg', 'mulasg', 'divasg']
    assignment_operators = ['+=', '-=', '*=', '/=']

    bit_assignment_operator_names = ['orasg', 'andasg', 'xorasg', 'lshasg', 'rhsasg']
    bit_assignment_operators = ['|=', '&=', '^=', '<<=', '>>=']

    scale_operator_names = ['scale', 'scale', 'scale', 'scale', 'scale', 'scale']
    scale_operators = ['*', '*', '*', '*', '*', '*']
    scale_operator_types = ['Float32', 'Float16', 'UInt32', 'UInt16', 'Int32', 'Int16']
    scale_operator_data_types = ['f32', 'f16', 'u32', 'u16', 'i32', 'i16']

    index_operator_names = ['index_Int32', 'index_UInt32', 'index_Int16', 'index_UInt16']
    index_operators = ['[]', '[]', '[]', '[]']
    index_types = ['Int32', 'UInt32', 'Int16', 'UInt16']
    index_data_types = ['i32', 'u32', 'i16', 'u16']

    vector_matrix_operator_names = ['mul']
    vector_matrix_operators = ['*']

    header_file = open("../generated/types.h", 'w')
    source_file = open("../generated/types.cc", 'w')

    ### Type conversion enum and SPIRV conversion methods ###
    spirv_intrinsics = open("../generated/types_spirv.h", 'w')

    conversion_table_enum = "enum TypeConversionTable\n"
    conversion_table_enum += '{\n'

    class TypeConverter:
        def __init__(self, enu, target, source_data_type, spirv_conversion_function, spirv_conversion_prep, spirv_conversion_arguments):
            self.enum = enu
            self.target = target
            self.source_data_type = source_data_type    
            self.spirv_conversion_function = spirv_conversion_function
            self.spirv_conversion_prep = spirv_conversion_prep
            self.spirv_conversion_arguments = spirv_conversion_arguments

    type_conversions = []
    for type1, width1, base_type1, data_type1 in zip(types, bit_widths, base_types, data_types):
        for type2, width2, base_type2, data_type2 in zip(types, bit_widths, base_types, data_types):
            if type1 != type2:
                conversion_table_enum += '    {}To{},\n'.format(type1, type2)
                spirv_conversion_function = ''
                spirv_conversion_prep = ''

                if type1.startswith('Bool'):
                    if type2.startswith('Int') or type2.startswith('UInt'):
                        spirv_conversion_prep = '            SPIRVResult trueValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::{}(1), vectorSize);\n'.format(type2)
                        spirv_conversion_prep += '            SPIRVResult falseValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::{}(0), vectorSize);\n'.format(type2)
                        type_conversions.append(TypeConverter('{}To{}'.format(type1, type2), type2, data_type1, 'OpSelect', spirv_conversion_prep, 'trueValue, falseValue'))
                else:    
                    if not type2.startswith('Bool'):
                        spirv_conversion_prep = ''
                        if type1.startswith('Float'):                    
                            if width1 != width2:
                                spirv_conversion_function = 'OpFConvert'
                            if type2.startswith('UInt'):
                                spirv_conversion_function = 'OpConvertFToU'
                            elif type2.startswith('Int'):
                                spirv_conversion_function = 'OpConvertFToS'
                        elif type1.startswith('UInt'):
                            if width1 != width2:
                                spirv_conversion_function = 'OpUConvert'
                            if type2.startswith('Int'):
                                spirv_conversion_function = 'OpBitcast'
                            elif type2.startswith('Float'):
                                spirv_conversion_function = 'OpConvertUToF'
                        elif type1.startswith('Int'):
                            if width1 != width2:
                                spirv_conversion_function = 'OpSConvert'
                            if type2.startswith('UInt'):
                                spirv_conversion_function = 'OpBitcast'
                            elif type2.startswith('Float'):
                                spirv_conversion_function = 'OpConvertSToF'
                        type_conversions.append(TypeConverter('{}To{}'.format(type1, type2), type2, data_type1, spirv_conversion_function, spirv_conversion_prep, ''))
                    else:
                        if type1.startswith('UInt') or type1.startswith('Int'):
                            spirv_conversion_prep = '            value = LoadValueSPIRV(c, g, value);\n'
                            spirv_conversion_prep += '            SPIRVResult falseValue = GenerateConstantSPIRV(c, g, ConstantCreationInfo::{}(0), vectorSize);\n'.format(type1)   
                            type_conversions.append(TypeConverter('{}To{}'.format(type1, type2), type2, data_type1, 'OpINotEqual', spirv_conversion_prep, 'value, falseValue'))


    conversion_table_enum = conversion_table_enum[0:-2]
    conversion_table_enum += '\n};\n\n'

    spirv_intrinsics.write("//-------------------------------------------------\n")
    spirv_intrinsics.write("// *** Generated by type_gen.py. ***\n")
    spirv_intrinsics.write("//       DO NOT MODIFY!!!\n")
    spirv_intrinsics.write("//-------------------------------------------------\n")
    spirv_intrinsics.write('#include "compiler.h"\n')
    spirv_intrinsics.write('#include "generators/spirvgenerator.h"\n')
    spirv_intrinsics.write('#include "util/containers.h"\n')
    spirv_intrinsics.write('namespace GPULang\n')
    spirv_intrinsics.write('{\n')
    spirv_intrinsics.write('constexpr ConverterTable = StaticMap{ std::array{\n')
    spirv_converter = ''
    for converter in type_conversions:
        spirv_converter += '    {{ TypeConversionTable::{}, [](const Compiler*, SPIRVGenerator*, uint32_t, SPIRVResult) -> SPIRVResult {{\n'.format(converter.enum)
        spirv_converter += '        if (value.isLiteral)\n'
        spirv_converter += '        {\n'
        spirv_converter += '            assert(vectorSize == 1);\n'
        spirv_converter += '            return GenerateConstantSPIRV(c, g, ConstantCreationInfo::{}(value.literalValue.{}));\n'.format(converter.target, converter.source_data_type)
        spirv_converter += '        }\n'
        spirv_converter += '        else\n'
        spirv_converter += '        {\n'
        spirv_converter += '            uint32_t type;\n'
        spirv_converter += '            if (vectorSize > 1)\n'
        spirv_converter += '                type = GeneratePODTypeSPIRV(c, g, TypeCode::{}, vectorSize);\n'.format(converter.target)
        spirv_converter += '            else\n'
        spirv_converter += '                type = GeneratePODTypeSPIRV(c, g, TypeCode::{});\n'.format(converter.target)
        if not converter.spirv_conversion_arguments:
            spirv_converter += '            value = LoadValueSPIRV(c, g, value);\n'
            spirv_converter += '            uint32_t res = value.name;\n'
        if converter.spirv_conversion_prep:
            spirv_converter += converter.spirv_conversion_prep
        if not converter.spirv_conversion_arguments:
            spirv_converter += '            res = g->writer->MappedInstruction({}, SPVWriter::Section::LocalFunction, type, SPVArg{{res}});\n'.format(converter.spirv_conversion_function)
        else:
            spirv_converter += '            res = g->writer->MappedInstruction({}, SPVWriter::Section::LocalFunction, type, {});\n'.format(converter.spirv_conversion_function, converter.spirv_conversion_arguments)
        spirv_converter += '            return SPIRVResult(res, type, true);\n'
        spirv_converter += '        }\n'
        spirv_converter += '    } },\n'
    spirv_intrinsics.write(spirv_converter[0:-2])
    spirv_intrinsics.write('\n}};\n\n')
    spirv_intrinsics.write('StaticMap default_intrinsics = std::array{\n')
    

    ### Built-in data types (Float, Int, UInt, Bool and their vector/matrix variants)
    header_file.write("//-------------------------------------------------\n")
    header_file.write("// *** Generated by type_gen.py. ***\n")
    header_file.write("//       DO NOT MODIFY!!!\n")
    header_file.write("//-------------------------------------------------\n")
    header_file.write('#include "ast/types/type.h"\n')
    header_file.write('#include "ast/variable.h"\n')
    header_file.write('#include "ast/function.h"\n')
    header_file.write('namespace GPULang\n')
    header_file.write('{\n')
    header_file.write(conversion_table_enum)

    source_file.write("//-------------------------------------------------\n")
    source_file.write("// *** Generated by type_gen.py. ***\n")
    source_file.write("//       DO NOT MODIFY!!!\n")
    source_file.write("//-------------------------------------------------\n")
    source_file.write('#include "types.h"\n')
    source_file.write('namespace GPULang\n')
    source_file.write('{\n')

    def spirv_intrinsic(fun, arg):
        return 'std::pair{{ &{} , [](const Compiler*, SPIRVGenerator*, uint32_t, const std::vector<SPIRVResult>&) -> SPIRVResult;\n{{\n    {}\n}};\n'.format(fun, arg)

    for size in range(1, 5):
        for type, data_type, bits in zip(types, data_types, bit_widths):
            if size == 1:
                data_type_name = data_type
                type_name = type
            else:
                type_name = '{}x{}'.format(type, size)
                data_type_name = '{}x{}'.format(data_type, size)

            class_decl = ""
            class_decl += 'struct {} : public Type\n'.format(type_name)
            class_decl += '{\n'
            class_decl += '    {}();\n'.format(type_name)
            class_decl += '};\n'
            class_decl += 'extern {} {}Type;\n\n'.format(type_name, type_name)
            
            
            header_file.write(class_decl)

            declaration_string = ""
            #declaration_string = '#define DECL_{}_ctors\\\n'.format(type_name)
            definition_string = '#define DEF_{}_ctors\\\n'.format(type_name)
            setup_string = ""
            list_string = ""
            for type2, data_type2, bits2 in zip(types, data_types, bit_widths):
                if type2 == 'Bool8' and type != 'Bool8':
                    continue

                if size == 1 and type2 == type:
                    continue

                if type == 'Bool8' and not (type2.startswith('Int') or type2.startswith('UInt')):
                    continue

                if size == 1:
                    data_type_name2 = data_type2
                    type_name2 = type2
                else:
                    type_name2 = '{}x{}'.format(type2, size)
                    data_type_name2 = '{}x{}'.format(data_type2, size)

                fun_name = '{}_convert_{}'.format(type_name, type_name2)
                arg_name = '{}_convert_{}_arg0'.format(type_name, type_name2)
                declaration_string += 'extern Variable {};\n'.format(arg_name)
                definition_string += 'Variable {};\\\n'.format(arg_name)
                declaration_string += 'extern Function {};\n'.format(fun_name)
                definition_string += 'Function {};\\\n'.format(fun_name)
                setup_string += '    // Conversion from {}\n'.format(type_name2)
                setup_string += '    {}.name = "_arg0"_c;\n'.format(arg_name)
                setup_string += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(arg_name, type_name2)
                setup_string += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(arg_name, type_name2)
                setup_string += '    {}.name = "{}"_c;\n'.format(fun_name, data_type_name)
                setup_string += '    {}.returnType = Type::FullType {{ {}Type.name }};\n'.format(fun_name, type_name)
                setup_string += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(fun_name, type_name)
                list_string += '        std::pair{{ "{}"_c, &{} }},\n'.format(data_type_name, fun_name)
                list_string += '        std::pair{{ "{}({})"_c, &{} }},\n'.format(data_type_name, data_type_name2, fun_name)
                spirv_intrinsics.write(spirv_intrinsic(fun_name, 'GenerateCompositeSPIRV(c, g, returnType, {{args[0], args[1]}});'))
                if size > 1:
                    fun_name = '{}_splat_{}'.format(type_name, type2)
                    arg_name = '{}_splat_{}_arg0'.format(type_name, type2)
                    declaration_string += 'extern Variable {};\n'.format(arg_name)
                    definition_string += 'Variable {};\\\n'.format(arg_name)
                    declaration_string += 'extern Function {};\n'.format(fun_name)
                    definition_string += 'Function {};\\\n'.format(fun_name)
                    setup_string += '    // Splat with {}\n'.format(type2)
                    setup_string += '    {}.name = "_arg0"_c;\n'.format(arg_name)
                    setup_string += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(arg_name, type2)
                    setup_string += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(arg_name, type2)
                    setup_string += '    {}.name = "{}"_c;\n'.format(fun_name, data_type_name)
                    setup_string += '    {}.returnType = Type::FullType {{ {}Type.name }};\n'.format(fun_name, type_name)
                    setup_string += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(fun_name, type_name)
                    list_string += '        std::pair{{ "{}"_c, &{} }},\n'.format(data_type_name, fun_name)
                    list_string += '        std::pair{{ "{}({})"_c, &{} }},\n'.format(data_type_name, data_type2, fun_name)
                    spirv_intrinsics.write(spirv_intrinsic(fun_name, 'GenerateSplatCompositeSPIRV(c, g, returnType, {}, args[0]);'.format(size)))


            four_component_combinations = [[1, 1, 1, 1], [2, 1, 1], [1, 2, 1], [1, 1, 2], [3, 1], [1,3]]
            three_component_combiations = [[1,1,1], [2, 1], [1, 2]]
            two_component_combinations = [[1, 1]]
            if size == 1:
                combinations = [[1]]
            elif size == 2:
                combinations = two_component_combinations
            elif size == 3:
                combinations = three_component_combiations
            elif size == 4:
                combinations = four_component_combinations
            for ctor_idx, comb in enumerate(combinations):
                fun_name = '{}_ctor{}'.format(type_name, ctor_idx)                

                dec_var = ''
                def_var = ''
                list_entry_key = ""
                list_entry_value = ""
                arg_list = ""
                setup_args = ""

                for arg_idx, s in enumerate(comb):
                    if list_entry_key != "":
                        list_entry_key += ","
                    if s == 1:
                        arg_type_name = '{}'.format(type)
                        fun_name += '_{}'.format(type)
                        list_entry_value += '_{}'.format(type)
                        list_entry_key += '{}'.format(data_type)
                        dec_var += 'extern Variable {}_ctor{}_arg{};\n'.format(type_name, ctor_idx, arg_idx)
                        def_var += 'Variable {}_ctor{}_arg{};\\\n'.format(type_name, ctor_idx, arg_idx)
                        arg_list += '{}, '.format(arg_type_name)
                        
                    else:
                        fun_name += '_{}x{}'.format(type, s)
                        list_entry_key += '{}x{}'.format(data_type, s)
                        list_entry_value += '_{}x{}'.format(type, s)
                        dec_var += 'extern Variable {}_ctor{}_arg{};\n'.format(type_name, ctor_idx, arg_idx)
                        def_var += 'Variable {}_ctor{}_arg{};\\\n'.format(type_name, ctor_idx, arg_idx)
                        arg_type_name = '{}x{}'.format(type, s)
                        arg_list += '{}, '.format(arg_type_name)
                    setup_args += '    {}_ctor{}_arg{}.name = "_arg{}"_c;\n'.format(type_name, ctor_idx, arg_idx, arg_idx)
                    setup_args += '    {}_ctor{}_arg{}.type = Type::FullType {{ {}Type.name }};\n'.format(type_name, ctor_idx, arg_idx, arg_type_name)
                    setup_args += '    Symbol::Resolved(&{}_ctor{}_arg{})->typeSymbol = &{}Type;\n'.format(type_name, ctor_idx, arg_idx, arg_type_name)
                
                setup_string += '    // Construct with {}\n'.format(arg_list[0:-2])
                setup_string += setup_args
                setup_string += '    {}.name = "{}"_c;\n'.format(fun_name, ctor_idx, data_type_name)
                setup_string += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(fun_name, type_name)
                setup_string += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(fun_name, type_name)
                
                list_string += '        std::pair{{ "{}"_c, &{}_ctor{}{}}},\n'.format(data_type_name, type_name, ctor_idx, list_entry_value)
                list_string += '        std::pair{{ "{}({})"_c, &{}_ctor{}{}}},\n'.format(data_type_name, list_entry_key, type_name, ctor_idx, list_entry_value)
                declaration_string += '{}'.format(dec_var)
                declaration_string += 'extern Function {};\n'.format(fun_name)
                definition_string += '{}'.format(def_var)
                definition_string += 'Function {};\\\n'.format(fun_name)
                
            header_file.write(declaration_string[0:-1] + '\n')
            header_file.write("\n")
            header_file.write(definition_string[0:-2] + '\n')
            header_file.write("\n")
            header_file.write("\n")
        
            definition_string = "#define DEF_{}_operators\\\n".format(type_name)

            for name, op, idx_type, idx_data_type in zip(index_operator_names, index_operators, index_types, index_data_types):
                fun_name = '{}_operator_{}'.format(type_name, name)
                arg_name = '{}_operator_{}_arg0'.format(type_name, name)
                declaration_string += 'extern Variable {};\n'.format(arg_name)
                declaration_string += 'extern Function {};\n'.format(fun_name)
                definition_string += 'Variable {};\\\n'.format(arg_name)
                definition_string += 'Function {};\\\n'.format(fun_name)
                setup_string += '    // operator{}({})\n'.format(op, idx_data_type)
                setup_string += '    {}.name = "_arg0"_c;\n'.format(arg_name, name)
                setup_string += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(arg_name, idx_type)
                setup_string += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(arg_name, idx_type)
                setup_string += '    {}.name = "operator{}"_c;\n'.format(fun_name, op)
                setup_string += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(fun_name, type)
                setup_string += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(fun_name, type)
                list_string += '        std::pair{{ "operator{}({})"_c, &{}}},\n'.format(op, idx_data_type, fun_name)

            if type == 'Bool8':
                for name, op in zip(bool_operator_names, bool_operators):
                    fun_name = '{}_operator_{}_{}'.format(type_name, name, type_name)
                    arg_name = '{}_operator_{}_{}_arg0'.format(type_name, name, type_name)
                    setup_string += '    // operator{}({})\n'.format(op, data_type_name)
                    setup_string += '    {}.name = "_arg0"_c;\n'.format(arg_name, name)
                    setup_string += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(arg_name, type_name)
                    setup_string += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(arg_name, type_name)
                    setup_string += '    {}.name = "operator{}"_c;\n'.format(fun_name, op)
                    setup_string += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(fun_name, type_name)
                    setup_string += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(fun_name, type_name)
                    declaration_string += 'extern Variable {};\n'.format(arg_name)
                    declaration_string += 'extern Function {};\n'.format(fun_name)
                    definition_string += 'Variable {};\\\n'.format(arg_name)
                    definition_string += 'Function {};\\\n'.format(fun_name)
                    list_string += '        std::pair{{ "operator{}({})"_c, &{}}},\n'.format(op, data_type_name, fun_name)
            else:
                operator_sets = [
                    zip(scalar_operator_names, scalar_operators), 
                    zip(assignment_operator_names, assignment_operators),
                    zip(comparison_operator_names, comparison_operators)
                    ]
                for operator_set in operator_sets:
                    for name, op in operator_set:
                        fun_name = '{}_operator_{}_{}'.format(type_name, name, type_name)
                        arg_name = '{}_operator_{}_{}_arg0'.format(type_name, name, type_name)
                        setup_string += '    // operator{}({})\n'.format(op, data_type_name)
                        setup_string += '    {}.name = "_arg0"_c;\n'.format(arg_name, name)
                        setup_string += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(arg_name, type_name)
                        setup_string += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(arg_name, type_name)
                        setup_string += '    {}.name = "operator{}"_c;\n'.format(fun_name, op)
                        setup_string += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(fun_name, type_name)
                        setup_string += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(fun_name, type_name)
                        declaration_string += 'extern Variable {};\n'.format(arg_name)
                        declaration_string += 'extern Function {};\n'.format(fun_name)
                        definition_string += 'Variable {};\\\n'.format(arg_name)
                        definition_string += 'Function {};\\\n'.format(fun_name)
                        list_string += '        std::pair{{ "operator{}({})"_c, &{}}},\n'.format(op, data_type_name, fun_name)
                
                if size > 1:
                    for name, op, scale_type, scale_data_type in zip(scale_operator_names, scale_operators, scale_operator_types, scale_operator_data_types):
                        fun_name = '{}_operator_{}_{}_{}'.format(type_name, name, type_name, scale_type)
                        arg_name = '{}_operator_{}_{}_{}_arg0'.format(type_name, name, type_name, scale_type)
                        setup_string += '    // operator{}({})\n'.format(op, scale_data_type)
                        setup_string += '    {}.name = "_arg0"_c;\n'.format(arg_name, name)
                        setup_string += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(arg_name, scale_type)
                        setup_string += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(arg_name, scale_type)
                        setup_string += '    {}.name = "operator{}"_c;\n'.format(fun_name, op)
                        setup_string += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(fun_name, type_name)
                        setup_string += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(fun_name, type_name)
                        declaration_string += 'extern Variable {};\n'.format(arg_name)
                        declaration_string += 'extern Function {};\n'.format(fun_name)
                        definition_string += 'Variable {};\\\n'.format(arg_name)
                        definition_string += 'Function {};\\\n'.format(fun_name)
                        list_string += '        std::pair{{ "operator{}({})"_c, &{}}},\n'.format(op, scale_data_type, fun_name)

            if type.startswith('Float') and size > 1:
                
                for cols in range(2, 5):
                    compatible_matrix_type = 'Float32x{}x{}'.format(size, cols)
                    compatible_matrix_data_type = 'f32x{}x{}'.format(size, cols)
                    return_type = '{}x{}'.format(type, cols)
                    return_data_type = 'f32x{}'.format(cols)
                    for name, op in zip(vector_matrix_operator_names, vector_matrix_operators):
                        fun_name = '{}_operator_{}_{}'.format(type_name, name, compatible_matrix_type)
                        arg_name = '{}_operator_{}_{}_arg0'.format(type_name, name, compatible_matrix_type)
                        setup_string += '    // operator{}({})\n'.format(op, compatible_matrix_data_type)
                        setup_string += '    {}.name = "_arg0"_c;\n'.format(arg_name, name)
                        setup_string += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(arg_name, compatible_matrix_type)
                        setup_string += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(arg_name, compatible_matrix_type)
                        setup_string += '    {}.name = "operator{}"_c;\n'.format(fun_name, op)
                        setup_string += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(fun_name, return_type)
                        setup_string += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(fun_name, return_type)
                        declaration_string += 'extern Variable {};\n'.format(arg_name)
                        declaration_string += 'extern Function {};\n'.format(fun_name)
                        definition_string += 'Variable {};\\\n'.format(arg_name)
                        definition_string += 'Function {};\\\n'.format(fun_name)
                        list_string += '        std::pair{{ "operator{}({})"_c, &{}}},\n'.format(op, compatible_matrix_data_type, fun_name)  

            if type.startswith("UInt") or type.startswith("Int"):
                operator_sets = [
                    zip(bit_operator_names, bit_operators)
                    , zip(bit_assignment_operator_names, bit_assignment_operators)
                    ]
                for operator_set in operator_sets:
                    for name, op in operator_set:
                        fun_name = '{}_operator_{}_{}'.format(type_name, name, type_name)
                        arg_name = '{}_operator_{}_{}_arg0'.format(type_name, name, type_name)
                        setup_string += '    // operator{}\n'.format(op)
                        setup_string += '    {}.name = "_arg0"_c;\n'.format(arg_name, name)
                        setup_string += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(arg_name, type_name)
                        setup_string += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(arg_name, type_name)
                        setup_string += '    {}.name = "operator{}"_c;\n'.format(fun_name, op)
                        setup_string += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(fun_name, type_name)
                        setup_string += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(fun_name, type_name)
                        
                        declaration_string += 'extern Variable {};\n'.format(arg_name)
                        declaration_string += 'extern Function {};\n'.format(fun_name)
                        definition_string += 'Variable {};\\\n'.format(arg_name)
                        definition_string += 'Function {};\\\n'.format(fun_name)
                        list_string += '        std::pair{{ "operator{}({})"_c, &{}}},\n'.format(op, data_type_name, fun_name)

            class_def = ""
            class_def += '{}::{}()\n'.format(type_name, type_name)
            class_def += '{\n'
            class_def += '    this->name = "{}";\n'.format(data_type)
            class_def += '    this->columnSize = {};\n'.format(size)
            class_def += '    this->rowSize = 1;\n'
            class_def += '    this->byteSize = {:d};\n'.format(trunc((bits * size) / 8))
            class_def += '    this->category = Type::ScalarCategory;\n'
            class_def += '    this->baseType = TypeCode::{};\n'.format(type)
            class_def += '    this->builtin = true;\n'
            class_def += '\n'
            class_def += '{}'.format(setup_string)
            class_def += '    this->scope.symbolLookup = StaticMap {{ std::array{{\n{}\n    }}}};   \n'.format(list_string[0:-2])
            class_def += '}\n\n'

            header_file.write(declaration_string[0:-1] + '\n')
            header_file.write("\n")
            header_file.write(definition_string[0:-2] + '\n')
            header_file.write("\n")
            source_file.write(class_def)
            #source_file.write("\n")
            header_file.write("\n")

    # Matrix types
    types = ['Float32', 'Float16']
    bit_widths = [32, 16]
    data_types = ["f32", "f16"]

    scalar_operator_names = ['add', 'sub', 'mul']
    scalar_operators = ['+', '-', '*']

    assignment_operator_names = ['addasg', 'subasg', 'mulasg']
    assignment_operators = ['+=', '-=', '*=']

    scale_operator_names = ['scale', 'scale', 'scale', 'scale', 'scale', 'scale']
    scale_operators = ['*', '*', '*', '*', '*', '*']
    scale_operator_types = ['Float32', 'Float16', 'UInt32', 'UInt16', 'Int32', 'Int16']
    scale_operator_data_types = ['f32', 'f16', 'u32', 'u16', 'i32', 'i16']

    for type, data_type, bits in zip(types, data_types, bit_widths):
        for row_size in range(2, 5):
            for column_size in range(2, 5):

                type_name = '{}x{}x{}'.format(type, row_size, column_size)
                data_type_name = '{}x{}x{}'.format(data_type, row_size, column_size)

                declaration_string = ""
                definition_string = "#define DEF_{}_ctors\\\n".format(type_name)
                list_string = ""
                setup_string = ""
                
                class_decl = ""
                class_decl += 'struct {} : public Type\n'.format(type_name)
                class_decl += '{\n'
                class_decl += '    {}();\n'.format(type_name)
                class_decl += '};\n'
                class_decl += 'extern {} {}Type;\n\n'.format(type_name, type_name)

                header_file.write(class_decl)

                vector_ctor_name = '{}_{}x{}_ctor'.format(type_name, type, column_size)
                
                for arg_index in range(0, row_size):
                    arg_name = '{}_arg{}'.format(vector_ctor_name, arg_index)
                    declaration_string += 'extern Variable {};\n'.format(arg_name)
                    definition_string += 'Variable {};\\\n'.format(arg_name)

                declaration_string += 'extern Function {};\n'.format(vector_ctor_name)
                definition_string += 'Function {};\\\n'.format(vector_ctor_name)
                list_string += '        std::pair{{ "{}"_c, &{}}},\n'.format(data_type_name, vector_ctor_name)


                declaration_string += 'extern Function {}_identity;\n'.format(type_name)
                definition_string += 'Function {}_identity;\\\n'.format(type_name)
                list_string += '        std::pair{{ "{}"_c, &{}_identity}},\n'.format(data_type_name, type_name)

                array_ctor_name = '{}_{}_{}_ctor'.format(type_name, type, column_size * row_size)
                for arg_index in range(0, column_size * row_size):
                    arg_name = '{}_arg{}'.format(array_ctor_name, arg_index)
                    declaration_string += 'extern Variable {};\n'.format(arg_name)
                    definition_string += 'Variable {};\\\n'.format(arg_name)

                declaration_string += 'extern Function {};\n'.format(array_ctor_name)
                definition_string += 'Function {};\n'.format(array_ctor_name)
                list_string += '        std::pair{{ "{}"_c, &{}}},\n'.format(data_type_name, array_ctor_name)

                header_file.write(declaration_string[0:-1] + '\n')
                header_file.write("\n")
                header_file.write(definition_string[0:-2] + '\n')
                header_file.write("\n")
                header_file.write("\n")
        
                definition_string = "#define DEF_{}_operators\\\n".format(type_name)
                declaration_string = ""

                vec_type = '{}x{}'.format(type, column_size)
                for name, op, idx_type, idx_data_type in zip(index_operator_names, index_operators, index_types, index_data_types):
                    fun_name = '{}_operator_{}'.format(type_name, name)
                    arg_name = '{}_operator_{}_arg0'.format(type_name, name)
                    declaration_string += 'extern Variable {};\n'.format(arg_name)
                    declaration_string += 'extern Function {};\n'.format(fun_name)
                    definition_string += 'Variable {};\\\n'.format(arg_name)
                    definition_string += 'Function {};\\\n'.format(fun_name)
                    setup_string += '    // operator{}({})\n'.format(op, idx_data_type)
                    setup_string += '    {}.name = "_arg0"_c;\n'.format(arg_name, name)
                    setup_string += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(arg_name, idx_type)
                    setup_string += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(arg_name, idx_type)
                    setup_string += '    {}.name = "operator{}"_c;\n'.format(fun_name, op)
                    setup_string += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(fun_name, vec_type)
                    setup_string += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(fun_name, vec_type)
                    list_string += '        std::pair{{ "operator{}({})"_c, &{}}},\n'.format(op, idx_data_type, fun_name)

                operator_sets = [
                    zip(scalar_operator_names, scalar_operators), 
                    zip(assignment_operator_names, assignment_operators)
                ]
                for operator_set in operator_sets:
                    for name, op in operator_set:
                        fun_name = '{}_operator_{}_{}'.format(type_name, name, type_name)
                        arg_name = '{}_operator_{}_{}_arg0'.format(type_name, name, type_name)
                        setup_string += '    // operator{}\n'.format(op)
                        setup_string += '    {}.name = "_arg0"_c;\n'.format(arg_name, name)
                        setup_string += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(arg_name, type_name)
                        setup_string += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(arg_name, type_name)
                        setup_string += '    {}.name = "operator{}"_c;\n'.format(fun_name, op)
                        setup_string += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(fun_name, type_name)
                        setup_string += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(fun_name, type_name)
                        
                        declaration_string += 'extern Variable {};\n'.format(arg_name)
                        declaration_string += 'extern Function {};\n'.format(fun_name)
                        definition_string += 'Variable {};\\\n'.format(arg_name)
                        definition_string += 'Function {};\\\n'.format(fun_name)
                        list_string += '        std::pair{{ "operator{}({})"_c, &{}}},\n'.format(op, data_type_name, fun_name)

                for name, op, scale_type, scale_data_type in zip(scale_operator_names, scale_operators, scale_operator_types, scale_operator_data_types):
                    fun_name = '{}_operator_{}_{}_{}'.format(type_name, name, type_name, scale_type)
                    arg_name = '{}_operator_{}_{}_{}_arg0'.format(type_name, name, type_name, scale_type)
                    setup_string += '    // operator{}({})\n'.format(op, scale_data_type)
                    setup_string += '    {}.name = "_arg0"_c;\n'.format(arg_name, name)
                    setup_string += '    {}.type = Type::FullType{{ {}Type.name }};\n'.format(arg_name, scale_type)
                    setup_string += '    Symbol::Resolved(&{})->typeSymbol = &{}Type;\n'.format(arg_name, scale_type)
                    setup_string += '    {}.name = "operator{}"_c;\n'.format(fun_name, op)
                    setup_string += '    {}.returnType = Type::FullType{{ {}Type.name }};\n'.format(fun_name, type_name)
                    setup_string += '    Symbol::Resolved(&{})->returnTypeSymbol = &{}Type;\n\n'.format(fun_name, type_name)
                    declaration_string += 'extern Variable {};\n'.format(arg_name)
                    declaration_string += 'extern Function {};\n'.format(fun_name)
                    definition_string += 'Variable {};\\\n'.format(arg_name)
                    definition_string += 'Function {};\\\n'.format(fun_name)
                    list_string += '        std::pair{{ "operator{}({})"_c, &{}}},\n'.format(op, scale_data_type, fun_name)

                class_def = ""
                class_def += '{}::{}()\n'.format(type_name, type_name)
                class_def += '{\n'
                class_def += '    this->name = "{}";\n'.format(data_type)
                class_def += '    this->columnSize = {};\n'.format(column_size)
                class_def += '    this->rowSize = {};\n'.format(row_size)
                class_def += '    this->byteSize = {:d};\n'.format(trunc((bits * row_size * column_size) / 8))
                class_def += '    this->category = Type::ScalarCategory;\n'
                class_def += '    this->baseType = TypeCode::{};\n'.format(type)
                class_def += '    this->builtin = true;\n'
                class_def += '\n'
                class_def += '{}'.format(setup_string)
                class_def += '    this->scope.symbolLookup = StaticMap {{ \n    std::array{{\n{}\n    }}\n    }};   \n'.format(list_string[0:-2])
                class_def += '}\n\n'

                header_file.write(declaration_string[0:-1] + '\n')
                header_file.write("\n")
                header_file.write(definition_string[0:-2] + '\n')
                header_file.write("\n")
                source_file.write(class_def)
                #source_file.write("\n")
                header_file.write("\n")


    header_file.write('} // namespace GPULang\n\n')
    source_file.write('} // namespace GPULang\n\n')

    spirv_intrinsics.write('};')
    spirv_intrinsics.write('} // namespace GPULang\n\n')

    ### Intrinsics
    intrinsics_header = open("../generated/intrinsics.h", "w")
    intrinsics_source = open("../generated/intrinsics.cc", "w")

    float_types = ['Float32', 'Float32x2', 'Float32x3', 'Float32x4', 'Float16', 'Float16x2', 'Float16x3', 'Float16x4']
    integer_types = ['Int32', 'Int32x2', 'Int32x3', 'Int32x4', 'Int16', 'Int16x2', 'Int16x3', 'Int16x4', 'UInt32', 'UInt32x2', 'UInt32x3', 'UInt32x4', 'UInt16', 'UInt16x2', 'UInt16x3', 'UInt16x4']
    scalar_types = float_types + integer_types
    float_vec_types = ['Float32x2', 'Float32x3', 'Float32x4', 'Float16x2', 'Float16x3', 'Float16x4']
    signed_types = ['Int32', 'Int32x2', 'Int32x3', 'Int32x4', 'Int16', 'Int16x2', 'Int16x3', 'Int16x4', 'Float32', 'Float32x2', 'Float32x3', 'Float32x4', 'Float16', 'Float16x2', 'Float16x3', 'Float16x4']
    bool_types = ['Bool8', 'Bool8x2', 'Bool8x3', 'Bool8x4']

    intrinsics_header.write("//-------------------------------------------------\n")
    intrinsics_header.write("// *** Generated by type_gen.py. ***\n")
    intrinsics_header.write("//       DO NOT MODIFY!!!\n")
    intrinsics_header.write("//-------------------------------------------------\n")
    intrinsics_header.write('namespace GPULang\n')
    intrinsics_header.write('{\n')

    intrinsic_decls = ''
    intrinsic_defs = ''

    float_only_intrinsics = [
        'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'cos', 'cosh', 'exp',
        'exp2', 'invSqrt', 'log', 'log2', 'pow', 'sin', 'sinh', 'sqrt', 'tan', 'tanh'
    ]
    for float_type in float_types:
        for intrinsic in float_only_intrinsics:
            intrinsic_decls += 'extern Function {}_{};\n'.format(float_type, intrinsic)

    intrinsics_header.write(intrinsic_decls)
    intrinsics_header.write('} // namespace GPULang\n\n')




generate_swizzle_four()
generate_swizzle_three()
generate_swizzle_two()
generate_types()

open_file.close()
print("Types generated!")